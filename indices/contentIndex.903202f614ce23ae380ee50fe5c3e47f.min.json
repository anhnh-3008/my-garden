{"/":{"title":"Home","content":"\n\n\u003ch1\u003e Hi there, I'm a Ruby Developer 👋\n\u003ch2\u003e Welcome to my blog!!!\n\n🌱 \u003ca class=\"homepage-list-link\" href=\"50-til/\"\u003eTIL\u003c/a\u003e","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/40123345-posts/42-Code/42.01-Ruby/RubyCritic":{"title":"🌳 RubyCritic","content":"![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020164959.png]]\n\n🌱 `RubyCritic` cung cấp báo cáo trực quan về những vấn đề như code thối, cấu trúc code, tính dễ kiểm tra, và độ phủ của test case cho app Ruby. \n\n🌱 Đang liên tục phát triển và release tính năng mới. Có trong danh sách [Ruby Awesome](https://github.com/markets/awesome-ruby#:~:text=Rubycritic%20%2D%20A%20Ruby%20code%20quality%20reporter.).\n\n🌱 Bài viết này sẽ giới thiệu về một số những lợi ích mà `RubyCritic` đem lại, các `dependencies` của nó và cách để đọc `code reports`.\n\n## 🌿Why?\n\n🌱 Bạn có thể xem xét sử dụng `RubyCritic` nếu muốn có một nơi có thể theo dõi sự phát triển của code trong dự án. Áp dụng `RubyCritic` vào process dự án chắc chắn sẽ giảm được thời gian của team dev cho việc khắc phục `Technical debts`. Hầu hết các `technical debts` đều sẽ được phát hiện sớm và 'trả nợ' trong giai đoạn phát triển luôn.\n\n\u003e technical debts là gì?\n\u003e ...\n\u003e ...\n\u003e ...\n\n🌱 Một số những lợi ích của `RubyCritic` khi chúng ta áp dụng cho dự án hay process phát triển:\n- Thống nhất thông tin về một nơi duy nhất.\n- Báo cáo trực quan\n- Cài đặt dễ dàng\n- Không config\n- Cho phép tùy chỉnh theo nhu cầu sử dụng\n- Có thể mở rộng - Là open-source chúng ta có thể tích hợp thêm tính năng của mình.\n- Một trình tạo huy hiệu.\n\nĐể hiểu hơn về cách `RubyCritic` hoạt động, hãy xem những `internal dependencies` được sử dụng để tạo một report mặt mũi như thế nào nhé!  \n\n## 🌿 Internal dependencies trong Rubycritic\n\n- Khi bạn thêm `RubyCritic`, một số dependencies cũng được thêm kèm. \n- Điểm qua những dependencies chủ chốt: `The Reek`, `Flay`, và `Flog`. Đây đều là những gem cho phép `RubyCritic` hiển thị những thông tin hữu ích liên quan đến những code của bạn. Hiểu được cách hoạt động của bọn này sẽ thuận tiện hơn trong việc sử dụng `RubyCritic`.\n\n### 🌱 Reek: Tìm code Ruby bốc mùi 💩\n\n- [Reek](https://github.com/troessner/reek) là một gem dùng để tìm những dòng code 💩 trong Ruby. Code thối không phải là code sai, nó là những dòng code có thể được viết dễ đọc hơn, dễ bảo trì hoặc phát triển hơn nhưng vẫn đúng logic với ban đầu.\n- Reek sẽ phân tích xem có chỗ nào bốc mùi nhưng sẽ không gợi ý là sửa như thế nào vì hầu như code 'có mùi' đều liên quan đến business logic hoặc dựa theo kinh nghiệm của lập trình viên đối với một ngôn ngữ lập trình.\n\n\u003e Reek chỉ đánh giá được theo hướng chủ quan, nên chúng ta cũng nên cân nhắc thêm dựa theo logic của dự án cũng như kinh nghiệm của bản thân trước khi quyết định sửa code.\n\n- Reek cung cấp  [extensive list of smells](https://github.com/troessner/reek/blob/master/docs/Code-Smells.md). Kiểm tra và chỉ ra những chỗ bốc mùi trong:\n\t- Classes\n\t- Attributes\n\t- Methods\n\t- Parameters\n\t- Moduldes\n\t- Iterators\n\t- The implementation of polymorphism\n\n- Nhờ đó chúng ta sẽ chủ động trong việc làm cho code dễ đọc và dễ bảo trì hơn.\n\n- Cho phép config để:\n\t- Tắt kiểm tra những rule ko phù hợp với dự án.\n\t- Chỉ định các thư mục không cần kiểm tra.\n\t- Sử dụng filter để tắt tiếng cảnh báo.\n\n### 🌱 Flay: Kiểm tra code lặp\n- [Flay](https://ruby.sadi.st/Flay.html) xác định những điểm tương đồng trong cấu trúc code, bao gồm:\n\t- Tìm ra code bị lặp lại trong dự án.\n\t- Cho điểm để đánh giá mức độ tốt của code(điểm càng thấp, code càng ngon).\n\t- Checking the difference at any code level.\n\n- Nếu Flay báo cáo có sự trùng lặp trong code, khả năng cao chúng ta nên sửa nó. Đừng  bỏ qua vì nó rất có khả năng dẫn đến bugs. Khi bạn fix thêm gì đó ở một chỗ nhưng quên sửa những chỗ còn lại thì có khả năng bug sẽ xuất hiện đó.\n\n```rb\n# lib/flay.rb:80\nopts.on(\"-m\", \"--mass MASS\", Integer, \"Sets mass threshold (default = #{options[:mass]})\") do |m|\n  options[:mass] = m.to_i\nend\n \n# lib/flay.rb:105\nopts.on(\"-t\", \"--timeout TIME\", Integer, \"Set the timeout. (default = #{options[:timeout]})\") do |t|\n  options[:timeout] = t.to_i\nend\n```\n\nKiểm tra:\n```bash\n$ flay lib/flay.rb\nTotal score (lower is better) = 36\n \n1) Similar code found in :iter (mass = 36)\n  lib/flay.rb:80\n  lib/flay.rb:105\n```\n\nMặc dù nội dung bên trong không giống nhau hoàn toàn nhưng cấu trúc code có thể được cấu trúc lại để tránh trùng lặp. Đó là magic của Flay.\n\n\u003e Flay đánh giá trùng lặp dựa trên cấu trúc code, nếu điểm trùng lặp càng thấp có nghĩa code chúng ta càng ngon(dry). Tuy nhiên, chúng ta vẫn cần đánh giá thêm cả về logic của dự án trước khi sửa nhé.\n\n### 🌱 Flog: Kiểm tra độ phức tạp trong code\n[Flog](https://ruby.sadi.st/Flog.html) kiểm tra xem độ phức tạp của code(code khó đọc). Flog gán điểm phức tạp cho từng dòng sau đó tính tổng cho mỗi method hoặc class.\n\n``` rb\ndef validate_expiration\n  return if exp_month.blank? || exp_year.blank?\n \n  ...\nend\n```\n\nKiểm tra:\n```sh\n$ flog app/models/credit_card.rb\n \n5.2: CreditCard#validate_expiration   app/models/credit_card.rb:12-15\n```\n\n\n- Độ phức tạp đang là 5.2, giờ mình sẽ sửa để nó dễ đọc hơn một chút\n\n```rb\ndef validate_expiration\n  return if exp_month.blank?\n  return if exp_year.blank?\n \n  ...\nend\n```\n\nKiểm tra:\n```sh\n$ flog app/models/credit_card.rb\n \n4.8: CreditCard#validate_expiration app/models/credit_card.rb:12-15\n```\n\n\u003e Viết code là trò chơi đơn giản, nhưng để viết code đơn giản, dễ hiểu thì lại khó nhất trên đời 😆 Đừng cố viết cao siêu làm gì, hãy viết code thật dễ hiểu, hiệu quả để những người đồng nghiệp đọc code của bạn không phải chửi thầm nhé ❤️  \n\n### 🌱 Other Dependencies \n- Ngoài ra `RubyCritic` còn có nhiều dependencies khác, có cả những gem phổ biến mà chúng ta vẫn thường dùng như `buybug`, `simpleCov`, `rubocop`. Mọi người có thể xem đầy đủ các dependencies ở [đây](https://github.com/whitesmith/rubycritic/blob/main/rubycritic.gemspec).\n\n\n## 🌿Áp dụng cho dự án Ruby on Rails\n\n- `RubyCritic` cung cấp tài liệu chi tiết để bắt đầu mà không cần config nhiều. Trong khuôn khổ bài viết này, chúng ta sẽ tập trung cho việc phân tích những thông số có trong những báo cáo của `RubyCritic`.\n- Có 3 vấn đề được báo cáo là `Code`, `Smells` và `Coverage`. Cùng lược qua từng tính năng này nhé!\n\n### 🌱 Overview\nSau khi chạy `rubycritic` xong, tự động redirect tới một trang html chứa các reports của dự án.\n\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020153521.png]]\n\n- Màn `Overview` hiển thị tổng điểm của dự án trên một cái biểu đồ donut, xếp hạng theo A là tốt nhất và F là tệ nhất.\n- Phần `Summary` hiển thị chi tiết của từng rating (A -\u003e F) bao gồm số lượng files, số lượng commit(churns) và số lượng smell code được tìm thấy.\n- `Churn vs Complexity` hiển thị vị trí các Class/Module là một điểm, ứng với 2 chỉ số độ phức tạp và số lượng commit =\u003e phản ánh chính xác những điểm chưa tốt của dự án.\n\n### 🌱 Code Report\n\n- Hiển thị điểm của từng Class/Module bao gồm `churn`, `complexity`, `duplication` and `smells`.\n- Bạn có thể sort theo từng chỉ số để tiện đánh giá.\n- Có thể search tên của Class/Module.\n\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020154211.png]]\n\n- Click vào một Class/Module bất kỳ sẽ hiển thị chi tiết source code và các số liệu đi kèm như:\n\t- Code line\n\t- Chất lượng code\n\t- Churn\n\t- Độ phức tạp của method\n\t- Điểm phức tạp(tổng của class)\n\t- Số lượng code bị duplicates.\n\t- Số lượng smells tìm thấy.\n\n- Những dòng code có vấn đề sẽ được highlight(Dựa theo thông tin cả Reek gem cung cấp)\n\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020155314.png]]\n\n\n### 🌱 Smells Report\n- Hiển thị smell type, vị trí chính xác nơi bốc mùi và tình trạng khắc phục.\n- Như đã nói ở trên, Smells được cung cấp bởi gem Reek, và màn này chúng ta cũng có thể search và sort được như `Code Report`.\n- Bạn có thể nhìn thấy các class/module được nhóm theo smell type.\n\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020162956.png]]\n\n### 🌱 Coverage Report\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020164032.png]]\n\n- Chỉ hiển thị thông số độ bao phủ của kiếm thử đối với những class/module. \n- Không thể sắp xếp hoặc tìm kiếm như 2 trang bên trên.\n- Nếu tích hợp `SimpleCov` thì sẽ chi tiết và trực quan hơn, nhưng với hầu hết trường hợp chỉ cần một báo cáo đơn giản để đánh giá độ phủ của dự án, `Coverage Report` đã hoàn toàn đáp ứng được rồi.\n\n## ☘️Tham khảo\n- https://github.com/whitesmith/rubycritic\n- https://blog.appsignal.com/2022/10/19/improve-code-in-your-ruby-application-with-rubycritic.html\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/40123345-posts/43-Psychology/T%C6%B0-duy-nhanh-v%C3%A0-ch%E1%BA%ADm":{"title":"📘 Tư duy nhanh và chậm","content":"\n---\n\nChào mọi người, thời tiết hôm nay nó cứ bị mưa mưa, mát mẻ làm mình lười viết về mấy bài công nghệ khô khan quá =)) Chắc để đổi gió nay mình sẽ viết về quyển sách mà dạo này mình đang đọc nha. Quyển sách này giúp chúng ta nhìn cách vận hành suy nghĩ một cách rất dễ hiểu thông qua những diễn đạt của tác giả - một người đã dành cả cuộc đời để nghiên cứu về Tâm lý học hành vi.\n\n![[00 Meta/01 Attachments/tu-duy-nhanh-va-cham.png]]\n\n## Tác giả\n---\n`Daniel Kahneman` sinh năm 1934, nhà Tâm lý học người Mỹ gốc Israel, giành giải Nobel kinh tế năm 2002. Ông dành cả đời để nghiên cứu về Tâm lý học hành vi. Cùng với người động sự đã qua đời là Amos Tversky, hai ông đã có những nghiên cứu sâu sắc về con đường tư duy và nhận thức của con người.\n\nCuốn sách đã dành được nhiều giải thưởng danh giá như: Sách khoa học hay nhất của Học viện Khoa học Quóc gia năm 2012, Sách hay nhất nhất năm 2011 do Thời Báo New York bình chọn, cuốn sách được quan tâm nhất năm 2021 của tạp chí Los Angeles. \n## Nội dung\n---\nXuyên suốt quyển sách hai khái niệm được nhắc đến nhiều nhất đó là `Hệ Thống 1` và `Hệ Thống 2`. Hai nhân vật chính này là xuất phát điểm cho tất cả những suy nghĩ, quan sát, hành vi, trải nghiệm, hay quyết định, ... của mỗi chúng ta.\n`Hệ Thống 1` hoạt động với cơ chế suy nghĩ nhanh, tự động, cảm tính, bản năng, rập khuôn và kiểu giác quan thứ 6 mà chị em phụ nữ hay được trải nghiệm =))\n`Hệ Thống 2` thì ngược lại, suy nghĩ chậm, sở hữu sự điềm tĩnh, logic, tính toán, ý thức và đòi hỏi một sự nỗ lực khi hoạt động.\n\nKhông phải tự nhiên mà ca sĩ Tóc Tiên đã hát:\n\t`Chọn con \u003c3 hay là nghe lý trí, chọn yêu anh hay chọn phút giây biệt ly.`\n\nPhần lớn chúng ta thường lười kích hoạt `Hệ Thống 2`, để mặc cho `Hệ Thống 1` 'tự do tác oai tác quái' :D. Bạn nhớ lại xem bạn đã từng đột nhiên nổi hứng lên mua một món đồ đắt tiền nhưng khi nhận về bạn lại bỏ xó. Nếu tại thời điểm nổi hứng đó `Hệ Thống 2` xuất hiện có phải đã tốt hơn rồi không =))) Nhưng nếu chúng ta kích hoạt liên tục `Hệ Thống 2` thì sao? Cẩn thận bộ não của bạn sẽ bị quá tải đấy =)) 'Hội trầm cảm sau sinh' sẽ ko quên mời bạn gia nhập đâu :D   \n\nChúng ta luôn luôn suy nghĩ, lựa chọn, quyết định với mọi vấn đề trong cuộc sống và những điều đó đôi khi sẽ thay đổi cả cuộc đời của chính chúng ta hay nhiều người khác nữa. Hiểu được các cơ chế hoạt động, tránh được `những lỗi sai hệ thống` là điều vô cùng cần thiết. Cuốn sách này sẽ giúp chúng ta hiểu được những 'dòng chảy' của não bộ, hai Hệ Thống giao tiếp với thế giới xung quanh ntn, ... từ đó giúp chúng ta sẽ phần nào hiểu được năng lực tư duy của chính mình và phát huy nó một cách hiệu quả \u003c3\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/40123345-posts/44-Finance/9-sai-l%E1%BA%A7m-t%C3%A0i-ch%C3%ADnh-c%E1%BB%A7a-ng-tr%E1%BA%BB":{"title":"💵 9 sai lầm tài chính của ng trẻ","content":"\n## 🌱 9 sai lầm tài chính của người trẻ\n\n![[00 Meta/01 Attachments/Pasted image 20221021224059.png]]\n\n### Nguồn\n- https://www.youtube.com/watch?v=2EyGqvZrbyc\u0026ab_channel=HieuNguyen\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/40123345-posts/44-Finance/C%C4%83ng-th%E1%BA%B3ng-B%E1%BA%A5t-an":{"title":"🥶 Giai đoạn căng thẳng \u0026 Bất an","content":"\n✍️ Các kiến thức trong bài viết này được tổng hợp từ những chia sẻ của chú Hiếu Nguyễn trong [podcast](https://www.youtube.com/watch?v=rqtDSOCUEj0\u0026list=PL1bLXQ3Ow2laRk3IFEqbDLM_l6YHNPp8W\u0026index=3\u0026ab_channel=HieuNguyen).\n\n## 🌿 Nợ nần (level ⚠️) \n\n🌱 Thường sẽ là giai đoạn xuất phát điểm của các bạn trẻ bên nước ngoài. Vì bên này họ phát triển tư duy tự lập từ rất sớm, nên khi học đại học, các sinh viên sẽ phải tự trả số tiền học của mình. Nhưng vì hầu như các bản trẻ lúc này chưa có bất kỳ khoản tích lũy nào nên chính phủ sẽ hỗ trợ cho vay , khoản vay này có tên là [Student Loan](https://en.wikipedia.org/wiki/Student_loan)\n- Khoản nợ này ở Mỹ có thể lên đến vài chục nghìn đô.\n- Thường sẽ mất vài năm, có thể lâu hơn mới có thể trả được hết món nợ này.\n\n\u003e Là món nợ lớn.\n\n## 🌿 Ăn bám gia đình (level 0️⃣)\n\n🌱 Tự bản thân chưa nuôi được mình, phụ thuộc hoàn toàn vào chu cấp của gia đình.\n\n🌱 Nên đi làm sớm để biết **Quý trọng đồng tiền**. Từ đó có thể dần dần hình thành cảm nhận về tài chính =\u003e Nền tảng để xây dựng về sau.\n\n\u003e Đến năm 18 tuổi, nên kiếm việc làm thêm(phù hợp, lương thấp xíu cũng được). \n\u003e Cố gắng chuyển sang level 1️⃣ sớm nhất có thể.\n\n## 🌿 Tự nuôi bản thân (level 1️⃣)\n\n🌱 Tự làm được tiền, nuôi bản thân, không phụ thuộc vào gia đình nữa.\n\n🌱 Sống theo kiểu có tháng nào tiêu hết tháng đó. Có rất nhiều người chỉ dừng lại ở bước này đến cuối đời.\n\n🌱 Tiềm ẩn rủi ro bị lùi về level 0️⃣ hoặc tệ hơn level ⚠️. Khi bản thân có tiền, nếu không có cách quản lý tài chính hợp lý + tâm lý có thể dùng lương để trả thì rất có thể sẽ bị vướng vào nợ nần - báo nhà :v\n\n\u003e Rất bấp bênh, không thể xử lý được các biến cố bất ngờ xảy ra(mất việc, đau ốm, có việc đột xuất, ...). Có thể tụt level bất cứ lúc nào.\n\u003e \n\u003e Đạt được level này, hay ngay lập tức chuyển qua giai đoạn tiếp theo đó là [Theo dõi \u0026 Kiến tạo](40123345%20posts/44%20Finance/Theo%20dõi%20\u0026%20Kiến%20tạo.md)  \n\n## ⛔ Ảnh hưởng của nợ nần\n\nCó 2 kiểu nợ phổ biến:\n\n### 🌱 Nợ không có lãi suất\n- Thường sẽ là nợ người thân, bạn bè. Mà để từ level 1️⃣ về đến level ⚠️ thì chúng ta cũng đã phải nợ nhiều nguồn, nhiều tiền rồi.\n- Không trả được đúng hạn =\u003e Mất uy tín.\n- Nhiều quá không trả nổi =\u003e Mất tư cách.\n\n\u003e Cái mất nhiều nhất chính là mất những mối quan hệ chất lượng.\n\n### 🌱 Nợ có lãi suất\n\nLoại này thì lại có 2 kiểu =))\n\n- Nợ tử tế\n\t- Nợ kiểu vay ngân hàng, nợ tín dụng =\u003e lãi suất cao, thường sẽ là 2%-4%/tháng =\u003e ~24%-42%/năm 😱.\n\n- Nợ không tử tế\n\t- Vay nóng, nợ xã hội đen, ... thì thôi 🥵 \n\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/40123345-posts/44-Finance/Each-step-to-the-Financial-Freedom":{"title":"🗺️ Each step to the Financial Freedom","content":"\n![Pasted image 20221119163052](00%20Meta/01%20Attachments/Pasted%20image%2020221119163052.png)\n\n📂 Ảnh được lấy từ [podcast](https://www.youtube.com/watch?v=GlUvl-MWn6E\u0026list=PL1bLXQ3Ow2laRk3IFEqbDLM_l6YHNPp8W\u0026index=2\u0026ab_channel=HieuNguyen) của chú Hiếu Nguyễn và bài viết này là tổng hợp những kiến thức mà chú đã chia sẻ trong podcast đó.\n\nNhư đã thấy ở bức ảnh trên, có bốn cột mốc chính đánh dấu cho từng giai đoạn trong hành trình ***Tự do tài chính***. \n\n## 🌿 [Căng thẳng \u0026 Bất an](40123345%20posts/44%20Finance/Căng%20thẳng%20\u0026%20Bất%20an.md)\n\n🌱 Nợ nần: trạng thái thấp nhất (level ⚠️) \n- Đây thường sẽ là xuất phát điểm của hầu hết các bạn trẻ bên nước ngoài. Khi ra trường họ sẽ phải gách 1 món nợ - [Student Loan](https://en.wikipedia.org/wiki/Student_loan)\n- Còn ở VN thường sẽ có xuất phát điểm ở cột mốc thứ 2\n\n🌱 Ăn bám gia đình (level 0️⃣)\n- Chưa có gì trong tay, phụ thuộc hoàn toàn vào gia đình.\n\n🌱 Tự nuôi bản thân (level 1️⃣)\n- Bắt đầu có thu nhập và có thể tự nuôi bản thân nhưng vẫn theo kiểu lương tháng nào tiêu hết tháng đấy.\n\n\u003e Điểm chung ở giai đoạn này là bản thân sẽ luôn ở trong trạng thái căng thằng và bất an. Nếu có những biến cố(mất việc, ốm đau, ...) xảy ra sẽ hoàn toàn không có khả năng đối ứng được.\n\n## 🌿 [Theo dõi \u0026 Kiến tạo](40123345%20posts/44%20Finance/Theo%20dõi%20\u0026%20Kiến%20tạo.md)\n\n🌱 Theo dõi chi tiêu (level 2️⃣ - trạng thái hiện tại của tôi)\n-  Theo dõi chi tiết từng chi tiêu hàng ngày của bản thân. Từ đó tính toán được mức ***Chi tiêu tối thiểu*** và ***Chi tiêu tiêu chuẩn***. \n- Bước này cực kì quan trọng, 2 mức độ chi tiêu xác định được ở trên sẽ là tiền đề để chúng ta tính toán những cột mốc tiếp theo.\n- Hiện tại tôi đã và đang tập hình thành thói quen lưu lại chi tiêu hằng ngày bằng app Money Lover.\n\n\u003e Tạo cho bản thân thói quen theo dõi chi tiêu. Các mức chi tiêu sẽ thay đổi theo thời gian nên thói quen này vô cùng quan trọng.\n\u003e \n\u003e Xác định được mức ***Chi tiêu tối thiểu*** và ***Chi tiêu tiêu chuẩn***. \n\nSau quá trình **theo dõi** 👀, tiếp đến sẽ là **hành động** 👷‍♂️.\n\n🌱 Xóa nợ (level 3️⃣)\n- Là nền móng quan trọng để chúng ta có thể xây dựng vững chắc mô hình tài chính của bản thân sau này. \n- Ở level này, chúng ta cần xác định những khoản nợ xấu, khoản nợ tốt, thứ tự ưu tiên của từng khoản nợ. Kết hợp với kết quả của việc theo dõi chi tiêu =\u003e Có một kế hoạch rõ ràng cho việc trả nợ dứt điểm.\n- Đừng nóng vội khi vừa muốn trả nợ vừa muốn tích góp và vừa muốn đầu tư. Bạn sẽ phải hối hận vì phải xử lý nhiều những tasks khó cùng một lúc đấy.\n\n\u003e Tâm lý thoải mái, không lo đến nợ nần nữa, tập trung hoàn toàn tâm trí cũng như nguồn tiền cho việc xây dựng tài chính cá nhân.\n\nTrả nợ đời xong rồi thì tập trung xây dựng mô hình tài chính của bản thân thôi 💪\n\n🌱 Setup dòng tiền (level 4️⃣)\n- Không nên để tiền ở một chỗ, dễ dẫn đến việc tiêu tiền lấn sang những quỹ có mục đích khác.\n- Ở bước này chúng ta sẽ thiết lập Dòng chảy cho nguồn tiền của bản thân. Tiếp cận những định nghĩa mới như Quỹ Khẩn Cấp (Emergency Fund), Rainy Day Fund, Every Day Fund, Saving Account, ... được sử dụng như thế nào? Cách xác định tỉ lệ cho từng quỹ là bao nhiêu?\n- Sau khi Setup xong, tôi có thể xác định được runway của mình là bao nhiêu. Khi có biến cố, chất lượng cuộc sống của tôi vẫn được đảm bảo trong thời gian bao lâu. \n\n\u003e Tạo ra một hành lang an toàn về tài chính cho bản thân. Tránh bản thân gặp phải những bất an khi có biến cố xảy đến.\n\u003e \n## 🌿 Tích lũy \u0026 Đầu tư (Well Building)\n\nMượn cách ví von của [Kevin O'Leary](https://en.wikipedia.org/wiki/Kevin_O%27Leary) - một trong những Shark xuất hiện trong chương trình Shark Tank của Mỹ chia sẻ:\n\u003e Tôi coi tiền của mình là những chiến binh 💂. Mỗi ngày tôi thả những chiến binh của mình ra trận và cuối ngày tôi muốn những chiến binh đó sẽ đem lại cho mình thật nhiều tù binh 💵💵💵.\n\nSau khi đạt được level 4️⃣, chúng ta đã xây dựng được một hậu phương vững chắc. Công việc bây giờ sẽ là tuyển mộ quân sĩ để bắt đầu ra trận chinh chiến ⚔️.  \n\n🌱 Trương mục đầu tư (level 5️⃣)\n- Xây dựng trương mục đầu tư và có cho mình những phương châm để quản lý những trương mục này.\n\n🌱 Thu nhập thụ động (Passive Incomes - level 6️⃣)\n- Xây dựng và phát triển những nguồn thu nhập thụ động.\n\n\u003e Level 5️⃣ \u0026 6️⃣ sẽ đi liền với nhau, giúp chúng ta chiêu mộ thêm nhiều binh lính 💂 (gia tăng nguồn vốn).\n\u003e Nguyên tắc căn bản của giai đoạn này đó là tăng thu và giảm chi.\n\n![](00%20Meta/01%20Attachments/Pasted%20image%2020221119225431.png)\n\nSau 2 level trên, khi đã tích lũy được một nguồn vốn nhất định, bây giờ chúng ta có thể chuyển qua bước **Đầu tư**.\n\n🌱 Đầu tư (level 7️⃣)\n- Tìm cách chọn những mô hình đầu tư hiệu quả.\n- Học hỏi, trau dồi, nâng cao kiến thức, kinh nghiệm đầu tư.\n\n\u003e Ở gian đoạn này, chúng ta có thể xen kẽ thực hiện các bước với nhau, không cần tuần tự như giai đoạn 2.\n\u003e Giai đoạn này sẽ là giai đoạn dài hơi nhất trong hành trình.  Liên tục tích góp và đầu tư thì sẽ đến lúc chúng ta sẽ bước đến giai đoạn thứ 4(tôi không muốn dùng từ giai đoạn cuối cùng vì đây không phải là điểm kết thúc).\n\n## 🌿 Tự do tài chính\n\nCó 3 cột mốc khi chúng ta đạt đến giai đoạn `chính quả` này, đó là:\n\n🌱 An toàn tài chính (Finacial Security - level 8️⃣)\n- Có được số tiền có thể đảm bảo mức sống cơ bản của bản thân cho đến cuối đời, kể cả khi chúng ta vì một lý do nào đó mà không thể làm việc được nữa.\n- Có quyền bỏ đi(ở mọi lĩnh vực)\n\n🌱 Độc lập tài chính (Financial Independence - level 9️⃣)\n- Khái niệm FIRE - Financal Independence Retire Early - Ngưng làm việc nhưng vẫn đáp ứng được những nhu cầu liên quan đến tài chính theo mức chúng ta mong muốn.\n\n🌱  [Tự do tài chính](40123345%20posts/44%20Finance/What%20is%20the%20Financial%20Freedom?.md) (Financial Freedom - level 🔟)\n- Khi đã ở level 9️⃣ đủ lâu chúng ta sẽ dần cảm nhận được sự tư do khi không phải lệ thuộc vào tiền bạc.\n- Lúc này tiền sẽ là công cụ để chúng ta thực hiện những mục tiêu khác.\n-  Có thể tự tin nói: ***Fuckyou Money!!!***\n\n\n \n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/40123345-posts/44-Finance/The-4-Rule":{"title":"🗺️ The 4% Rule","content":"![Pasted image 20221118220330](00%20Meta/01%20Attachments/Pasted%20image%2020221118220330.png)\n🌱 Quy tắc 4% trong lĩnh vực tài chính cá nhân được sử dụng để xác định tương đối 3 cột mốc quan trọng trong hành trình [Tự do tài chính](40123345%20posts/44%20Finance/What%20is%20the%20Financial%20Freedom?.md), đó là:\n- An toàn tài chính (Financial Security)\n- Độc lập tài chính (Financial Independent)\n- Tự do tài chính (Financial Freedom)\n\n## 🌿What?\nQuy tắc 4% được hình thành trong quá trình nghiên cứu và phân tích thị trường trong suốt 75 năm của William P. Bengen. Ông nhận ra rằng trong chu kì 30 năm, 90% các nhà đầu tư có thể bảo toàn được tài sản của mình nếu mỗi năm rút ra 4% trong tổng số đó, cùng với với mức lạm phát trung bình là 3%.\n\n## 🌿 Issue\nTuy nhiên, vẫn có điểm yếu đối với quy tắc này. Theo Bob Dockendorff - chuyên gia tư vấn tài chính cá nhân người Mỹ, Phó chủ tịch Công ty tư vấn tài chính Claro Advisors đã nêu ra khá nhiều điểm bất cập có thể bị ảnh hưởng như:\n- Mức lạm phát hiện nay biến động vô cùng khó đoán\n- Các yếu tố vĩ mô như suy thoái kinh tế, biến động chính trị(Nga X Ucraina), bệnh tật(Covid 19), ...\n\n\u003e Chính vì vậy, chúng ta cần chuẩn bị những phương án quản lý số tiền của mình một cách hợp lý hơn.\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/40123345-posts/44-Finance/Theo-d%C3%B5i-Ki%E1%BA%BFn-t%E1%BA%A1o":{"title":"✍️ Giai đoạn Theo dõi \u0026 Kiến tạo","content":"\n✍️ Các kiến thức trong bài viết này được tổng hợp từ những chia sẻ của chú Hiếu Nguyễn trong [podcast](https://www.youtube.com/watch?v=lKhIompb0M0\u0026list=PL1bLXQ3Ow2laRk3IFEqbDLM_l6YHNPp8W\u0026index=4\u0026ab_channel=HieuNguyen).\n\n## 🌿 Theo dõi chi tiêu (level 2️⃣ )\n\n🌱 Là bước quan trọng nhất! Nếu trong toàn bộ hành trình, chỉ làm duy nhất một bước theo dõi chi tiêu thì nó chắc chắn vẫn sẽ ảnh hưởng rất lớn đến vấn đề tài chính cá nhân của chúng ta.\n\n###  Bước 1 - Ghi lại chi tiêu\n\n🌱 Sử dụng một app điện thoại(hay bất cứ tool gì tiện nhất) như tôi đang sử dụng Money Lover để ghi chú lại tất cả những chi tiêu hàng ngày của mình. Cấu trúc ghi chú:\n- Ngày.                     Vd: 2022-11-20 \n- Mục đích chi tiêu. Vd: Đổ xăng\n- Số tiền.                  Vd: 70,000\n\n\u003e Quan trọng nhất là ghi chép đầy đủ tất cả chi tiêu. Từ đó mới có đủ dữ liệu để chúng ta đánh giá cho những bước tiếp theo.\n\n### Bước 2 - Phân loại chi tiêu\n\n🌱 Sử dụng Excel thống kê toàn bộ dữ liệu chi tiêu của chúng ta đã log lại theo từng tháng. Cấu trúc thống kê:\n\n![](00%20Meta/01%20Attachments/Pasted%20image%2020221120145932.png)\n\n- **Must have**: Các khoản thiết yếu, bắt buộc phải chi tiêu.\n- **Nice to have**: Các khoản có thì tốt mà không có cũng chả làm sao.\n- **Wasted**: Chi tiêu lãng phí, không có mục đích(Ăn nhậu, mua sắm linh tinh, ...).\n\n\u003e Nên làm ít nhất 1 tháng, lí tưởng là vài tháng. Phân loại càng lâu sẽ cover được càng đầy đủ những chi tiêu của chúng ta\n\n🌱 ***Chi tiêu tối thiểu*** =  **Must have**\n\n🌱 ***Chi tiêu tiêu chuẩn*** = **Must have** + **Nice to have**\n\nNếu trong sheet phân loại của chúng ta không có dòng nào là trả nợ, thì chúng ta có thể skip qua bước tiếp theo.\n\n## 🌿 Trả nợ (level 3️⃣)\n\nTháng trước do ăn cơm Thố nhiều quá nên tôi có dùng ví trả sau Momo, mà tôi trả xong rồi nên trộm vía giờ tôi đang không có khoản nợ nào cả 😆.\n\nNhưng kiến thức không thừa, xem trước để nếu sau này có ăn cơm Thố quá liều thì còn biết đường mà trả nợ. Let's gooo 💪!!\n\n![](00%20Meta/01%20Attachments/Pasted%20image%2020221120152632.png)\n\n### Bước 1 - Tách nguồn tiền\n \n 🌱 Setup thành 2 nguồn tiền\n - **Everyday account**: là số tiền phục vụ cho chi tiêu tối thiểu của bản thân(= **Must have**)\n - **Emergency Fund**:  quỹ khẩn cấp, theo đúng tên gọi, trong giai đoạn này, khẩn cấp nhất chính là trả nợ.\n\n\u003e Nên tách riêng ra 2 tài khoản ở hai ngân hàng, cho cái quỹ Emergency khuất mắt đi, không nghĩ gì đến nó nữa.\n \n### Bước 2 - Xác định các khoản nợ \u0026 Đánh độ ưu tiên\n- Lãi suất cao trả trước.\n- Cố gắng sống ở mức tối thiểu, chỉ tập trung trả nợ thôi.\n\n## 🌿 Setup dòng tiền (level 4️⃣)\n\n🌱 Setup thành 4 tài khoản:\n\n![](00%20Meta/01%20Attachments/Pasted%20image%2020221120155605.png)\n\n### 💰 Everyday Account\n- Mỗi tháng sẽ để ở đây mức sống tối thiểu.\n- Ép bản thân chỉ được chi tiêu với số tiền trong tài khoản này thôi.\n\n### 💰 Emergency Fund\n- Quỹ khẩn cấp dùng khi có những việc bất khả kháng như mất việc, bệnh tật, ...\n- Ưu tiên đổ đầy quỹ khẩn cấp trước tiên(nếu có những nguồn thu nhập khác sẽ đổ vào đây trước, khi đầy rồi mới đổ vào những quỹ tiếp theo).\n- ***Target*** = ***Chi tiêu tối thiểu*** x ***runway***(số tháng quỹ cover)\n\n\u003e Tối thiểu là 6 tháng, lý tưởng là 12 tháng.\n\n### 💰 RainyDay Fund\n- Quỹ dùng cho những việc có kế hoạch trước như mua điện thoại mới, sửa nhà, ...\n- Có 2 kiểu xác định ***target*** cho quỹ này:\n\t- Dựa theo kế hoạch, ví dụ như xác định trước cần mua điện thoại 30tr, sửa nhà 50tr, chúng ta sẽ set **target** cho RainyDay Fund là 80tr\n\t- Dựa theo runway. Nếu chúng ta chưa có kế hoạch gì thì có thể set ***target*** với runway từ 3-6 tháng x ***Chi tiêu tối thiểu***.\n\n### 💰 Investment Account\n- Không có ***target*** cho tài khoản này. Bỏ tiền vào càng nhiều càng tốt.\n\n\u003e Ở giai đoạn này, bất cứ khi nào chúng ta có thêm nguồn thu nhập, ngay lập tức phân phối tiền theo mô hình đã setup ở trên. Hạn chế tối đa việc để tiền rảnh ở ***Everyday Account*** nếu không muốn hối hận khi thấy tiền nó cứ bay đi mất 💸\n\u003e \n\u003e Sau giai đoạn này chúng ta đã có thêm quyền lựa chọn. Vd nếu môi trường làm việc hay công việc hiện tại không còn chất lượng, chúng ta hoàn toàn có thể xin nghỉ 👋, bỏ ra vài tháng để tìm cho mình công việc tốt hơn.\n\u003e \n\u003e ✨ Loại bỏ cảm giác bất an, có đủ khả năng đối ứng với những biến cố trong cuộc sống.","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/40123345-posts/44-Finance/What-is-the-Financial-Freedom":{"title":"🗺️ What is the Financial Freedom?","content":"\n\u003e 🚀 Khi bắt đầu muốn tìm hiểu bất kì lĩnh vực gì, chúng ta nên có thói quen chủ động đặt ra 2 câu hỏi `What?` và `Why?` trước khi thực sự theo đuổi. Trong suốt hành trình đó, liên tục làm rõ câu hỏi `How?`. \n\u003e \n\u003e Câu hỏi `How?` thường sẽ mất rất nhiều thời gian, chúng ta cần có nhiều trải nghiệm, kinh nghiệm để đúc kết. Quá trình này có thể là một vài năm, chục năm hay có khi là cả đời. Chính vì vậy làm rõ  `What?` và `Why?` thật sự quan trọng nếu không chúng ta sẽ lãng phí thời gian và công sức của mình. \n\u003e \n\u003e 🌱 What? : làm rõ cái chúng ta muốn thực hiện, theo đuổi là gì?\n\u003e \n\u003e 🌱 Why? : tại sao chúng ta nên thực hiện, theo đuổi nó, chúng ta sẽ \n\u003e nhận được gì?\n\u003e \n\u003e 🌱 How? : tôi cần làm như thế nào để cải thiện kết quả?\n \n## 🌿 What?\n\u003e 🤔 Tự do tài chính là gì?\n\n![Pasted image 20221119145610](00%20Meta/01%20Attachments/Pasted%20image%2020221119145610.png)\n\n🌱 Theo ý hiểu ở thời điểm hiện tại của tôi, ***tự do tài chính*** là trạng thái đạt được khi chúng ta đã thoát khỏi sự ràng buộc của đồng tiền. \n\n🌱 Tiền sẽ là công cụ để chúng ta thực hiện những mục tiêu khác.\n\n🌱 Là khi chúng ta có thể tự tin nói: \n\u003e Fuckyou Money 😏😏😏\n\n\n## 🌿 Why?\n\u003e 🤔 Tại sao tôi phải bỏ ra rất nhiều thời gian và công sức để đạt được ***Tự do tài chính***?\n\n\u003e Đồng tiền không có xấu. Chỉ có 2 sự lựa chọn: ***Mình quản lý Tiền*** hoặc ***Tiền quản lý Mình***.\n\n🌱 Không phải Tự do tài chính là **~~Sự giàu có~~**. Gốc rễ thật sự của hành trình này chính là ***Tự Do***. Đây là thứ xa xỉ nhất mà đến cả những người có rất nhiều tiền cũng chưa chắc đã có được. \n\n🌱 Lúc này đồng tiền chỉ là công cụ giúp chúng ta thoải mái hơn trong mọi quyết định mà thôi.\n\n🌱 Là hành trình giúp chúng ta thay đổi và trau dồi mindset.\n\n🌱 Mang lại chất lượng cho cuộc sống - một cuộc đời đáng sống.\n\n## 🌿 How?\n\u003e 🤔 Làm thế nào để đạt đuợc ***Tự do tài chính***?\n\n🌱 Loại bỏ những lối suy nghĩ sai lệch về tài chính.\n- Đánh đồng chi tiêu phóng khoáng và chi tiêu không có kiểm soát.\n- Không có quản lý chi tiêu, lương tháng nào tiêu hết tháng đấy.\n- Cẩn thận khi chưa kịp ***Giàu*** đã ***Già***.\n\n🌱 Trang bị kiến thức:\n- **Mindset \"biết đủ\"**.\n- **Escape Velocity** - Vận tốc thắng được trọng lực của Trái Đất để có thể đưa được vệ tinh ra ngoài vũ trụ. Trong lĩnh vực tài chính, **là một con số (dựa trên [The 4% Rule](40%20posts/44%20Finance/The%204%%20Rule.md)) thắng được sức cản của đồng tiền** giúp chúng ta mở rộng danh sách lựa chọn của bản thân(Tự do).\n- [Xác định từng cột mốc nhỏ](40123345%20posts/44%20Finance/Each%20step%20to%20the%20Financial%20Freedom.md) cho hành trình này.","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.01-Style/SOLID":{"title":"💪 What is SOLID?","content":"\n🌱 SOLID là cụm từ  tạo thành từ những chữ cái viết tắt của 5 nguyên tắc được đúc kết từ 'xương máu' của rất nhiều lập trình viên đi trước =)) Nếu đã từng làm dự án thực tế, mọi người sẽ đều biết là gần 80% thời gian sẽ là bảo trì hệ thống(thêm tính năng, sửa lỗi, ...). Áp dụng SOLID, công việc bảo trì  và mở rộng sẽ dễ dàng hơn rất nhiều. Cùng xem những nguyên tắc 'thần thánh' nhưng vô cùng 'thân thuộc' này là gì nha! \n\n## 🌿 Single Responsibility Principle\n\nMỗi class chỉ nên thực hiện **một nhiệm vụ** đơn lẻ!\n\n![[00 Meta/01 Attachments/Single Responsibility Principle.png]]\n\n\n## 🌿 Open/Closed Principle\n\nKhi thêm tính năng cho class, nên viết những class mới kế thừa class cần mở rộng.\n\n![[00 Meta/01 Attachments/Open-Closed Principle.png]]\n\n## 🌿 Liskov Substitution Principle\n\n\n![[00 Meta/01 Attachments/Liskov Subtitution Principle.png]]\n\n## 🌿 Interface Segregation Principle\n\n![[00 Meta/01 Attachments/Interface Segregation Principle.png]]\n\n\n## 🌿 Dependency Inversion Principle\n\n![[00 Meta/01 Attachments/Dependency Inversion Principle.png]]","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.02-Git/Git-config-for-multi-accounts":{"title":"⚙️ Git config for multi accounts","content":"\n---\n\n#til #gitconfig\n## Vấn đề\n---\n Bài viết này ra đời khi mình bị các anh ngồi cạnh 'cười chê' do dùng nhiều accounts git trên cùng một máy nhưng lại switch bằng cơm =))) Sau khi khóc xong thì mình có tìm hiểu cách config để thuận tiện hơn cho việc sử dụng.\n\n## Giải pháp\n---\n Ý tưởng là mình sẽ chia ra làm 2 thư mục **work** và **personal**  để sử dụng cho các repo tương ứng.\nỞ file **.gitconfig** global set user mặc định và điều hướng config riêng cho từng folder.\n``` git\n# .gitconfig\n\n[user]\n  name = anhnh-1028\n  email = nguyen.hoang.anh-c@sun-asterisk.com\n\n[includeIf \"gitdir:~/personal/\"]\n  path = ~/personal/.gitconfig-personal\n\n[includeIf \"gitdir:~/work/\"]\n  path = ~/work/.gitconfig-work\n```\n- Set user cho từng folder\n---\n```git\n# ~/work/.gitconfig\n\n[user]\n  name = anhnh-1028\n  email = nguyen.hoang.anh-c@sun-asterisk.com\n\n# ~/personal/.gitconfig\n[user]\n  name = anhnh-3008\n  email = mail-personal@gmail.com\n```\n- Xong phần config thông tin, giờ đến phần ssh. Skip bước gen ssh-key + add key lên git, giờ mình set [[50 til/51 Code/51.06 Servers/Config SSH]] thôi.\n---\n```git\n# ~/.ssh/config\n\nHost git-work\n  HostName github.com\n  User git\n  IdentityFile ~/.ssh/ssh-key-work\n\nHost git-personal\n  HostName github.com\n  User git\n  IdentityFile ~/.ssh/ssh-key-personal\n```\n\nThế là xong rồi, giờ mình chỉ cần set-url remote theo tên Host đã config thôi là chạy phà phà rồi.\n```sh\ngit@github.com:anhnh-3008/app.git -\u003e git@git-personal:anhnh-3008/app.git\n```\n\nNgoài ra trong file .gitconfig còn có thể setup được cả color branch, alias, editor, ... Mình có chôm được mấy cái [settings](https://github.com/ttuan/dotfiles/blob/master/git/gitconfig) hay hay của một anh ở công ty, mọi người có thể tham khảo nhé =)) nếu thấy hay thì cho anh mình một ⭐ nha \u003c3\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.02-Git/Git-hooks-with-pre-commit":{"title":"🥦 Git hooks with pre-commit","content":"\n🌱 Để tránh tình trạng gặp phải **stupid mistakes** như push code lên mà có cả `byebug`, `binding.pry`, `debugger`, ... Git cho phép chúng ta sử dụng `hooks` để kiểm tra tự động những vấn đề ntn 🥳\n\n🌱 Tất cả các hooks của 1 repo được lưu trong folder `.git/hooks`\n\n![](00%20Meta/01%20Attachments/Pasted%20image%2020221121182121.png)\n\n🌱 Tạo file `.git/hooks/pre-commit`. Có thể viết bằng bất kỳ `script language(như Ruby, Python, JS, ...)` nào chúng ta muốn.\n\n```sh\n#!/bin/sh\n\nFILES_PATTERN='\\.?$'\n\nFORBIDDEN='binding.pry\\|byebug\\|console.log'\n\ngit diff --cached --name-only | \\\n    grep -E $FILES_PATTERN | \\\n    xargs grep --color --with-filename -n $FORBIDDEN \u0026\u0026 \\\n    echo 'COMMIT REJECTED' \u0026\u0026 \\\n    exit 1\n\nexit 0\n```\n\n🌱 Bạn có thể custom những từ khóa không muốn push lên repo thông qua biến `FORBIDDEN`.\n\n![](00%20Meta/01%20Attachments/Pasted%20image%2020221121182849.png)","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.03-Operating-System/Pipe-Data-between-Programs":{"title":"🥦 Pipe Data between Programs","content":"\n🌿 Trong Shell, The Pipe cho phép kết hợp giữa nhiều commands trên cùng một dòng. Được kí hiệu bằng ký tự ASCII 124 ( | ), dấu gạch dọc.\n\n```sh\nVD1:\n🌱 kết hợp câu lệnh tìm kiếm theo pattern và đếm có bao nhiêu lines trả về từ grep\n\n\u003e grep /bin/bash$ [PATTERN] | wc -l\n```\n\n![](https://lh3.googleusercontent.com/P_MDCWdC8VPh8ZMVK3p-MxX8uWYP2w2XFv9mEeMoIudE4x9hJw4S5OaAMjaIRn6Utr8gjNVSSVg89VtDzlL5TI-PUwcDJEM24e-ylJUzcIMpeNFSvTnbrDbctMs8FHrnp_xQ8Mz-jf4pNJzsGQ-79Tf1hTenyIh1fAGdLqz5DS4X9KAtvQVhaVv358Qi)\n\n### Nguồn\n- LPIC - 1 - trang 105 ","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.03-Operating-System/Some-Tips-for-irb-rails-console":{"title":"🥦 Some Tips for irb/rails console","content":"\n### 🌿 Lấy giá trị output cuối cùng\n🌱 `_` được gán giá trị là output mới nhất của irb/rails console.\n\n```sh\n\u003e 1 + 1 \n=\u003e 2\n\u003e _\n=\u003e 2\n```\n\n### 🌿 Sandbox\n🌱 Khi dùng option `--sandbox` các thay đổi đối với `atabase` sẽ được `rollback` khi thoát `rails console`.  \n\n```sh\nrails c --sandbox\n\n\u003e Account.first.destroy\n=\u003e true\n\u003e Account.find(1)\n=\u003e ActiveRecord::RecordNotFound: Could not find Account with id=1\n\u003e exit\n\nrails c\n\u003e Account.find(1)\n=\u003e #\u003cAccount id: 1, ...\u003e\n```\n\n### Tham khảo\n- https://pragmaticstudio.com/tutorials/rails-console-shortcuts-tips-tricks","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.03-Operating-System/Why-must-run-apt-update-before-install-any-lib-for-Linux":{"title":"🥦 Why must run apt update before install any lib for Linux?","content":"\n[Câu trả lời](https://askubuntu.com/questions/337198/is-sudo-apt-get-update-mandatory-before-every-package-installation)\n\n🌱 Lệnh `apt update` sẽ cập nhật danh sách mới nhất các packages có trong kho Ubuntu.\n\n🌱 Lệnh `apt install` sẽ đọc trong danh sách packages được cập nhật ở lệnh `apt update` gần nhất.\n\n🌱 Nếu chắc chắn package chuẩn bị install đã nằm trong danh sách cập nhật, việc chạy `apt update` có vẻ là hơi thừa 😶 Cơ mà thay vì ngồi xác định như thế thì mình chọn chạy `apt update` cho đỡ mệt mọi 😆\n\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.03-Operating-System/create-multi-folders-linux":{"title":"🥦 Create multi folders linux","content":"\n🌱 Create multi foders in Linux with command below:\n\n```sh\nmkdir /path/{folder1, folder2, folder3}\n\ntree /path/\n \n├── folder1\n├── folder2\n├── folder3\n```\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.03-Operating-System/visudo":{"title":"🥦 visudo","content":"\n🌱 Cấp quyền(cho user root, lệnh sudo, group admin) được cấu hình trong file `/etc/sudoers` .\n-    Không bao giờ sử dụng trình soạn thảo văn bản thông thường(nano, vim, ...) để sửa `/etc/sudoers` , thay vào đó hãy dùng `visudo` .\n-   `visudo` validate cú pháp trước khi save file còn nano, vim, .... thì không, save mà sai syntax là oẳng luôn đó 🥵\n\n🌱 Xem thêm: [https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file](https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file)","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.04-Rails/Add-custom-flash-keys":{"title":"🥦 Add custom flash keys","content":"\n---\n\n`ActionController::Base` mặc định cung cấp key `:notice` cho `#redirect_to`   \n```ruby\n  class flash_demo\n    if true\n      redirect_to root_path, notice: \"Notice\"\n    else\n      flash[:error] = \"Error\"\n      redirect_to root_path\n    end\n  end\n```\n\nNhưng nếu bạn muốn thêm `:error` như `:notice` thì có thể thử cách này nhé!\n```ruby\n  class flash_demo\n    add_flash_types :error\n    \n    if true\n      redirect_to root_path, notice: \"Notice\"\n    else\n      redirect_to root_path, error: \"Error\"\n    end\n  end\n```\n\nRefer: [add_flash_keys](https://til.hashrocket.com/posts/ouyfd1cpfu-add-custom-flash-keys)","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.04-Rails/Config-warning-when-fetched-a-lot-of-records":{"title":"🥦 Config warning when fetched a lot of records","content":"\n 🌱 Từ Rails 5 chúng ta đã có thể thêm config `warn_on_records_fetched_greater_than`:  hiển thị cảnh báo trong `rails server` hoặc `rails console` khi có số lượng câu queries lớn hơn số lượng chúng ta đã chỉ định.\n\n```rb\n# config/environments/development.rb\n\n# Show warn if fetch greater than 50 records\nconfig.active_record.warn_on_records_fetched_greater_than = 50\n```\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Config warning when fetched a lot of records/Pasted image 20221020091559.png]]","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.04-Rails/Custom-condition-sign-in-for-devise":{"title":"🥦 Custom condition sign-in for devise gem","content":"\n---\n\nMặc định khi đăng nhập, Devise sẽ tìm User dựa theo scope đã được thiết lập trong `config/initializers/devise.rb` \nVd như đăng nhập theo email:\n\n```rb\nDevise.setup do |config|\n  config.authentication_keys = [:v_code]\nend\n```\n\n## Vấn đề\n---\nThế nhưng cuộc sống thường lắm gian truân và cuộc đời của mình cũng không ngoại lệ. \nDự án của mình có đồng thời 2 cơ chế đăng nhập 1 là qua Devise, 2 là SSO thông qua bên thứ 3. Khi thực hiện SSO, hệ thống sẽ lưu user đó vào DB chung luôn và phân biệt bằng trường `provider`. Vấn đề là giờ phải xử lý sao cho khi đăng nhập với Devise, những thằng user do bên thứ 3 cung cấp không thể login vào được hệ thống.\n\n## find_for_database_authentication(warden_conditions)\n---\nChúng ta có thể overwrite lại method `find_for_database_authentication` của Devise.\n\t- Method nhận vào scope chứa `authentication_keys`.\n\t- Output trả về một record tồn tại trong DB hoặc `nil`.\n\n```rb\ndef find_for_database_authentication(warden_conditions)\n  conditions = warden_conditions.dup\n  # trim space and downcase\n  email = conditions.delete(:email).strip.downcase\n  find_by(email: email, provider: :traditional)\nend\n```\n\n\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.04-Rails/Custom-direct-URL-by-Routes-in-Rails":{"title":"🥦 Custom direct URL by Routes in Rails","content":"\n🌱 Rails cung cấp `direct` giúp chúng ta xác định một `route` `redirect` đến một URL bất kỳ. \n\n```rb\n# config/routes.rb\nRails.application.routes.draw do\n\tdirect :get_to_my_blog do\n\t\t\"https://nhanh.netlify.app\"\n\tend\nend\n```\n\n🌱 Trong Rails ta sẽ có route `get_to_my_blog_url` gọn gàng đẹp đẽ. \n\n🌱 Ngoài ra có thể thêm điều kiện để  get URL.\n\n```rb\n# config/routes.rb\nRails.application.routes.draw do\n\tdirect :get_to_the_goog, search: nil do |options| \n\t\t\"https://google.com/search?q=#{options[:search]}\"\n\tend\nend\n\nget_to_the_goog_url(search: \"stackoverflow\")\n```\n\n🌱 `Direct` sẽ không hiển thị routes khi chúng ta gõ `rails routes`. Chúng ta sẽ vẫn có `_path` helper nhưng ko nên sử dụng vì nó cắt mất cái tên miền đấy 😂. \n🌱 Ngoài ra `direct` không dùng được trong `namespace` hoặc `scope`. Nếu đặt nhầm thì rails sẽ `raise exception`.\n\n### Tham khảo\n- https://guides.rubyonrails.org/v5.2/routing.html#direct-routes","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.04-Rails/Custom-order-in-SQL-with-RoR":{"title":"🥦 Custom order in SQL with RoR","content":"\n🌱 `in_order_of` cho phép order theo thứ tự chỉ định trong SQL.\n\n```rb\nUser.in_order_of(:id, [1, 5, 3])\n# SELECT \"users\".* FROM \"users\"\n#   WHERE \"users\".\"id\" IN (1, 5, 3)\n#   ORDER BY CASE\n#     WHEN \"users\".\"id\" = 1 THEN 1\n#     WHEN \"users\".\"id\" = 5 THEN 2\n#     WHEN \"users\".\"id\" = 3 THEN 3\n#   END ASC\n```\n\n🌱 [source code](https://github.com/rails/rails/blob/1f6202a1fe6cd976993c88a7e22afc165ba06c5f/activerecord/lib/active_record/relation/query_methods.rb#L526)\n\nFYI: Cách này trong SQL sẽ sort mà không sử dụng index. \n![[00 Meta/01 Attachments/Pasted image 20221114184148.png]]\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.04-Rails/How-to-safely-remove-a-column-in-Rails":{"title":"🥦 How to safely remove a column in Rails? ","content":"\n---\n\nRails cung cấp method `ignored_columns` để xóa tạm thời một cột trong DB, sau khi sửa logic xong xuôi chúng ta mới thực hiện migrate, tránh việc migrate đi migrate lại, deploy nhiều lần(nếu cột đã có trên môi trường STG/PROD).\n\n🌱 Step 1️⃣: Set ignore cột cần xóa trong model.\n\n```rb\nclass User \u003c ActiveRecord::Base\n  self.ignored_columns = [:username]\nend\n```\n\n🌱 Step 2️⃣: Kiểm tra xem cột `username` đã được xóa tạm thời chưa.\n\n```rb\nUser.first.username\n\n=\u003e raises exception NoMethodError\n```\n\n🌱 Step 3️⃣: Thay đổi logic code liên quan đến trường `username`.\n\n🌱 Step 4️⃣: Deploy lên các môi trường, test/fix những \"lỗi lầm\" nếu có.\n\n🌱 Step 5️⃣: Thêm migrate xóa cột `username` .\n\n🌵Refer: [https://newsletter.shortruby.com/p/how-to-safely-remove-a-column-in](https://newsletter.shortruby.com/p/how-to-safely-remove-a-column-in)","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.04-Rails/Quick-open-source-of-gem":{"title":"🥦 Quick open source of gem","content":"\n🌱 Nếu bạn muốn debug hoặc sửa gem, có thể truy cập đến thư mục gem một cách nhanh chóng bằng command:\n\n```sh\nbundle open GEM_NAME\n```\n\n🌱 Trình soạn thảo văn bản sẽ được mở theo `$EDITOR` hoặc `$BUNDLER_EDITOR`\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.04-Rails/Run-Rspec-save-your-time":{"title":"🥦 Run Rspec save your time","content":"\n---\n\n#til #rspec\n\tIf you want to run rspec for a specific example, context or describe without having to care about path file, line number, you can try it:\n\n```ruby\n# spec/rails_helper.rb\n\nRSpec.configure do |config|\n  config.filter_run_when_matching focus: true\nend\n```\nThen you add f to example, context or describe, Rspec will only focus it.\n\n```ruby\n#example\nfit 'should tell height' do\n  expect(@person.height).to eq(160)\nend\n\n# as well\n\nit 'should tell height', focus: true do\n  expect(@person.height).to eq(160)\nend\n```\np/s: you can add focus for multi examples\nRef: https://manny.codes/7-ways-to-selectively-run-rspec-tests/","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.04-Rails/Sidekiq-Beta-7.0-available":{"title":"🥋 Sidekiq Beta 7.0 available","content":"\n---\n\nHôm 2022-09-26 Author and Maintainer của Sidekiq **Mike Perham** đã cho ra mắt bản beta version 7.0 của **Sidekiq**. Đây được giới thiệu là một đợt big update với một vài tính năng siêu to và mới =)) một vài tính năng bị loại bỏ, một số API được cấu trúc lại và requirements được update.\n\n## Version Support\n---\n- Required Redis 6.2+\n- Required Ruby 2.7+\n- Support for Rails 6.0+\n\n## Upgrade\n---\nNếu bạn muốn upgrade lên ver 7.0 để trải nghiệm và có cơ hội trở thành contributer cho **sidekiq** thì đừng ngần ngại mà hãy thêm dòng này vào Gemfile của mình nhé =))\n```ruby\ngem 'sidekiq', '\u003c 8'\n```\n\n## What's new?\n---\n\n### Job Metrics\n---\nVersion 7.0 sẽ add một tab metrics trên Web UI với high-resolution data cho thời gian excute job cũng như là khả năng đánh dấu thời điểm deploy. \nMọi người có thể xem chi tiết tính năng này ở [Metrics](https://github.com/mperham/sidekiq/wiki/Metrics) \n\n### Embedding\n---\nTrước đây mọi người chỉ có thể khởi động **Sidekiq** bằng câu lệnh \n```sh\nbundle exec sidekiq\n```\nTính năng này theo tác giả có nói là một cách thử nghiệm để chạy **Sidekiq** thông qua việc gọi trực tiếp bằng những dòng code Ruby. Nó được gán nhãn thử nghiệm là vì có khả năng xung đột với plugins bên thứ 3 hay với chính hệ thống của bạn.\nMọi người có thể xem chi tiết tính năng này ở [Embedding](https://github.com/mperham/sidekiq/wiki/Embedding)\n\n### Capsules\n---\n...\n\n### redis-client\n---\n- **redis-client** là một Rubygem mới sử dụng giao thức RESP3 có trong Redis 6.0+.\n- Sidekiq 6.5 đã giới thiệu về việc hỗ trợ cho gem **redis-client**  trong khi vẫn sử dụng gem **redis** là mặc định. Đến sidekiq 7.0 đã hoàn thiện việc chuyển đổi này và đã không còn sử dụng **redis** là mặc định nữa.\n- **App của bạn vẫn có thể tiếp tục sử dụng redis**. \n- Hiện tại nếu bạn sử dụng **Sidekiq.redis** để truy cập vào kết nối Redis, API đó sẽ expose một connection dựa trên **redis-client**.\n\n### redis-namespace\n- 7.0 đã bỏ phần support cho **redis-namespace**. \n\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.04-Rails/Validate-number-of-association":{"title":"🥦 Validate number of association","content":"\n---\n\n#til #validate #rails \n\tIf you have a People model and a Vehicle model, every people has_many vehicles but you want to set maximum for number of vehicles which a people can has. You can use following command below:\n\n```ruby\n# vehicle.rb\nclass Vehicle\n  belongs_to :people\nend\n\n# people.rb\nclass People\n  has_many :vehicles\n\n  validates :vehicles, length: { maximum: 2 }\nend\n```\nRef: https://til.hashrocket.com/posts/egegrgsdnj-limiting-object-counts-in-rails-associations-\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.04-Rails/_in_-and-_out_-of-Pry":{"title":"🥦 _in_ and _out_ of Pry","content":"\n🌱 Trong Pry, các giá trị `input`, `output` sẽ tự động được lưu trong 2 array có thể truy cập được đó là `_in_` và `_out_`. Số lượng phần tử cache của 2 cu này được định nghĩa ở `Pry.config.memory_size`(mặc định là 100 phần tử). Nếu hết dung lượng, những giá trị mới sẽ được ghi đè.\n\n```sh\n[1] pry(main)\u003e 1\n=\u003e 1\n[2] pry(main)\u003e 2\n=\u003e 2\n[3] pry(main)\u003e 3\n=\u003e 3\n[4] pry(main)\u003e _in_\n=\u003e #\u003cPry::Ring:0x0000562f98b2ce88 @buffer=[nil, \"1\\n\", \"2\\n\", \"3\\n\", \"_in_\\n\"], @count=5, @max_size=100, @mutex=#\u003cThread::Mutex:0x0000562f98b2ce60\u003e\u003e\n[5] pry(main)\u003e _out_\n=\u003e #\u003cPry::Ring:0x000055d4e3002b80 @buffer=[nil, 1, 2, 3, #\u003cPry::Ring:0x000055d4e3002b80 ...\u003e], @count=5, @max_size=100, @mutex=#\u003cThread::Mutex:0x000055d4e3002b58\u003e\u003e\n[6] pry(main)\u003e _out_.to_a[1] + _out_.to_a[2]\n=\u003e 3\n```\n\n🌱 [document](https://github.com/pry/pry/wiki/Special-Locals#the-input-and-output-cache)\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.04-Rails/frozen_string_literal-in-rails":{"title":"🥦 frozen_string_literal in rails","content":"\n🌱 Rubocop có rule check khai báo `frozen_string_literal: true` cho từng file, nhưng nó để làm gì?\n\n🌱 `frozen_string_literal` là một **magic comments** có từ Ruby 2.3, nó giúp tối ưu bộ nhớ cũng như cải thiện performance bằng việc **cung cấp vùng nhớ dựa theo nội dung của string**(nội dung giống nhau sẽ chung 1 vùng nhớ), tương tự như `:symbol`. Ngoài ra, sử dụng comment trên cũng sẽ ngăn chặn việc thay đổi string.\n\n```rb\n# test.rb\n\n# frozen_string_literal: true \np 'name'.object_id\np 'name'.object_id\n\nstr  =  'hello'\nstr  \u003c\u003c  ' world'\n\np str\n```\n\n```sh\nruby test.rb\n60\n60\nTraceback (most recent call last):\ntest.rb:6:in `\u003cmain\u003e': can't modify frozen String: \"hello\" (FrozenError)\n```\n\n🌱 Nếu trong file `frozen`, chúng ta vẫn muốn một string động, có thể khai báo:\n\n```rb\nstr = String.new('hello')\nstr \u003c\u003c ' world'\n```\n\n- [Tham khảo](https://www.mikeperham.com/2018/02/28/ruby-optimization-with-one-magic-comment/)\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.05-Ruby/Awesome-Ruby-Repository":{"title":"💎 Awesome-Ruby Repository","content":"\n---\n\n-   Được khởi xướng bởi Marc Anguera - Lead engineer \u0026 CTO tại Crisalix(cung cấp dịch vụ xuất hình ảnh 3D, 4D cho những người muốn nhìn thấy trước những thay đổi như phẫu thuật thẩm mỹ chẳng hạn, em **cảnh báo** là không nên xem web này ở trên cty nha :D ), repo hiện tại đã nhận được 12.4k sao và nhiều phản hồi tích cực từ cộng đồng Ruby Dev.\n-   [Awesome-ruby](https://github.com/markets/awesome-ruby) là repo phân loại tổng hợp những `thư viện cho Ruby`, những `tools`, `frameworks`, `best practice` và `phần mềm` có chất lượng `awesome` có thể sẽ cần thiết để chúng ta xây dựng những `modern Apps` hay `Web Apps` .\n-   Điều kiện tiêu chuẩn:\nĐể được thêm vào repo, cần đạt những chất lượng tiêu chuẩn sau:\n\t- Thường được sử dụng(tối thiểu là 20k lượt tải) và hữu ích với cộng đồng.\n\t-   Chủ động bảo trì, cập nhật thường xuyên(chỉ cần là vẫn giải quyết các issues cho version hiện tại cũng là đạt yêu cầu rồi).\n\t-   Ổn định.\n\t-   Được tài liệu hóa.\n\t-   Có tests.\n\nVới những điều kiện trên thì mọi người có thể yên tâm mấy thứ được suggests trên repo toàn là hàng chất lượng thôi nhé =))","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.05-Ruby/Check-prefix-of-string":{"title":"🥦 Check prefix of string","content":"\n---\n\n🌱 Trong Ruby, class `String` cung cấp method `start_with?` nhận vào những tiền tố mà bạn muốn xác định, trả về `true` nếu chuỗi kiểm tra bắt đầu bằng một trong những tiền tố đó.\n\n```rb\nstring = \"hello world\"\n\nstring.start_with?(\"abc\", \"mentor\") # =\u003e false\nstring.start_with?(\"zys\", \"hell\")   # =\u003e true\n```\n\n🌱 Tham số:  \n\t- Phân biệt chữ Hoa và chữ thường\n\t-   Nhận regex\n\n```rb\nstring = \"hello world\"\n\nstring.start_with?(\"zys\", \"Hell\") # =\u003e false\nstring.start_with?(/[\\s\\S]*/)     # =\u003e true\n```\n\n🌱 Ref: [https://til.hashrocket.com/posts/rettwv4dgl-check-if-string-starts-with-prefixes](https://til.hashrocket.com/posts/rettwv4dgl-check-if-string-starts-with-prefixes)","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.05-Ruby/Operator-+-and-with-string":{"title":"🥦 Operator += and \u003c\u003c with string","content":"\n🌱 Trong Ruby, hãy nối chuỗi bằng `\u003c\u003c` thay vì `+=`!\n- `+=` sẽ tạo ra một object mới sau khi nối chuỗi.\n\n```rb\nname = \"Hoang\"\n\nname.object_id\n=\u003e 71860\n\nname += \" Anh\"\n\nname.object_id\n=\u003e 71880\n```\n\n- `\u003e\u003e` sẽ nối chuỗi trực tiếp trên object cũ, không tạo ra object mới. Cải thiện performance khi thao tác với những chuỗi lớn.\n\n```rb\nname = \"Hoang\"\n\nname.object_id\n=\u003e 71900\n\nname \u003c\u003c \" Anh\"\n\nname.object_id\n=\u003e 71900\n```\n\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.05-Ruby/Ruby-Module-Include-Prepend-and-Extend":{"title":"🥦 Ruby Module: Include, Prepend and Extend","content":"\n## 🌿 Ancestors chain\n- Khi khởi tạo một Class, mỗi Class sẽ có một `ancestors chain` - là danh sách các classes và modules mà nó được kế thừa hoặc imported.\nTrong Ruby có 3 cách để import Module cho 1 Class.\n\n### 🌱 Include\n- Method trong module sẽ trở thành `instance method` của Class.\n- Thứ tự trong `ancestors chain`: `Class` \u003e `Module/Class imported` \u003e `Superclass`.  \n\n```rb\nmodule A\n\tdef say\n\t\tp 'hello'\n\tend\t\nend\n\nclass B\n\tinclude A\nend\n```\n\n``` sh\n\u003e B.new.say\n=\u003e \"hello\"\n\u003e\n\u003e B.ancestors\n=\u003e [B, A, ..., Object, ..., BasicObject]\n```\n\n### 🌱 Prepend\n- Giống `include`, khác thứ tự được thêm vào trong `list ancestors`.\n- Thứ tự trong `ancestors chain`: `Module/Class imported` \u003e `Class` \u003e `Superclass`.\n\n```rb\nmodule A\n\tdef say\n\t\tp 'hello'\n\tend\t\nend\n\nclass B\n\tprepend A\nend\n```\n\n``` sh\n\u003e B.new.say\n=\u003e \"hello\"\n\u003e\n\u003e B.ancestors\n=\u003e [A, B, ..., Object, ..., BasicObject]\n```\n\n### 🌱 Extend\n- Method trong module trở thành `class method` của Class.\n- Import methods của module vào `ancestors chain` của `singleton class` của class extend.\n\n```rb\nmodule C\n\tdef say\n\t\tp 'hello'\n\tend\t\nend\n\nclass D\n\textend C\nend\n```\n\n``` sh\n\u003e D.new.say\n=\u003e undefined method 'say' ...\n\u003e\n\u003e D.say\n=\u003e \"hello\"\n\u003e\n\u003e D.ancestors\n=\u003e [D, ..., Object, ..., BasicObject]\n\u003e\n\u003e D.singleton_class.ancestors\n=\u003e [#\u003cClass:D\u003e, C, ...] \n```\n\n\n### Tham khảo\n- https://medium.com/@leo_hetsch/ruby-modules-include-vs-prepend-vs-extend-f09837a5b073","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.05-Ruby/Splat-in-ruby":{"title":"🥦 Splat in ruby","content":"\n🌱 Splat array in ruby with syntax below:\n\n```rb\narray = [1,2,3]\nsplat_array = [*array, 4, 5] # =\u003e [1,2,3,4,5]\n```\n\n🌱 Splat hash in ruby with syntax below:\n\n```rb\nhash = {a: 1, b: 2}\nsplat_hash = { **hash, c: 3} # =\u003e {:a=\u003e1, :b=\u003e2, :c=\u003e3}\n```","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.06-Servers/Config-SSH":{"title":"⚙️ Config SSH","content":"\n---\n\n## Issue\n---\nChắc hẳn là một dev BE, các bạn ít nhiều cũng từng có lần ssh lên server để check log, xem db, hay là config dự án, ... Quy trình đểcó thể ssh được lên  server sẽ gồm có những bước cơ bản như sau:\n- Tạo một bộ khóa tại máy local.\n- Đưa public key cho bên infra hoặc người có thể lên được server, để họ thêm key của chúng ta vào 1 file - file này sẽ chứa các keys có thể ssh.\nSau đó mỗi lần ssh chúng ta sẽ cần phải gõ command:\n\n```sh\nssh user_name@ip\n```\n\nVấn đề ở đây là, chúng ta khó có thể nhớ chính xác 2 thông tin trên cho mỗi lần ssh. Trước đây mình sẽ note những thông tin này vào một chỗ nào đấy bí mật, khi nào cần ssh thì bật lên và copy vào, rất là mất thời gian. Đã thế khi gen ra nhiều key ssh, mình còn phải set -i để chỉ định ssh-key nào sẽ được dùng để ssh nữa.\n\n## Solution\n---\nKhi search vấn đề này, mình thấy mọi người thường sẽ không dùng cách stupid trên kia của mình mà sẽ sử dụng file  ~/.ssh/config. Và nó giải quyết hoàn toàn được 2 vấn đề mình gặp phải ở trên.\n1. Không cần nhớ thông tin ssh: user_name, ip\n2. Không cần chỉ định bằng cơm ssh-key khi ssh nữa\n\nMọi người chỉ cần thêm vào file ~/.ssh/config như ở dưới:\n\n```sh\nHost project-dev\n  Hostname 1.0.5.374\n  User deployer\n  IdentityFile ~/.ssh/project-dev-ecdsa\n\nHost project-prod\n  HostName 1.12.6.52\n  User deployer\n  IdentityFile ~/.ssh/project-pro-ecdsa\n```\n- Host: tên tắt dùng để ssh, có thể đặt tên theo project để dễ nhớ nhé. \n- Hostname: ip server\n- User: user trên server\n- IndentityFile: chỉ định ssh-key sẽ dùng để ssh cho Host\n\nViệc đơn giản bây giờ là chúng ta ssh theo Host thôi :D !!\n\n```sh\nssh project-dev\n```\n\n---","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.06-Servers/Remote-Desktop-Protocol":{"title":"🥦 Remote Desktop Protocol","content":"\nBình thường các server mình được làm trước đây đều là Ubuntu Server, muốn truy cập lên thì dùng ssh-key là được. Nhưng do spec của dự án hiện tại mình làm có yêu cầu sử dụng Window Server. Khi gửi thông tin Server(IP, users, pass) anh PSM có gợi ý dùng `RDP Client` để truy cập vào. Cơ mà `RDP Client` là cái khỉ gì 😅\n\n# 🌱 What?\n---\n- `RDP` là một giao thức độc quyền được phát triển bởi Microsoft, cung cấp cho người dùng giao diện để truy cập đến một máy tính khác thông qua kết nối internet. Bạn có thể làm mọi thứ với PC remote như một PC vật lý bình thường. Ví dụ như:  \n\t- Sử dụng các ứng dụng của PC remote.\n\t- Truy cập file và các tài nguyên mạng của PC remote.\n\t- Tắt các ứng dụng khi bạn thoát khỏi `RDP Client` (giống shut down PC vật lý.)\n\n🌿 `Remote Desktop Protocol severs` được dùng để các clients kết nối, severs mặc định của RDP là `TCP port 3389` và `UDP port 3389`.\n\n🌿 **Remote Desktop Connection** được tích hợp cho `RDP Clients` trong hệ điều hành Windows.\n\n# 🌱 Quick connect to a Windows Server from Ubuntu using RDP Client\n---\n\n🌿 Step 1: Đảm bảo PC hoặc server Windows mà bạn muốn truy cập đã được bật Remote Desktop Connections. \n- Nếu chưa bạn có thể xem cách bật ở [đây](https://www.digitalcitizen.life/enable-remote-desktop-windows/).\n\n🌿 Step 2: Mặc định Ubuntu cung cấp `Remmina` để hỗ trợ RDP. Turn on!\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Remote Desktop Protocol/Pasted image 20221017142240.png]]\n\n🌿 Step 3: Tạo một connect mới.\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Remote Desktop Protocol/Pasted image 20221017171736.png]]\n\n🌿 Step 4: Điền thông tin server.\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Remote Desktop Protocol/Pasted image 20221017172232.png]]\n\n- Tiếp theo là setting độ phân giải và color depth của màn hình desktop remote. Mặc định sẽ chọn độ phân giải và color depth ở mức cao nhất. Tuy nhiên, setting 2 thông số này thấp hơn sẽ cải thiện khá nhiều perfomance đấy.\n- Nếu muốn chia sẻ folder với Windows Server, check folder box và chỉ định folder cần chia sẻ.\n- Ngoài ra ở mục Advanced, bạn có thể bật/tắt tiếng, chia sẻ máy in, tắt đồng bộ cho bộ nhớ tạm, ...\n\n🌿 Step 5: Lưu và chạy thôi!\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Remote Desktop Protocol/Pasted image 20221017174839.png]]\n\n\n# 🌱 Góc so sánh\n---\n\n🌿 Theo định nghĩa, công dụng của thằng này nghe cũng khá giống TeamView nhỉ 😀 So sánh thôi 😗\n\n\nRemote Desktop Protocol | TeamView\n------------ | ------------\nLà giao thức được tích hợp sẵn trong hệ điều hành Windows và được phát triển độc quyền bởi công ty Microsoft  | Là một phần mềm chia sẻ quyền điều hành máy tính được phát triển bởi TeamViewer GmbH\nKhông cho phép người dùng theo dõi tác vụ trên máy remote | Cho phép người dùng dõi tác vụ trên máy remote\nYêu cầu cấu hình port chuyển tiếp trên `firewall` hoặc route của máy remote | Chỉ cần cài đặt là dùng bình thường\n\n🌿 Nhìn chung TeamView ngon và dễ sử dụng hơn RDP nhưng TeamView lại tiềm ẩn rủi ro bị lộ dữ liệu,  thông tin, như ở công ty mình TeamView được liệt vào danh sách đen không được cài đặt ấy.\n\n🌿 Tùy theo bối cảnh mọi người có thể cân nhắc sử dụng giữa 2 này nhé. \n\n### Tham khảo\n- https://learn.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/remote-desktop-clients\n- https://www.techrepublic.com/article/teamviewer-vs-remote-desktop/","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.06-Servers/The-paradigms-that-generually-applied-when-release":{"title":"🥦 The paradigms that generually applied when release","content":"\n\nVới những dự án đã có cộng đồng người dùng lớn, việc deploy những tính năng mới lên môi trường `production` cần phải có những phương pháp để giảm thiểu tối đa những rủi ro cũng như đạt được trải nghiệm tốt nhất dành cho người dùng.  Những mô hình thường được áp dụng thực tế: `A/B Testing`, `Canary Deployments`  và  `Blue-Green Deployments`.\n\n### 🌱 A/B Testing\n-  Sử dụng để review độ hiệu quả và phản ứng của người dùng đối với những thay đổi mới.\n- Những thay đổi mới sẽ chỉ được `rolled out` với một bộ phận người dùng nhất định. So sánh đánh giá của người dùng để đưa ra những chiến lược phát triển phù hợp hơn trong tương lai.\n- Mô hình này được áp dụng cả cho phát triển web, bán hàng, quảng cáo, vv... \n\n![[00 Meta/01 Attachments/Pasted image 20221025184727.png]]\n\n\n### 🌱 Blue-Green Deployments\n- Là một chiến lược deploy dùng để kiểm thử những tính năng mới của dự án.\n- Deploy without downtime.\n-  Mô hình này gồm 2 servers chạy đồng thời là Blue và Green, đều là môi trường `production` nhưng một server có status `live` - nhận reqs của users còn server kia là `idle` - không hoạt động.\n\n![[00 Meta/01 Attachments/Blue-Green Deployments.excalidraw.png]]\n\n### 🌱 Canary Testing\n- Cũng giống 2 ý đầu của  `Blue-Green Deployments`.\n- Thay vì switch toàn bộ users truy cập giữa Blue và Green, `Canary Testing` sử dụng cân bằng tải, cho phép một số users có thể sử dụng version code mới, sau khi chạy ngon lành thì dần dần áp dụng cho toàn bộ users của hệ thống.\n\n![[00 Meta/01 Attachments/Pasted image 20221025184522.png]]\n\n### Tham khảo\n- https://www.oreilly.com/library/view/spring-50-microservices/9781787127685/6fab55ad-8897-42b7-b509-dd90850c861b.xhtml\n- https://circleci.com/blog/canary-vs-blue-green-downtime/\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.07-Utils/%C4%90%C3%A1nh-s%E1%BB%91-hi%E1%BB%87u-phi%C3%AAn-b%E1%BA%A3n-ph%E1%BA%A7n-m%E1%BB%81m":{"title":"🌿 Đánh số hiệu phiên bản phần mềm","content":"\n🌱 What?  \n-    Là quy tắc để xác định và phân biệt tên của phần mềm ở mỗi giai đoạn phát triển. \n\n 🌱Sematic Versioning  \n-   Là quy tắc thường được sử dụng nhất. Do [Tom Preston-Werner](https://tom.preston-werner.com/) (ng sáng lập và là cựu CEO của Github) tạo ra.\n-   Có format là `[major].[minor].[patch]` , vd: 5.6.8\n\t-   `major`  - tăng lên khi có những thay đổi **không tương thích với phiên bản cũ** (vd thay đổi cấu trúcc response).\n\t-   `minor`  - tăng lên khi thêm tính năng mới **nhưng vẫn tương thích với phiên bản cũ** (vd thêm trường trả về trong response).\n\t-   `patch`  - tăng lên khi fix bug **nhưng vẫn tương thích với phiên bản cũ**.\n\n**Xem thêm:** [https://viblo.asia/p/semantic-versioning-OeVKBN2EKkW](https://viblo.asia/p/semantic-versioning-OeVKBN2EKkW)","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.07-Utils/Cron-job-notify-drink-water":{"title":"🥂 Tạo background job nhắc nhở uống nước đều đặn","content":"\n---\nKhông biết mọi người có giống mình không, mỗi khi làm việc mình cứ bị quên uống nước ấy, có khi cả buổi mình còn chả uống được 250ml nước =((. Tác hại của việc uống ít nước mọi người có thể gg nha, nhưng ncl uống nước đủ mỗi ngày là thói quen rất có lợi cho sức khỏe cũng như làn da của chúng ta =)).\n\nHôm trước mình có gặp anh mentor ở cty, anh ấy chia sẻ là vì hay ngồi gù lưng nên anh ấy viết một script để sau một khoảng thời gian, thông báo kiểu như 'Thẳng lưng lên!' được hiển thị trên Touch Bar. 🤩, hay thế!!! Sao mình ko áp dụng để improve khả năng uống nước của bản thân nhỉ 🤔 Thế nên tranh thủ cuối tuần, mình có tìm cách để setup cronjob cho Ubuntu.\n\n🌱 Đầu tiên là setup cronjob, mình có xài `cron`, mn có thể dùng apt để install và enable nó lên nhé.\n```sh\nsudo apt update\n# Check if cron package is installed\ndpkg -l cron\n\n# install cron\nsudo apt install cron\n\n# enable cron\nsystemctl start cron\n\n# check status cron\nsystemctl status cron\n\n# stop cron\nsystemctl stop cron\n```\n\n🌱 Để thêm job, sử dụng command:\n```sh\ncrontab -e\n```\n\nTrong file đã có hướng dẫn cụ thể, về cơ bản cũng giống như setup cron-sidekiq, nếu chưa quen settings thời gian chạy job mọi người có thể sử dụng [cron-time](https://crontab.guru/) cho trực quan nhé!\n\nVí dụ mình set 20p là phải nhắc t uống nước đó nha Ubuntu =))\n```sh\n20 * * * * cd ~/personal \u0026\u0026 ./script-notify-myself.sh\n```\n\n🌱 Tạo script:\n```sh\n#!/bin/bash\n\nexport DBUS_SESSION_BUS_ADDRESS=\"${DBUS_SESSION_BUS_ADDRESS:-unix:path=/run/user/${UID}/bus}\"\nnotify-send \"Uống nước đii!!!\"\n```\n\n🌱 Và kết quả là:\n**![](https://lh5.googleusercontent.com/0NKuSVNogMqGwdDajpn-B901GQITiJWGHqrWUFlI6FYn20D7eaE3DbcREvNv-bBYiwZQvJxaC0GuQry-tXdIIWbm-VG9WpXql-A8pr8ZzybJRR0q62qFrfVKmioH9AHzGqZ6oES1olMjkKRUNN18liShoJREFpkd9EflllQjAGoJW2D1EJkM3WBI0A)**\n\n\n### 🌱 Update\n---\nSau một thời gian thêm cronjob, mình khá là khó chịu vì cái bảng thông báo của mình nó cứ hiển thị chất đống `Uống nước đii!!!`, rất là mất mỹ quan đô thị.\n\n![[00 Meta/01 Attachments/Notifi Trash.png]]\n\nĐể khắc phục vấn đề này, mình có thêm một script chịu trách nhiệm để clear-all tất cả những thông báo hiện tại. \n\n```sh\n# ./remove-all-notify-tray.sh\n\n#!/bin/bash\ngdbus call --session --dest org.gnome.Shell --object-path /org/gnome/Shell --method org.gnome.Shell.Eval 'Main.panel.statusArea.dateMenu._messageList._notificationSection._list.remove_all_children()'\n```\n\n🌱 Mình có viết scripts ở [đây](https://github.com/anhnh-3008/dotfiles/tree/main/cronjob)  để sau dụng lại cho tiện, nếu thấy hứng thú mọi người có thể pull về chạy thử nha ❤️\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.07-Utils/DATE_SUB":{"title":"🥦 DATE_SUB - ngược về quá khứ","content":"\n🌱 Trong SQL, hàm `DATE_SUB()` trả về ngày sau khi đã lùi một khoảng thời gian chỉ định.\n\n```sql\nDATE_SUB(date, INTERVAL value unit)\n\n# date: Ngày làm mốc.\n# value: thời gian bị trừ(có thể chỉ định giá trị âm || dương)\n# unit: đơn vị thời gian(ngày, giờ, phút, ...)\n```","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.08-System-Design/CORS-Cross-origin-Resource-Sharing":{"title":"📑 CORS - Cross-origin Resource Sharing","content":"\n## What?\n---\n`CORS`  là một cơ chế cho phép chia sẻ nhiều tài nguyên(images, files, fonts, javascript,...) giữa nhiều trang web khác nhau.\n\n## Why?\n---\nCORS ra đời do sự xuất hiện của [[50 til/51 Code/51.08 System Design/Same-origin policy]].\n\n## How?\n---\n`CORS` sử dụng các HTTP Header để thông báo với trình duyệt nhận request là 'Em là con ông A nhà bà B ở cuối làng, anh cho em vào lấy ít đồ cho bố em nhé ' =))\n`Access-Control-Allow-Origin`  ở header mà trường này ko có giá trị hoặc giá trị ko hợp lệ thì sẽ bị báo lỗi.\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.08-System-Design/Open-ID-ConnectOIDC":{"title":"🔐 Open ID Connect(OIDC)","content":"\n---\n\nLà một loại cơ chế xác thực kiểu [[50 til/51 Code/51.08 System Design/Single Sign-On(SSO)]] dựa trên thuật toán **mật mã hóa khóa bất đối xứng**. Có 2 khóa đảm nhiệm riêng từng nhiệm vụ là mã hóa và giải mã.\n**![](https://lh5.googleusercontent.com/1cxM7BkCmyzrm0Q17OIv7x3GcMzfyLhaHnExHl6foJLIL0e0nruB8tWPJu4RwoZNlLn1XFNlieM0gG2JiCHff760sQ87LyzxX1GJobxyoPGE0i72olWaxzLasNXmm3_iC4NEYfsKheuPVME_LxigUMArWVomwIKfbCD1Gt82o_Hs3Vh2d_HKWweu3A)**\n**![](https://lh4.googleusercontent.com/ku-PU5gsE-WnRbitam-zVKFWzcmYPxsst_bfbtVlU3KhmKcIbJ9qB5-TVBnoxQHkOfWRWEVLmV_fwQk7lgiU_t8-UYHti_T4ZBSXxh3k-Ei_2Gm_oufq8LKosdEVYrjenxEnkzPqNYCKAA_3vggJT2XeD8_Rj_ud8g6gNCTWO_0qtfKY_kfMFiD66g)**\n\nẢnh trên mô tả cơ chế hoạt động của [Mật mã hóa khóa công khai](https://vi.wikipedia.org/wiki/M%E1%BA%ADt_m%C3%A3_h%C3%B3a_kh%C3%B3a_c%C3%B4ng_khai), hiểu đơn giản thì 2 cái này sẽ giống nhau nhưng với 1 cái thì cả 2 khóa phải được giữ bí mật còn lại thì một khóa bí mật một khóa công khai.\n\nOIDC là phiên bản mở rộng của Oauth 2.0, thay vì là Access-Token chúng ta sẽ nhận được một Id Token từ Auth Server. Với [access-token](https://oauth.net/id-tokens-vs-access-tokens/#:~:text=Access%20tokens%20are%20what%20the,read%20by%20the%20OAuth%20client.), mỗi lần qua một trang web khác chúng ta sẽ cần request lại access-token mới nhưng với id-token có thể dùng lại thoải mái, [id-token](https://oauth.net/id-tokens-vs-access-tokens/#:~:text=Access%20tokens%20are%20what%20the,read%20by%20the%20OAuth%20client.) có thể xác thực được user cũng như đảm bảo được các thông tin thuộc về User là ko thể bị giả mạo.\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.08-System-Design/Robustness-Diagram":{"title":"🥦 Robustness Diagram","content":"\n## 🌿 What?\n🌱 Là một dạng UML diagram nằm trong `ICONIX Process`, xác định tất cả những objects và mối liên hệ của từng `use case`.\n- Giảm sự mơ hồ của phần mô tả `use case`, dễ dàng hơn cho việc thiết kế, kiểm tra và estimate. \n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/Robustness Diagram/Robustness reponsibility.excalidraw.png]]\n\n\u003e `ICONIX Process` là một phương pháp luận phát triển phần mềm, mục tiêu là để tránh [analysis paralysis](https://en.wikipedia.org/wiki/Analysis_paralysis). Chỉ sử dụng 4 UML cơ bản ứng với 4 bước trong quá trình chuyển đổi từ `Use Case text` thành `Code` .\n\nMỗi diagram sẽ trả lời cho từng câu hỏi:\n- `Use Cases` - Users đang làm gì?\n- `Domain Models` - Có những Objects nào?\n\u003e 🌱 `Robustness Diagrams` - Những Object nào tham gia trong từng `use case`?\n- `Sequence Diagrams` - Những Object tương tác với nhau như thế nào?\n\n## 🌿 How?\n🌱 Sử dụng khuôn mẫu `boundary/control/entity class`.\n\n🌱 4 nguyên tắc cơ bản:\n- `Actors` chỉ có thể giao tiếp với `Boundary objects`.\n- `Boundary objects` chỉ có thể giao tiếp với `Control objects` hoặc `Actors`.\n- `Entity objects` chỉ giao tiếp được với `Control objects`.\n- `Control objects` có thể giao tiếp với `Boundary objects`, `Entity objects` và một số `Control objects` khác, nhưng cấm chơi với `Actors`.\n\u003e [Ý nghĩ của các khuôn mẫu](https://docs.nomagic.com/display/MD190/Robustness+diagram#:~:text=Boundary%20or%20Interface,and%20entity%20objects.)\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/Robustness Diagram/Object Rubustness.excalidraw.png|500]]\n\n\n🌱 Ví dụ:\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/Robustness Diagram/Robustness of use case access to homepage.excalidraw.png]]\n\n## Tham khảo\n- https://en.wikipedia.org/wiki/ICONIX\n- https://docs.nomagic.com/display/MD190/Robustness+diagram","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.08-System-Design/Same-origin-policy":{"title":"📑 Same-origin policy","content":"\n---\n\n## What?\n---\n-  Là một cơ chế bảo mật hạn chế việc `documents` hoặc `script load` thuộc một `origin` có thể tương tác với những `resources` thuộc một `origin` khác.\n-  Được cài đặt vào toàn bộ  các trình duyệt hiện nay.\n-  Chính sách này giúp trang web của chúng ta không bị truy cập bừa bãi từ những tác nhân lạ.\n\t- Ví dụ nếu bạn vào một trang web bất kỳ được cài sẵn một mã độc truy cập đến trang web VCB, nếu bạn đã đăng nhập vào VCB, vẫn còn hiệu lực đăng nhập và không có chính sách này, hacker sẽ chiếm được quyền sử dụng tài khoản ngân hàng của bạn.\n\t- Còn bình thường mn sẽ nhận được message này ở console browser\n\n```js\nAccess to XMLHttpRequest at 'https://vietcombank.com/profile' from origin 'xxx' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.\n```\n\nNhưng thực hiện truy vấn giữa nhiều trang web với nhau là việc rất thường xuyên đối với một lập trình viên, đặc biệt là vụ call API. Và thế là Cross-origin Resource Sharing - CORS ra đời =))","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.08-System-Design/Sequence-Diagram-l%C3%A0-g%C3%AC":{"title":"🥦 Sequence Diagram là gì?","content":"\n---\n\nSắp tới mình được giao tasks là vẽ lại `sequence diagram` cho toàn bộ tính năng của một con dự án ở cty, mà nghe đâu là gần 40 chục cái hay sao ấy 🤢 Thế nên tranh thủ cuối tuần mình ngồi ôn lại chút để tuần sau vào việc cho lẹ 💪 Let's go!!!\n\n# 🌱 What?\n---\n- `Sequence Diagram`  -Biểu đồ tuần tự là một dạng biểu đồ `UML - Unified Modeling Language` dùng để xác định trình tự diễn ra của một nhóm đối tượng nào đó.\n- Biểu đồ miêu tả chi tiết các thông điệp được gửi và nhận của từng đối tượng đồng thời cũng chú trọng cả việc xác định thứ tự của những thông điệp đó.\n\n# 🌱 Các thành phần\n---\n\nGồm 4 thành phần chính:\n- Đối tượng (Object or Class)\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Đối tượng.excalidraw.png]]\n\n- Đường đời đối tượng (Lifelines)\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Đường đời đối tượng.excalidraw.png]]\n\n\n- Thông điệp (messages)\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp.excalidraw.png]]\n\n- Các dạng thông điệp\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp đồng bộ.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp không đồng bộ.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp trả về.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp nội tại.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp tạo mới.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp cập nhật.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp xóa.excalidraw.png]]\n\n- Tiến trình xử lý (process)\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Tiến trình xử lý.excalidraw.png]]\n\n\n\n# 🌱 Ví dụ\n---\n\n![[00 Meta/01 Attachments/Sequence Diagram chức năng đăng nhập.excalidraw.png]]\n\n## 🌱 Tham khảo\n- https://www.smartdraw.com/uml-diagram/\n\n\n\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.08-System-Design/Single-Sign-OnSSO":{"title":"🔐 Single Sign-On(SSO)","content":"\n## 🌱 Issue\n---\nHiện nay hầu hết các dịch vụ web đều yêu cầu người dùng đăng nhập trước khi sử dụng. Nhu cầu sử dụng dịch vụ ngày càng nhiều đồng nghĩa chúng ta càng phải nhớ nhiều thông tin đăng nhập, giả sử nếu chúng ta dùng 10 webs khác nhau, việc nhớ nhớ thông tin đăng nhập cũng khá là 'vất vả' đúng ko nào =))\n- Chính vì vậy mà đã lòi ra cu SSO này =))\n\n## 🌱 What?\n---\n![[00 Meta/01 Attachments/Single Sign-On.png]]\n\n- `Single Sign-On` là cơ chế giúp người dùng đăng nhập một ID cho một vài trang webs hoặc hệ thống liên quan nhưng độc lập với nhau. Kiểu như Google dùng tài khoản Gmail đăng nhập cho các services độc lập(Driver, Clouds, ...). Một khóa mở được nhiều chìa 🤞\n\n## 🌱 Why?\n---\n\n### Ưu điểm\n- Giảm thời gian nhập lại thông tin đăng nhập\n- Giảm [password fatigue](https://en.wikipedia.org/wiki/Password_fatigue) cho hệ thống\n- Giảm effort phát triển chức năng log-in\n- Giảm thiểu rủi ro việc lộ thông tin của người dùng\n- Nâng cao hiệu suất cho người dùng. Người dùng ko phải nhớ nhiều thông tin đăng nhập.\n- Quản lý dễ dàng hơn. Giả sử bạn có 3 trang webs và bạn muốn ban account A, nếu dùng SSO bn chỉ cần setting banned một lần cho cả 3 webs.\n\n### Nhược điểm:\n- Phụ thuộc vào bên thứ 3\n\n\n🌱 Lắm ưu ít nhược nên SSO khá là ngon, hiện tại cũng có khá nhiều service thứ 3 cung cấp dịch vụ SSO miễn phí(Facebook, Google, Github, ...) mọi người có thể cân nhắc sử dụng theo nhu cầu phát triển của dự án nhé =))\n\n---\n\n## 🌱 How?\n---\n\nSSO là một phần của [[50 til/51 Code/51.08 System Design/System Identification Link]], có liên quan chặt chẽ với việc xác thực thông tin người dùng. Nó sẽ định danh người dùng, và sau đó chia sẻ thông tin định danh được với các hệ thống con.\n\n### Cơ chế\n---\nTheo luồng bình thường user đăng nhập web A sẽ sinh ra cookie để xác thực cho những request sau, nếu mang cookie đó sang web B để xác thực thì sẽ tạch do các trình duyệt hiện nay chỉ có thể truy cập cookie do chính nó tạo ra.\n![[00 Meta/01 Attachments/Auth SSO.png]]\nHiểu đơn giản giữa các web sẽ có một **browser cookie storage** chung và sử dụng cơ chế Cross-origin resource sharing. Khi Web nào đăng nhập thì sẽ truy cập vào **browser cookie storage** để lấy cookie lên **server auth**(của bên thứ 3) để xác thực.\n\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.08-System-Design/Store-passwords-safely-in-the-database":{"title":"🛡️ Store passwords safely in the database","content":"\n## Những điều không nên làm\n---\n- Không được lưu passwords dạng text trong db, vì bất cứ người nào có quyền connect vào db đều sẽ xem được nó.\n- Lưu password hashes trực tiếp cũng không an toàn vì nó có thể vị vô hiệu hóa bởi những cuộc tấn công tính toán trước(`precomputation attacks`), vd như là `rainbow tables`.\n- Để hạn chế `precomputation attacks`, chúng ta hãy `salt the passwords`.\n\n### What is salt?\n---\n- Theo như hướng dẫn của OWASP, `salt` là một chuỗi duy nhất, được sinh ra ngẫu nhiên và được thêm cho từng password như là một phần của quá trình mã hóa.\n\n\n## How to store?\n---\n![[00 Meta/01 Attachments/Pasted image 20221004102412.png]]\nTheo hình trên, mọi người có thể hình dung các bước để lưu password vào DB như sau:\n\t1. User cung cấp password.\n\t2. Hệ thống sinh ra `salt` cho password.\n\t3. Trong DB sẽ lưu cả `salt` và `hash` được mã hóa từ `password + salt`. \n\n## How to validate?\n---\n**![](https://lh5.googleusercontent.com/VT3b8cvDZ6idbl8D3zYpTNiHhiBp72vR4CLfjAvJx0-Tjp7ZIGy63DtQeMfbtsjwfh5Q8uk3ch16YIMp4wCVwmzyb1A9-aTZ0cSFgyb3kVjvr9X3N_ZmP7-iD_Akoh7TqveaTkM-jBZG1084xwwNqYUs5RaI7GwfxiV7fxYwQngMrmgirVgS9lHk)**\nCác bước hệ thống thực hiện validate:\n\t1. User cung cấp validate.\n\t2. Lấy mã `salt`  của user được lưu trong DB.\n\t3. Thực hiện mã hóa từ `password + salt` =\u003e `hash`\n\t4. So sánh `hash` tạo từ bước 3 và `hash` lưu trong DB. \n\nP/s:  Ngoài ra mọi người có thêm cơ chế nào khác để có thể lưu trữ pasword an toàn trong DB không? Nếu có hãy cmt cho mình biết với nha \u003c3\n\n### Tham khảo\n- Free System Design - ByteByteGo - Trang 13\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.08-System-Design/System-Identification-Link":{"title":"📑 Hệ thống nhận diện liên kết","content":"\n---\n\nHệ thống nhận dạng liên kết( Federated Identity Glossary) là nơi tập trung và liên kết thông tin người dùng. Có 4 yếu tố nền tảng cấu thành nên hệ thống này:\n-   **Xác thực (Authentication):** kiểm tra thông tin đăng nhập và tiến hàng định danh người dùng.\n-   **Phân quyền (Authorization):** dựa trên thông tin định danh để kiểm tra quyền truy cập của user.\n-   **Trao đổi thông tin người dùng (User attributes exchange):** Mỗi hệ thống con sẽ cần và lưu trữ các thông tin khác nhau của người dùng, tuy nhiên sẽ có các thông tin bị lặp lại, ví dụ như tên, họ.... Do đó, cần có một nơi để tổng hợp lại các thông tin này, và trao đổi cho các hệ thống con.\n-   **Quản lí người dùng (User management):** admin có thể quản lí người dùng bằng các thao tác thêm, sửa, xóa... ở các hệ thống con.\n\n---\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.08-System-Design/Why-is-RAM-access-faster-than-hard-disk-drive":{"title":"♻️ Why is RAM access faster than hard disk drive?","content":"\n# Why is RAM access faster than hard disk drive acess?\n---\n Khi sử dụng Redis, mọi người thường hay nói Redis thực hiện thao tác dữ liệu trên Ram nên có tốc độ truy xuất nhanh hơn rất nhiều so với truy cập vào HDD. Vậy tại sao lại như thế? \n \n## Why?\n---\n\n![[00 Meta/01 Attachments/Communication between CPU - RAM - Hard Storage.png]]\n\n\n- HDD nằm cách xa CPU, được kết nối với bảng điều khiển thông qua cổng SATA. 6Gb/s là tốc độ tiêu chuẩn của SATA III, HDD chỉ có thể đọc hoặc viết chứ không thể làm cả hai trong cùng một thời điểm.\n- RAM nằm rất gần CPU và có kết nối băng thông rất cao. Thông lượng của DDR4 là khoản 40Gb/s, ngoài ra RAM còn có thể thực hiện đọc và viết cùng lúc. Khi sử dụng dual channel, RAM sẽ đọc/đọc, viết/đọc, viết/viết chính vì vậy mà nó có thể thao tác một lượng dữ liệu vô cùng lớn trong cùng một thời điểm.\n\n\n## Câu hỏi\n---\nThế tại sao người ta lại không thiết kế để HDD lại gần CPU?\nVấn đề lớn nhất là chi phí. Tốc độ xử lý cao tương ứng với giá thành sản xuất cũng sẽ đắt. Và tùy theo mục đích nên mỗi phần sẽ có thiết kế phù hợp -\u003e đạt được cả hiệu năng và giá thành tốt nhất.\n-   Đối với những tác vụ lưu trữ file, đọc/ ghi đơn giản, không yêu cầu xử lý nhanh thì người ta dùng HDD cho rẻ. (ổ cứng lưu trữ)\n-   Các tác vụ cần xử lý nhanh hơn 1 chút, như load hệ điều hành, người ta ưu tiên dùng SSD (ổ cài win ý :v )\n-   Thằng nào cần cache, xử lý tốc độ bàn thờ (làm bộ nhớ tạm cho các phần mềm đang chạy) thì người ta dùng tới RAM, CPU.\n\n![[00 Meta/01 Attachments/Why is RAM access faster than hard disk drive acess.png]]\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.08-System-Design/Why-is-Redis-so-Fast":{"title":"♻️ Why is Redis so Fast?","content":"\n---\n🌱 Có 3 lý do chính giải thích điều này:\n\n![[00 Meta/01 Attachments/3 Reasons why Redis is fast.png]]\n\n- Redis là một cơ sở dữ liệu lưu trữ trên RAM. Tốc độ truy cập RAM đểu nhất cx nhanh hơn 1000 lần so với tốc độ truy cập ổ cứng. Mọi người có thể xem thêm \n- Redis sử dụng `IO multiplexing` và `single-threaded`. IO multiplexing là cơ chế đọc/ghi liên tục của RAM. RAM nhận tất cả các yêu cầu đọc/ghi dữ liệu, để vào một chỗ, sau đó dùng single-threaded lặp qua từng event để tiếp tục xử lý.\n- Redis sử dụng một vài cấu trúc dữ liệu `lower-level`(String lưu thành SDS, ...).\n\n\n## Câu hỏi\n---\n### 🌱 Tại sao truy cập từ RAM lại nhanh hơn từ HDD?\n[[50 til/51 Code/51.08 System Design/Why is RAM access faster than hard disk drive?]]\n\n\nP/s: Memcached cũng là một giải pháp khá phổ biến để giải quyết vấn đề cached dữ liệu, mọi người có thể tìm hiểu thêm nhé.\n\n### 🌱 Tham khảo\n- Free System Design - ByteByteGo - Trang 76","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.09-Docker/Docker":{"title":"🐬 Docker","content":"\n---\n\n## I. Bối cảnh\n---\n\n**![](https://lh6.googleusercontent.com/l1T2krPv068MLPC1J8jYFIDgQ47_VT1VmUcFofBWypN-Kb-EX6IBfULvpeD4TsBh40meAUN-7A6erjR-s48nkuQxA8xWOxAC4GiFLLWPoyLHEViSScy14ABVJP0VPY8sT1MMUFNDBp8yTOQWxEZcgS0erEK4qO9orhKcrRJEv_6KlyPbbjl-Pmca)**\n🌱 Trước đây mô hình máy chủ được tạo thành bởi ba yếu tố:\n* Máy chủ vật lý (Physical Server)\n- Hệ điều hành ([[50 til/51 Code/51.03 Operating System/Linux Basic|Operating System]])\n- Các ứng dụng (Application)\n\nMô hình trên có những nhược điểm:\n-   Một máy chủ chỉ cài được 1 OS\n-   Cho dù ổ cứng khủng, ram khủng thì cũng không thể tận dụng hết được\n\n🌱 Vì những nhược điểm đó, công nghệ ảo hóa **Virtualization** được ra đời, ưu điểm so với mô hình cũ là:\n-   Trên một máy chủ vật lý, có thể cài được nhiều hệ điều hành, tận dụng được tài nguyên tốt hơn do có thể phân chia tài nguyên cho từng máy ảo\n\nNhưng vẫn có những thứ chưa được tối ưu:\n-   Về tài nguyên:\n\t-   Khi thiết lập máy ảo chúng ta sẽ cần cấu hình để cung cấp tài nguyên từ ổ cứng và ram từ máy thật cho máy ảo. Những tài nguyên được phân ra sẽ là cố định. Dẫn đến việc, khi bật máy ảo, kể cả khi không làm gì thì máy thật cũng sẽ mất một lượng tài nguyên mà ban đầu chúng ta đã cung cấp.\n-   Về thời gian:\n\t-   Thời gian bật/tắt máy ảo khá lâu(mấy phút lận)\n\n🌱 Để khắc phục những nhược điểm còn tồn đọng đó, công nghệ **Containerization**, ưu điểm của công nghệ này đó là:\n\n![](https://lh4.googleusercontent.com/mUbQaVuvrz58iy4ySacviA8nGD1-MNeX6TzY3sSxY982frJtmsICy3JZplo52qHH4ffyiy01eKZpH9x0oE2nMgnkLT7l2iAHkSzoucvthQsozcYFAt1soJAmHPjftBXcQ8x5EGPJYzYV5GvZJ9LTZ1XfFTvNzMf8K6wBMei84RzAicKTG0fBsVLk)\n\n-   Thừa hưởng khả năng tạo được nhiều máy ảo trên cùng một máy chủ vật lý như **Virtualization** , nhưng tốt hơn ở chỗ những máy ảo này sẽ dùng chung phần nhân và cùng chia sẻ với nhau tài nguyên của máy mẹ. Máy ảo dùng bao nhiêu tài nguyên sẽ được cấp bấy nhiêu, chứ ko có tình trạng tài nguyên bị rảnh rỗi nữa, như vậy thì việc tận dụng tài nguyên sẽ tối ưu hơn.\n-   Đặc trưng của công nghệ này là sử dụng các **containers**.    \n\n![](https://lh6.googleusercontent.com/r4-OlfYsbR1dZ0M_NkB6e49MefZWZUR2RZK2kppihpj1PTkebxA_C-cT4SIRJuKiNuSBYxpWO46t_-U16KCSHJNiYD9P1Mdr1SEIomyw9fi5gEga5srvhymPoJoOpx_sOtR2KJsytnhTDk6fhS-3O-7yfFuRPy5Oh6Tsi48i-BYiU999MuwBsSZ7)\n\n\n🌱 Với công nghệ **Virtualization**, chúng ta có thể dùng các công cụ tiêu biểu như **Virtualbox** hay **VMware**, còn với **Containerization** đó chính **Docker**.\n\n![](https://lh3.googleusercontent.com/tc5QldwzU46Kx0zuTQZ8inuJax19jfTODrl5z6Wo8KnYXExUbuEA1hKcQ6Os6R_RWv9qU0knCYzlFdOspkgtuE7LRgqrKEYqwdSfXOh7dCw1l3-7RYuKg6BqN_X22_JcGxJNA2Z1NFmMwEqI8mjspbvD6X8XWj7S86edsc-s269_XqNFF--EIkHb)\n\n\n## II. What Docker?\n---\n\n- Là mã nguồn mở\n- Mục đích develop, deploy and run applications bằng những containers\n\nXem hướng dẫn cài Docker tại [đây](https://docs.docker.com/engine/installation/)\n\n## III. Why Docker?\n---\n\n- Build một lần dùng được nhiều lần và nhiều chỗ\n- Bật/tắt nhanh chóng\n\n## IV. Những khái niệm phổ biến\n---\n\n### 1. Container\n---\n- Là một quá trình chạy trên **[[50 til/51 Code/51.03 Operating System/Linux Basic|Linux kernel]]**. \n\tĐược cấp phát tài nguyên riêng: CPU, bộ nhớ và hệ thống tập tin. Chính vì vậy, Docker độc lập với những tiến trình đang chạy của máy tính và không ảnh hưởng đến các containers/processes khác đang chạy.\n\n### 2. Image\n---\nLà tệp chứa mọi thứ cần để thực thi: dependencies, binaries, source code, ... Xây dựng bằng cách thực thi các câu lệnh trong **Dockerfile**. Một **Image** có thể được sử dụng để tạo nhiều **containers** giống nhau. Mỗi **container** là một **instantiation** của **image**.\n\n### 3. Dockerfile\n---\nLà một tệp chứa các câu lệnh cần thiết để xây dựng một **Image**.\n\n## V. Một vài câu lệnh hay được sử dụng\n---\n\n- **docker pull image_name**: pull một image từ Docker Hub.\n\n- **docker build**: build một container từ Dockerfile và một context(bao gồm các folders|files được đặt ở PATH/URL).\n\n- **docker run**: chạy container từ một image.\n\n- **docker ps**: list ra những containers đang chạy. **-a/--all** để lấy tất cả containers hoặc -q/--quite nếu chỉ muốn lấy cấc ids của containers.\n\n- **docker logs [container_id/container_name]**: xem logs của 1 container, **-f/--follow** để xem log output.\n\n- **docker volume ls**: list ra các volumes được dùng để lưu trữ data được sinh ra và sử dụng bởi các containers.\n\n- **docker rm [container_id/container_name]**: xóa 1 hoặc nhiều containers.\n\n- **docker rmi [image_id]**: xóa 1 hoặc nhiều images.\n\n- **docker stop**: dừng 1 hoặc nhiều containers.\n\n- **docker kill**: kill 1 hoặc nhiều containers.\n\n- **docker kill $(docker ps -q)**: kill tất cả containers đang chạy\n```cmd\n$(docker ps -q) #lấy ra id của các containers đang chạy.\n\n$(docker ps -a -q) #lấy id của toàn bộ các containers.\n```\n\n- **docker system prune**: Dọn toàn bộ resources(images, containers, volumes, networks) đang bị treo(không liên kết với bất kì container nào).\n\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.09-Docker/Docker-Compose":{"title":"🦑 Docker Compose","content":"\n**![](https://lh6.googleusercontent.com/xSCCWpZ4m29JV6UPl9zCuNj4pDxdGD9shUACJ1auetH158BOcrCYKdtuETCxhgwHVjVrR4BFAeSCXAlz3-QfkhJ9tQoipVV2Taq0O64Bu_TITkvRfVM9io8uUNuc3Mf0amW_Z_mbRVEWhivppaEnymHpucB7YKB08UqkzUzYxoEp8SfG0pysEEpq-g)**\n\n## I. What?\n---\n\n🌱 Chúng ta muốn ứng dụng [[50 til/51 Code/51.09 Docker/Docker]] cho:\n\t- Dự án mới\n\t- Dự án đang phát triển\n\n🌱 Chúng ta có thể dùng [[50 til/51 Code/51.09 Docker/Dockerfile]] cài chung tất cả vào một container duy nhất sau đó chạy project trên container đó.\n**![](https://lh4.googleusercontent.com/mS7LvI78YjVqb9jh1QY0K_KR_n_9jQJm_XLUhq-cVmKhgbj2KKqqA0xczpkSxfDPIf8Z85lI5J9-h1MDb2CLtR2Nod47XYNQFGtwwQ7qr0QqakS5hf9kGHoZ-05xQ46PG6vQI9z0RGCmfrTOe5HrezDmZkzdPnQY5yEMf28vQnubyKVXS0AcyTakDQ)**\n🌱 Tuy nhiên cách này không hợp lý cho việc mở rộng cũng như sử dụng lại cho nhiều projects.\n-\u003e docker-compose ra đời để kết nối những containers riêng lẻ với nhau.\n**![](https://lh5.googleusercontent.com/Jw9aHt8OVq5fMYhpOD_QYb0k3SGMT9hJvafVH7yiJdODYDeiQR_A6_b2wuXKhO5E5xr75B5wrl9KNL_jdRDgHHpiIvPCKxmZEToJ8_W1-C3vhRUGlAbfTHJHkfiBB6HKPSfWJEgqgawsqpFUa5h1WtDEVABZdKYvUCsO4f8VkXXMaXi12Hwff_xmNQ)**\n\n---\n- Có thể hiểu docker là con cá voi đang vận chuyển nhiều containers đến cảng Project A.\n- Còn docker-compose sẽ là con bạch tuộc sử dụng các xúc tua của mình để lấy những containers cần thiết cho Project A.\n---\n\nXem hướng dẫn cài docker-compose tại [đây](https://docs.docker.com/compose/install/)\n\n## II. Xây dựng docker-compose\n---\n\n### 1. Cấu trúc thư mục\n🌱 Mình sẽ chỉ làm một project demo nên cấu trúc đơn giản gồm:\n- [x] docker/entrypoint.sh\n- [x] Dockerfile\n- [x] docker-compose.yml\n\n🌱 Khi làm dự án thật, do phải build cho từng môi trường(development, staging, production) nên cấu trúc sẽ có khác hơn một chút, nhưng về cơ bản vẫn là vẫn có đủ thành phần cấu trúc như trên.\n\n### 2. Xác định những containers cần thiết\n🌱 Mình làm demo trên Rails app và những công nghệ mình thấy hay được sử dụng nhất là:\n- [x] Web\n\t- Ruby\n\t- Rails(là Ruby framework nên chỉ cần pull image của ruby thôi)\n- [x] Mysql (hoặc postgret)\n- [x] Redis (lưu cache, backgournd job)\n- [x] Sidekiq (chạy background job)\n\nok triển thôi!!\n\n### 3. Viết docker-compose\n1. **version**: những version sẽ có vài điểm khác nhau như:\n\t- về cấu trúc và các keys config\n\t- về Docker Engine version thấp nhất mà bạn cần đáp ứng\n\t- networking\nTại thời điểm viết bài này, trên trang chủ cập nhật version mới nhất là 3.8 hỗ trợ cho Docker Engine 19.03.0+\nChi tiết hơn về sự khác nhau của từng version hay các năng cấp từ 2.x lên 3.x thì mọi người có thể đọc thêm ở [đây](https://docs.docker.com/compose/compose-file/compose-versioning) nhé.\n2. **services**: những containers chúng ta định nghĩa sẽ nằm ở đây.\n3. những config trong từng container:\n\t- [x] **image**: chỉ định image được dùng để build container\n\t- [x] **build**: khi muốn build container bằng Dockerfile\n\t- [x] **container_name**: chỉ định tên tùy chỉnh của container nếu ko muốn dùng tên mặc định\n\t- [x] **restart**: mặc định là **no**, nếu set **always** container sẽ khởi động lại khi có lỗi\n\t- [x] **environment**: chỉ định biến mối trường, có thể chỉ định từng biến hoặc file chứa các biến môi trường\n\t- [x] **volumes**: chia sẻ dữ liệu từ máy ảo tới máy thật hoặc giữa nhiều containers với nhau\n\t\t- Ví dụ như container mysql, dữ liệu được tạo ra sẽ được lưu ở thư mục **var/lib/mysql**  trong container, nếu xóa container thì dữ liệu sẽ bị mất sạch.\n\t\t- Chính vì thế nên chúng ta dùng volumes để dữ liệu của container được mount ra ngoài host, nếu có xóa container thì dữ liệu vẫn còn, và khi khởi động lại, dữ liệu được mount ngược vào container và sử dụng bình thường.\n\t- [x] **ports**: Cấu hình cổng kết nối\n\t\t- có thể chỉ định cả 2 cổng **host:container** \n\t\t- vd 123:345 cổng 123 của máy thật sẽ trỏ đến cổng 345 của container\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.09-Docker/Docker-Network":{"title":"🐬 Docker Network","content":"\n## What? \n---\n\n🌱 Là mạng sử dụng cho các **containers** có thể kết nối và giao tiếp với nhau. Mỗi **container** có một vùng chứa riêng biệt nên cũng sẽ có mạng, port, IP riêng.\n\n🌱 **[[50 til/51 Code/51.09 Docker/Docker]]** cung cấp sẵn một số mạng mặc định cho các **container**, chúng ta có thể gom một nhóm **[[50 til/51 Code/51.09 Docker/Docker|container]]** vào một mạng chung. Điều này khá là tiện lợi trong trường hợp chúng ta muốn chỉ định một stack phù hợp cho dự án.\n\n## What type of network?\n---\n\n### 🌱 Bridge network\n---\n- Mạng **Bridge** cho phép kết nối giữa các **container** cùng mạng và sử dụng một dải ip được cấp ngẫu nhiên hoặc tự thiết lập.\n- Mạng Bridge đáp ứng hầu hết các usecase nếu triển khai các container trên cùng một host. Nhưng nếu chạy một môi trường đa host, **Bridge** sẽ không làm được điều này, đây sẽ là nhược điểm của mạng **Bridge**.\n- Driver của mạng **Bridge** là **bridge**.\n\n### 🌱 Host network\n---\n- **Host network** cho phép mạng **container** kết nối với **host**. Và sử dụng IP có cùng dải mạng với **host**.\n- Driver của mạng **Host** là **host**.\n\n### 🌱 None network\n---\n-   Tắt tất cả kết nối mạng.\n-   Driver của mạng **None** là **null**.\n\n### 🌱 Overlay network\n---\n-   Nhược điểm của mạng **Bridge** được **Overlay network** và **Macvlan** khắc phục.\n-   **Overlay network** thực hiện kết nối nhiều **Docker daemon** với nhau để tạo một mạng ảo trên các máy chủ. Nơi có thể thiết lập kêt nối giữa **swarm service** và **container** độc lặp hoặc hai **container** trên các host khác nhau.\n-   Driver của mạng **Overlay** là **overlay**.\n\n### 🌱 Macvlan netwrok\n---\n-  **Macvlan network** cho phép bạn gán địa chỉ MAC cho một **container**, biến **container** như một thiết bị vật lý trên mạng.\n-   Driver của mạng **Macvlan** là **macvlan**.\n\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/51-Code/51.09-Docker/Dockerfile":{"title":"🐬 Dockerfile","content":"\n---\n\n# I. Config\n---\n\n- **FROM**: chỉ định image gốc. [[50 til/51 Code/51.09 Docker/Docker]] Hub nơi lưu trữ và chia sẻ các images. Chúng ta có thể lấy các image gốc trên này và về xào nấu lại để phù hợp với nhu cầu sử dụng của mình.\n\n- **MAINTAINER**: optional để đặt tên cho tác giả viết Dockerfile\n\n- **RUN**: thực thi 1 câu lệnh trong quá trình build image.\n\n- **CMD**: thực thi 1 câu lệnh trong quá trình bật [[50 til/51 Code/51.09 Docker/Docker|container]].\n\n\t- Mỗi **Dockerfile** chỉ chạy một câu lệnh CMD, nếu có nhiều hơn sẽ chỉ chạy câu lệnh **CMD** cuối cùng.\n\t\n\t- Nếu muốn khởi động nhiều ứng dụng khi start container, hay sử dụng **ENTRYPOINT**.\n\n- **ENTRYPOINT**: thực thi một số câu lệnh trong quá trình bật container, những câu lệnh này sẽ được viết trong file script có đuôi .sh.\n\n- **EXPOSE**: chỉ định cổng mà container sẽ nghe khi chạy.\n\n- **ADD**: Copy file, thư mục, hoặc remote file thêm chúng vào filesystem của image.\n\n- **COPY**: Copy file, thư mục từ host machine vào image. Có thể sử dụng url cho tập tin cần copy(chưa dùng baoh =))).\n\n- **WORKDIR**: chỉ định directory cho câu lệnh CMD\n\n- **VOLUME**: mount thư mục từ máy host vào container.\n\n\nMình sẽ build những gì học được về docker ở repo này : [app-demo-rails-docker]( https://github.com/anhnh-3008/app-demo-rails-docker), mọi người có thể theo dõi các steps theo pulls cho tiện nhé. \n\nPull mình build Dockerfile: [pull build Dockerfile](https://github.com/anhnh-3008/app-demo-rails-docker/pull/1)\n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null},"/50-til/53-Psychology/S%E1%BB%B1-ng%E1%BB%A5y-bi%E1%BB%87n-c%E1%BB%A7a-tay-thi%E1%BB%87n-x%E1%BA%A1-Texas":{"title":"🧠 Sự ngụy biện của tay thiện xạ Texas","content":"\nMột gã cao bồi bắn bừa lên trên một bức tường, sau đó anh ta vẽ một vòng tròn bao quanh chỗ có nhiều lỗ đạn nhất và tự nhận mình là thiện xạ.\n\n![[00 Meta/01 Attachments/Pasted image 20221026172307.png]]\n\nĐây là cơ chế tâm lý phổ biến ở con người. Chúng ta thường sẽ có xu hướng bỏ qua sự ngẫu nhiên khi kết quả có vẻ có ý nghĩa. \n","lastmodified":"2022-11-22T15:57:34.657815247Z","tags":null}}