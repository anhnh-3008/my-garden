{"/":{"title":"Home","content":"\n\n\u003ch1\u003e Hi there, I'm a Ruby Developer 👋\n\u003ch2\u003e Welcome to my blog!!!\n\n🌱 \u003ca class=\"homepage-list-link\" href=\"50-til/\"\u003eTIL\u003c/a\u003e","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/40123345-posts/42-Code/42.01-Ruby/RubyCritic":{"title":"🌳 RubyCritic","content":"![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020164959.png]]\n\n🌱 `RubyCritic` cung cấp báo cáo trực quan về những vấn đề như code thối, cấu trúc code, tính dễ kiểm tra, và độ phủ của test case cho app Ruby. \n\n🌱 Đang liên tục phát triển và release tính năng mới. Có trong danh sách [Ruby Awesome](https://github.com/markets/awesome-ruby#:~:text=Rubycritic%20%2D%20A%20Ruby%20code%20quality%20reporter.).\n\n🌱 Bài viết này sẽ giới thiệu về một số những lợi ích mà `RubyCritic` đem lại, các `dependencies` của nó và cách để đọc `code reports`.\n\n## 🌿Why?\n\n🌱 Bạn có thể xem xét sử dụng `RubyCritic` nếu muốn có một nơi có thể theo dõi sự phát triển của code trong dự án. Áp dụng `RubyCritic` vào process dự án chắc chắn sẽ giảm được thời gian của team dev cho việc khắc phục `Technical debts`. Hầu hết các `technical debts` đều sẽ được phát hiện sớm và 'trả nợ' trong giai đoạn phát triển luôn.\n\n\u003e technical debts là gì?\n\u003e ...\n\u003e ...\n\u003e ...\n\n🌱 Một số những lợi ích của `RubyCritic` khi chúng ta áp dụng cho dự án hay process phát triển:\n- Thống nhất thông tin về một nơi duy nhất.\n- Báo cáo trực quan\n- Cài đặt dễ dàng\n- Không config\n- Cho phép tùy chỉnh theo nhu cầu sử dụng\n- Có thể mở rộng - Là open-source chúng ta có thể tích hợp thêm tính năng của mình.\n- Một trình tạo huy hiệu.\n\nĐể hiểu hơn về cách `RubyCritic` hoạt động, hãy xem những `internal dependencies` được sử dụng để tạo một report mặt mũi như thế nào nhé!  \n\n## 🌿 Internal dependencies trong Rubycritic\n\n- Khi bạn thêm `RubyCritic`, một số dependencies cũng được thêm kèm. \n- Điểm qua những dependencies chủ chốt: `The Reek`, `Flay`, và `Flog`. Đây đều là những gem cho phép `RubyCritic` hiển thị những thông tin hữu ích liên quan đến những code của bạn. Hiểu được cách hoạt động của bọn này sẽ thuận tiện hơn trong việc sử dụng `RubyCritic`.\n\n### 🌱 Reek: Tìm code Ruby bốc mùi 💩\n\n- [Reek](https://github.com/troessner/reek) là một gem dùng để tìm những dòng code 💩 trong Ruby. Code thối không phải là code sai, nó là những dòng code có thể được viết dễ đọc hơn, dễ bảo trì hoặc phát triển hơn nhưng vẫn đúng logic với ban đầu.\n- Reek sẽ phân tích xem có chỗ nào bốc mùi nhưng sẽ không gợi ý là sửa như thế nào vì hầu như code 'có mùi' đều liên quan đến business logic hoặc dựa theo kinh nghiệm của lập trình viên đối với một ngôn ngữ lập trình.\n\n\u003e Reek chỉ đánh giá được theo hướng chủ quan, nên chúng ta cũng nên cân nhắc thêm dựa theo logic của dự án cũng như kinh nghiệm của bản thân trước khi quyết định sửa code.\n\n- Reek cung cấp  [extensive list of smells](https://github.com/troessner/reek/blob/master/docs/Code-Smells.md). Kiểm tra và chỉ ra những chỗ bốc mùi trong:\n\t- Classes\n\t- Attributes\n\t- Methods\n\t- Parameters\n\t- Moduldes\n\t- Iterators\n\t- The implementation of polymorphism\n\n- Nhờ đó chúng ta sẽ chủ động trong việc làm cho code dễ đọc và dễ bảo trì hơn.\n\n- Cho phép config để:\n\t- Tắt kiểm tra những rule ko phù hợp với dự án.\n\t- Chỉ định các thư mục không cần kiểm tra.\n\t- Sử dụng filter để tắt tiếng cảnh báo.\n\n### 🌱 Flay: Kiểm tra code lặp\n- [Flay](https://ruby.sadi.st/Flay.html) xác định những điểm tương đồng trong cấu trúc code, bao gồm:\n\t- Tìm ra code bị lặp lại trong dự án.\n\t- Cho điểm để đánh giá mức độ tốt của code(điểm càng thấp, code càng ngon).\n\t- Checking the difference at any code level.\n\n- Nếu Flay báo cáo có sự trùng lặp trong code, khả năng cao chúng ta nên sửa nó. Đừng  bỏ qua vì nó rất có khả năng dẫn đến bugs. Khi bạn fix thêm gì đó ở một chỗ nhưng quên sửa những chỗ còn lại thì có khả năng bug sẽ xuất hiện đó.\n\n```rb\n# lib/flay.rb:80\nopts.on(\"-m\", \"--mass MASS\", Integer, \"Sets mass threshold (default = #{options[:mass]})\") do |m|\n  options[:mass] = m.to_i\nend\n \n# lib/flay.rb:105\nopts.on(\"-t\", \"--timeout TIME\", Integer, \"Set the timeout. (default = #{options[:timeout]})\") do |t|\n  options[:timeout] = t.to_i\nend\n```\n\nKiểm tra:\n```bash\n$ flay lib/flay.rb\nTotal score (lower is better) = 36\n \n1) Similar code found in :iter (mass = 36)\n  lib/flay.rb:80\n  lib/flay.rb:105\n```\n\nMặc dù nội dung bên trong không giống nhau hoàn toàn nhưng cấu trúc code có thể được cấu trúc lại để tránh trùng lặp. Đó là magic của Flay.\n\n\u003e Flay đánh giá trùng lặp dựa trên cấu trúc code, nếu điểm trùng lặp càng thấp có nghĩa code chúng ta càng ngon(dry). Tuy nhiên, chúng ta vẫn cần đánh giá thêm cả về logic của dự án trước khi sửa nhé.\n\n### 🌱 Flog: Kiểm tra độ phức tạp trong code\n[Flog](https://ruby.sadi.st/Flog.html) kiểm tra xem độ phức tạp của code(code khó đọc). Flog gán điểm phức tạp cho từng dòng sau đó tính tổng cho mỗi method hoặc class.\n\n``` rb\ndef validate_expiration\n  return if exp_month.blank? || exp_year.blank?\n \n  ...\nend\n```\n\nKiểm tra:\n```sh\n$ flog app/models/credit_card.rb\n \n5.2: CreditCard#validate_expiration   app/models/credit_card.rb:12-15\n```\n\n\n- Độ phức tạp đang là 5.2, giờ mình sẽ sửa để nó dễ đọc hơn một chút\n\n```rb\ndef validate_expiration\n  return if exp_month.blank?\n  return if exp_year.blank?\n \n  ...\nend\n```\n\nKiểm tra:\n```sh\n$ flog app/models/credit_card.rb\n \n4.8: CreditCard#validate_expiration app/models/credit_card.rb:12-15\n```\n\n\u003e Viết code là trò chơi đơn giản, nhưng để viết code đơn giản, dễ hiểu thì lại khó nhất trên đời 😆 Đừng cố viết cao siêu làm gì, hãy viết code thật dễ hiểu, hiệu quả để những người đồng nghiệp đọc code của bạn không phải chửi thầm nhé ❤️  \n\n### 🌱 Other Dependencies \n- Ngoài ra `RubyCritic` còn có nhiều dependencies khác, có cả những gem phổ biến mà chúng ta vẫn thường dùng như `buybug`, `simpleCov`, `rubocop`. Mọi người có thể xem đầy đủ các dependencies ở [đây](https://github.com/whitesmith/rubycritic/blob/main/rubycritic.gemspec).\n\n\n## 🌿Áp dụng cho dự án Ruby on Rails\n\n- `RubyCritic` cung cấp tài liệu chi tiết để bắt đầu mà không cần config nhiều. Trong khuôn khổ bài viết này, chúng ta sẽ tập trung cho việc phân tích những thông số có trong những báo cáo của `RubyCritic`.\n- Có 3 vấn đề được báo cáo là `Code`, `Smells` và `Coverage`. Cùng lược qua từng tính năng này nhé!\n\n### 🌱 Overview\nSau khi chạy `rubycritic` xong, tự động redirect tới một trang html chứa các reports của dự án.\n\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020153521.png]]\n\n- Màn `Overview` hiển thị tổng điểm của dự án trên một cái biểu đồ donut, xếp hạng theo A là tốt nhất và F là tệ nhất.\n- Phần `Summary` hiển thị chi tiết của từng rating (A -\u003e F) bao gồm số lượng files, số lượng commit(churns) và số lượng smell code được tìm thấy.\n- `Churn vs Complexity` hiển thị vị trí các Class/Module là một điểm, ứng với 2 chỉ số độ phức tạp và số lượng commit =\u003e phản ánh chính xác những điểm chưa tốt của dự án.\n\n### 🌱 Code Report\n\n- Hiển thị điểm của từng Class/Module bao gồm `churn`, `complexity`, `duplication` and `smells`.\n- Bạn có thể sort theo từng chỉ số để tiện đánh giá.\n- Có thể search tên của Class/Module.\n\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020154211.png]]\n\n- Click vào một Class/Module bất kỳ sẽ hiển thị chi tiết source code và các số liệu đi kèm như:\n\t- Code line\n\t- Chất lượng code\n\t- Churn\n\t- Độ phức tạp của method\n\t- Điểm phức tạp(tổng của class)\n\t- Số lượng code bị duplicates.\n\t- Số lượng smells tìm thấy.\n\n- Những dòng code có vấn đề sẽ được highlight(Dựa theo thông tin cả Reek gem cung cấp)\n\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020155314.png]]\n\n\n### 🌱 Smells Report\n- Hiển thị smell type, vị trí chính xác nơi bốc mùi và tình trạng khắc phục.\n- Như đã nói ở trên, Smells được cung cấp bởi gem Reek, và màn này chúng ta cũng có thể search và sort được như `Code Report`.\n- Bạn có thể nhìn thấy các class/module được nhóm theo smell type.\n\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020162956.png]]\n\n### 🌱 Coverage Report\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020164032.png]]\n\n- Chỉ hiển thị thông số độ bao phủ của kiếm thử đối với những class/module. \n- Không thể sắp xếp hoặc tìm kiếm như 2 trang bên trên.\n- Nếu tích hợp `SimpleCov` thì sẽ chi tiết và trực quan hơn, nhưng với hầu hết trường hợp chỉ cần một báo cáo đơn giản để đánh giá độ phủ của dự án, `Coverage Report` đã hoàn toàn đáp ứng được rồi.\n\n## ☘️Tham khảo\n- https://github.com/whitesmith/rubycritic\n- https://blog.appsignal.com/2022/10/19/improve-code-in-your-ruby-application-with-rubycritic.html\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.02-Vuejs/Vue3-Essentials":{"title":"🥦 Vue3 - Essentials","content":"\n## 🌿 I. Creating the Vue App\n\n- Tạo Vue App(được khởi tạo một lần, tất cả đều config ở đây).\n\n```js\nconst app = Vue.createApp({ // Heart of the Vue App\n  data() { // data option\n    return {\n      product: 'Socks'\n    }\n  }\n})\n```\n\n- Mount App to DOM - như ví dụ ở dưới, mount tới div tag có id là app, tất cả DOM element bao trong div đó sẽ có thể truy cập tới Vue App.\n\n```html\n\u003cscript\u003e\n  const mountedApp = app.mount('#app')\n\u003c/script\u003e\n```\n\n- Sử dụng [Mustache Syntax](https://vuejs.org/guide/essentials/template-syntax.html) để call dữ liệu từ Vue App.\n\n```html\n\u003ch1\u003e{{ product }}\u003c/h1\u003e\n```\n\n- Multiple application instances\n\n```js\nconst app1 = createApp({\n  /* ... */\n})\napp1.mount('#container-1')\n\nconst app2 = createApp({\n  /* ... */\n})\napp2.mount('#container-2')\n```\n\n- doc: https://vuejs.org/guide/essentials/application.html\n- pull https://github.com/anhnh-3008/Vue3/pull/1\n\n## 🌿 II. Template syntax\n\n1. Muốn call dữ liệu cho các attribute của DOM element, sử dụng **v-bind**.\n\n```html\n\u003cimg v-bind:src=\"image\"\u003e\n\n\u003c!-- Shorthand: --\u003e\n\u003cimg :src=\"image\"\u003e\n\n\u003c!-- Use cases: --\u003e\n\u003cimg :alt=\"description\"\u003e\n\u003ca :href=\"link\"\u003e\n\u003cdiv :class=\"isActive\"\u003e\n\u003cspan :style=\"isActive\"\u003e\n```\n\n2. Dynamically Binding Multiple Attributes\n\n```js\ndata() {\n  return {\n    objectOfAttrs: {\n      id: 'container',\n      class: 'wrapper',\n      disabled: 'false'\n    }\n  }\n}\n```\n\n```html\n\u003cdiv v-bind=\"objectOfAttrs\"\u003e\u003c/div\u003e\n\u003c!-- \u003cdiv id=\"container\" class=\"wrapper\" disabled=\"false\"\u003e\u003c/div\u003e --\u003e\n```\n\n3. Calling functions\n\n- Có thể gọi function trong **v-bind**, function chỉ được một lần khi init component nên không sử dụng cho những case cần data động như changing data hoặc triggering asynchronous operations.\n\n```html\n\u003cspan :title=\"toTitleDate(date)\"\u003e\n  {{ formatDate(date) }}\n\u003c/span\u003e\n```\n\n4. Dynamic Arguments\n\n```html\n\u003ca :[someAttr]=\"value\"\u003e ... \u003c/a\u003e\n```\n\n- **someAttr** - giá trị thay đổi theo data mount từ Vue App, với những giá trị phức tạp, có thể sử dụng **computed properties**, xem thêm ở mục VIII.\n\n5. Modifiers\n- Khái niệm hiểu như trong JQuery. Vd **.prevent** có nghĩa là `v-on` sẽ call `event.preventDefault()` trong quá trình trigger sự kiện.\n\n```html\n\u003cform @submit.prevent=\"onSubmit\"\u003e...\u003c/form\u003e\n```\n\n![[00 Meta/01 Attachments/Pasted image 20221225223906.png]]\n\n- doc: https://vuejs.org/guide/essentials/template-syntax.html\n- pull https://github.com/anhnh-3008/Vue3/pull/2\n\n\n## 🌿 III. Condition rendering\n\n- **v-show**: luôn render DOM element, condition chỉ toggle `display` CSS property \n- **v-if** - **v-eles-if** - **v-else**: đúng condition thì mới render DOM, logic giống với các ngôn ngữ lập trình khác.\n\n```html\n\u003cp v-if=\"condition\"\u003eCondition is true\u003c/p\u003e\n\u003cp v-else\u003eCondition is false\u003c/p\u003e\n```\n\n- So sánh **v-if** và **v-show**:\n\n|**v-if**|**v-show**|\n|----|--------|\n|Là chuẩn conditional rendering vì nó đảm bảo sẽ xóa và render lại toàn bộ listener events or components nằm trong block khi toggles điều kiện|Toggle điều kiện thì chỉ thay đổi duy nhất `display: none` thôi|\n|Lazy - chỉ render DOM khi condition == true|Luôn render DOM|\n|higher toggle costs - dùng với những điều kiện ít thay đổi|higher initial render costs - dùng với những element cần toggle điều kiện thường xuyên|\n\n- Khi **v-if** và **v-for** được sử dụng trên cùng một object, **v-if** sẽ được gọi đầu tiên.\n\n- doc: https://vuejs.org/guide/essentials/conditional.html\n- pull https://github.com/anhnh-3008/Vue3/pull/3\n\n## 🌿 IV. List rendering\n\n1. **v-for**: lặp một mảng.\n\n```html\n\u003cul\u003e\n  \u003cli v-for=\"user in users\"\u003e\n    \u003cp\u003e{{user.id}}\u003c/p\u003e\n    \u003cp\u003e{{user.name}}\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n```\n\n2. Nested loop:\n\n```html\n\u003cli v-for=\"item in items\"\u003e\n  \u003cspan v-for=\"childItem in item.children\"\u003e\n    {{ item.message }} {{ childItem }}\n  \u003c/span\u003e\n\u003c/li\u003e\n```\n\n3. Có thể dùng **of** thay **in**.\n\n```html\n\u003cdiv v-for=\"item of items\"\u003e\u003c/div\u003e\n```\n\n4. Ngoài mảng, có thể lặp Object, cơ chế lặp qua các keys base theo **Object.keys()**.\n\n```js\ndata() {\n  return {\n    myObject: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n}\n```\n\n```html\n\u003cul\u003e\n  \u003cli v-for=\"value in myObject\"\u003e\n    {{ value }}\n  \u003c/li\u003e\n\u003c/ul\u003e\n```\n\n5. for with a range\n\n```html\n\u003cspan v-for=\"n in 10\"\u003e{{ n }}\u003c/span\u003e\n```\n\n\n- doc: https://vuejs.org/guide/essentials/list.html\n- pull https://github.com/anhnh-3008/Vue3/pull/4\n\n## 🌿 V. Event handling\n\n- **v-on:event**: bắt sự kiện\n\n```html\n\u003c!-- shorthand: @event --\u003e\n\u003cdiv v-for=\"variant in variants\" :key=\"variant.id\" @mouseover=\"updateImage(variant.image)\"\u003e{{ variant.color }}\u003c/div\u003e\n\n\u003cbutton class=\"button\" @click=\"addToCart\"\u003eAdd to Cart\u003c/button\u003e\n```\n\n1. Inline handlers\n- Với logic ngắn, đơn giản có thể truyền thẳng.\n```js\ndata() {\n  return {\n    count: 0\n  }\n}\n```\n\n```html\n\u003cbutton @click=\"count++\"\u003eIncrease\u003c/button\u003e\n\u003cp\u003eCount is: {{ count }}\u003c/p\u003e\n```\n\n2. Method handlers\n- Logic dài + phức tạp thì có thể xử lý thông qua method\n```js\ndata() {\n  return {\n    count: 0\n  }\n},\nmethods: {\n  alertCount() {\n    if (count \u003e 0) {\n      alert('Count is positive');\n    } else {\n      alert('Count is negative');\n    }\n  }\n}\n```\n\n```html\n\u003cbutton @click=\"alertCount\"\u003eAlert\u003c/button\u003e\n```\n\n3. Event Modifiers\n- Chúng ta thường xuyên phải sử dụng event modifiers(chỉ định những common event ví dụ như không reload khi submit form, ...). Có thể định nghĩa  Event Modifiers trong method nhưng theo quan điểm của Vue, method chỉ để xử lý logic thôi. Nên trong Vue, chúng ta có thể chỉ định trực tiếp như sau:\n\n```html\n\u003c!-- the click event's propagation will be stopped --\u003e\n\u003ca @click.stop=\"doThis\"\u003e\u003c/a\u003e\n\n\u003c!-- the submit event will no longer reload the page --\u003e\n\u003cform @submit.prevent=\"onSubmit\"\u003e\u003c/form\u003e\n\n\u003c!-- modifiers can be chained --\u003e\n\u003ca @click.stop.prevent=\"doThat\"\u003e\u003c/a\u003e\n\n\u003c!-- just the modifier --\u003e\n\u003cform @submit.prevent\u003e\u003c/form\u003e\n\n\u003c!-- only trigger handler if event.target is the element itself --\u003e\n\u003c!-- i.e. not from a child element --\u003e\n\u003cdiv @click.self=\"doThat\"\u003e...\u003c/div\u003e\n```\n\n4. Key Modifiers\n- Khi xử lý event theo các keys đặc biệt, Vue cho phép chỉ định nhanh như sau:\n\n``` js\n\u003c!-- only call `submit` when the `key` is `Enter` --\u003e\n\u003cinput @keyup.enter=\"submit\" /\u003e\n```\n\n- Với TH xử lý combo(vd: Ctrl + Enter), Vue cho phép thực hiện thông qua 4 keys bắt đầu :\n\t- `.ctrl`\n\t- `.alt`\n\t- `.shift`\n\t- `.meta`\n\n```html\n\u003c!-- Alt + Enter --\u003e\n\u003cinput @keyup.alt.enter=\"clear\" /\u003e\n\n\u003c!-- Ctrl + Click, mặc định sẽ + với click --\u003e\n\u003cdiv @click.ctrl=\"doSomething\"\u003eDo something\u003c/div\u003e\n```\n\n- `exact` - xem vd\n\n```html\n\u003c!-- chỉ cần có ấn ctrl (có thể là ctrl + shift) method sẽ được gọi --\u003e\n\u003cbutton @click.ctrl=\"onClick\"\u003eA\u003c/button\u003e\n\n\u003c!-- chỉ gọi method khi hệ thống nhận duy nhất key ctrl --\u003e\n\u003cbutton @click.ctrl.exact=\"onCtrlClick\"\u003eA\u003c/button\u003e\n\n\u003c!-- chỉ gọi method khi hệ thống không có event modifiers nào --\u003e\n\u003cbutton @click.exact=\"onClick\"\u003eA\u003c/button\u003e\n```\n\n- doc: https://vuejs.org/guide/essentials/event-handling.html\n- pull https://github.com/anhnh-3008/Vue3/pull/5\n\n## 🌿 VI. Class \u0026 Style binding\n\n### 🌱 Class binding\n\n- **:class**: xử lý tên class\n\n```html\n\u003cbutton class=\"button\"\n:class=\"{ disabledButton: inventories \u003c= 0 }\"\n:disable=\"inventories \u003c= 0\"\u003eAdd to Cart\u003c/button\u003e\n```\n\n1. Binding to Object\n-  Ngoài cách truyền điều kiện boolean như trên, có thể truyền object để dễ quản lý.\n```js\nconst classObject = reactive({\n  active: true,\n  'text-danger': false\n})\n```\n\n```html\n\u003cdiv :class=\"classObject\"\u003e\u003c/div\u003e\n\n\u003c!-- render --\u003e\n\n\u003cdiv class=\"active text-danger\"\u003e\u003c/div\u003e\n```\n\n2.  Binding to Array\n- Truyền một mảng, kết quả cũng giống bên trên.\n```js\nconst activeClass = ref('active')\nconst errorClass = ref('text-danger')\n```\n\n```html\n\u003cdiv :class=\"[activeClass, errorClass]\"\u003e\u003c/div\u003e\n```\n\n\u003e [!note] Note\n\u003e \n\u003e Trong doc có giới thiệu inline handle nhưng mình thấy không hợp lý lắm, có gì cần xử lý logic cứ nhét hết vào file Js, trong HTML để biến boolean thôi.\n\n3. With Components\n- Chỉ định `:class` cho component sẽ merge cho những class của child DOMs trong component(những DOM có define class)\n```html\n\u003c!-- child component template --\u003e\n\u003cp class=\"foo bar\"\u003eHi!\u003c/p\u003e\n\n\u003c!-- when using the component --\u003e\n\u003cMyComponent class=\"baz boo\" /\u003e\n\n\u003c!-- child rendered will be --\u003e\n\u003cp class=\"foo bar baz boo\"\u003eHi\u003c/p\u003e\n```\n\n- `class` của component được lưu trong biến `$attrs`, có thể chỉ định trực tiếp cho child DOM:\n\n```html\n\u003c!-- child component template --\u003e\n\u003cp :class=\"$attrs.class\"\u003eHi!\u003c/p\u003e\n\n\u003c!-- when using the component --\u003e\n\u003cMyComponent class=\"baz\" /\u003e\n\n\u003c!-- child rendered will be --\u003e\n\u003cp class=\"baz\"\u003eHi\u003c/p\u003e\n```\n\n### 🌱 Style binding\n\n- **:style**: xử lý style\n\n```html\n\u003cdiv\nclass=\"color-circle\"\n:style=\"{ backgroundColor: variant.color }\"\n\u003e\u003c/div\u003e\n```\n\n1. Giống với Class, cũng nhận Object và Array\n2. Support cả camelCase và kebab-cases(để trong nháy kép)\n\n```html\n\u003c!-- camelCase --\u003e\n\u003cdiv :style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"\u003e\u003c/div\u003e\n\n\u003c!-- kebab-cases --\u003e\n\u003cdiv :style=\"{ 'font-size': fontSize + 'px' }\"\u003e\u003c/div\u003e\n```\n\n- doc: https://vuejs.org/guide/essentials/class-and-style.html\n- pull: https://github.com/anhnh-3008/Vue3/pull/6\n\n## 🌿 VII. Computed Properties\n\n- Các thuộc tính cần dùng thêm logic để tính toán, khai báo trong **computed**.\n```js\nconst app = Vue.createApp({\n  data() {\n    return {\n      product: 'Socks'\n    }\n  },\n  computed: {\n    productWithBrandTilte() {\n      return 'Brand Vue - ' + this.product // Brand Vue - Socks\n    }\n  },\n})\n```\n\n- Tại sao không dùng function mà phải dùng computed làm gì?\n\n|Computed property|Function|\n|--------------------|---------|\n|cache dựa trên **reactive dependencies**, như vd trên nếu product không thay đổi khi gọi lại sẽ return ngay lập tức|không cache, luôn gọi lại getter|\n\n### 🌱 Best practice\n\n1. Chỉ nên tính toán, xử lý trả về giá trị, đừng có nhét cả logic thay đổi DOM hay gọi bất đồng bộ lấy dữ liêu, ... Trách nhiệm duy nhất của computed chính là tính toán và trả về giá trị - S(Single Responsibility Principle) in SOLID.\n2. Tránh trực tiếp thay đổi giá trị computed. Chỉ nên thay đổi những variables nằm trong logic xử lý của computed property.\n\n- doc: https://vuejs.org/guide/essentials/computed.html\n- pull: https://github.com/anhnh-3008/Vue3/pull/7\n\n## 🌿 VIII. Component basic\n\n### 🌱 Components\n\n-  Cho phép chia UI thành những phần nhỏ độc lập, có khả năng tái sử dụng, dễ quản lý hơn.\n- Không chỉ nhóm các DOM elments, Vue còn cho phép đóng gói dữ liệu, logic cho từng **component**.\n\n![[00 Meta/01 Attachments/Pasted image 20230103092932.png]]\n\n-  Defining a component:\n\n```js\napp.component('product-detail', {\n  // options\n  template:, // define DOM elements\n  data() {return {} }, // define data\n  methods {}, // define methods\n  computed {}, // define computed properties\n})\n```\n\n```html\n\u003cproduct-display\u003e\u003c/product-display\u003e\n\n\u003c!-- Import Component --\u003e\n\u003cscript src=\"./components/ProductDisplay.js\"\u003e\u003c/script\u003e\n```\n\n- Có thể sử dụng lại nhiều lần một **component**, mỗi khi một **component** được khởi tạo, toàn bộ data, computed properties sẽ được tạo mới, độc lập không liên quan gì đến nhau. Nếu muốn trigger đến một biến chung cho những **components** con, hãy define **variable** ở **component** cha và truyền vào **component** con thông qua **props**.\n\n### 🌱 Props\n\n- **Props** - Là option chỉ định những tham số nhận từ thằng cha vào **component**.\n- Ví dụ một trang web bán hàng có nhiều sản phẩm, nếu sản phẩm được gắn **premium** thì sẽ free ship ngược là phí ship sẽ là 2.99$. Biến **premium** sẽ dùng chung cho nhiều sản phẩm cùng category nên chúng ta sẽ define **premium** riêng và truyền vào **component** sản phẩm.\n\n```js\nconst app = Vue.createApp({\n  data() {\n    return {\n      premium: false\n    }\n  }\n})\n```\n\n```html\n\u003cproduct-display :premium=\"premium\"\u003e\u003c/product-display\u003e\n\n\u003c!-- Import Component --\u003e\n\u003cscript src=\"./components/ProductDisplay.js\"\u003e\u003c/script\u003e\n```\n\n```js\napp.component('product-detail', {\n  // define property recieve from parent component\n  props: {\n    premium: {\n      type: Boolean,\n      required: true\n    }\n  }\n  template:, // define DOM elements\n  data() {return {} }, // define data\n  methods {}, // define methods\n  computed {\n    shipping() {\n      if (this.premium) return 'free'\n      \n      return '2.99$'\n    }\n  }\n})\n```\n\n- doc: https://vuejs.org/guide/essentials/component-basics.html\n- pull: https://github.com/anhnh-3008/Vue3/pull/8\n\n### 🌱 Communicating events\n\n- Trong quá trình phát triển, TH chúng ta muốn method trong **component** con tương tác được với varibale define trong **component** cha, có thể giao tiếp thông qua `$emit`.\n\n```html\n\u003c!-- index.html --\u003e\n\u003cproduct-display @add-to-cart=\"updateCart\"\u003e\u003c/product-display\u003e\n\n\u003c!-- Import Component --\u003e\n\u003cscript src=\"./components/ProductDisplay.js\"\u003e\u003c/script\u003e\n```\n\n```js\n// main.js\nmethods: {\n  updateCart() {\n    this.cart += 1\n  }\n}\n```\n\n```js\n// ProductDisplay.js\ntemplate:\n  /*html*/\n  `\u003cbutton\n  class=\"button\"\n  @click=\"addToCart\"\u003e\n  Add to Cart\n  \u003c/button\u003e`,\nmethods: {\n  addToCart() {\n    this.$emit('add-to-cart')\n    // this.$emit('add-to-cart', params)\n  }\n}\n```\n\n- doc: https://vuejs.org/guide/essentials/component-basics.html#listening-to-events\n- pull: https://github.com/anhnh-3008/Vue3/pull/9\n\n## 🌿 X. Form Input Bindings \n\n- **v-model** - liên kết element trong form tới các biến trong data.\n\n```html\n\u003cp\u003eMessage is: {{ message }}\u003c/p\u003e\n\u003cinput v-model=\"message\" placeholder=\"edit me\" /\u003e\n```\n\n- doc: https://vuejs.org/guide/essentials/forms.html\n- pull: https://github.com/anhnh-3008/Vue3/pull/10","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.02-Vuejs/What-is-Vue":{"title":"🥦 What is Vue?","content":"\n## 🌿 What is Vue?\n\n![[00 Meta/01 Attachments/Pasted image 20221224114448.png]]\n- Vuejs là một open source Javascript framework hướng tới việc xây dựng giao diện người dùng(UI), được tạo ra bởi [Evan You](https://twitter.com/youyuxi?lang=en). Như trên [Landing page](https://vuejs.org/) có giới thiệu, Vuejs là một phiên bản cấp tiến của Javascript framework với những đặc điểm nổi bật như dễ tiếp cận, linh hoạt và hiệu quả. \n\n## 🌿 Why use it?\n\n### 🌱 Progressive - Cấp tiến\n\n- Vue được công nhận là **progressive** vì nó thường có thể scale down cũng như up. Với đa số những trường hợp sử dụng phổ thông, chúng ta có thể tích hợp Vue như jQuery - thêm một script tag như sau: \n\n```html\n\u003cscript src=\"https://cdn.jsdelivr.net/npm/vue\"\u003e\u003c/script\u003e\n```\n\n- Khi nhu cầu sử dụng của chúng ta phát triển, Vue cũng sẽ cung cấp thêm những công cụ có trong hệ sinh thái giúp nâng cao hiệu quả sử dụng. \n  \n### 🌱 Approachable - Dễ tiếp cận\n\n- Vue rất dễ tiếp cận miễn là chúng ta có hiểu biết HTML, CSS, và JS tiêu chuẩn. Vậy là bạn có thể bắt đầu làm việc với Vue được rồi. \n\n### 🌱 Versatile - Linh hoạt\n\n![[00 Meta/01 Attachments/Pasted image 20221224114549.png|80%]]\n\n- Vue linh hoạt vì xung quanh thư viện có đầy đủ các tools support, muốn dùng gì thì mình tích hợp thêm, chứ không cần phải cài hết một lượt. Các tools phổ biến:\n\t- [vue-cli](https://cli.vuejs.org/) (i.e. Vue Command Line Interface) - như cli của những framwork khác, cho phép giao tiếp nhanh cong với Vue app.\n\t- [vue-router](https://router.vuejs.org/) - chỉ định routes giao tiếp dễ dàng giữa client-side và server-side.\n\t- [vuex](https://vuex.vuejs.org/guide/) - hỗ trợ quản lý dữ liệu.\n\t- [vue-test-utils](https://vue-test-utils.vuejs.org/) - cung cấp đa dạng các helpers cũn như functions hỗ trợ chúng ta trong quá trình viết UT.\n\n- Các tools trên đều được created and maintained bởi chính đội Vue core nên việc tích hợp sẽ vẫn là trơn chu, mượt mà.\n  \n### 🌱 Performant - Hiệu quả\n\n![[00 Meta/01 Attachments/Pasted image 20221224120158.png]]\n\n- Cuối cùng, Vue hiệu quả vì nó tận dụng virtual DOM để có được thời gian re-render lại cực nhanh. Thư viện lõi của Vue cũng được phát triển với tiêu chí là tối ưu hiệu suất.\n\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/AMI-Amazon-Machine-Image":{"title":"🥦 AMI - Amazon Machine Image","content":"\n## 🌿 What?\n- AMI - Amazon Machine Image\n- Có chứa những thông tin về OS, phần mềm cài đặt, volumes, cấu hình, hay các thiết lập khác của một EC2 Instance.\n\t- Dễ dàng triển khai. Nhất quán về cấu hình cũng như  thiết lập của các EC2 Instances.\n\t- Fast boot vì Image đã được chuẩn bị trước về phần mềm cài đặt, thiết lập, ...\n- AMI thuộc về một Region chỉ định( chúng ta có thể copy để sử dụng ở những Region khác)\n- Các Options để có một AMI:\n\t- A public AMI: AWS cung cấp một số AMI mẫu, mỳ ăn liền.\n\t- Your own AMI: tự tạo và thiết lập để phù hợp với nhu cầu sử dụng của bản thân.\n\t- An AWS Marketplace AMI: Có thể mua/bán AMI trên market. Có thể khởi nghiệp bằng công việc bán AMI luôn 😍\n\n## 🌿 AMI Process( từ một EC2 Instance)\n- Tạo một EC2 Instance và tùy chỉnh nó.\n- Dừng Instance(Data được toàn vẹn)\n- Tạo AMI - Giống tạo EBS snapshots\n- Launch Instance từ AMIs\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/ASG-Auto-Scaling-Group":{"title":"🥦 ASG - Auto Scaling Group","content":"\n## 🌿 What?\n- Là một service của AWS hỗ trợ việc tự động mở rộng hay thu nhỏ số lượng instances để phù hợp với lượng tải của ứng dụng.\n- Mục đích:\n\t- Thêm số lượng EC2 Instances để đáp ứng lượng tải tăng cao.\n\t- Giảm số lượng EC2 Instances để phù hợp với lượng tải ít đi.\n\t- Xác định được số lượng lớn nhất cũng như nhỏ nhất của các EC2 Instances.\n\t- Tự động đăng ký instances mới để cân bằng tải.\n\t- Tự động tạo lại một EC2 Instance thay thế trong trường hợp instance trước đó bị đánh giá là unhealthy.\n- ASG are free (chỉ phải trả tiền thuê các EC2 instances)\n\n## 🌿 Attributes\n- Gọi là một **Launch Template**, bao gồm:\n\t- Nhưng thông tin về EC2 Instance:\n\t\t- AMI + Instance Type\n\t\t- EC2 User Data\n\t\t- EBS Volumes\n\t\t- Security Groups\n\t\t- SSH Key Pair\n\t\t- IAM Roles cho EC2 Instances\n\t\t- Network + Subnet\n\t- Thông tin Load Balancer\n- Min Size/ Max Size/ Initial Capacity\n- Scaling Policy\n\t- Khả năng auto scale dựa vào báo động CloudWatch - cái mà dùng để theo dõi metric(như Average CPU, ...) và từ đó có thể tính toán scale.\n\n## 🌿 Scaling Policies\n- Dynamic Scaling policies\n\t- Target Tracking Scaling\n\t\t- Đơn giản về dễ setup nhất\n\t\t- VD: tôi muốn trung bình ASG CPU ở khoảng 40%\n\t- Simple/Step Scaling\n\t\t- Scale dự theo thông tin của CloudWatch báo. Điều chỉnh mở rộng theo ngưỡng(min - max)\n\t\t- Vd nó báo CPU \u003e 70% -\u003e tự động add thêm 2 instances\n\t\t- vd nó bảo CPU \u003c 30% -\u003e tự động remove 1 instance\n\t- Scheduled Actions\n\t\t- Thực hiện mở rộng dựa theo lịch lên sẵn.\n\t\t- Ví dụ app dùng nhiều vào cuối tuần thì sẽ tăng instance lên vào thứ 7 và CN\n\t- Predictive Scaling\n\t\t- Dựa trên lịch sử khai thác dữ liệu của ứng dụng, ASG sẽ tự động điều chỉnh trước resources để luôn có để đáp ứng nhu cầu sử dụng.\n\n## 🌿 Các chỉ số chính để đánh giá scale\n- Chỉ số trung bình CPU của các instances\n- Số requests trên từng Target\n- Trung bình network in/out\n- Any custom metric\n\n## 🌿 Scaling cooldowns\n- Sau mỗi hoạt động scale, ASG sẽ phải đợi **cooldown period( thời gian hồi chiêu )**, mặc định là 300s.\n- Trong thời gian này, ASG sẽ không lauch hoặc terminate bất kỳ instance nào, việc này để đảm bảo các chỉ số được ổn định sau đó mới tiếp tục thực hiện các hoạt động scale khác.\n- Sử dụng ready-to-use AMI để giảm thời gian config, từ đó giảm được quá trình hồi chiêu của ASG.","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/AWS-API-Gateway":{"title":"🥦 AWS API Gateway","content":"\n## 🌿 What?\n- Kết hợp với [[40123345 posts/42 Code/42.03 AWS/AWS Lambda|AWS Lambda]]: kiến trúc không có server.\n- Expose REST API.\n- Hỗ trợ giao thức WebSocket\n- Xử lý API versioning(v1,v2,...)\n- Xử lý giữa các môi trường phát triển khác nhau(dev, test, prod, ...)\n- Xử lý bảo mật(Authen \u0026 Authori)\n- Tạo API keys\n- Kết hợp được với Swagger/Open API để nhanh chóng tạo ra doc.\n- Có thể transform và validate requests và responses.\n- Gen ra SDK và API specifications.\n- Cache lại responses của API.\n\n## 🌿 Integrations\nKết hợp được với:\n- **[[40123345 posts/42 Code/42.03 AWS/AWS Lambda|Lambda]] Function**\n- **HTTP**\n\t- Dùng để add rate limit, caching hoặc authen cho users, ...\n- **AWS Service**\n\n## 🌿 Endpoint Types\n- **Edge-Optimized(default)**\n\t- Cho global clients\n\t- Requests sẽ được định tuyến tới các edge location(độ trễ thấp)\n\t- API Gateway chỉ tồn tại trên một region nhưng users ở những chỗ khác vẫn truy cập với độ trễ thấp.\n- **Region**\n\t- Cho những clients ở cùng một region\n\t- Có thể kết hợp thủ công với CloudFront\n- **Private**\n\t- Chỉ có thể kết nối từ VPC thông qua ENI.\n\t- Sử dụng policy để xác định quyền truy cập.\n\n## 🌿 Security\n- **Dùng để xác thực người dùng**:\n\t- IAM roles(phù hợp với các app nội bộ)\n\t- Cognito (xác định các user bên ngoài - vd như mobiles user)\n\t- Custom Authorizer (cho logic của chúng ta)\n- **Custom Domain Name HTTPS** bằng việc tích hợp AWS Certificate Manager(ACM)\n\t- Nếu sử dụng Edge-Optimized endpoint, certificate phải thuộc về **us-east-1**\n\t- Nếu sử dụng Regional endpoint, certificate phải nằm trong API Gateway region\n\t- Nếu dùng với Route53, phải sử dụng CNAME hoặc A-alias.\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/AWS-App-Runner":{"title":"🥦 AWS App Runner","content":"\n## 🌿 What?\n![[00 Meta/01 Attachments/Pasted image 20230327172620.png]]\n- Là một service giúp chúng ta dễ dàng hơn trong việc triển khai web applications và APIs.\n- Không cần yêu cầu có kinh nghiệm với cơ sở hạ tầng(infrastructure).\n- Đầu tiên cần có source code hoặc container image.\n- Thiết lập các thông số như vCPU, RAM, Auto Scaling, Health Check, ....\n- Sau đó service tự động build và deploy web app.\n- Tự động scaling, HA, load balancer, mã hoá.\n- Hỗ trợ truy cập VPC.\n- Kết nối với các dịch vụ database, cache và message queue.\n- Use cases: web apps, APIs, microservices, triển khai nhanh.\n\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/AWS-Batch":{"title":"🥦 AWS Batch","content":"\n## 🌿 What?\n- Do AWS quản lý hoàn toàn.\n- Hỗ trợ chạy các tác vụ theo lô(kiểu như xử lý ảnh khi người dùng gửi lên [[40123345 posts/42 Code/42.03 AWS/Elastic Beanstalk|S3]], ...)\n- Batch sẽ linh động tạo ra các EC2 Instances hoặc Spot Instances để xử lý logic, nó sẽ tự biết lựa chọn về compute/memory phù hợp.\n- Các Batch jobs được định nghĩa như là các [[50 til/51 Code/51.09 Docker/Docker|Docker]] Imaged và sẽ chạy trên [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon ECS - Elastic Container Service|ECS]].\n- Phù hợp khi chúng ta muốn tối ưu chi phí cũng như đơn giản hoá kiến trúc của hệ thống.\n![[00 Meta/01 Attachments/Pasted image 20230427162102.png]]\n\n|AWS Lambda|AWS Batch|\n|--------------|----------|\n|Time limit| No time limit|\n|Limit runtime|Cứ chạy cái docker là sử dụng tẹt ga|\n|Giới hạn bộ nhớ tạm| Phụ thuộc vào EBS/instance store|\n|Serverless| Có launch EC2 Instance(được AWS quản lý)|\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/AWS-CloudFormation":{"title":"🥦 AWS CloudFormation","content":"\n## 🌿 What?\n- Là một bản phác thảo cho kiến trúc hạ tầng trên AWS, cho hầu hết các resources trên AWS.\n- Ví dụ, chúng ta cần một kiến trúc bao gồm:\n\t- Security Group\n\t- 2 EC2 Instances sử dụng SG trên\n\t- Một [[40123345 posts/42 Code/42.03 AWS/S3|S3]] Bucket\n\t- Một ELB\n- CloudFormation sẽ tạo tất cả **theo đúng trình tự** như trên và **đúng theo những thông số mà chúng ta đã chỉ định**.\n\n## 🌿 Benefits\n- **Infrastructure as code** \n\t- Không phải tạo resources thủ công nữa.\n\t- Các thay đổi về resources sẽ được review thông qua code.\n- Chi phí:\n\t- Dễ dàng theo dõi chi phí theo stack build trong code.\n\t- Có thể ước lượng được chi phí sử dụng nhờ CloudFormation template.\n\t- Saving strategies: ở môi trường dev, có thể dễ dàng tự động xoá template vào lúc 6 giờ chiều(khi mn tan làm) và bật lại vào lúc 8 giờ sáng(khi mọi người bắt đầu làm việc).\n- Hiệu suất:\n\t- Có khả năng xoá, tự động tạo infrastructure ở bất cứ đâu.\n\t- Tự động tạo biểu đồ cho template\n\t- Lập trình khai báo(không cần thực hiện theo thứ tự, vd như cần tạo một [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon DynamoDB|DynamoDB]] thì phải tạo trước một EC2 Instance, ... CloudFormation tự tìm được cách thực hiện)\n- Không chế tạo lại bánh xe(tận dụng những cái có sẵn)\n\t- Tận dụng những templates sẵn có trên web.\n\t- Tận dụng lại các tài liệu.\n- **Hỗ trợ hầu như tất cả các AWS resources**\n\t- Có thể sử dụng \"custome resources\" cho những resources không được hỗ trợ.\n\n## 🌿 Stack Designer\n![[00 Meta/01 Attachments/Pasted image 20230427110235.png]]\n- Chúng ta có thể thấy được **toàn bộ resouces** được áp dụng cho infrastructure.\n- Ngoài ra còn có thể thấy được **quan hệ** của chúng.","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/AWS-CloudFront":{"title":"🥦 AWS CloudFront","content":"\n## 🌿 What?\n- Là một dịch vụ CDN(Content Delivery Network)\n- **Tăng hiệu suất đọc, content được cache ở edge location.**\n\t- Ví dụ S3 đặt ở Singapore, có user truy cập dữ liệu từ Mỹ, dữ liệu sẽ được fetch về một **edge location** ở Mỹ và cache lại, sau đấy, người dùng khác ở Mỹ muốn truy cập dữ liệu thì sẽ đọc ở **edge location** đấy luôn. \n- Nâng cao trải nghiệm của người dùng.\n- **DDoS protection(bởi vì là toàn thế giới), tích hợp với Shield, AWS Web Applocation Firewall**\n\n## 🌿 Origins\n- **[[40123345 posts/42 Code/42.03 AWS/S3|S3]] Bucket**\n\t- Để phân phối files và caching chúng ở các edge\n\t- Tăng cường bảo mật với CloudFront **Origin Access Control(OAC)**\n\t- OAC đang thay thế Origin Access Identity (OAI)\n\t- CloudFront có thể được sử dụng như một nơi để truy cập để upload files vào S3\n- **Custom Origin (HTTP)**\n\t- Application Load Balancer\n\t- EC2 Instance\n\t- S3 website (cần phải bật static web)\n\t- Bất kỳ HTTP backend nào bạn muốn.\n\n## 🌿 So sánh giữa CloudFront và S3 Replication\n- **CloudFront**\n\t- Global Edge network\n\t- Files được cached trên các edge location(có thể là một ngày)\n\t- **Phù hợp cho các static content mà cần available ở mọi nơi**.\n- **S3 Cross Region Replication**\n\t- Cần setup cho từng region mà chúng ta muốn nhân bản.\n\t- Filed được update gần như là real-time\n\t- Chỉ được đọc\n\t- **Phù hợp với những dynamic content cần available với độ trễ thấp ở một vài regions.**\n\n## 🌿 CloudFront Geo Restriction\n- Có thể giới hạn người có thể truy cập vào bản phân phối của chúng ta.\n\t- **Allowlist:** Cho phép người dùng của những khu vực được cho phép, truy cập vào content của bạn\n\t- **Blocklist:** Ngăn ngừa người dùng của những khu vực chỉ định, không được truy cập vào content của bạn.\n- Khu vực sẽ sử dụng một bên thứ 3 - Geo-IP database để giúp chúng ta xác định.\n- Use case: Luật bản quyền để kiểm soát truy cập vào dữ liệu.\n\n## 🌿 CloudFront - Pricing\n- CloudFront Edge locations ở khắp nơi trên thế giới. Và mỗi khu vực lại có những chi phí khác nhau.\n![[00 Meta/01 Attachments/Pasted image 20230321214502.png]]\n\n- Chúng ta có thể giảm số lượng các edge locations để **giảm chi phí**.\n- Có 3 price classes:\n\t1. Price Class All: có trên tất cả các regions - hiệu suất tốt nhất\n\t2. Price Class 200: hầu hết các regions, trừ những regions có giá thành cao nhất.\n\t3. Price Class 100: chỉ những regions có chi phí thấp nhất.\n![[00 Meta/01 Attachments/Pasted image 20230321215002.png]]\n![[00 Meta/01 Attachments/Pasted image 20230321215128.png]]\n\n## 🌿 Cache Invalidations\n- Chức năng cho phép xóa dữ liệu trong cache trước khi hết thời gian hết hạn. Tránh tình trạng dữ liệu được cập nhật mới ở S3 những trên các Edge locations vẫn sử dụng phiên bản cũ -\u003e ảnh hưởng đến trải nghiệm của người dùng.\n- Chức năng sẽ giúp các edge locations xóa cache để truy cập lại vào orgin để lấy dữ liệu mới nhất.\n- Chúng ta có thể refresh toàn bộ(all files - dấu hoa thị) hoặc một phần(/images/hoa thị) cache.","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/AWS-DataSync":{"title":"🥦 AWS DataSync","content":"\n## 🌿 What?\n- Dùng để move một số lượng lớn dữ liệu \n\t- Từ mặt đất lên could\n\t- Từ service này -\u003e service khác\n- Có thể đồng bộ dữ liệu:\n\t- Amazon S3(với bất kỳ storage classes nào - bảo gồm cả Glacier)\n\t- Amazon EFS\n\t- [[40123345 posts/42 Code/42.03 AWS/Amazon FSx|Amazon FSx]]\n- Các tasks nhân bản sẽ được đặt lịch hàng giờ/hàng ngày/hang tuần.\n- **File permissions và metadata được giữ nguyên khi đồng bộ.**\n- Một agent có thê sử dụng 10Gps, có thể setup giới hạn cho băng thông.\n\n- Đồng bộ dữ liệu giữa on-premises và cloud:\n![[00 Meta/01 Attachments/Pasted image 20230323233411.png]]\n\n- Đồng bộ giữa các services:\n![[00 Meta/01 Attachments/Pasted image 20230323233636.png]]\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/AWS-Global-Accelerator":{"title":"🥦 AWS Global Accelerator","content":"\n## 🌿 Vấn đề\n![[00 Meta/01 Attachments/Pasted image 20230321222308.png]]\n- Chúng ta có một server app đặt tại một region, và người dùng của app là khắp nơi trên thế giới.\n- Họ đến public internet và điều này sẽ gây ra độ trễ lớn từ nhiều bước truyền dữ liệu.\n- Chúng ta muốn dữ liệu được truyền nhanh nhất có thể thống AWS network với độ trễ tối thiểu.\n\n## 🌿 Unicast IP và Anycast IP\n- **Unicast IP:** mỗi server có một địa chỉ IP riêng\n- **Anycast IP:** tất cả server đều có IP giống nhau và user sẽ được định tuyến đến server gần nhất.\n\n## 🌿 How\n- Tận dụng mạng nội bộ của AWS để định tuyến tới app của bạn.\n- **2 Anycast IP** được tạo cho app của chúng ta.\n- Anycast IP gửi lượng truy cập trực tiếp tới các edge locations và edge locations sẽ gửi lượng truy cập về app của chúng ta.\n\n- Works với **Elastic IP, EC2 Instance, ALB, NLB, public hoặc private**\n- Hiệu suất nhất quán.\n\t- Định tuyến thông minh để có độ trễ thấp nhất và khả năng chuyển đổi dự phòng region nhanh nhất.\n\t- Không ảnh hưởng đến client cache(bởi vì IP không đổi)\n\t- Sử dụng mạng nội bộ của AWS\n- Health Checks\n\t- Có thực hiện health check với app của chúng ta.\n\t- Giúp app của chúng ta được global(có khả năng chuyển đổi dự phòng dưới một phút nếu app bị đánh giá unhealthy)\n\t- Phù hợp cho TH phục hồi sau thảm họa.\n- Security\n\t- Chỉ được cho phép 2 IP nội bộ truy cập.\n\t- Có DDoS nhờ có thằng AWS Shield\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/AWS-Global-infrastructure":{"title":"🥦 AWS Global infrastructure","content":"\n## AWS Cloud Use Cases\n- 🌱 Enterprise IT(chuyển giao công nghệ), Backup \u0026 Storage, Big Data analytics \n- 🌱 Website hosting, Mobile \u0026 Social Apps\n- 🌱 Gaming, ...\n\n## Global infrastructure\n- 🌱 Regions\n- 🌱 Availability Zones(AZs)\n- 🌱 Data Centers\n- 🌱 Edge Locations / Points of Presence\n\n### Regions\n- 🌱 Là khu vực vật lý, một cụm nhiều AZs, tối thiểu là 3, không quá 6.\n- 🌱 Tên: eu-west-3, eu-east-1, ...\n\n\u003e [!question] How to choose an AWS region?\n\u003e \n\u003e Some factors could be impact to your choice:\n\u003e \n\u003e \t1.  Compliance with data governance and legal requirements: xem xét dự án có dữ liệu chỉ được lưu hành trong nước không(ví dụ như dự án phục vụ chính phủ) -\u003e chọn region phù hợp.\n\u003e \n\u003e \t2.  Proximity to customers: Xem xét tập khách hàng chủ yếu truy cập từ đâu -\u003e chọn region gần đó sẽ giảm thiểu được độ trễ.\n\u003e \n\u003e \t3. Available Services within a Region: Không phải tất cả các Regions đều có đầy đủ Services. Xác định rõ services sẽ được sử dụng để lựa chọn Region phù hợp. Xem các available services cho từng khu vực ở [đây 👇](https://aws.amazon.com/about-aws/global-infrastructure/regional-product-services/).\n\u003e \n\u003e \t4. Pricing: Mỗi region có một giá khác nhau, đây cũng là một yếu tố cần cân nhắc khi chọn AWS region.\n\n### Availability Zones(AZs)\n- 🌱 Cách nhau tối thiểu 100km, độc lập, tránh các TH thiên tai.\n- 🌱 Là tập hợp của một hoặc nhiều trung tâm dữ liệu riêng biệt, bao gồm:\n\t- Nguồn điện dự phòng.\n\t- Networking.\n\t- Được liên kết với một AWS Region.\n- 🌱 Tất cả AZs trong một AWS Region đều được kết nối với nhau với điều kiện:\n\t- Băng thông cao\n\t- Độ trễ cực thấp\n\t- Networking\n\n### Edge Locations\n- 🌱 Chứa CloudFront(Amazon's content delivery network - CDN): truyền tải dữ liệu đến end-user với độ trễ thấp nhất có thể.\n\n### AWS Service liên quan đến AWS Solution Architect Exam\n\n![[00 Meta/01 Attachments/Screenshot 2023-02-22 at 13.42.03.png]]\n\nAnd more ...","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/AWS-Integartion":{"title":"🥦 AWS Integartion","content":"\n## 🌿 What?\n- Trong quá trình phát triển, dự án có thể sử dụng nhiều services lưu trữ và chúng ta cần thực hiện đồng bộ cả về trạng thái cũng như dữ liệu.\n- Có 2 parterns để các services giao tiếp với nhau:\n\t- Đồng bộ trực tiếp giữa 2 services\n\t- Bất đồng bộ, đặt ở giữa 2 services một Queue, dữ liệu sẽ đi qua queue rồi mới đến service kia.\n![[00 Meta/01 Attachments/Pasted image 20230325144616.png]]\n\n- Với cách 1 sẽ có vấn đề là 2 services sẽ có liên kết và bị ảnh hưởng lẫn nhau, nếu một bên bị quá tải thì service còn lại cx sẽ bị ngáo ngơ.\n- Vì vậy mà chúng ta cần **tách riêng(decouple)** 2 services. Queue trong AWS có cung cấp 3 services:\n\t- [[40123345 posts/42 Code/42.03 AWS/Amazon SQS - Simple Queue Service|SQS]]: queue model\n\t- SNS: pub/sub model\n\t- Kinesis: real-time streaming model\n- Những services này có thể được scale độc lập với app của chúng ta.\n\n\n\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/AWS-Lambda":{"title":"🥦 AWS Lambda","content":"\n## 🌿 What?\n- Là một dịch vụ tính toán không máy chủ được cung cấp bởi AWS.\n- Cho phép run code mà không cần chúng ta phải cung cấp hay quản lý servers.\n\n## 🌿 Why?\n- **Virtual Functions - không cần quản lý server.**\n- **Giới hạn thời gian excute**\n- **Run on-demand(chạy theo yêu cầu), có yêu cầu gửi đến thì mới chạy. Còn như EC2 là chạy bất kể ngày đêm, chỉ trừ khi chúng tắt**\n- **Tự động mở rộng một cách mượt mà, không giống EC2 phải xóa add/remove servers**\n\n## 🌿 Benefits of AWS Lambda\n- Dễ dàng thanh toán:\n\t- Trả theo từng request và thời gian compute\n\t- Free tier cung cấp 1,000,000 AWS Lambda requests và 400,000 GBs thời gian compute\n- Tích hợp được với toàn bộ các services của AWS.\n- Tích hợp được với nhiều ngôn ngữ lập trình.\n- Dễ dàng giám sát chỉ số thông qua AWS CloudWatch\n- Dễ dàng lấy thêm tài nguyên cho từng funtions(up to 10GB RAM)\n- Khi tăng RAM tự động cũng sẽ phát triển cả CPU và network!\n\n## 🌿 Language support\n- Node\n- Python\n- Java(tương thích Java 8)\n- C#(.NET Core)\n- Golang\n- C# / Powershell\n- Ruby\n- Custom Runtime API\n- Lambda Container Image\n\n## 🌿 Pricing\n- Pay per **calls**:\n\t- 1,000,000 requests đầu tiên sẽ được miễn phí.\n\t- 0.2$ cho mỗi 1,000,000 requests tiếp theo.\n- Pay per **duration**:\n\t- 400,000 GB-seconds thời gian tính toán trong một tháng - free\n\t- = 400,000 seconds ứng với function là 1GB RAM.\n\t- = 3,200,000 seconds ứng với 1288 MB RAM\n- Rất rẻ để chạy AWS Lambda nên nó rất rất phổ biến!\n\n## 🌿 Invoking from RDS \u0026 Aurora\n- Trong thực tế, có những trường hợp chúng ta cần gọi Lambda Funtions từ trong DB instance để thực hiện một tác vụ gì đó (ví dụ như khi người dùng insert một bản ghi vào RDS -\u003e RDS gọi Lambda để Lambda gửi email xác nhận tới người dùng)\n- Cho phép chúng ta thực hiện các data events từ trong một databases.\n- Hỗ trợ với **RDS for PostgreSQL và Aurora MySQL**.\n- **Phải cho phép outbound traffic của DB instance tới Lambda function**.\n- **DB instance cần phải yêu cầu quyền để gọi Lambda funtion**.(Lambda Resource-based Policy \u0026 IAM Policy)\n![[00 Meta/01 Attachments/Pasted image 20230328213427.png]]\n\n- RDS Event Notifications\n\t- Chỉ gửi event về trạng thái hoạt động của database(created, stopped, start,...), sẽ không gửi thông tin về dữ liệu.\n\t- Đăng ký để theo dõi các event của: **DB Instance, DB snapshot, DB Parameter Group, DB Security Group, RDS Proxy, Custom Engine Version.**\n\t- Gần với thời gian thực(chậm nhất là 5p có thông báo)\n\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/AWS-Lambda-ver2":{"title":"🥦 Fill title","content":"\n## 🌿 Limits\n- Giới hạn của Lambda trên **từng region\"\n\t- **Excution:**\n\t\t- Bộ nhớ được cấp phát: 128MB - 10GB\n\t\t- Thời gian excution: 900 senconds(15 phút)\n\t\t- Các biến môi trường: 4KB\n\t\t- Dung lượng lưu trữ trong \"funtion container\"(in/tmp): 512MB - 10GB\n\t\t- Thực thi đồng thời: 1000(có thể gia tăng)\n\t- **Deployment:**\n\t\t- Lambda function deployment size(compresed .zip): 50MB\n\t\t- Size of uncompressed deployment(code + dependencied): 250MB\n\t\t- Có thể sử dụng thư mục /tmp để load các files khác để khởi động.\n\t\t- Các biến môi trường: 4KB\n\n- Trong bài thi nếu người ta hỏi cần 30GB of RAM hay 30 phút excution times hay cần load các files lớn mấy GB thì =\u003e không phải Lambda đâu.\n\n## 🌿 Networking\n- Mặc định Lambda function được launch bên ngoài VPC của chúng ta, nó chạy trong một VPC của AWS. Vì vậy mà nó không thể truy cập được tới các tài nguyên trong VPC của chúng ta(RDS, ElastiCache, internal ELB, ...)\n![[00 Meta/01 Attachments/Pasted image 20230328164920.png]]\n\n- Để giải quyết vấn đề này, chúng ta cần launch Lambda Funtion trong VPC. \n\t- Đầu tiên cần xác định VPC ID, Subnets và Security Groups.\n\t- Lambda sẽ tạo ra một ENI trong subnets, thông qua đó để giao tiếp với các resources nằm trong VPC.\n![[00 Meta/01 Attachments/Pasted image 20230328165321.png]]\n\n- Trường hợp sử dụng phổ biến nhất mà cần Lambda nằm trong VPC đó là connect với RDS Proxy.\n- Thật ra để Lambda connect trực tiếp với RDS thì cũng được, chỉ cần public access là được. Nhưng vấn đề là không được để Lambda connect trực tiếp với RDS vì rất có thể nó sẽ mở thêm quá nhiều các kết nối, vượt quá khả năng chịu tải của RDS.\n- Giải pháp là sử dụng thằng RDS Proxy ở giữa để nó điều hoà nội tiết các kết nối. **Lý do phải cho thằng Lambda này vào VPC bởi vì RDS Proxy không thể set truy cập public được**.\n![[00 Meta/01 Attachments/Pasted image 20230328172457.png]]","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/AWS-Snow-Family":{"title":"🥦 AWS Snow Family","content":"\n## 🌿 What?\n- Là dịch vụ có tính bảo mật cao, cung cấp các thiết bị di chuyển được dùng cho mục đích:\n\t- **Thu thập và xử lý dữ liệu trên các edge**\n\t- **Migrate data trong hoặc ngoài AWS**\n\n- **Data migration:**\n\t- Snowcone\n\t- Snowball Edge\n\t- Snowmobile\n![[00 Meta/01 Attachments/Pasted image 20230322210750.png]]\n\n- **Edge computing:**\n\t- Snowcone\n\t- Snowball Edge\n![[00 Meta/01 Attachments/Pasted image 20230322210759.png]]\n\n## 🌿 Why?\n- Lý do phải sử dụng Snow Family để chuyển dữ liệu vì thời gian truyền tải dữ liệu trên mạng là rất lâu.\n![[00 Meta/01 Attachments/Pasted image 20230322211122.png]]\n\n- Thử thách đưa ra cần giải quyết các vấn đề sau:\n\t- Kết nối bị giới hạn.\n\t- Băng thông cũng bị giới hạn.\n\t- Chi phí di chuyển cao.\n\t- Băng thông bị chia năm sẻ bảy(dùng chung -\u003e không thể sử dụng tối đa được)\n\t- Kết nối ổn định(mạng public thì hay chập chờn)\n- **Snow Family sẽ giải quyết các vấn đề trên bằng cách gửi thiết bị offline đến cho bn(qua bưu điện chẳng hạn), mất tầm khoảng một tuần, bạn nhận được và chỉ việc tải dữ liệu từ thiết bị offline lên AWS thôi.**\n![[00 Meta/01 Attachments/Pasted image 20230322211904.png]]\n\n## 🌿 Types\n\n### 🍃 Snowball Edge\n![[00 Meta/01 Attachments/Pasted image 20230322212938.png]]\n- Giải pháp vật lý vận chuyển dữ liệu: move TBs hoặc PBs dữ liệu vào hoặc ra từ AWS, thay thế cho việc truyền tải dữ liệu qua mạng(và việc trả phí cho mạng)\n- Trả tiền theo từng job\n- Cung cấp block storage và Amazon S3-compatible object storage\n- **Snowball Edge Storage Optimized**\n\t- Dung lượng HDD là 80TB\n- **Snowball Edge Compute Optimized**\n\t- Dung lượng HDD là 42TB\n- Use Cases: migrate cho dữ liệu lớn trên cloud, phục hồi sau thảm họa, ...\n\n### 🍃 AWS Snowcone \u0026 Snowcone SSD\n![[00 Meta/01 Attachments/Pasted image 20230322213729.png]]\n- Nhỏ gọn, có thể thực hiện tính toán ở bất cứ đâu, bền bỉ và bảo mật, phù hợp với những môi trường cần dữ liệu không lớn.\n- Nặng khoảng 2.1kg\n- **Snowcone** - 8 TB HDD\n- **Snowcone SSD** - 14 TB SSD\n- Sử dụng khi Snowball không phù hợp(ví dụ như cần tối ưu cân nặng để mang lên máy bay chẳng hạn)\n- Phải cung cấp sạc hoặc pin để nó hoạt động\n- Có thể gửi về AWS offline hoặc connect nó với internet và sử dụng **AWS DataSync** để gửi dữ liệu.\n\n### 🍃 AWS Snowmobile\n![[00 Meta/01 Attachments/Pasted image 20230322213848.png]]\n\n- Là một cái xe tải chở các thiết bị lưu trữ\n- Dùng để vận chuyển dữ liệu lên đến exabyte(1EB = 1000PB = 1000000TBs)\n- Mỗi một Snowmobile(1 xe tải) có dung lượng là 100PB\n- Bảo mật cao, nhiệt được điều kiểm soát, GPS, video giáo sát 24/7\n- Tối hơn Snowball nếu chúng ta muốn vận chuyển nhiều hơn 10PB dữ liệu.\n\n## 🌿 AWS OpsHub\n- Trước đây để sử dụng các thiết bị Snow Familly, bạn cần phải có 1 CLI tool\n- Giờ chúng ta có thể sử dụng AWS OpsHub(một phần mềm có thể cài vào máy tính) để quản lý các thiết bị Snow Family.\n\n## 🌿 Snowball into Glacier\n- **Không thể chuyển dữ liệu trực tiếp từ Snowball vào Glacier được.**\n- Chúng ta phải sử dụng Amazon S3 để nhận dữ liệu từ Snowball, sau đó kết hợp với S3 lifecycle police để chuyển dữ liệu vào Amazon Glacier.\n![[00 Meta/01 Attachments/Pasted image 20230323213336.png]]\n\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/AWS-Step-Function":{"title":"🥦 AWS Step Function","content":"\n## 🌿 What?\n- Build trực quan workflow cho [[40123345 posts/42 Code/42.03 AWS/AWS Lambda|Lambda]] funtions.\n- Tính năng: sequence, parallel, conditions, timeouts, error handling, ...\n- Có thể tích hợp với các AWS services khác như: EC2, [[40123345 posts/42 Code/42.03 AWS/Amazon ECS - Elastic Container Service|ECS]], On-premises server, [[40123345 posts/42 Code/42.03 AWS/AWS API Gateway|API Gateway]], [[40123345 posts/42 Code/42.03 AWS/Amazon SQS - Simple Queue Service|SQS]] queue, ...\n- Use cases: order fullfillment, data processing, web applications, any workflow. \n![[00 Meta/01 Attachments/Pasted image 20230331144315.png]]\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/AWS-Storage-Compare":{"title":"🥦 AWS Storage Compare","content":"\n![[00 Meta/01 Attachments/Pasted image 20230323234024.png]]\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/AWS-System-Manger":{"title":"🥦 AWS System Manger","content":"\n## 🌿 SSM Session Manager\n- Cho phép start một secure shell trên EC2 Instance hoặc on-premise server thông qua IAM Permissions, không cần thông qua [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/Bastion Host|bastion host]], ssh.\n- Không cần tạo cổng 22 luôn.\n- Hỗ trợ cho Windows, Linux và MacOS.\n- Dùng để send session log data đến [[40123345 posts/42 Code/42.03 AWS/S3|S3]] hoặc [[40123345 posts/42 Code/42.03 AWS/Monitoring/Amazon CloudWatch|CloudWatch]] Logs\n![[00 Meta/01 Attachments/Pasted image 20230427153017.png]]\n\n## 🌿 SSM Run Command\n![[00 Meta/01 Attachments/Pasted image 20230427153727.png]]\n- Thực thi script hoặc chạy một câu lệnh tới các EC2 Instances thông qua SSM Agent.\n- Output sẽ có thể gửi tới [[40123345 posts/42 Code/42.03 AWS/Monitoring/Amazon CloudWatch|CloudWatch Logs]], [[40123345 posts/42 Code/42.03 AWS/S3|S3]], [[40123345 posts/42 Code/42.03 AWS/Amazon SNS - Simple Notification Service|SNS]].\n- Có thể được gọi từ [[40123345 posts/42 Code/42.03 AWS/Monitoring/Amazon EventBridge|EventBridge]].\n\n## 🌿 SSM Patch Manager\n![[00 Meta/01 Attachments/Pasted image 20230427154104.png]]\n- Tự động thực hiện các tiến trình update bản vá cho OS, hệ thống hoặc bảo mật.\n- Hỗ trợ cho các EC2 Instances và on-premise servers.\n- Hỗ trợ hệ điều hành Windows, Linux, MacOS.\n- Patch on-demand hoặc lập lịch bằng **Maintenance Windows**.\n- Scan Instance và gen ra báo cáo về những bản vá cần thiết(phát hiện thiếu bản vá nào).\n\n## 🌿 Maintenance Windows\n![[00 Meta/01 Attachments/Pasted image 20230427154512.png]]\n- Giúp lập lịch để thực hiện các hành động theo maintain theo kế hoạch.\n- Nó bao gồm:\n\t- Lịch.\n\t- DIễn ra trong bao lâu\n\t- Các Instances được chỉ định maintain\n\t- Các tasks được chỉ định thực thi\n\n## 🌿 Automation\n![[00 Meta/01 Attachments/Pasted image 20230427154703.png]]\n- Giúp thực hiện một số các actions đơn giản và thường được sử dụng trong maintain và deploy.\n\t- vd như restart instance, create an AMI, [[40123345 posts/42 Code/42.03 AWS/EBS Volume - Elastic Block Store|EBS]] snapshot.\n- **Automation Runbook** - Là nơi define các actions sẽ thực thi với các EC2 Instances hoặc AWS resources.\n- Có thể trigger tới SSM Automation bằng các cách sau:\n\t- Thủ công kích hoạt thông qua AWS Console, SDK, CLI.\n\t- [[40123345 posts/42 Code/42.03 AWS/Monitoring/Amazon EventBridge|EventBridge]]\n\t- Maintenance Windows\n\t- [[40123345 posts/42 Code/42.03 AWS/Monitoring/AWS Config|AWS Config]]","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/AWS-Transfer-Family":{"title":"🥦 AWS Transfer Family","content":"\n## 🌿 What?\n- Là một dịch vụ toàn quyền quản lý, thực hiện chuyển dữ liệu vào hoặc ra khỏi S3 hoặc EFS bằng giao thức FTP.\n- Hỗ trợ các giao thức:\n\t- **AWS Transfer for FTP(File Transfer Protocol)**\n\t- **AWS Transfer for FTPS(File Transfer Protocol over SSL**\n\t- **AWS Transfer for SFTP(Secure File Transfer Protocol**\n- Quản lý hạ tầng, scalable, reliable, HA(multi-AZ)\n- Trả tiền theo endpoint thuê theo giờ + số Gb chuyển dữ liệu.\n- Lưu trữ và quản lý credential của user trong service.\n- Tích hợp được với các hệ thống xác thực có sẵn(LDAP, Okta, ...)\n- Usage: chia sẻ files, public datasets, CRM, ERP, ...\n\n![[00 Meta/01 Attachments/Pasted image 20230323231409.png]]\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Amazon-Cognito":{"title":"🥦 Amazon Cognito","content":"\n## 🌿 What?\n- Là dịch vụ cấp phát cho người dùng định danh để có thể giao tiếp với các web hoặc mobile apps.\n- **Cognito User Pools:**\n\t- Đăng nhập cho người dùng app.\n\t- Tích hợp được với [[40123345 posts/42 Code/42.03 AWS/AWS API Gateway|API Gateway]] \u0026 Application Load Balancer.\n- **Cognito Identity Pools:**\n\t- Cung cấp AWS credentials để user có thể truy cập trực tiếp vào các AWS Services.\n\t- Tích hợp với Cognito User Pools như một nơi cung cấp định danh.\n- **Cognito vs IAM:** \n\t- Hàng trăm users.\n\t- Sử dụng cho cả mobile users.\n\t- Xác thực với SAML.\n## 🌿 Cognito User Pools(CUP)\n- Tính năng:\n\t- Tạo ra một database không máy chủ lưu dữ liệu người dùng cho web hoặc mobile apps.\n\t- Simple login\n\t- Password reset\n\t- Verify email/phone number\n\t- MFA\n\t- Login với bên thứ3 - Facebook, Github, SAML, ...\n\n- Mô hình tích hợp với [[40123345 posts/42 Code/42.03 AWS/AWS API Gateway|API Gateway]] và ALB:\n![[00 Meta/01 Attachments/Pasted image 20230331150227.png]]\n\n\n## 🌿 Cognito Identity Pools\n- Diagram:\n![[00 Meta/01 Attachments/Screenshot 2023-03-31 at 15.08.15.png]]\n\n## 🌿 Row level Security in DynamoDB\n- Có thể thông qua Cognito để chỉ định user được đọc những row nào trong [[40123345 posts/42 Code/42.03 AWS/Amazon DynamoDB|DynamoDB]].\n![[00 Meta/01 Attachments/Pasted image 20230331151223.png]]","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Amazon-ECR":{"title":"🥦 Amazon ECR - Elastic Container Registry","content":"\n## 🌿 What?\n- Là nơi lưu trữ và quản lý các [[50 til/51 Code/51.09 Docker/Docker|Docker]] images trên AWS.\n- Có thể lưu trữ **private** hoặc **public(trên Amazon ECR Public Gallery)**.\n- Tương thích cao với ECS, được [[40123345 posts/42 Code/42.03 AWS/S3|S3]] hỗ trợ.\n- Quản lý truy cập thông qua IAM\n- Hỗ trợ scanning lỗ hổng bảo mật (vulnerability scanning), quản lý phiên bản, tags, lifecycle, ...\n\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Amazon-EKS":{"title":"🥦 Amazon EKS - Elastic Kubernetes Service","content":"\n## 🌿 What?\n- Là một cách để launch containers được quản lý bởi các **Kubernetes clusters trên AWS.**\n- Kubernetes là một hệ thống open-source hỗ trợ việc tự động deployment, scaling và quản lý các app chạy trên containers.\n- Cái này là một lựa chọn khác, bên cạnh ECS, cùng chung mục đích những khác API.\n- EKS hỗ trợ **EC2** nếu chúng ta muốn triển khai các worker nodes hoặc **Fargate** nếu chúng ta muốn triển khai các serverless containers.\n- **Use Cases:** Nếu công ty, tổ chức đã áp dụng Kubernetes vào hệ thống, thì sài cái này thôi.\n- **Kubernetes là dịch vụ riêng, không thuộc bất kỳ cloud nào, vì vậy chúng ta có thể sử dụng Kubernetes ở các Cloud khác nữa. Có thể chọn EKS để phòng cho sau này muốn chuyển qua sử dụng một Cloud khác.**\n## 🌿 Node Types\n- **Managed Node Groups**\n\t- Tạo và quản lý Nodes(EC2 Instances) cho chúng ta.\n\t- Nodes là một phần của ASG đươc quản lý bởi AWS.\n\t- Hỗ trợ On-demand và Spot Instances\n- **Self-Managed Nodes**\n\t- Chúng ta tự tạo các nodes và đăng ký chúng với EKS clusters và được quản lý bởi một ASG.\n\t- Hỗ trợ On-demand và Spot Instances\n- **AWS Fargate**\n\t- Không yêu cầu bảo trì, không cần quản lý nodes.\n\n## 🌿 Data Volume\n- Cần chỉ định một **StorageClass** rõ ràng cho EKS cluster.\n- Hỗ trợ với:\n\t- Amazon EBS\n\t- Amazon EFS(dùng được với Fargate)\n\t- Amazon FSx for Lustre\n\t- Amazon FSx for NetApp ONTAP\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Amazon-Elastic-Transcoder":{"title":"🥦 Amazon Elastic Transcoder","content":"\n## 🌿 What?\n- Là dịch vụ convert các media files trong S3 thành định dạng phù hợp với bên nhận files(phone, macbook, ...)\n- Lợi ích:\n\t- Dễ dàng sử dụng\n\t- Có khả năng mở rộng tốt - không sợ file to\n\t- Giá cả hợp lý, dùng đến đâu trả tiền đến đấy\n\t- Chỉ việc dùng thôi các vấn đề còn lại AWS lo.\n![[00 Meta/01 Attachments/Pasted image 20230427160310.png]]","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Amazon-FSx":{"title":"🥦 Amazon FSx","content":"\n## 🌿 Overview\n- Launch 3rd party - một file system có hiệu suất cao trên AWS.\n- Dịch vụ toàn quyền quản lý.\n- 4 loại phổ biến:\n\t- **FSx for Lustre**\n\t- **FSx for NetApp ONTAP**\n\t- **FSx Windows File Server**\n\t- **FSx for OpenZFS**\n\n## 🌿 FSx for Windows File Server\n- Quản lý hoàn toàn hệ thống file Windows.\n- Hỗ trợ giao thức SMB và Windows NTFS.\n- Tich hợp Microsoft Active Directory, ACLs, user quotas.\n- Có thể mounted vào trong Linux EC2 Instances.\n- Hỗ trợ **Microsoft's Distributed File System (DFS) Namespaces**(Nhóm các files trên nhiều FS).\n- Storage options:\n\t- **SSD** - độ trễ thấp, tính toán nhanh(databases, media processing, data analytics, ...).\n\t- **HDD** - phù hợp để lưu trữ dữ liệu lớn, ít được truy cập hơn.\n- Có thể truy cập từ những hạ tầng có sẵn(VPN chẳng hạn).\n- Có thể config multi-AZ.\n- Dữ liệu được backup hàng ngày vào S3.\n\n## 🌿 FSx for Lustre\n- Là một kiểu hệ thống files phân phối song song, dùng cho những trường hợp tính toán phức tạp\n- Cái tên Lustre có nguồn gốc từ 'Linux' và 'cluster'\n- Dùng cho ML, **High Performance Computing (HPC)**\n- Storage options:\n\t- **SSD**\n\t- **HDD**\n- Có khả năng tích hợp liền mạch với S3\n\t- Có thể đọc S3 như một file system(thông qua FSx)\n\t- Có thể ghi ngược vào S3( thông qua FSx)\n- Có thể sử dụng từ những hệ thống sẵn có của mình(VPN chẳng hạn)\n\n### 🍃 Deployment Options\n- **Scratch File System**\n\t- Lưu trữ tạm thời\n\t- Dữ liệu không được nhân bản\n\t- Nhanh gấp 6 lần option kia\n\t- Usage: sử dụng với những tiến trình ngắn hạn, tối ưu giá tiền\n- **Persistent File System**\n\t- Lưu trữ lâu\n\t- Dữ liệu được nhân bản trong AZ\n\t- Thay thế file lỗi trong vài phút\n\t- Usage: sử dụng với những tiến trình dài hạn, với những dữ liệu nhạy cảm\n\n## 🌿 FSx for NetApp ONTAP\n![[00 Meta/01 Attachments/Pasted image 20230323221704.png]]\n- Quản lý NetApp ONTAP trên AWS\n- **Tương thích với các giao thức NFS, SMB, iSCSI**.\n- **Có thể clone dữ liệu tại bất kỳ thời điểm nào.**\n\n## 🌿 FSx for OpenZFS\n![[00 Meta/01 Attachments/Pasted image 20230323221840.png]]\n- Quản lý OpenZFS trên AWS\n- **Có thể clone dữ liệu tại bất kỳ thời điểm nào.**","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Amazon-Kinesis":{"title":"🥦 Amazon Kinesis","content":"\n## 🌿 What?\n- Là dịch vụ giúp chúng ta đơn giản hóa việc **thu thập, xử lý cũng như là phân tích** luồng dữ liệu một cách realtime.\n\n- Có 4 loại:\n\t- **Kinesis Data Streams:** capture, xử lý và lưu trữ data streams.\n\t- **Kinesis Data Firehose:** load data streams vào các dịch vụ lưu trữ của AWS.\n\t- **Kinesis Data Analytics:** phân tích data streams cùng với SQL hoặc Apache Flick\n\t- **Kinesis Video Streams:** capture, xử lý và lưu trữ video streams.\n![[00 Meta/01 Attachments/Pasted image 20230325212843.png]]\n\n## 🌿  Kinesis Data Streams\n![[00 Meta/01 Attachments/Pasted image 20230325213658.png]]\n- Giữ lại dữ liệu từ 1 -\u003e 365 ngày.\n- Có khả năng xử lý lại dữ liệu.\n- Một khi dữ liệu được inserted vào Kinesis thì sẽ không thể xóa.\n- Data được chia sẻ chung một partition thì sẽ vào chung một shard.\n- Producers: AWS SDK, Kinesis Producer(KPL)\n- Consumers:\n\t- KCL - Kinesis Client Library, AWS SDK\n\t- AWS Lambda, Kinesis Data Firehose, Kinesis Data Analytics.\n\n### 🍃 Capacity modes\n- **Provisioned mode**\n\t- Chúng ta được chọn số lượng shards, scale thủ công hoặc sử dụng API\n\t- Mỗi shard là 1MB/s in (1000 records mỗi giây)\n\t- Mỗi shard là 2MB/s out.\n\t- Thanh toán cho từng shard theo giờ.\n- **On-demand mode**\n\t- Không cần khả năng cung cấp hoặc quản lý.\n\t- Mặc định 4MB/s\n\t- Tự động scale dựa vào thông lượng được quan sát trong 30 ngày gần nhất.\n\t- Trả tiền theo giờ từng stream, dữ liệu in/out per GB\n\n- Nếu không có yêu cầu gì đặc biệt thì chọn **on-demand mode** dùng cho thuận tiện.\n\n## 🌿 Kinesis Data Firehose\n![[00 Meta/01 Attachments/Pasted image 20230325215757.png]]\n- Dịch vụ toàn quyền sử lý, khong admin, tự động scale, serverless, giúp chuyển dữ liệu lớn vào storage tier.\n- Trả tiền theo dữ liệu được truyền đến Firehose.\n- **Gần real time.**\n- Không lưu trữ dữ liệu.\n- Không hỗ trợ khả năng replay.\n\n## 🌿 Ordering data\n- Giả sử app của chúng ta cần thực hiện check vị trí của các xe tải. Số lượng xe tải ngày càng tăng nếu tất cả dữ liệu được đổ vào các shards khác nhau trên Kinesis -\u003e Mất dữ liệu hoặc mất thời gian để truy vấn dữ liệu.\n- Giải pháp: Trong Kinesis, muốn dữ liệu được sắp xếp có thứ tự, sử dụng **partition key**. Vd keys là trunk_1, trunk_2, ...\n- Các dữ liệu cùng key sẽ được stream trong cùng shard -\u003e dễ dàng tìm kiếm hơn, tránh bị lack mất dữ liệu\n![[00 Meta/01 Attachments/Pasted image 20230326081953.png]]\n\n## 🌿 Kinesis vs SQS ordering\n- Giả sử chúng ta có 100 trucks, 5 shards và 1 SQS FIFO\n- Với Kinesis Data Streams:\n\t- Trung bình mỗi shard sẽ chứa dữ liệu của 20 trucks\n\t- Các trucks sẽ được sắp xếp trong mỗi shard.\n\t- Tối đa có thể có 5 consumers chạy đồng thời.\n\t- Có thể nhận được dữ liệu lên tới 5MB/s\n- SQS FIFO:\n\t- Chỉ có một Queue\n\t- Có 100 Group ID\n\t- Tối đa có thể có 100 consumers\n\t- Có thể nhận được 300 messages mỗi giây(hoặc 3000 nếu kết hợp sử dụng batching)\n\n\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Amazon-OpenSearch-Service":{"title":"🥦 Amazon OpenSearch Service","content":"\n## 🌿 What?\n- Được kế thừa từ Amazon ElasticSearch, cung cấp khả năng tìm kiếm dữ liệu mạnh mẽ và linh hoạt trên AWS.\n- Chúng ta có thể **tìm kiếm bất kỳ field nào thậm chí là cả tìm kiếm theo partially.**\n- Thường được sử dụng như một phần bổ sung cho các database khác.\n- OpenSearch yêu cầu một cụm các instances(không phải serverless).\n- Không hỗ trợ sẵn SQL(có thể enabled thông qua plugin)\n- Có thể tìm kiếm ở những services khác nhau như là Kinesis Data Firehose, AWS IoT và CloudWatch Logs.\n- Bảo mật thông qua Cognito \u0026 IAM, mã hóa KMS, TLS.\n\n- Có khả năng:\n\t- Xử lý ngôn ngữ tự nhiên\n\t- Tìm kiếm dữ liệu phân tán\n\n## 🌿 Cấu trúc\n- Cấu trúc thường được sử dụng với DynamoDB:\n![[00 Meta/01 Attachments/Pasted image 20230405224454.png]]\n\n- Cấu trúc thường được sử dụng với CloudWatch:\n![[00 Meta/01 Attachments/Pasted image 20230405224608.png]]\n\n- Cấu trúc thường được sử dụng với Kinesis Data Streams \u0026 Kinesis Data Firehose:\n![[00 Meta/01 Attachments/Pasted image 20230405224730.png]]\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Amazon-Pinpoint":{"title":"🥦 Amazon Pinpoint","content":"\n## 🌿 What?\n- Là dịch vụ cải tiến hơn của [[40123345 posts/42 Code/42.03 AWS/Amazon SES - Simple Email Service|SES]], nó có thể mở rộng ở cả 2 chiều(inbound và outbound), hỗ trợ cho dịch vụ marketing communication.\n- Hỗ trợ email, SMS, voice, push và in-app messaging.\n- Mở rộng tới hàng tỷ tin nhắn một ngày.\n- Use case:\n\t- Chạy chiến dịch marketing, có lượng traffic lớn\n\t- Bulk transaction, kiểu như mấy hôm shopee sale\n![[00 Meta/01 Attachments/Pasted image 20230427112807.png]]\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Amazon-QuickSight":{"title":"🥦 Amazon QuickSight","content":"\n## 🌿 What?\n- **Serverless ML, dịch vụ cung cấp khả năng trực quan hóa dữ liệu từ nhiều nguồn cho người dùng.**\n- Nhanh, có thể tự động scale, có thể nhúng, với per-session pricing.\n- Use cases:\n\t- Phân tích nghiệp vụ\n\t- Xây dựng trực quan\n\t- Giúp trực quan, hiểu hơn về dữ liệu.\n- Có thể kết hợp với nhiều services khác như RDS, Aurora, Athena, Redshift, S3, ...\n- **In-memory tính toán sử dụng SPICE engine** nếu dữ liệu được import vào QuickSight.\n- Phiên bản doanh nghiệp: Có thể setup bảo mật cho từng cột **Column-level security(CLS)**.\n\n- **Có thể chia sẻ những phân tích hoặc dashboard với Users hoặc Groups.** \n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Amazon-Route-53":{"title":"🥦 Amazon Route 53","content":"\n## 🌿 What?\n- Dịch vụ cung cấp tính khả dụng cao, khả năng mở rộng cũng như quản lý DNS.\n- Route 53 là một Domain Registrar.\n- Có khả năng check the health của các resources\n- Service duy nhất của AWS cung cấp 100% availability SLA.\n- Tại sao lại là số 53? 53 là cổng của DNS.\n\n## 🌿 Records\n- Định nghĩa cách mà bạn muốn điều hướng traffic cho một domain\n- Một record chứa:\n\t- **Domain/SubDomain name** - vd: example.com\n\t- **Record Type** - vd: A or AAAA\n\t- **Value** - 12.34.56.78\n\t- **Routing Policy** - Route 53 responds như thế nào\n\t- **TTL** - thời gian record được cached lại ở DNS Resolvers\n- Route 53 hỗ trợ những kiểu DNS records sau:\n\t- must know: A/ AAAA / CNAME / NS\n\t- advance: CAA / DS / MX / NAPTR / PTR / SOA / TXT / SPF / SRV\n\n### 🍃 Types\n- A - maps một hostname với IpV4\n- AAAA - maps một hostname với IpV6\n- CNAME - maps một hostname với một hostname khác.\n\t- Mục tiêu phải là một record A hoặc AAAA\n\t- Không thể tạo một CNAM record là node đầu tiên của DNS, vd không thể đặt là example.com mà phải đặt là www.example.com\n- NS - Name Servers cho Hosted Zone\n\t- Kiểm soát lượng truy cập được định tuyến đến một domain.\n\n## 🌿 Hosted Zones\n- Là khu vực chứa thông tin định tuyến lượng truy cập tới một domain\n- **Public Hosted Zones** - chứa những records được chỉ định để định tuyến truy cập trên internet\n- **Private Hosted Zones** - chứa những records được chỉ định để định tuyến truy cập trong một hoặc nhiều VPCs\n- Phải trả 0.5 $ một tháng cho tính năng này.\n\n## 🌿 Records TTL(Time to Live)\n- Thời gian chỉ định để clien cache lại thông tin IP của DNS. Nếu TTL chưa hết hạn, khi client gọi lại Domain, sẽ truy cập vào địa chỉ IP đã truy cập lần đầu, kể cả chúng ta có thực hiện thay đổi IP cho DNS. Chỉ đến khi hết hạn TTL, thông tin IP mới mới được refresh.\n- High TTL, 24h\n\t- Ít traffic tới Route 53\n\t- Có thể hết hạn records.\n- Low TTL, 60s\n\t- Nhiều traffic tới Route 53(thêm $)\n\t- Hết hạn records trong thời gian ngắn hơn.\n\t- Dễ dàng thay đổi records.\n- **Ngoại trừ Alias records, TTL là thông tin bắt buộc của mỗi một DNS record.**\n\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Amazon-SES-Simple-Email-Service":{"title":"🥦 Amazon SES - Simple Email Service","content":"\n## 🌿 What?\n- Là dịch vụ do AWS quản lý, hỗ trợ gửi mail với số lượng lớn và an toàn.  \n- Hỗ trợ thống kê:\n\t- số lượng mail chuyển đi\n\t- kết quả của các feedback\n\t- bao nhiêu email đã được xem, ...\n- Flexible IP deployment.\n- Use case:\n\t- marketing\n\t- bulk email communications\n![[00 Meta/01 Attachments/Pasted image 20230427112025.png]]","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Amazon-SNS-Simple-Notification-Service":{"title":"🥦 Amazon SNS - Simple Notification Service","content":"\n## 🌿 What?\n![[00 Meta/01 Attachments/Pasted image 20230325164033.png]]\n- Giống với [[40123345 posts/42 Code/42.03 AWS/Amazon SQS - Simple Queue Service|SQS]], nhưng cái này theo mô hình publish/subcriber. \n- Phù hợp khi ứng dụng có mô hình một service gửi message tới một số services được chỉ định.\n\n- Mỗi topic có thể set được 12,5000,000 subs.\n- Giới hạn 100,000 topics.\n- Các subcribers có thể nhận notification từ SNS:\n![[00 Meta/01 Attachments/Pasted image 20230325164534.png]]\n\n- Nhiều AWS Services có thể gửi dữ liệu trực tiếp đến SNS:\n![[00 Meta/01 Attachments/Pasted image 20230325164723.png]]\n\n## 🌿 Security\n- Same [[40123345 posts/42 Code/42.03 AWS/Amazon SQS - Simple Queue Service|SQS]] security\n\n## 🌿 SNS + SQS: Fan Out Pattern\n![[00 Meta/01 Attachments/Pasted image 20230325205522.png]]\n- Ý tưởng là muốn một message được gửi tới nhiều Queues.\n- Gửi noti vào SNS, setup các subcribers là các Queues.\n- Hoàn toàn tách biệt, không bị mất dữ liệu.\n- Có thể thêm nhiêu Queues hơn về sau.\n- Phải setup access policy cho phép SNS ghi vào SQS.\n- Cross-Region Delivery: họat động với cả những Queues khác region.\n\n## 🌿 FIFO Topic\n- Giống với bên [[40123345 posts/42 Code/42.03 AWS/Amazon SQS - Simple Queue Service|SQS]].\n- Nếu set Topic là FIFO thì chỉ có thể nhận SQS FIFO queues là subcribers.\n\n## 🌿 Message Filtering\n![[00 Meta/01 Attachments/Pasted image 20230325211312.png]]\n- Như một lớp filter theo điều kiện để các Queue nhận message từ SNS.\n- Nếu không có filter, Queue sẽ nhận được tất cả các messages từ SNS.\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Amazon-SQS-Simple-Queue-Service":{"title":"🥦 Amazon SQS - Simple Queue Service","content":"\n## 🌿 What?\n![[00 Meta/01 Attachments/Pasted image 20230325150553.png]]\n- Là dịch vụ lâu đời nhất của AWS - hơn 10 năm.\n- Dịch vụ lưu trữ messages, **sử dụng để tách biệt các ứng dụng** của chúng ta.\n- Attrubutes:\n\t- Không giới hạn thông lượng, không giới hạn số lượng messages trong queue.\n\t- Mặc định tin nhắn sẽ được giữ lại trong 4 ngày, lâu nhất là 14 ngày.\n\t- Độ trễ thấp\n\t- Mỗi message chỉ được gửi tối đa 265Kb.\n- Có thể sẽ nhận được tin nhắn bị duplicate\n- Có thể có order messages.\n\n## 🌿 Producing Messages\n![[00 Meta/01 Attachments/Pasted image 20230325150528.png]]\n- Gửi messages đến Queue(use SendMessage API)\n- Messages tồn tại trong Queue đến khi Consumer xóa\n- Mặc định giữ lại 4 ngày, nhiều nhất là 14 ngày.\n\n## 🌿 Consuming Messages\n![[00 Meta/01 Attachments/Pasted image 20230325150626.png]]\n- Nhận Messages từ Queue(nhận được 10 messages một lần)\n- Consumers có thể là EC2 Instance, AWS Lambda, hay server on-premises, ...\n- Khi nhận message sẽ tiếp tục xử lý(ở code của chúng ta)\n- Sau khi nhận xong thì sẽ gọi API xóa message trong Queue(DeleteMessage API)\n\n## 🌿 Kiến trúc phổ biến\n![[00 Meta/01 Attachments/Pasted image 20230325151657.png]]\n- Hiểu đơn giản SQS là một nơi lưu trữ các job để xử lý bất đồng bộ cho hệ thống của chúng ta.\n- Ví dụ, hệ thống cần chỉnh sửa video, nhưng tác vụ chỉnh sửa sẽ mất thời gian ở phía backend, để tăng trải nghiệm của người dùng, chúng ta chuyển tác vụ chỉnh sửa vào Queue để chạy bất đồng bộ, người dùng có thể tiếp tục thao tác mà không cần phải ngồi đợi chỉnh sửa video xong.\n- Hoàn toàn tách biệt các tầng của hệ thống\n\t- Tầng Front-End\n\t- Tầng Back-End\n\t- Tầng Database\n- Kết hợp với Auto-Scaling để tự động mở rộng đáp ứng với nhu cầu sử dụng của Queue.\n\n## 🌿 Security\n- **Encryption:**\n\t- In-flight encryption using - HTTPS API\n\t- Mã hóa phần còn lại với KMS Keys\n\t- Client-side encryption nếu clients muốn tự thực hiện mã hóa/giải mã.\n- **Access Controls:** IAM policies\n- **SQS Access Policies:**(giống cái S3 bucket polices)\n\t- Hữu ích khi muốn truy cập chéo account\n\t- Hữu ích khi cho phép những services khác(SNS, S3, ...) được quyền ghi.\n\n## 🌿 Message visibility timeout\n![[00 Meta/01 Attachments/Pasted image 20230325155057.png]]\n- Là khoảng thời gian cooldown sau khi có một consumer nhận được message, các consumers khác không thể nhận được message. Cái này sẽ tránh việc 2 consumers nhận 1 message và thực hiện logic.\n- Mặc định, timeout là 30s\n- Hết thời gian timeout, các consumers khác sẽ có thể nhận được messages, nếu trong thời gian đó nó chưa được xóa.\n- Nhưng trên thực tế, có thể consumer sẽ cần nhiều hơn 30s để thực hiện logic với message. Để cần thêm thời gian timeout, consumer có thể call **ChangeMessageVisibility API**.\n- Lưu ý không nên set timeout quá dài hoặc ngắn vì:\n\t- Nếu thời gian timeout quá dài(hàng giờ liền), consumer nhận message bị crashes vì một lý do nào đó, hệ thống sẽ phải đợi hàng để message visible trở lại để một consumer khác có thể nhận và thực hiện logic với nó.\n\t- Nếu thời gian timeout quá ngắn, consumer chưa xử lý xong mà đã hiển thị để một consumer khác nhận được message, hệ thống có thể sẽ thực hiện logic 2 lần trên cùng một message.\n\n## 🌿 Long Polling\n- Khi một consumer requests message từ Queue, nó có thể lựa chọn là đợi (chứ không ngắt poll luôn) khi Queue đang trống.\n- LongPolling giảm số lượng API gọi đến SQS, tăng hiệu quả và giảm độ trễ(nhận được message ngay khi nó được đẩy vào Queue).\n- Thời gian đợi có thể được set từ 1s -\u003e 20s.\n- Long Polling sẽ được khuyến khích sử dụng hơn Short Polling\n- Long polling có thể được enabled trong Queue hoặc có thể sử dụng API **WatiTimeSeconds** để set thời gian đợi.\n\n## 🌿 FIFO Queue\n![[00 Meta/01 Attachments/Pasted image 20230325161601.png]]\n- FIFO =  FIrst In First Out\n- Giới hạn thông lượng: 300 message/s\n- Tránh việc gửi duplicate\n- Các messages được thực thi theo đúng thứ tự.\n- Chỉ có nhận một consumer.\n\n### 🍃 Ordering data\n- Vì chỉ nhận một consumer -\u003e hiệu suất kém -\u003e muốn scale lên nhiều consumers -\u003e sử dụng Group ID\n- Các messages vẫn được gửi theo thứ tự FIFO, những mỗi message sẽ được gắn với một group. Từ đó có thể tạo ra nhiều consumers, mỗi consumer sẽ poll messages ứng với mỗi group.\n![[00 Meta/01 Attachments/Pasted image 20230326082442.png]]\n\n## 🌿 Integrate with Auto Scaling Group\n![[00 Meta/01 Attachments/Pasted image 20230325162158.png]]\n- Sử dụng cái CloudWach Metric để theo dõi số lượng messages trong Queue\n- Nếu nhiều hơn 100 chẳng hạn(server không xử lý kịp), cái CloudWatch Alarm sẽ báo cho [[40123345 posts/42 Code/42.03 AWS/ASG - Auto Scaling Group|ASG]] để thực hiện mở rộng, đáp ứng khả năng xử lý messages trong Queue, tương tự khi scale down.\n\n### 🌿 Kiến trúc sử dụng Queue làm buffer khi ghi dữ liệu lớn vào database\n![[00 Meta/01 Attachments/Pasted image 20230325162927.png]]\n\n- Ví dụ chúng ta có một trang thương mại điện tử và vào đợt sale, mọi người mua hàng rất rất nhiều. Nếu để server ghi trực tiếp dữ liệu vào databases, khả năng cao database sẽ bị quá tải và sẽ bị mất một số giao dịch của người dùng.\n- Giải pháp cho vấn đề này là sử dụng SQS, như vậy thì tất cả giao dịch của người dùng sẽ nằm trong Queue, một server khác sẽ có trách nhiệm nhận lại messages và thực hiện ghi dữ liệu dần dần vào databases.\n\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Big-Data-Ingestion-Pipeline":{"title":"🥦 Big Data Ingestion Pipeline","content":"\n## 🌿 Requirements\n- [[40123345 posts/42 Code/42.03 AWS/Some Solution Architectures/Serverless|Serverless]]\n- Muốn thu thập dữ liệu real-time\n- Muốn chuyển đổi dữ liệu\n- Muốn truy vấn dữ liệu đã qua chuyển đổi bằng SQL\n- Các báo cáo được tạo ra từ truy vấn cho [[40123345 posts/42 Code/42.03 AWS/S3|S3]].\n- Muốn load dữ liệu vào một warehouse và tạo dashboard.\n\n## 🌿 Architecture\n![[00 Meta/01 Attachments/Pasted image 20230405235737.png]]\n- [[40123345 posts/42 Code/42.03 AWS/Some Solution Architectures/Serverless|Serverless]]\n\t- [[40123345 posts/42 Code/42.03 AWS/Amazon Kinesis|Kinesis]] Data Streams: real-time\n\t- [[40123345 posts/42 Code/42.03 AWS/Amazon Kinesis|Kinesis]] Data Firehose: giúp delivery dữ liệu gần real-time(1 phút)\n\t- [[40123345 posts/42 Code/42.03 AWS/S3|S3]]: lưu trữ\n\t- [[40123345 posts/42 Code/42.03 AWS/AWS Lambda|Lambda]]: chuyển đổi dữ liệu\n\t- [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon Athena|Athena]]: truy vấn dữ liệu đã qua chuyển đổi\n\t- [[40123345 posts/42 Code/42.03 AWS/Redshift|Redshift]] -\u003e [[40123345 posts/42 Code/42.03 AWS/Amazon QuickSight|QuickSight]]: tạo báo cáo, load vào warehouse và tạo dashborad.\n\n\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/CNAME-and-Alias":{"title":"🥦 CNAME and Alias","content":"\n## 🌿 What?\n- Cả 2 đều là loại bản ghi DNS của Route53.\n- CNAME:\n\t- Ánh xạ một tên miền cho một tên miền khác.\n\t- Chỉ dùng được cho **NON-ROOT DOMAIN**.\n- Alias:\n\t- Ánh xạ một tên miền tới các AWS Resource(ELB, CloudFront, ...)\n\t- Dùng được cho cả **ROOT DOMAIN** và **NON ROOT DOMAIN**.\n\t- Không phải trả phí.\n\t- Có sẵn health check.\n\n## 🌿 Alias Records\n- Ánh xạ domain tới một AWS resource.\n- Một extension\n- Tự động nhận ra các thay đổi đối với địa chỉ IP của các resources.\n- Không như CNAME, có thể sử dụng với top node của DNS namespace(Zone Apex)\n- Luôn luôn là kiểu A/ AAAA đối với các AWS Resources\n- Không thể thiết lập TTL, nó sẽ được Route53 tự động set.\n\n## 🌿 Targets\n![[00 Meta/01 Attachments/Pasted image 20230311160422.png]]\n- **Không thể set Alias Record cho một EC2 DNS**\n\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Cost-Explorer":{"title":"🥦 Cost Explorer","content":"\n## 🌿 What?\n- Là dịch vụ giúp chúng ta quản lý các vấn đề về chi phí cũng như mức độ sử dụng một cách trực quan hoá, dễ tiếp cận.\n- Nó giúp chúng ta tạo báo cáo tuỳ chỉnh theo chi phí và mức độ sử dụng đã qua phân tích(theo tháng hoặc theo giờ).\n- Ngoài ra nó còn giúp chúng ta phân tích dữ liệu ở high level: tổng chi phí cũng như mức độ sử dụng trên nhiều accounts.\n- Từ đó giúp chúng ta chọn được Savings Plan để có chi phí sử dụng tốt hơn.\n**- Dự đoán mức độ sử dụng cho 12 tháng tới theo những dữ liệu đã có từ trước.**\n\n- Theo tháng:\n![[00 Meta/01 Attachments/Pasted image 20230427155638.png]]\n\n- Theo giờ:\n![[00 Meta/01 Attachments/Pasted image 20230427155707.png]]\n\n - Savings Plan - từ mức độ sử dụng lựa chọn plan phù hợp:\n ![[00 Meta/01 Attachments/Pasted image 20230427155805.png]]\n\n- Forecast:\n![[00 Meta/01 Attachments/Pasted image 20230427155855.png]]","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Customization-At-The-Edge":{"title":"🥦 Customization At The Edge","content":"\n## 🌿 What?\n- Trong thực tế, có những lúc app của chúng ta cần chạy một số form logic trên các edges. Để thực hiện việc này chúng ta có thể sử dụng **Edge Function.**\n- **Edge Function:**\n\t- Thực thi một đoạn code của chúng ta trên các bản phân phối của CloudFront.\n\t- Các đoạn code được chạy ở gần với users, đạt được độ trễ tối đa.\n- CloudFront cung cấp 2 loại: **CloudFront Functions \u0026 Lambda@Edge**\n- Chúng ta không cần tạo, quản lý hay triển khai bất kỳ server, **serverless.**\n\n- Use Cases: khi muốn custom lại CDN content.\n- Chỉ phải trả tiền khi sử dụng, còn để đấy không động vào thì không mất phí.\n\n## 🌿 CloudFront Functions\n- Là các lightweight functions được viết bởi Javascript.\n- Có khả năng mở rộng cao, độ trễ thấp\n- Thời gian khởi động cực nhanh, tốc độ xử lý requests là cả **triệu requests/giây.**\n- Sử dụng để thực hiện thay đổi requests/responses của user.\n- Đây là tính năng có sẵn của CloudFront(code được quản lý toàn bộ trong CloudFront)\n![[00 Meta/01 Attachments/Pasted image 20230328163241.png]]\n\n- Use cases:\n\t- Cache key\n\t- Thao tác với Header(thêm, xoá, sửa HTTP headers trong các requests hoặc responses)\n\t- Viết lại URL hoặc thực hiện redirects.\n\t- Request xác thực hoặc phân quyền.\n\n## 🌿 Lambda@Edge\n- Lambda functions được viết bởi NodeJS hoặc Python.\n- Scales lên 1000 yêu cầu/giây\n- Sử dụng để thay đổi các requests/response của cả viewer và origin server.\n- Cấp quyền cho các funtions trong một AWS Region, sau đó CloudFront sẽ sao chép đến các locations của nó.\n![[00 Meta/01 Attachments/Pasted image 20230328163706.png]]\n- Use cases:\n\t- Các tác vụ cần thời gian lâu hơn để thực thi.\n\t- Điều chỉnh CPU hoặc memory\n\t- Code của chúng ta phụ thuộc vào một thư viện bên thứ 3.\n\t- Network access để sử dụng các services nội bộ.\n\t- Truy cập vào hệ thống file hoặc body của các HTTP requests -\u003e tuỳ chỉnh được nhiều hơn.","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Databases/AWS-Lake-Formation":{"title":"🥦 AWS Lake Formation","content":"\n## 🌿 What?\n- Là dịch vụ quản lý dữ liệu trên AWS, giúp chúng ta dễ dàng xây dựng và quản lý các data lakes trên nền tảng AWS.\n- Data lake là một nơi lưu trữ dữ liệu phi cấu trúc và cấu trúc từ nhiều nguồn dữ liệu khác nhau đổ về. Phân tích được lake sẽ đưa ra cái nhìn toàn diện từ đó đưa ra được các quyết định chính xác hơn.\n- Các nguồn dữ liệu có thể là: RDS, S3, Relational \u0026 NoSQL DB, ...\n- Access control cho từng row và col.\n- Built trên AWS Glue.\n\n![[00 Meta/01 Attachments/Pasted image 20230405234323.png]]\n\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Databases/Amazon-Athena":{"title":"🥦 Amazon Athena","content":"\n## 🌿 What?\n- Là dịch vụ query **[[40123345 posts/42 Code/42.03 AWS/Some Solution Architectures/Serverless|serverless]]**, dùng để phân tích dữ liệu trong [[40123345 posts/42 Code/42.03 AWS/S3|S3]].\n- Sử dụng ngôn ngữ SQL tiêu chuẩn để query files(built trên Presto).\n- Hỗ trợ các định dạng CSV, JSON, ORC, Avro, và Parquet.\n- Giá: 5$ trên một TB dữ liệu scan.\n- Thường được kết hợp với một dịch vụ khác là Amazon QuickSight để báo cáo hoặc làm dashboard.\n\n- **Use cases:** Phân tích/ báo cáo, **CloudTrail trails**, ...\n- **Nói chung là muốn phân tích dữ liệu lưu trong [[40123345 posts/42 Code/42.03 AWS/S3|S3]] bằng [[40123345 posts/42 Code/42.03 AWS/Some Solution Architectures/Serverless|serverless]] SQL thì sử dụng Athena.**\n\n## 🌿  Performance Improvement\n- Sử dụng **columnar data** khi chỉ muốn scan đúng cột chúng ta cần.(less scan)\n\t- Tiết kiệm chi phí\n- **Compress data** cho những truy suất nhỏ hơn\n- **Partition** datasets trong [[40123345 posts/42 Code/42.03 AWS/S3|S3]], giúp query dễ dàng hơn trên các cột ảo.\n- **Use larger files**(\u003e 128MB) để tối thiểu overhead(truyền tải tốt hơn).\n\n## 🌿  Federated Query\n- Athena cho phép chúng ta chạy SQL queries cho cả những dự liệu được lưu trữ dưới dạng relational, non-relational, object và custom data sources(AWS hoặc on-premises)\n- Sử dụng **Data Source Connectors**([[40123345 posts/42 Code/42.03 AWS/AWS Lambda|AWS Lambda]]) để chạy Federated Queries(queries tới CloudWatch Logs, [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon DynamoDB|DynamoDB]], [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon RDS - Relational Database Service|RDS]], ...)\n- Lưu trữ kết quả phân tích được vào lại [[40123345 posts/42 Code/42.03 AWS/S3|S3]].","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Databases/Amazon-Aurora":{"title":"🥦 Amazon Aurora","content":"\n## 🌿 What?\n- Là công nghệ độc quyền của AWS(không phải open source)\n- Tương thích với Postgres và MySQL.\n- Aurora là **AWS  cloud optimized**, x5 performance so với MySQL trên RDS và x3 performance so với Postgres trên RDS.\n- Tự động tăng bộ nhớ, từ 10Gb(mặc định) có thể tăng lên 128TB\n- Aurora có 15 replicas trong khi MySQL có 5, và replication process cũng nhanh hơn(10ms)\n- Chuyển đổi dự phòng là tức thời. Đảm bảo High Available\n- Gía của Aurora đắt hơn 20% so với RDS, nhưng nó cũng hiểu quả hơn.\n\n## 🌿 High Availability và Read Scaling\n- Luôn tạo ra 6 bản sao ở trên 3 AZ mỗi khi ghi gì đó vào DB. Có khả năng nhân rộng, tự hồi phục cũng như tự động mở rộng.\n\t- 4 bản sao trong 6 dùng để viết.\n\t- 3 bản sao dùng để đọc\n- Có một Aurora Instance để ghi (master)\n- Tự động chuyển đổi dự phòng nếu master có lỗi trong vòng chưa đến 30s.\n- Master + 15 read replicas\n- Hỗ trợ nhân rộng giữa các Region.\n\n## 🌿 Aurora DB Cluster\n![[00 Meta/01 Attachments/Pasted image 20230308141108.png]]\n\n- Luôn chia sẻ dữ liệu lưu trữ với tất cả các cụm(master + read replicas)\n- Client connect thẳng tới master để ghi dữ liệu(writer endpoint)\n- Client conenct tới một Connection Load Balancing(reader endpoint) để truy cập đến cụm read replicas.\n\n## 🌿 Feature of Aurora\n- Tự động chuyển đổi dự phòng nếu có lỗi\n- Liên tục backup và recovery\n- Bảo mật và luôn sẵn sàng sử dụng\n- Tự động scaling\n- Zero downtime\n- Có thể restore data tại bất kỳ thời điểm nào.\n\n## 🌿 Custom EndPoint\n- Cho phép xác định custom endpoint để thực hiện tác vụ riêng.\n- Ví dụ cta có một cụm instance to hơn và nó tính toán tốt hơn, tạo một custom endpoint trỏ đến cụm đó để thực hiẹn các query phân tích dữ liệu(hay các query cần tính toán nhiều) để xử lý nhanh hơn.\n![[00 Meta/01 Attachments/Pasted image 20230308144242.png]]\n\n## 🌿 Aurora không có máy chủ\n- Tự động tạo khởi tạo cũng như scaling dựa theo tình trạng sử dụng thực tế.\n- Phù hợp với những ứng dụng không dự đoán trước được lưu lượng sử dụng.\n- Không cần lên kế hoạch sử dụng.\n- Dùng đến đâu trả đến đấy.\n\n## 🌿 Aurora Multi-Master\n- Trong trường hợp muốn chuyển đổi dự phòng ngay lập tức(chứ không phải đợi tầm khoảng 30s - HA), lựa chọn option này.\n- Tất cả các nodes đều được dùng để R/W và liên kết trực tiếp với client.(thay vì chuyển node chỉ đọc lên làm master)\n![[00 Meta/01 Attachments/Pasted image 20230308150206.png]]\n\n## 🌿 Global Aurora\n- **Aurora Cross Region Read replicas**\n\t- Đề phòng thảm hoạ\n\t- Dễ dàng đặt ở mọi nơi\n- **Aurora Global Database (khuyên dùng)**\n\t- 1 Primary Region(đọc/ghi)\n\t- Tối đa 5 regions phụ(chỉ đọc), nhân bản có ping nhỏ hơn 1s\n\t- Mỗi region phụ có thể có tối đa 16 read replicas, giảm độ trễ khi đọc dữ liệu\n\t- Khôi phục dữ liệu sau thảm hoạ trong vòng 1 phút.\n\t- Chưa đến một giây để sao chép toàn bộ dữ liệu trên tất cả regions.\n\n## 🌿 Aurora Machine Learning \n- Support services:\n\t- Amazon SageMaker(dùng với bất kỳ model ML nào)\n\t- Amazon Comprehend (dùng để phân tích cảm tính, đề xuất sản phẩm, ...)\n![[00 Meta/01 Attachments/Pasted image 20230308152417.png]]\n\n## 🌿 Aurora Backups\n- Giống với RDS backups\n\t- Backup tự động\n\t\t- Lưu trữ trong 1-35 ngày\n\t\t- Backup tại tất cả các thời điểm, vì vậy chúng ta có thể lấy lại dữ liệu tại bất kỳ thời điểm nào.\n\t- Backup thủ công\n\t\t- User tự thực hiện\n\t\t- Lưu trữ vô thời hạn\n\n## 🌿 Restore Options\n- Restoring từ Aurora backup hoặc snapshot tạo một database mới.\n- Restoring MySQL Aurora cluster từ S3\n\t- Tạo một backup sử dụng Percona XtraBackup\n\t- Lưu file backup vào S3\n\t- Restore từ file backup đó\n\n## 🌿 Aurora Database Cloning\n- Tạo một Database Cluster mới từ cái có sẵn.\n- Nhanh hơn snapshot\u0026restore\n- Một DB mới được tạo ra, giống y hệt cái cũ nhưng không đồng bộ(ko liên quan gì đến nhau, vd một cái dùng cho staging, mọt cái dùng cho production)\n- Rất nhanh và giá cả phải chăng\n- Hữu ích khi muốn tạo một staging database từ production database và không ảnh hưởng đến môi trường production.","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Databases/Amazon-DynamoDB":{"title":"🥦 Amazon DynamoDB","content":"\n## 🌿 What?\n- Là dịch vụ cung cấp cơ sở dữ liệu toàn quyền quản lý, HA(Highly available) với khả năng nhân bản trên nhiều AZs.\n- Kiểu NoSQL - không phải kiểu quan hệ. Hỗ trợ transaction.\n- Có khả năng scale với những dự án lớn.\n- Chịu được hàng triệu requests mỗi giây, hàng triệu triệu hàng, và hàng trăm TB dung lượng.\n- Hiệu suất nhanh và nhất quán.\n- Tích hợp được với IAM để bảo mật, phân quyền và quản trị viên.\n- Chi phí thấp và có khả năng tự động scaling\n- Không bảo trì hay vá version, vì AWS luôn cung cấp sẵn infrastructure nên không cần lo.\n- Có 2 loại bảng trong DynamoDB:\n\t- Standard Table\n\t- Infrequent Access(IA) Table\n\n## 🌿 Basics\n- DynamoDB được tạo thành từ các **bảng**.\n- Từng bảng có mọt **Primary Key** được chỉ định từ lúc khởi tạo.\n- Từng bảng có thể có vô hạn các item(các hàng).\n- Từng item có các **attributes**(có thể thêm bất kỳ lúc nào - có thể null)\n- Một item có size tối đa là **400KB**\n- Các kiểu dữ liệu được hỗ trợ:\n\t- **Scalar Types:** String, Number, Binary, Boolean, Null.\n\t- **Document Types:** List, Map.\n\t- **Set Types:** String Set, Number Set, Binary Set.\n- **Vì vậy, DynamoDB có thể giúp chúng ta phát triển nhanh chóng.**\n\n## 🌿 Read/Write Capacity Modes\n- Kiểm soát thông lượng. Có 2 mode:\n- **Provisioned Mode(default)**\n\t- Có thể chỉ định số lượng reads/writes trên mỗi giây\n\t- Bạn cần có một plan về khả năng sử dụng trước.\n\t- Trả cho Read Capacity Units (RCU) \u0026 Write Capacity Units (WCU)\n\t- Có thể add auto-scaling cho RCU và WCU\n- **On-Demand Mode**\n\t- Read/write tự động được scale theo khả năng sử dụng.\n\t- Không cần phải lên kế hoạch sử dụng trước.\n\t- Dùng đến đâu, trả đến đấy - đắt hơn cái trên\n\t- Phù hợp với những app không dự đoán trước được khả năng sử dụng, hoặc các app thử nghiệm, có thời gian sử dụng không dài.\n\n\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Databases/Amazon-ECS-Elastic-Container-Service":{"title":"🥦 Amazon ECS - Elastic Container Service","content":"\n## 🌿 What?\n- Là dịch vụ của AWS, giúp dễ dàng chạy và quản lý các [[50 til/51 Code/51.09 Docker/Docker|Docker]] containers trên 1 cụm EC2 instances hoặc AWS Fargate - một công cụ tính toán không máy chủ cho các containers.\n- Launch Docker container on AWS = Launch **EC2 Tasks** trên ECS Cluster.\n\n## 🌿 EC2 Launch Type\n- **EC2 Launch Type: bạn phải cung cấp và bảo trì cho cơ sở hạ tầng(là các EC2 instances)**\n- Mỗi EC2 Instance phải chạy một ECS Agent để đăng ký trên ECS Cluster. Sau đó, AWS có thể takes care việc starting/stopping các containers.\n![[00 Meta/01 Attachments/Pasted image 20230326190905.png]]\n\n## 🌿 Fargate Type\n- Launch Docker containers trên AWS mà **không cần tạo bất kỳ một EC2 Instances nào - tất cả đều là serverless**\n- Chỉ cần tạo task định nghĩa, AWS sẽ thực hiện chạy ECS Tasks cho chung ta dựa theo lượng CPU/RAM mà chúng ta cần.\n- Khi mở rộng, chỉ cần tạo thêm các tasks, không cần tạo thêm EC2 Instances.\n- Trong khi đi thi, **Fargate Type được khuyến khích sử dụng hơn vì nó là serverless - dễ mở rộng và quản lý.**\n![[00 Meta/01 Attachments/Pasted image 20230326191443.png]]\n\n## 🌿 IAM Roles\n- Có 2 dạng ứng với 2 type.\n- **EC2 Instance Profile (EC2 Launch Type only):**\n\t- Chỉ được sử dụng bởi các ECS Agents\n\t- Tác dụng:\n\t\t- Sử dụng để gọi API tới ECS service.\n\t\t- Gửi container logs đến CloudWatch Logs\n\t\t- Pull Docker image từ ECR\n\t\t- Xem các dữ liệu nhạy cảm trong Secrets Manager hoặc SSM Parameter Store.\n- **ECS Task Role:**\n\t- Cho phép các task sử dụng(mỗi task sẽ có những roles được chỉ định)\n\t- Tác dụng:\n\t\t- Sử dụng role để truy cập tới các AWS services của bạn.\n\t\t- Task Role được định nghĩa trong **task definition.**\n![[00 Meta/01 Attachments/Pasted image 20230326192400.png]]\n\n## 🌿Tích hợp với Load Balancer\n- **ALB - Application Load Balancer:** có được hỗ trợ và chạy được với hầu hết các use cases.\n- **Network Load Balancer:** nên sử dụng với các use cases cần thông lượng/hiệu suất cao hoặc là khi sử dụng với **AWS Private Link.**\n![[00 Meta/01 Attachments/Pasted image 20230326192918.png]]\n\n## 🌿 Data Volumes (EFS)\n- Mount thẳng EFS vào ECS tasks.\n- Có thể chạy được với cả 2 Type: **EC2 Launch Type and Fargate Type.**\n- Các tasks chạy trên bất kỳ AZ nào cũng sẽ chia sẻ chung dữ liệu trên EFS(chung một mối)\n- **Fargate + EFS =  Serverless.**\n- Use cases: cần chia sẻ và dùng chung dữ liệu cho các containers trên nhiều AZ.\n- Note:\n\t- S3 không thể mount được như một file system.\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Databases/Amazon-EMR-Elastic-MapReduce":{"title":"🥦 Amazon EMR - Elastic MapReduce","content":"\n## 🌿 What?\n- Là dịch vụ hỗ trợ quản lý các clusters Hadoop(Big Data) để phân tích và triển khai các ứng dụng big data.\n- Clusters có thể được tạo bởi hàng trăm EC2 instances.\n- EMR nó take care hết toàn bộ các tài nguyên cung cấp cũng như thông số thiết lập.\n- Tự động scale và tích hợp với Spot instances.\n- Use case: data processing, ML, web indexing, big data, ...\n\n## 🌿 Node types\n- **Master Node:** quản lý cluster, điều phối, quản lý sức khỏe - chạy dài hạn.\n- **Core Node:** Chạy các tasks và lưu trữ dữ liệu - chạy dài hạn.\n- **Task Node(optional):** chỉ để chạy task - thường là Spot.\n\n## 🌿 Purchasing\n- On-demand: tin cậy, có thể dự tính, sẽ không bị terminated.\n- Reserved(min là1 năm): tiết kiệm chi phí(EMR sẽ tự động sử dụng option này nếu nó phù hợp)\n- Spot instances: rẻ hơn nhưng có thể bị terminated nếu được giá =)) kém độ uy tín.\n\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Databases/Amazon-ElastiCache":{"title":"🥦 Amazon ElastiCache","content":"\n## 🌿 What?\n- Dịch vụ lưu cache của Amazon, hỗ trợ Redis hoặc Memcached.\n- Cache mang lại hiệu suất cao(dữ liệu cần đã có sẵn, chỉ việc lấy ra dùng), đỗ trễ thấp.\n- Giảm thiểu số lượng queris đọc vào database.\n- Giống RDS, Amazon sẽ takes care OS, patching, optimizations, setup configuration, monitoring, failure recovery and backups.\n- **Sử dụng ElastiCache sẽ phải thêm code.**\n\n## 🌿 Redis vs Memcached\n|Redis|Memcached|\n|------|------------|\n|**Multi-AZ** và tự động chuyển đổi dự phòng|Multi-node để phân vùng dữ liệu|\n|**Read replicas** để scale đọc và **high availability**| Không High Availibility|\n|Dữ liệu bền - persistence| Dữ liệu không bền|\n|**Có chức năng Backup và Restore**| Không có|\n|Hỗ trợ Sets và Sorted Sets| Kiến trúc đa luồng|\n\n## 🌿 Security\n- **IAM Authentication for Redis**, chỉ được dùng với AWS API-level security\n- **Redis AUTH**\n\t- set một cặp \"password/token\" khi tạo một cụm Redis cluster mới\n- **Memcached**\n\t- hỗ trợ SASL.\n\n## 🌿 Patterns\n- **Lazy Loading**\n- **Write Through**\n- **Session Store**\n\n## 🌿 Use Case\n- Xếp hạng Gaming, cần tính toán phức tạp. **Redis Sorted** đảm bảo tính uniq cũng như thứ hạng của elements.","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Databases/Amazon-Glue":{"title":"🥦 Amazon Glue","content":"\n## 🌿 What?\n- Là dịch vụ ETL(Extract, transform và load)\n- Hữu ích để chuẩn bị và chuyển đổi dữ liệu để phân tích.\n- **[[40123345 posts/42 Code/42.03 AWS/Some Solution Architectures/Serverless|serverless]]**\n![[00 Meta/01 Attachments/Pasted image 20230405232846.png]]\n\n- **Glue Job Bookmarks:** ngăn ngừa việc xử lý lại dữ liệu cũ.\n- **Glue Elastic Views:**\n\t- Kết hợp và sao chép dữ liệu trên nhiều dữ liệu lưu trữ bằng SQL.\n\t- Không custom code, Glue quan sát những thay đổi trong source data, serverless.\n\t- Tạn dụng một bảng ảo.\n- **Glue DataBrew:** làm sạch và chuẩn hóa dữ liệu sử dụng pre-built transformation.\n- **Glue Studio:** GUI mới để tạo, chạy và quan sát ETL jobs trong Glue.\n- **Glue Stream ETL:** tương thích với Kinesis Data Streaming, Kafka, MSK.\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Databases/Amazon-RDS-Relational-Database-Service":{"title":"🥦 Amazon RDS - Relational Database Service","content":"\n## 🌿 What?\n- Service quản lý DB sử dụng SQL là query language, cho phép cta có thể tạo databases trên cloud.\n- Các types AWS quản lý:\n\t- Postgres\n\t- MySQL\n\t- MariaDB\n\t- Oracle\n\t- Microsoft SQL Server\n\t- Aurora\n\n## 🌿 Advantage\n- Tự động cập nhật cũng như vá OS.\n- Liên tục backup và restore tại một thời diểm chỉ định\n- Có thể quan sát được thông số hoạt động\n- Có thể đọc bản sao để cải thiện hiệu suất đọc dữ liệu\n- Có thể setup trên nhiều AZs bằng DR(Disaster Recovery)\n- Có thể scaling(cả dọc và ngang)\n- Backup dữ liệu trên [[40123345 posts/42 Code/42.03 AWS/EBS Volume - Elastic Block Store|EBS]].\n\n- Nhưng không thể SSH vào instances.\n\n## 🌿 Storage Auto Scaling\n- Là tính năng giúp chúng ta có thể tự động tăng thêm bộ nhớ để lưu trữ trong TH free storage được sử dụng hết.\n- Tránh mở rộng bằng cách thủ công\n- Có thể set **Maximum Storage Threshold**, không được scale quá ngưỡng này.\n- Tính năng sẽ được kích hoạt mở rộng bộ nhớ khi:\n\t- Free space nhỏ hơn 10%\n\t- Dung lượng lưu trữ thấp quá 5p\n\t- 6h trôi qua kể từ lần modification cuối cùng.\n- Hữu ích với những app không dự đoán được trước lượng dữ liệu.\n- Hỗ trợ cho các engines: MariaDB, PostgreSQL, SQL Server, Oracle.\n\n## 🌿 Read Replicas\n- Tăng khả năng đọc dữ liệu, có thể tạo nhiều nhất 5 Read Replicas, thuộc về một AZ, khác AZ hoặc khác Region.\n- ASYNC.\n- Replicas có thể chuyển thành DB\n\n### 🍃 Network Cost\n- Trong AWS, khi dữ liệu đi từ AZ này sang AZ khác sẽ phải chịu phí, nhưng Với những RDS Read Replicas trong cùng một region, không phải trả phí.\n![[00 Meta/01 Attachments/Pasted image 20230307223247.png]]\n\n## 🌿 RDS Multi AZ (Disaster Recovery) \n- Chủ yếu là để khôi phục sau thảm họa(sóng thần cuốn mất data center 😔)\n- Tăng availability\n- SYNC replication\n- Không dùng với mục đich scale\n- Phòng trường hợp AZ mất kết nối, mất mạng hoặc instance hay store bị lỗi.\n\n## 🌿 From Single-AZ to Multi-AZ\n- Zero downtime, không cần dừng DB\n- Cơ chế hoạt động:\n\t- Một snapshot được tạo từ DB chính.\n\t- DB mới được restored ở region mới từ snapshot.\n\t- Quá trinh đồng bộ được thành lập giữa 2 databases.\n![[00 Meta/01 Attachments/Pasted image 20230307225946.png]]\n\n## 🌿 RDS Custom\n- **Quản lý Oracle và Microsoft SQL Server Database cùng với OS và tuỳ biến database.**\n|RDS|RDS Custom|\n|----|-------------|\n|tự động setup, hoạt động và scaling| truy cập được vào OS, databasem, có thể setting config, install patches, bật native features, truy cập vào EC2 Instance bằng **SSH** hoặc **SSM Session Manager**|\n- **De-active Automation Mode** để thực hiện custiomization, tốt hơn là nên tạo một DB snapshot trước.\n\n## 🌿 RDS Backups\n- Tính năng cho phép lưu lại dữ liệu để có thể restore khi dữ liệu bị mất hoặc nếu cần.\n- Có hai loại:\n\t- Backups tự động\n\t\t- Backup hàng ngày\n\t\t- Transaction logs ffoec backups 5p một lần\n\t\t- Có thể set thời gian lưu trữ (1 -\u003e 35 ngày), sau thời gian này sẽ không restore lại được nữa. Hoặc có thể set = 0 để disable tính năng này.\n\t- Backup thủ công (DB Snapshots)\n\t\t- Thực hiện thủ công\n\t\t-  Giữ lại backup vô thời hạn.\n- Trick: Nếu stop RDS database, chúng ta vẫn sẽ phải trả một khoản tiền cho bộ nhớ. Nếu chúng ta có kế hoạch sẽ stop lâu lâu, thì có thể snapshot để lưu trữ, sau dùng thì restore lại.\n\n## 🌿 RDS Restore\n- Restoring từ RDS backup hoặc snapshot tạo một database mới.\n- Restoring MySQL RDS database từ S3\n\t- Tạo một backup sử dụng Percona XtraBackup\n\t- Lưu file backup vào S3\n\t- Restore từ file backup đó","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Databases/Database-in-AWS":{"title":"🥦 Database in AWS","content":"\n## 🌿 Types\n- **RDBMS(=SQL/OLTP):** [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon RDS - Relational Database Service|RDS]], [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon Aurora|Aurora]].\n- **NoSQL:** [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon DynamoDB|DynamoDB]](~JSON), [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon ElastiCache|ElastiCache]] (key/value), Neptune(graphs),DocumentDB(MongoDB), Keyspaces(Apache Cassandra).\n- **Object Store:** [[40123345 posts/42 Code/42.03 AWS/S3|S3]](cho những object lớn) / Glacier(backup/archives).\n- **Data Warehouse:** Redshift(OLAP), Athena, EMR.\n- **Search:** OpenSearch - free text, tìm kiếm phi cấu trúc.\n- **Graphs:** Amazon Neptune - hiển thị quan hệ của dữ liệu.\n- **Ledger:** Amazon Quantum Ledger Database.\n- **Time series:** Amazon Timestream.\n\n## 🌿 Amazon RDS - Summary\n- Tóm tắt ý chính của [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon RDS - Relational Database Service|RDS]]:\n\t- Hỗ trợ với PosgreSQL / MySQL / Oracle / SQL Server / MariaDB / Custom\n\t- Cung cấp RDS Instance Size và [[40123345 posts/42 Code/42.03 AWS/EBS Volume - Elastic Block Store|EBS]] Volume Type \u0026 Size\n\t- Có khả năng tự động scale cho Storage\n\t- Hỗ trợ Read Replicas và Mutil AZs\n\t- Bảo mật với IAM, SG, KMS, SSL in transit.\n\t- Tính năng Automated Backup với từng thời điểm(tối đa lưu trữ trong 35 ngày)\n\t- Tính năng Manual DB Snapshot giúp lưu trữ với thời gian dài.\n\t- Hỗ trợ Xác thực IAM, tích hợp với Secrets Manager\n\t- RDS Custom có thể dùng để truy cập và customize các instance cơ bản(Oracle \u0026 SQL Server)\n\t- **Use cases**: dùng khi muốn lưu trữ cơ sở dữ liệu có quan hệ, thực hiện các câu lệnh SQL, các transactions.\n\n## 🌿 Amazon Aurora - Summary\n- Tóm tắt ý chính của [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon Aurora|Aurora]]:\n\t- Tương thích với PostgreSQL / MySQL, tách biệt giữa lưu trữ và tính toán.\n\t- Storage: Dữ liệu được lưu trữ trong 6 replicas trên 3 AZ - vì vậy nó luôn HA, tự động khôi phục nếu có lỗi, tự động scale.\n\t- Compute: Các cụm DB instance nằm trên nhiều AZ, tự động scale với Read Replicas.\n\t- Cluster: Custom endpoint cho các DB instances đọc và ghi.\n\t- Về bảo mật / monitoring / bảo trì / backup giống với RDS.\n\t- **Aurora Serverless:** dùng khi không dự đoán trước được nhu cầu sử dụng.\n\t- **Aurora Multi-Master:** liên tục ghi dữ liệu(luôn dự phòng, khả năng ghi luôn sẵn sàng).\n\t- **Aurora Global:** Lên đến 16 DB read instances trên từng region, \u003c 1 giây để nhân bản\n\t- **Aurora Machine Learning:** dùng với ML sử dụng module SageMaker \u0026 Comprehend trên Aurora.\n\t- **Aurora Database cloning:** Một cụm mới được clone từ cụm đã tồn tại, nhanh hơn sử dụng snapshot để restoring.\n\t- **Use Cases:** giống với nhu cầu sử dụng RDS, nhưng yêu cầu cần nhanh hơn, ít cần bảo trì hơn, linh hoạt hơn, hiệu suât tốt hơn và nhiều tính năng khác nữa.\n\n## 🌿 Amazon ElastiCache - Summary\n- Tóm tắt ý chính của [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon ElastiCache|ElastiCache]]:\n\t- Được quản lý bởi Redis hoặc Memcached(giống như RDS nhưng dùng cho cache)\n\t- Lưu dữ liệu trong bộ nhớ tạm, độ trễ cực thấp\n\t- Phải cung cấp một  EC2 instance.\n\t- Hỗ trợ Clustering(redis) và Multi AZ, Read Replicas\n\t- Bảo mật thông qua IAM, SG, KMS, Redis Auth\n\t- Backup / Snapshot / Lưu trữ tại thời điểm chỉ định.\n\t- Quản lý và lập lịch cho bảo trì.\n\t- **Yêu cầu phải thay đổi code của app để sử dụng**\n\t- **Use Cases:** Lưu trữ dạng Key/Value, dữ liệu cần đọc thường xuyên, ít ghi, cache các kết quả của các câu SQL queries, lưu phiên hoạt động của websites, không thể sử dụng SQL.\n\n## 🌿 Amazon DynamoDB - Summary\n- Tóm tắt ý chính của [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon DynamoDB|DynamoDB]]:\n\t- Công nghệ độc quyền của AWS, là database NoSQL serverless, độ trễ milisecond.\n\t- Capacity modes:\n\t\t- Optional auto-scaling: chủ động setting các thông số khi có plan cũng như ước lượng được trước nhu cầu sử dụng.\n\t\t- On-demand: không ước lượng được trước, nó sẽ tự động scale theo mức độ sử dụng của mình, dùng đến đâu trả đến đấy.\n\t- Có thể thay thế ElastiCache để lưu trữ dạng key/value\n\t- DAX cluster cache kết quả đọc, giảm độ trễ cũng như giảm số lượng truy cập đến DB.\n\t- Bảo mật, xác thực, phân quyền thông qua IAM.\n\t- Event processcing: DynamoDB Streams để tích hợp với AWS Lambda hoặc Kinesis Data Streams.\n\t- Global Table: thiết lập nhiều DB cùng active, dữ liệu được đồng bộ với nhau.\n\t- Tự động backup tối đa 35 ngày với PITR(để lưu trữ 1 bảng mới) hoặc on-demand backups.\n\t- **Nhanh chóng phát triển**\n\t- **Use case:** Phát triển ứng dụng với kiến trúc serverless, phân phối cache không máy chủ.\n\n## 🌿 Amazon S3 - Summary\n- Tóm tắt ý chính của [[40123345 posts/42 Code/42.03 AWS/S3|S3]]:\n\t- S3 là là một dạng lưu key/value cho các objects\n\t- Phù hợp với những objects lớn, không phù hợp với nhiều objects nhỏ.\n\t- Serverless, scale vô hạn, size của object tối đa là 5TB, có khả năng quản lý version.\n\t- **Tiers:** S3 Standard, S3 Infrequent Access, S3 Intelligent, S3 Glacier + lifecycle policy.\n\t- **Features:** Versioning, Encryption, Replication, MFA-Delte, Access Logs, ..\n\t- **Security:** IAM, Bucket Policies, ACL, Access Points, Object Lambda, CORS, Object/Vault lock\n\t- **Batch operation:** trên các objects sử dụng S3 Batch, liệt kê các files thì sử dụng S3 Inventory.\n\t- **Performance:** Multi-Part upload, S3 Transfer Acceleration, S3 Select.\n\t- **Automation:** S3 Event Notifications(SNS, SQS, Lambda, EventBridge)\n\t- **Use case:** Static files, key/value objects lưu trữ với những objects lớn, website hosting.\n\n## 🌿 DocumentDB - Summary\n- Tóm tắt ý chính của DocumentDB:\n\t- Là Aurora nhưng tương thích với mongoDB\n\t- Sử dụng để lưu trữ, query và index dữ liệu JSON.\n\t- Toàn quyền quản lý, HA với các nhân bản trên cả 3 AZ.\n\t- Tự động phát triển 10Gb - 64Tb,\n\t- Tự động scale worloads lên đến hàng triệu requests.\n\n## 🌿 Amazon Neptune - Summary\n- Graph database\n- Một ứng dụng phổ biến là **social network**.\n- HA trên 3 AZ, tối đa mở rộng 15 read replicas.\n- Build và chạy các apps hoạt động với các bộ dữ liệu có kết nối phức tạp - Nó đã được tối ưu với những queries khó và phức tạp.\n- Có thể lưu trữ lên đến hàng tỷ quan hệ và query với độ trễ cực thấp(milisecond)\n\n## 🌿 Amazon KeySpaces  - Summary\n*Apache Cassandra là một database open-source NoSQL*\n- Tương thích với Apache Cassandra.\n- Serverless, có thể scale, HA, toàn quyền quản lý bởi AWS.\n- Tự động scale các bảng dựa theo lượng sử dụng của app.\n- Các bảng sẽ được nhân bản ba lần trên nhiều AZ.\n- Sử dụng Cassandra Query Language(CQL)\n- Mode: on-demand và provisioned mode.\n- Encryption, backup, Point-In-Time Recovery(PITR) tối đa 35 ngày.\n- Use case: lưu trữ thông tin thiết bị IoT, time-series data, ...\n\n## 🌿 Amazon QLDB  - Summary\n- Quantum Ledger Database.\n- Là một cái sổ cái để **lưu lại các giao dịch tài chính**.\n- Toàn quyền quản lý, serverless, HA, Nhân bản trên cả 3 AZ.\n- Sử dụng để **review lại lịch sử của toàn bộ những thay đổi đối với dữ liệu của app** từ trước đến nay,\n- **immutable system:** không tác nhân nào có thể xóa, sửa.\n\n## 🌿 Amazon Timestream  - Summary\n- Nhanh, có thể scale, **serveless database time series.**\n- Tự động scale để điều chỉnh khả năng sử dụng.\n- Lưu trữ và phân tích hàng nghìn tỷ events mỗi ngày.\n- Rẻ nhất\n- Use case: IoT apps, phân tích real-time, ...","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Disaster-Recovery/AWS-Application-Discovery-Service":{"title":"🥦 AWS Application Discovery Service","content":"\n## 🌿 What?\n- Là dịch vụ giúp chúng ta khám phá và phân tích cơ sở hạ tầng của hệ thống.\n- Hiểu đơn giản nó sẽ scan hệ thống, tìm kiếm thông tin về ứng dụng, dịch vụ, máy chủ, phần cứng, ... sau đó tổng hợp lại thành một báo cáo.\n- Giúp đánh giá hiệu suất, độ tin cậy, tính khả dụng của hệ thống.\n- Giúp tìm ra những vấn đề tiềm ẩn, từ đó khắc phục cũng như tối ưu hệ thống.\n- Đặc biệt là dịch vụ này thường được dùng để làm tài liệu tham khảo cho việc lên plan để migrate server từ on-premise lên cloud.\n- **Agentless Discovery** - các thông tin liên quan đến phần cứng.\n- **Agent-based Discovery** - các thông tin liên quan đến hiệu suất của ứng dụng, network, ...\n- Kết quả có thể xem được trong AWS Migration Hub.\n- \n\n## 🌿 Refer \n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Disaster-Recovery/AWS-Backup":{"title":"🥦 AWS Backup","content":"\n## 🌿 What?\n- Là dịch vụ được quản lý hoàn toàn bởi AWS.\n- Hỗ trợ chúng ta quản lý cũng như tự động backups cho nhiều AWS Services.\n- Không cần phải tạo custom script hay những tiến trình thủ công, AWS lo tất.\n- Các services được hỗ trợ:\n\t- EC2 / [[40123345 posts/42 Code/42.03 AWS/EBS Volume - Elastic Block Store|EBS]]\n\t- [[40123345 posts/42 Code/42.03 AWS/S3|S3]]\n\t- [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon RDS - Relational Database Service|RDS]] / [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon Aurora|Aurora]] / [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon DynamoDB|DynamoDB]]\n\t- DocumentDB / Neptune\n\t- EFS / FSx\n\t- Storage Gateway\n- Hỗ trợ backup trên nhiều regions và accounts.\n- **Backup Plans** - có thể hiểu là Backup policies:\n\t- Tần suất backup - 1h, daily, weekly, ...\n\t- Backup windows\n\t- Transaction to Cold Storage(never, 1 day, month, ...)\n\t- Chu kỳ giữ lại(always, day, weeek, ...)\n![[00 Meta/01 Attachments/Pasted image 20230420213933.png]]\n\n## 🌿 Backup Vault Lock\n- Chỉ có ghi vào và đọc chứ không có xóa được.","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Disaster-Recovery/DMS-Database-Migration-Service":{"title":"🥦 DMS - Database Migration Service","content":"\n## 🌿 What?\n![[00 Meta/01 Attachments/Pasted image 20230420205602.png]]\n- Là dịch vụ hỗ trợ migrate database ở bất cứ đâu và đến bất kỳ chỗ nào bạn muốn một cách nhanh chóng và an toàn.\n- Có khả năng tự phục hồi cũng như tự động chạy lại nếu có lỗi trong quá trình hoạt động.\n- Trong quá trình migrate, main database luôn phải trong trạng thái available.\n- Hỗ trợ:\n\t- Migrate đồng nhất: vd như từ Oracle -\u003e Oracle.\n\t- Migrate không đồng nhất: vd như Microsoft SQL Server -\u003e [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon Aurora|Aurora]].\n- Có thể sử dụng CDC - Continuous Data Relication: thực hiện nhân bản dữ liệu liên tục.\n- Sử dụng dịch vụ này, về bản chất chúng ta sẽ phải launch một EC2 Instance, nó sẽ chịu trách nhiệm nhân bản dữ liệu cho chúng ta.\n![[00 Meta/01 Attachments/Pasted image 20230420205549.png]]\n\n## 🌿 Schema Conversation Tool(SCT)\n- Tính năng hỗ trợ convert schema của database sang engine phù hợp, để bên target có thể migrate được.\n![[00 Meta/01 Attachments/Pasted image 20230420210059.png]]\n\n- Best practice:\n![[00 Meta/01 Attachments/Pasted image 20230420210320.png]]\n- Đặt một server ở on-premise để thực hiện convert schema.\n- DMS đặt ở public subnet trên Cloud, thực hiện Migrate + CDC. ","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Disaster-Recovery/On-Premise-strategies-with-AWS":{"title":"🥦 On-Premise strategies with AWS","content":"\n## 🌿 Các chiến lược sử dụng để liên kết on-premise với cloud\n- Có khả năng Download Amazon Linux 2 AMI như một VM.\n- VM import/export\n\t- Có thể migrate hệ thống đã có vào EC2\n\t- Tạo một nơi để thực hiện DC trên máy ảo.\n\t- Có thể export ngược lại từ EC2 về on-premise.\n- AWS Application Discovery Service\n\t- Tổng hợp các thông tin về on-premise servers để lên kế hoạch migrate.\n\t- Kiểm tra, giám sát với AWS Migration Hub.\n- AWS Database Migration Service([[40123345 posts/42 Code/42.03 AWS/Disaster Recovery/DMS - Database Migration Service|DMS]])\n\t- Nhân bản, sao chép cơ sở dữ liệu từ on-premise lên cloud\n\t- Hỗ trợ đa dạng các kiểu databases.\n- AWS Server Migration Service(SMS)\n\t- Cung cấp một cái live server thực hiện nhân bản, sao chép database từ on-premise lên cloud.\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Disaster-Recovery/Overview":{"title":"🥦 Fill title","content":"\n## 🌿 What?\n- Bất kỳ sự kiện nào gây ảnh hưởng tiêu cực tới quá trình nghiệp vụ liên tục hoặc vấn đề tài chính của một công ty thì đó được gọi là disaster(hay còn được gọi là incident)\n- Disaster Recovery(DC) là các hoạt động được chuẩn bị để thực hiện quá trình hồi phục sau khi xuất hiện một disaster. \n- Các loại DC:\n\t- On-premise =\u003e On-premise: thuê một datacenter đặt ở Hà Nội, một cái đặt ở Hải Phòng chẳng hạn.\n\t- On-premise =\u003e Cloud: Hybrid Recovery - có một máy chủ vật lý đặt ở cty, thuê thêm datacenter trên cloud, nếu on-premise có vấn đề thì switch qua cloud sài.\n\t- Cloud Region =\u003e Cloud Region\n\n- Phân biệt 2 định nghĩa:\n\t- RPO - Recovery Point Objective - bao nhiêu dữ liệu bị mất khi xảy ra disaster\n\t- RTO - Recovery Time Objective - thời gian downtime là bao lâu kể từ thời điểm phát sinh disater.\n=\u003e Việc của chúng ta làm làm cách nào đó tối ưu Data loss và Downtime càng nhỏ càng tốt.\n![[00 Meta/01 Attachments/Pasted image 20230420152447.png]]\n\n## 🌿 Strategies\n![[00 Meta/01 Attachments/Pasted image 20230420152835.png]]\n- 4 strategies sắp xếp theo thời gian Downtime, cũng như giá tiền, càng đắt thời gian Downtime càng nhỏ.\n\n### 🍃 Backup and Restore (High RPO)\n![[00 Meta/01 Attachments/Pasted image 20230420153524.png]]\n- Đặt lịch để datacenter tự động tạo snapshot, hoặc với on-premise thì gửi dữ liệu lên Cloud. Cách này thì không cần setup gì nhiều, giá còn rẻ.\n- Cơ mà cách này thì nó dễ High RPO và RTO khi có disaster.\n\t- Vd như dùng AWS Snowball để chuyển dữ liệu tầm 7 ngày, trong thời gian di chuyển, on-premise nó cháy phát, thế là mất toàn bộ data trong 1 tuần luôn.\n\t- Hoặc tạo snapshot 24h hoặc 1h một lần thì nếu có disaster, hệ thống cx sẽ mất toàn bộ dữ liệu trong thời gian countdown đó.\n- Ngoài ra còn một số hạn chế cần xem xét khi triển khai:\n\t- Mất thời gian và tài nguyên để thực hiện sao lưu.\n\t- Không thể khôi phục ngay lập tức, khi xảy ra disater, dữ liệu chưa thể sử dụng ngay được mà sẽ có một khoảng downtime để khôi phục lại dữ liệu.\n\t- Nói là rẻ nhưng chúng ta cũng phải mất thêm phí để trả cho việc lưu trữ, băng tần sao lưu, ...\n\n### 🍃 Pilot Light\n![[00 Meta/01 Attachments/Pasted image 20230420161932.png]]\n- Là chiến lược duy trì một bản sao của hệ thống, bản sao này sẽ chỉ bao gồm các phần quan trọng của hệ thống(vd như [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon RDS - Relational Database Service|RDS]], EC2 thì lúc nào sử dụng tạo sau nên không cần), duy trì ở mức tối thiểu để tối ưu chi phí.\n- Như ví dụ trên, khi disaster xảy ra, hệ thống sẽ điều hướng để chạy trên bản sao, từ đó giúp giảm thiểu RTO, cũng như dữ liệu luôn được nhân bản liên tục, giảm thiểu RPO.\n- Hạn chế:\n\t- Chi phí để duy trì bản sao\n\t- Cần có một kế hoạch chi tiết để thực hiện hồi phục nhanh chóng và chính xác. Chiến lược này liên quan nhiều đến cấu hình, kích thước, tài nguyên, network, và nhiều yếu tố khác của hệ thống.\n\n### 🍃 Warm Standby\n![[00 Meta/01 Attachments/Pasted image 20230420164451.png]]\n- Giống Spot Light, cũng duy trì một bản sao dự phòng nhưng bản sao này sẽ chạy thêm cả các dịch vụ chính của hệ thống.\n- Bên trên không chạy EC2 Instances thì chiến lược này sẽ có chạy sẵn để tạch thì chạy luôn, chứ không có downtime để launch EC2 Instance nữa.\n- Hạn chế:\n\t- Chi phí tất nhiêu là nhiều hơn rồi, đắt luôn ấy chứ.\n\t- Có thể bản sao sẽ không đáp ứng được đầy đủ lượng traffic của hệ thống cũ, lúc này thì vẫn cần thời gian để scale trước khi hoàn toàn ổn định.\n\n### 🍃 Multi Site\n![[00 Meta/01 Attachments/Pasted image 20230420165605.png]]\n- Phiên bản khô máu, chạy song song 2 phiên bản poroduction luôn, nó cái nào gặp lỗi, điều hướng qua cái còn lại để sử dụng.\n- Rất đắt.\n- Downtime hầu như rất thấp mấy giây, cùng lắm là mấy phút thôi.\n\n## 🌿 Tips\n- **Backup**\n\t- [[40123345 posts/42 Code/42.03 AWS/EBS Volume - Elastic Block Store|EBS]] snapshots, [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon RDS - Relational Database Service|RDS]] auto snapshot, ...\n\t- Thường xuyên push lên [[40123345 posts/42 Code/42.03 AWS/S3|S3]]/[[40123345 posts/42 Code/42.03 AWS/S3|S3]] Glacier, ... dùng lifecycle policies\n\t- Nếu chạy cả trên on-premise: sử dụng Snowball hoặc Storage Gateway\n- **High Availability**\n\t- Dùng Route53 để migrate DNS trên nhiều Regions.\n\t- [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon RDS - Relational Database Service|RDS]]/[[40123345 posts/42 Code/42.03 AWS/Databases/Amazon ElastiCache|ElastiCache]] Multi-AZs, EFS, [[40123345 posts/42 Code/42.03 AWS/S3|S3]], ...\n\t- [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/AWS Site-to-Site VPC|Site-to-site]] để recovery cho [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/Direct Connect (DX)|Direct Connect]]\n- **Replication**\n\t- [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon RDS - Relational Database Service|RDS]] Replication, [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon Aurora|Aurora]] + Global Database\n\t- Database relication từ on-premise lên [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon RDS - Relational Database Service|RDS]].\n\t- Storage Gateway\n- **Automation**\n\t- CloudFormation/[[40123345 posts/42 Code/42.03 AWS/Elastic Beanstalk|Elastic Beanstalk]] để tạo lại toàn bộ hệ thống trên môi trường mới.\n\t- Recover/Reboost thông qua [[40123345 posts/42 Code/42.03 AWS/Monitoring/Amazon CloudWatch|CloudWatch]] nếu nó có alarm lỗi.\n\t- Dùng [[40123345 posts/42 Code/42.03 AWS/AWS Lambda|AWS Lambda]] Function để thực hiện tự động các tác vụ chỉ định.\n- **Chaos**\n\t- Kiểm thử, như Netflix đặt toàn bộ tài nguyên trên AWS Cloud, có một thuật ngữ \"simian-army\". Là kiểu kiểm thử khả năng DC của hệ thống - random terminate EC2 của production luôn chứ không phải của môi tường test luôn =)))","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/EBS-Volume-Elastic-Block-Store":{"title":"🥦 EBS Volume - Elastic Block Store","content":"\n## 🌿 What?\n![[00 Meta/01 Attachments/Screenshot 2023-03-03 at 11.24.50.png]]\n- Là một dịch vụ lưu trữ thông qua các **virtual disks**, giúp chúng ta có thể truy xuất dữ liệu từ các EC2 Instances (a network drive, not a physical drive).\n\t- EBS sẽ sử dụng network để giao tiếp với các EC2 Instance, vì vậy có thể có chút độ trễ.\n- Cho phép lưu trữ dữ liệu cả khi đã terminate EC2 instance. Có thể mount lại dữ liệu nếu cần.\n- 1 EBS chỉ mounted được tới 1 instance tại cùng một thời điểm.\n\t- Có thể detached khỏi một Instance và attached vào một Instance khác dễ dàng và nhanh chóng.\n- Bound trong 1 AZ chỉ định, không sử dụng được cho các EC2 instance ở khác AZ.\n\t- Để move một volume qua AZ khác, chúng ta cần snapshot nó.\n- Có thể hiểu nó như một cái USB, có thể mang đi cắm vào các EC2 instances khác cần sử dụng dữ liệu.\n- Đương nhiên chúng ta sẽ cần chỉ định cấu hình(bao nhiêu Gbs và IOPS - Input/output Operations Per Second - tốc độ đọc ghi thế nào)\n\t- Có thể thêm tiền để upgrade cấu hình.\n\n## 🌿 EBS Snapshots\n![[00 Meta/01 Attachments/Screenshot 2023-03-03 at 11.56.30.png]]\n- Là tính năng giúp cta sao chép EBS Volume, bao gồm dữ liệu, tệp tin và cấu hình của chúng.\n- Giúp move volume giữa những AZs khác nhau.\n\n### 🍃 Features\n\n1. 🌱 EBS Snapshot Archive\n\t- Có thể chuyển Snapshot vào một **archive tier** thay vì lưu trữ thông thường, cách này rẻ hơn 75%.\n\t- Mất 24-72h để restoring lại.\n\n2. 🌱 Recycle Bin for EBS Snapshots\n\t- Giữ lại những snapshots đã bị xóa, từ đó có thể lấy lại được nếu chẳng may chúng ta xóa nhầm.\n\t- Chỉ định thời gian giữ lại (1 ngày - 1 năm)\n\n3. 🌱 Fast Snapshot Restore (FSR)\n\t- Cho phép khởi tạo không có độ trễ cho lần đầu tiên. Nếu cta có snapshot lớn và muốn khởi tạo EBS Volume nhanh.\n\t- Tính năng này cần trả thêm phí để sử dụng.\n\n## 🌿 EBS Volume Types\n-   Có 6 loại:\n\t- gp2/gp3(SSD): cho những nhu cầu sử dụng tiêu chuẩn, cân bằng giữa giá cả và hiệu suất sử dụng. Phù hợp với nhiều ứng dụng.\n\t- io1/io2(SSD): hiệu suất tốt nhất, sử dụng cho những ứng dụng cần thực hiện tính toán tốc độ cao, I/O tốt.\n\t- st1(HDD): Giá thấp hơn, sử dụng HDD phục vụ lưu trữ dữ liệu thường xuyên truy xuất và yêu cầu khả năng truyền tải dữ liệu lớn.\n\t- sc1(HDD): Giá thấp nhất, để lưu trữ dữ liệu lớn và dữ liệu không được thường xuyên truy xuất.\n- Các đặc điểm của EBS Volume là: Size, Throughput, IOPS(I/O Operating Per Second)\n- Chỉ gp2/gp3 và io I/io2 mới có thể sử dụng để làm boot volumes. \n\n### 🍃 General Purpose SSD\n- Giá cả hợp lý, độ trễ thấp.\n- Sử dụng làm boot volumes, virtual desktops, development and test environments.\n- 1Gb - 16Tb\n|gp3|gp2|\n|----|----|\n|Baseline là 3000 IOPS và throughput of 125 Mib/s|Chỉ lên được 3000 IOPS là max|\n|IOPS và Throughput có thể set độc lập|IOPS và Throughput luôn linked với nhau|\n\n### 🍃 Provisioned IOPS\n- Dự án có nghiệp vụ quan trọng cần duy trì hiệu suất IOPS hoặc rõ hơn là cần nhiều hơn 16000 IOPS.\n- Là lựa chọn tuyệt vời cho **database workloads**\n- 4Gb - 16Tb\n\t- Max: 64000 IOPS với **Nitro EC2 instance** và 32000 với những EC2 instances thường.\n\t- Giống gp3, có thể nâng IOPS độc lập.\n\t- io2 có độ bền cao hơn và IOPS trên GiB cao hơn io1 với cùng mức giá.\n- io2 Block Express (4GB - 64 TB)\n\t- Độ trễ cực thấp.\n\t- Max: 256000 IOPS\n- Hỗ trợ Multi-attach\n\t- Cho phép một EBS Volume attach với nhiều EC2 Instances trong cùng một AZ.\n\t- Mỗi Instance đều có full quyền đọc ghi.\n\t- Max có thể attach được 16 Instances một lúc.\n\n### 🍃 Hard Disk Drivers\n- Không thể là một boot volume\n- 125GB - 16TB\n- Throughput Optimized HDD - st1\n\t- Use cases: Big Data, Data Warehouses\n\t- Max Throughput: 500 MiB/s - max IOPS 500\n- Cold HDD - sc1\n\t- Dùng để lưu trữ data không thường xuyên truy xuất\n\t- Chi phí thấp nhất\n\t- Max throughput 250MiB/s - max IOPS 250\n\n## 🌿 EBS Encryption\n- Mã hóa dữ liệu trước khi được lưu trữ.\n- Sau khi tạo một EBS Volume được mã hóa:\n\t- Toàn bộ data trong volume đều được mã hóa\n\t- Toàn bộ dữ liệu chuyển đổi giữa instance và volume đều được mã hóa\n\t- Tất cả snapshots đều được mã hóa.\n\t- Tạo volume mới phải tạo từ snapshot.\n- Cơ chế mã hóa và giải mã được thực hiện tự động.\n- Quá trình mã hóa không ảnh hưởng nhiều đến độ trễ.\n- Được mã hóa bởi thuật toán AES-256.\n- Nếu tạo một EBS volume không mã hóa, muốn chuyển qua một EBS volume mã hóa:\n\t- Tạo snapchat từ Volume đang sử dụng.\n\t- Tạo một Volume từ snapchat -\u003e chọn encrypt.\n\t- Attach tới EC2 Instance.\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/EC2-Elastic-Compute-Cloud":{"title":"🥦 EC2 - Elastic Compute Cloud","content":"\n## 🌿 What?\n- 🌱 EC2 - Elastic Compute Cloud - Infrastructure as a Service.\n- 🌱 Là một trong những Services được thuê nhiều nhất của AWS.\n- 🌱 Service này chủ yếu được sử dụng để:\n\t- Thuê virtual machines(EC2)\n\t- Lưu dữ liệu trên virtual drives([[40123345 posts/42 Code/42.03 AWS/EBS Volume - Elastic Block Store|EBS]] - Elastic Block Store)\n\t- Phân phối tải tới các máy ảo([[40123345 posts/42 Code/42.03 AWS/ELB - Elastic Load Balancing|ELB - Elastic Load Balancing]])\n\t- Auto-scaling group (ASG)\n\n## 🌿 EC2 sizing \u0026 Configuration options\n- 🌱 OS: Linux, Windows hoặc Mac OS.\n- 🌱 CPU: Cần tốc độ xử lý thế nào?\n- 🌱 RAM: Cần bộ nhớ đệm bao nhiêu?\n- 🌱 Storage space:\n\t- Network-attached ([[40123345 posts/42 Code/42.03 AWS/EBS Volume - Elastic Block Store|EBS]] \u0026 [[40123345 posts/42 Code/42.03 AWS/EFS - Elastic File System|EFS - Elastic File System]])\n\t- Hardware ([[40123345 posts/42 Code/42.03 AWS/EC2 Instance Store|EC2 Instance Store]])\n- 🌱 Network Card: tốc độ, Public IP address.\n- 🌱 Firewall rules: bảo mật\n- 🌱 Boootstap script(chạy 1 lần đầu tiên khi launch): EC2 User Data\n\n### 🌱 EC2 User Data\n- Chạy một số câu lệnh khi một máy ảo khởi chạy.\n- Script này chỉ chạy 1 lần duy nhất khi máy ảo khởi chạy lần đầu tiên.\n- Mục đích thường là để:\n\t- Installing updates\n\t- Installing software\n\t- Downloading common files from the internet\n\t- Hay bất kỳ tác vụ nào mà chúng ta muốn chạy.\n- Root user sẽ chạy EC2 User Data Script.\n\n## 🌿 EC2 instance types\n![[00 Meta/01 Attachments/Pasted image 20230225140557.png]]\n- 🌱 Choosing the kind of intance that fits best your application.\n- 🌱 Naming convention: ví dụ: **m5.2xlarge**\n\t- m: instance class\n\t- 5: gen 5\n\t- 2xlarge: size của instance(size, memory, CPU)\n- 🌱 Có 7 types.\n\n### 🍃 General Purpose Type\n- Sử dụng cho đa dạng workloads như web servers hoặc code repositories( hiểu là những tác vụ không có yêu cầu đặc biệt).\n- Cân bằng giữa:\n\t- Compute\n\t- Memory\n\t- Networking\n\n### 🍃 Compute Optimized Type\n- Sử dụng cho những ứng dụng có yêu cầu cao về hiệu suất tính toán, xử lý(CPU). Ví dụ như:\n\t- Batch processing workloads (tác vụ xử lý dữ liệu hàng loạt)\n\t- Media transcoding\n\t- Web servers hiệu năng cao\n\t- HPC - High performance computing\n\t- Machine Learning \u0026 Modeling (mô hình hóa)\n\t- Gaming servers\n- Instance class: C (CPU)\n\n### 🍃 Memory Optimized Type\n- Sử dụng cho những ứng dụng có yêu cầu cao về tốc độ xử lý những bộ dữ liệu lớn trong bộ nhớ(RAM). Ví dụ như: \n\t- Cần high performance để xử lý dữ liệu.\n\t- Ứng dụng cần xử lý real-time với những bộ dữ liệu không cấu trúc lớn.\n\t- Databases optimized for BI(business intelligence)\n- Instance class: thường là R (RAM)\n\n### 🍃 Storage Optimized Type\n- Sử dụng với những ứng dụng thường xuyên phải tương tác với dữ liệu(đọc, ghi) ở local storage. Ví dụ như:\n\t- Hệ thống xử lý transaction online (OLTP).\n\t- Databases(Relational \u0026 NoSQL)\n\t- Cache dữ liệu(Redis)\n\t- Data warehousing\n\t- Lưu files.\n\n## 🌿 Security Groups\n\n### 🍃 Overview\n- 🌱 Là nền tảng an ninh mạng của AWS.\n- 🌱 Kiểm soát cách traffic tương tác với các EC2 Instances của chúng ta.\n- 🌱 Security groups **chỉ chứa allow rules.**\n- 🌱 Rules có thể tham chiếu theo IP hoặc Security Group. \n\n### 🍃 Deeper dive\n- 🌱 Hoạt động như một \"firewall\" bảo vệ cho EC2 Intances.\n- 🌱 Qui định:\n\t- Truy cập vào các cổng\n\t- Trao quyền IP ranges -  IPv4 và IPv6\n\t- Kiểm soát inbound connect (từ bên ngoài vào instance)\n\t- Kiểm soát outbound connect (từ instance ra bên ngoài)\n\n### 🍃 Good to know\n- 🌱 Có thể attached tới nhiều instances.\n- 🌱 Locked down một khu vực\n- 🌱 Sẽ tốt hơn khi có một security group riêng để truy cập bằng SSH\n- 🌱 Nếu app của bạn ko truy cập được(time out), có thể security group có vấn đề.\n- 🌱 Nếu app nhận được \"connection refused\", là do app có vấn đề hoặc EC2 intance chưa được launched.\n- 🌱 Mặc định tất cả inbound traffic sẽ bị blocked.\n- 🌱 Mặc định tất cả outbound traffic được thông qua.\n\n![[00 Meta/01 Attachments/Pasted image 20230227215728.png]]\n\n### 🍃 Classic Port\n- 🌱 22 = SSH - log into a Linux instance\n- 🌱 21 = FTP (File Transfer Protocol) - upload files\n- 🌱 22 = SFTP (Secure File Transfer Protocol)\n- 🌱 80 = HTTP\n- 🌱 443 = HTTPS\n- 🌱 3389 = RDP ([[50 til/51 Code/51.06 Servers/Remote Desktop Protocol|Remote Desktop Protocol]]) - log into a Windows intance.\n\n## 🌿 Purchasing Options\n- Cần lựa chọn các phương án phù hợp với nhu cầu sử dụng và tối ưu chi phí.\n\n### 🍃 On-Demand Instances\n- 🌱 Đoán trước được chi phí, dùng đến đâu trả đến đấy.\n\t- Nếu dùng Linux or Windows - trả tiền theo từng giây, sau phút đầu tiên\n\t- Tất cả OS còn lại - trả tiền theo giờ.\n- 🌱 Có giá cao nhất khi không thanh toán trước.\n- 🌱 Không cần phải cam kết thời gian sử dụng.\n- 🤔 Nên sử dụng cho short-term và un-interrupted workloads, những dự án chúng ta không thể dự đoán được triển vọng tương lai cũng như yêu cầu tài nguyên:\n\t- Dự án kiểm thử.\n\t- Dự án cần triển khai nhanh nhưng có thể đóng bất kì lúc nào.\n\n### 🍃 Reserved Instances (1 \u0026 3 years)\n- 🤔 Sử dụng cho các dự án dài hạn, vì thuê thời gian dài nên AWS sẽ discount tùy theo thời gian chúng ta thuê là bao lâu. Các dự án ví dụ như:\n\t- Một trang blog\n\t- Duy trì một database\n- Rẻ hơn nhiều so với On-demand instances.\n- Có thể chọn attributes(type, region, OS,tenancy)\n- Càng thuê nhiều năm càng được discount nhiều.\n- No upfront(+), Partial Upfront(++), All Upfront(+++)\n- Lựa chọn đuọc phạm vi: region, zone.\n- Có thể mua hoặc bán trên Reserved Instance Marketplace tùy theo nhu cầu.\n\n- Convertible Reserved Instances - long workloads\n\t- flexible instances(có thể thay đổi được type, OS, family, tenancy của instance)\n\n### 🍃  Savings Plans(1 \u0026 3 years)\n- Long workloads.\n- Discount dựa theo thời gian sử dụng(thuê càng lâu càng rẻ)\n- Cam kết về số lượng sử dụng(vd 10$/hour for 1 - 3 years)\n- Bất kì chi phí phát sinh nào sẽ tính theo giá của On-Demand instances.\n- Chỉ định được instance family và region(vd M5 in us-west-1)\n- Có thể thay đổi:\n\t- Instance size(m5.xlarge, m5.2xlarge)\n\t- OS\n\t- Tenancy(Host, Dedicated, Default)\n\n### 🍃 Spot Instances\n- Short workloads.\n- Lựa chọn rẻ nhất.\n- Có thể hiểu option này chúng ta sẽ thuê những EC2 Instances chưa có người sử dụng, cta sẽ đấu giá nó là 1$ để xài, nếu không có người trả giá cao hơn thì vấn có quyền sử dụng. Nếu ai trả cao hơn thì mất luôn 😗\n- Phù hợp với những servers chạy các tác vụ sẽ chạy lại khi có lỗi.Hoặc dự án thử nghiệm, không quan trọng khi bị dừng đột ngột.\n\t- Jobs\n\t- Image processing\n- Không phù hợp với những công việc quan trọng hoặc sử dụng cho database.\n\n#### 🌱 Terminate Spot Instances\n- Phải cancel **spot request** trước(có thể launch instances), việc này sẽ không terminate các EC2 Instances. Sau khi cancel, chúng ta tiếp theo mới thực hiện terminate các Instances.\n\n#### 🌱 Spot Fleets\n- Spot Fleets = Spot Instances + (optional) On-Demand Instances\n- Đạt được target capacity với mức phí hạn chế.\n- Stop launching khi đạt ngưỡng tải hoặc hạn mức chi phí.\n- Chiến lược sắp xếp Spot Instances:\n\t- lowestPrice\n\t- diversified\n\t- capacityOptimized\n- Cho phép chúng ta tự động request Spot Instances với chi phí thấp nhất.\n\n### 🍃 Dedicated Hosts\n- Thuê hẳn một server vật lý.\n- Đắt nhất.\n- Công ty tổ chức nào có tiền thì xài, hoặc phần mềm có những yêu cầu đặc thù(ví dụ như các phần mềm của chính phủ)\n\n### 🍃 Dedicated Instances\n- Thuê riêng hardware để chạy instances, chỉ mình mình dùng thôi, ko có thằng nào dùng chung hardware với mình cả.\n\n### 🍃 Capacity Reservations\n- Có thể đặt trước ở một AZ bất kỳ thời gian nào.\n- Truy cập vào EC2 bất cứ khi nào.\n- Không cần cam kết thời gian. không có discount.\n- Trả tiền theo tỉ lệ của On-Demand \n\n![[00 Meta/01 Attachments/Pasted image 20230228222033.png]]\n\n## 🌿 Some notes\n- 🌱 Khi start lại một EC2 Instance, Private IPv4 giữ nguyên còn Public IPv4 có thể bị thay đổi.","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/EC2-Hibernate":{"title":"🥦 EC2 Hibernate","content":"\n## 🌿 What?\n![[00 Meta/01 Attachments/Pasted image 20230302224154.png]]\n- Là một service giúp giữ lại trạng thái, toàn bộ bộ nhớ của một instance vào ổ đĩa EBS trước khi nó stop hoặc bị terminate.\n- Giúp Instance khởi động nhanh hơn.\n- Root EBS volume phải được mã hóa.\n- Giúp tiết kiệm chi phí khi chúng ta có thể giải phóng tài nguyên khi không cần sử dụng và không sợ phải mất dữ liệu hoặc cấu hình của một instance.\n- Use cases:\n\t- Những dự án có tiến trình khởi chạy lâu.\n\t- Muốn lưu trữ trạng thái của RAM.\n\n\n## 🌿 Good to Know\n- Hỗ trợ các Instance Families: C3, C4, C5, I3, M3, M4, R3, R4, R2, T3, ...\n- Instance RAM size: phải nhỏ hơn 150Gb\n- Root Volume: phải là EBS, được mã hóa. Không hỗ trợ với những Instances sử dụng **instance store** và volume lớn.\n- Có sẵn với các purchasing options sau: On-Demand, Reserved và Spot Instances.\n- Một instance không thể lưu trữ trạng thái quá 60 ngày(có thể thay đổi số này nhưng đây là thời gian tiêu chuẩn).","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/EC2-Instance-Store":{"title":"🥦 EC2 Instance Store","content":"\n## 🌿 What?\n- Cho phép lưu trữ dữ liệu của 1 EC2 Instance ở trên một ổ đĩa vật lý, được đặt cùng với máy chủ chứa Instance.\n- Khác với EBS Volume lưu trữ và truy xuất dữ liệu thông qua mạng, EC2 Instance Store có một đặc điểm sau:\n\t- I/O performance tốt hơn EBS Volume\n\t- Giảm thiểu khả năng xảy ra do sự cố mạng và hao tổn băng thông. Nhưng có khả năng bị mất dữ liệu do hardware xảy ra lỗi.\n\t- Mất dữ liệu khi EC2 Instance bị dừng hoặc xóa.\n\t- Nên sử dụng với những ứng dụng không cần lưu trữ dữ liệu dài hạn hoặc không thì cần phải thực hiện lưu trữ và backup bằng những dịch vụ khác.\n- Cân nhắc giữa EC2 Instance và EBS Volume để có lựa chọn phù hợp nhất với dự án.\n\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/ECS-Service-Auto-Scaling":{"title":"🥦 ECS Service Auto Scaling","content":"\n## 🌿 What?\n- Tự động tăng hoặc giảm số lượng desired(mong muốn) của ECS tasks.\n- Sử dụng **AWS Application Auto Scaling**\n\t- Scale theo CPU\n\t- Theo RAM\n\t- Theo số lượng request đếm được ở ALB\n- **Target Tracking** - scale dựa theo giá trị của một thông số chỉ định CloudWatch.\n- **Step Scaling** - scale dựa theo CloudWatch Alarm chỉ định.\n- **Scheduled Scaling** - scale dựa theo thời gian chỉ định(có thể dự đoán được thay đổi)\n\n- ECS Service Auto Scaling là ở **tasks level** != EC2 Auto Scaling là ở **EC2 instance level**.\n- Fargate Auto Scaling dễ dàng setup hơn vì nó là **serverless**.\n\n## 🌿 Auto Scaling EC2 Instances\n- Là Add thêm EC2 Instances.\n- **Auto Scaling Group Scaling**\n\t- Scale ASG dựa theo CPU\n\t- Add thêm EC2 Instances để đáp ứng nhu cầu sử dụng thực tế.\n- **ECS Cluster Capacity Provider**\n\t- Tự động cung cấp cũng như mở rộng cơ sở hạ tầng cho các ECS Tasks của chúng ta.\n\t- Capacity Provider được kết hợp với một Auto Scaling Group.\n\t- Add EC2 Instances khi thiếu capacity(CPU, RAM, ...)\n\n- Luôn ưu tiên sử dụng **ECS Cluster Capacity Provider**.\n\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/EFS-Elastic-File-System":{"title":"🥦 EFS - Elastic File System","content":"\n## 🌿 What?\n![[00 Meta/01 Attachments/Pasted image 20230304223657.png]]\n- Hệ thống quản lý file, có thể mounted tới nhiều EC2 Instances, ở nhiều AZ khác nhau. Một giải pháp hiệu quả để chia sẻ các files trên môi trường cloud.\n- Highly available, dễ dàng scale, chi phí(gấp 3 lần gp2), dùng đến đâu trả tiền đến đấy.\n- Use case: content management, web serving, data sharing, wordpress\n- Sử dụng giao thức NFSv4.1\n- Sử dụng Security Group để kiểm soát truy cập tới EFS.\n- Tương thích với Linux based AMI(not Windows)\n- Mã hóa sử dụng KMS\n- Scale tự động, dùng đến đâu trả đến đấy, không có đặt trước hay gì cả.\n\n\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/ELB-Elastic-Load-Balancing":{"title":"🥦 ELB - Elastic Load Balancing","content":"\n## 🌿 What?\n![[00 Meta/01 Attachments/Pasted image 20230305184858.png]]\n- Là dịch vụ phân phối tải tới các instances của hệ thống.\n\n## 🌿 Why to use?\n- Phân phối tải đều cho những instances của hệ thống, tránh tình trạng quá tải.\n- Expose một điểm truy cập(DNS) duy nhất cho ứng dụng\n- Vẫn hoạt động bình thường khi có lỗi ở một instance.\n- Cung cấp SSL cho web\n- Tách biệt được public traffic và private traffic.\n- Thực hiện heath check thường xuyên cho các instances.\n\n## 🌿 Types of load balancer on AWS\n- Nên dùng mấy cái gen mới, nó sẽ cung cấp nhiều tính năng mới hơn.\n- Một số load balancers có thể setup private hoặc public ELBs.\n\n### 🍃 Classic Load Balancer\n- v1 - 2009 - CLB (có warning deprecated nhưng vẫn available)\n- HTTP, HTTPS, TCP, SSL\n\n### 🍃 Application Load Balancer\n- v2 - 2016 - ALB\n- Hoạt động ở layer-7(Application) - HTTP\n- Hỗ trợ redirect(vd như từ HTTP sang HTTPS)\n- Routing\n\t- Dựa theo path trên URL\n\t- Dựa theo hostname trên URL\n\t- Dựa vào query string, hearders\n- ALB phù hợp với micro services và app chạy trên container(Docker || Amazon ECS)\n- Có tính năng ánh xạ cổng để điều hướng đến một cổng động trong ECS.\n- Target groups:\n\t- EC2 Instances (có thể được quản lý bằng Auto Scaling Group) - HTTP\n\t- ECS tasks (quản lý bởi ECS) - HTTP\n\t- Lambda functions - in a future lecture\n\t- IP Addresses - phải là private IPs\n- Có thể định tuyến đến nhiều target groups\n- Health checks là một target group.\n![[00 Meta/01 Attachments/Pasted image 20230305212402.png]]\n\n- Edit inbound rules Security Group của EC2 Instances để client phải truy cập qua ALB chứ không được truy cập trực tiếp qua publicIP của instance.\n![[00 Meta/01 Attachments/Screenshot 2023-03-06 at 09.14.22.png]]được truy cập trực tiếp từ public IP của Instance.\n\n### 🍃 Network Load Balancer\n- v2 - 2017 - NLB\n- Hoạt động ở layer-4(Transport)\n\t- Chuyển tiếp TCP \u0026 UDP traffic tới các instances.\n\t- Mỗi giaay xử lý được hàng triệu requests.\n\t- Độ trễ thấp hơn so với ALB (~100ms vs 400ms)\n- Có một static IP cho từng AZ, có thể sử dụng ElasticIP(hữu ích nếu dự án cần chỉ định IP)\n- Không được hỗ trợ trong free tier.\n- Target groups:\n\t- EC2 Instances\n\t- IP Addresses - must be private IPs\n\t- Application Load Balancer\n- Health check hỗ trợ qua các giao thức TCP, HTTP, HTTPS.\n### 🍃 Gateway Load Balancer\n- v3 - 2020 - GWLB\n- Hoạt động ở [[50 til/51 Code/51.06 Servers/Layer-3 - Network Layer|layer 3(Network layer)]] - IP Protocol\n- Để triển khai, scale và quản lý một cụm network virtual applicances trong AWS, vd như Firewalls, Intrusion Detection and Prevention Systems, ...\n- Kết hợp của:\n\t- **Transparent Network Gateway** - single entry/exit cho tất cả traffic\n\t- **Load Balencer** -  phân phối traffic tới các virtual appliances.\n- Sử dụng GENEVE protocol trên cổng 6081\n\n\u003e [!note] Note\n\u003e \n\u003e Khác với ALB và NLB, GWLB mục đích phân tải cho cụm ứng dụng ảo thực hiện các công việc ngăn ngừa các traffic độc hại vd như Firewall\n\n## 🌿 Security Group\n![[00 Meta/01 Attachments/Pasted image 20230305204858.png]]\n\n## 🌿 Sticky Session(Session Affinity)\n- Là tính năng điều hướng requests của cùng một người dùng đến cùng một instance. Đảm bảo tính nhất quán trong phiên làm việc cùa người dùng và tránh phân tán dữ liệu trên nhiều instances.\n- Tính năng hoạt động trên CLB \u0026 ALB\n- Gửi Cookie tới client, với mỗi request sau sẽ được gắn cookie để xác định phiên của người dùng, ELB sẽ thực hiện điều hướng tới cùng một instance. Khi cookie hết hạn, người dùng có thể được điều hướng qua một instance khác.\n- Use case: trong TH chúng ta không muốn thất lạc dữ liệu trong phiên hoạt động của người dùng.\n- Tuy nhiên, tính năng này cũng có khả năng gây nên mất cân bằng tải do nhiều user sticky trên một instance chẳng hạn.\n- Cookie name:\n\t- **Application-based Cookies**\n\t\t- Custom cookie\n\t\t- Application cookie\n\t- **Duration-based Cookies**\n\n## 🌿 Cross-Zone Load Balancing\n- Cân bằng tải cho tất cả các instances ở trên nhiều AZs.\n![[00 Meta/01 Attachments/Screenshot 2023-03-06 at 17.40.10.png]]\n- ALB\n\t- Mặc định được bật(có thể tắt ở phần edit attributes của target group)\n\t- Không phải trả phí\n- NLB \u0026 GWLB\n\t- Mặc định tắt\n\t- Bật lên thì phải trả tiền\n- CLB\n\t- Mặc định tắt\n\t- Không phải trả nếu bật\n\n\n## 🌿 SSL Certificates\n![[00 Meta/01 Attachments/Pasted image 20230306221530.png]]\n\n- Sử dụng X.509 certificate(SSL/TLS server certificate)\n- Có thể quản lý các certificates bằng ACM - Amazon Certificate Manager\n- Có thể tự tạo certificates.\n- HTTP listener:\n\t- Bạn cần có một default certificate\n\t- Bạn có thể thêm một danh sách các certs để hỗ trợ cho multiple domains\n\t- **Clients có thể sử dụng SNI - Server Name Indication để chỉ định hostname**\n\t- Có khả năng chỉ dịnh một chính sách bảo mật để hỗ trợ cho những phiên bản cũ SSL/TLS.\n\n### 🍃 Server Name Indication\n- Giải quyết vấn đề phải load nhiều chứng chỉ SSL trên cùng một web server.\n- Giao thức mới, yêu cầu người dùng phải chỉ định hostname của tên máy chủ target trong lần đầu thực hiện khởi tạo SSL handshake.\n- Server sẽ tìm ra đúng chứng chỉ hoặc trả về mặc định.\n- Chỉ work với ALB \u0026 NLB, CloudFront\n\n## 🌿 Connection Draining\n- **Feature naming**:\n\t- Connection Draining - for CLB\n\t- Deregistration Delay - for ALB \u0026 NLB\n- Là tính năng giúp cho ELB dừng gửi traffic tới một instance đang có vấn đề(unhealthy, deploy lại) nhưng vẫn giữ kết nối tới instance đó.\n- Có thể tắt tính năng này đi","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/ENI-Elastic-Network-Interfaces":{"title":"🥦 ENI - Elastic Network Interfaces","content":"\n## 🌿 What?\n-  Là một phần logic của một VPC - Virtual Private Cloud, đại diện cho một **virtual network card**. Cho phép instances kết nối với mạng VPC.\n- ENI có thể có những attributes sau:\n\t- Primary private IP, một hoặc nhiều IPv4 phụ.\n\t- Một Elastic IP trên tuengf private IPv4\n\t- Một public IPv4\n\t- Một hoặc nhiều Security Groups\n\t- Một địa chỉ MAC\n- Khi launch một instance sẽ tự động tạo ra một ENI.\n- Có thể tạo một ENI độc lập và sử dụng cho những trường hợp thay thế dự phòng. Ví dụ như Instance1 đang dùng ENI2 mà nó tạch, có thể chuyển ENI2 cho Instance2 để thay thế.\n- Bao một AZ chỉ định.\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Elastic-Beanstalk":{"title":"🥦 Elastic Beanstalk","content":"\n\n- Trên thực tế, một kiến trúc có thể áp dụng được cho rất nhiều các dự án hoăc một dự án có nhiều môi trường(dev, test, stg, production, ...). Mà mỗi dự án lại phải lọ mọ setup lại từng cái một (ELB, ASG, RDS, ElastiCache, ...) thì rất là một mỏi. Những lúc thế này, hãy nghĩ ngay tới **Elastic Beanstalk**.\n\n## 🌿 What?\n- **Elastic Beanstalk** sẽ tạo ra một môi trường giúp chúng ta thực hiện triển khai, mở rộng cho dự án. Chúng ta chỉ cần quan tâm đên source code phát triển tính năng của sản phẩm thôi.\n- Nó sử dụng toàn bộ các components mà chúng ta đã sử dụng: ELB, RDS, ASG, ...\n- Quan trọng là chúng ta vẫn có toàn quyền can thiệp vào quá trình config.\n- Beanstalk thì miễn phí còn các dịch vụ nó quản lý bên trong(EC2 Instance, ELB, ...) thì chúng ta phải trả tiền như bình thường.\n\n## 🌿 Components\n- **Application**: Tổng hợp toàn bộ các component của một Beanstalk(enviroments, configuration, versions, ...)\n- **Application Version**\n- **Environments**\n\t- Tổng hợp toàn bộ AWS resourecs để chạy một website(chỉ chạy được mỗi ứng dụng một môi trường)\n\t- **Tiers**- quản lý từng tầng, vd như tầng server và tầng worker.\n\t- Có thể tạo nhiều enviroments(test, dev, stg, production)\n\n![[00 Meta/01 Attachments/Pasted image 20230312233517.png]]\n\n## 🌿 Deployment modes\n- **Single Instance**\n![[00 Meta/01 Attachments/Pasted image 20230312233803.png]]\n\n- **High Availability**\n![[00 Meta/01 Attachments/Pasted image 20230312233815.png]]\n\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Hybrid-Cloud-for-Storage":{"title":"🥦 Hybrid Cloud for Storage","content":"\n## 🌿 What?\n- AWS thúc đẩy hybrid cloud\n\t- Một phần thuộc về cơ sở hạ tầng trên cloud\n\t- Một phần thuộc về cơ sở hạ tầng(mặt đất) của chúng ta.\n- Vậy làm thế nào để chúng ta có thể cho dữ liệu được giao tiếp mượt mà giữa hai hạ tầng đó? - **AWS Storage Gateway**\n\n## 🌿 AWS Storage Cloud Native Options\n![[00 Meta/01 Attachments/Pasted image 20230323222856.png]]\n\n## 🌿 AWS Storage Gateway\n- Là cầu nối giữa dữ liệu 'mặt đất' và dữ liệu trên cloud\n![[00 Meta/01 Attachments/Pasted image 20230323223125.png]]\n- **Use cases:**\n\t- Phục hồi thảm họa\n\t- Backup \u0026 restore\n\t- Làm tầng lưu trữ\n\t- cache\n- Types:\n\t- **S3 File Gateway**\n\t- **FSx File Gateway**\n\t- **Volume Gateway**\n\t- **Tape Gateway**\n\n### 🍃 S3 File Gateway\n![[00 Meta/01 Attachments/Pasted image 20230323223809.png]]\n- Có thể truy cập S3 File Gateway thông qua 2 giao thức là NFS và SMB.\n- **Hầu hết các dữ liệu thường xuyên được truy cập sẽ năm ở file gateway.**\n- Hỗ trợ S3 Standard, S3 Standard IA, S3 One Zone A, S3 Intelligent Tiering.\n- **Chuyển dữ liệu tới S3 Glacier bằng Lifecrycle Policy.**\n- Bucket sử dụng IAM roles để truy cập cho từng File Gateway.\n- Giao thức SMB tích hợp với Active Directory (AD) để xác thực người dùng.\n\n### 🍃 FSx File Gateway\n![[00 Meta/01 Attachments/Pasted image 20230323224430.png]]\n- **Local cache những dữ liệu thường xuyên được truy cập**\n- Tương thích với Window\n- Hữu ích cho việc nhóm các file và làm thư mục home.\n\n### 🍃 Volume Gateway\n![[00 Meta/01 Attachments/Pasted image 20230323225014.png]]\n- Sử dụng giao thức iCSI để giao tiếp giữa local và Volume Gateway\n- EBS snapshots có thể giúp restore dữ liệu 'mặt đất'.\n- **Cached volumes:** độ trễ thấp khi truy cập dữ liệu thường xuyên.\n- **Stored volumes:** lưu trữ được toàn bộ dữ liệu 'mặt đất', sắp lịch để backups dữ liệu vào S3.\n\n### 🍃 Tape Gateway\n![[00 Meta/01 Attachments/Pasted image 20230323225348.png]]\n- Với một số công ty vẫn thực hiện việc sao chép dữ liệu trên đĩa từ, có thể sử dụng option này. Luồng thì vẫn như trên, dữ liệu vẫn sẽ được lưu trữ trên cloud.\n- Dữ liệu trên S3 sẽ được lưu trữ trong Amazon Glacier hoặc Glacier Deep Archive.\n\n\n## 🌿 Hardware appliance\n![[00 Meta/01 Attachments/Pasted image 20230323225827.png]]\n- Với 4 options trên, chúng ta đều sẽ cài các gateway trên máy ảo ở dưới local để sử dụng. Nhưng nếu chúng ta không có đủ tài nguyên để add thêm một gateway, chúng ta có thể thuê hardware của AWS, sau đó cài gateway lên đấy.\n- Hoạt động với 3 options trên trừ S3 File Gateway.\n- Hữu ích cho việc backup hàng ngày hệ thống NFS ở những data centers nhỏ.\n\n## 🌿 Summary\n![[00 Meta/01 Attachments/Pasted image 20230323230247.png]]","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/IAM-Identify-and-Access-Management/Amazon-SSO":{"title":"🥦 Amazon SSO - Single Sign-On Service","content":"\n## 🌿 What?\n- Là dịch vụ cho phép đăng nhập một lần.\n- Quan trọng, dịch vụ này còn cung cấp giải pháp quản lý quyền truy cập cho các accounts, roles, ...\n- Có 3 kiểu xác định chính:\n\t- **Multi-Account Permission:**\n\t\t- Quán lý truy cập của nhiều accounts trong Organization của bạn.\n\t\t- Permission Sets - Là các bộ xác định quyền có thể sử dụng để assign cho các accounts.\n\t- **Application Assignment:**\n\t\t- Quản lý thông qua một bên thứ 3 kiểu Okta, Saleforce, ...\n\t\t- Bên thứ 3 sẽ cung cấp các thông tin như url, metadata, user info, ...\n\t- **Attribute-Base Access Control:**\n\t\t- Xác định quyền truy cập dựa vào attribute của account.\n\t\t- Vd quyền truy cập được xác định khác nhau với từng level account: junior, senior, expert,...\n\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/IAM-Identify-and-Access-Management/IAM-Identify-and-Access-Management":{"title":"🥦 IAM - Identify and Access Management","content":"\n## 🌿 What?\n- 🌱 Một Global service - Region nào cũng có.\n- 🌱 Sử dụng để tạo users và groups.\n- 🌱 Mỗi user đại diện cho một người trong tổ chức.\n- 🌱 Mỗi group chỉ chứa users, không chứa group khác.\n- 🌱 Users có thể không thuộc một group nào(ko best practice) và 1 user có thể thuộc nhiều groups.\n![[00 Meta/01 Attachments/Pasted image 20230222221540.png]]\n\n## 🌿 Why?\n- 🌱 Không bao giờ được cho tất cả users được sử dụng tất cả services. \n- 🌱 User cần làm gì -\u003e tạo quyền cho sử dụng cái đó. Tránh chi phí phát sinh(do user có thể launch được một đống services), vấn đề bảo mật. \n- 🌱 Users hoặc Groups có thể được assign JSON documents gọi là polices.\n\t![[00 Meta/01 Attachments/Pasted image 20230222224819.png|500]]\n\n\u003e [!note] Note\n\u003e \n\u003e The least privilege principle: Nguyên tắc đặc quyền tối thiểu.\n\n## 🌿 What is polices?\n- 🌱 Xác định quyền của users hoặc groups.\n- 🌱 Bao gồm:\n\t- Version\n\t- ID (optional)\n\t- Statement:\n\t\t- Sid: Statement id\n\t\t- **Effect**: Allow | Deny\n\t\t- **Principal**: account/user/role áp dụng policy\n\t\t- **Action**: những acctions được cho phép || không cho phép\n\t\t- **Resource**: những resources áp dụng policy \n\t\t- Condition(optional): điều kiện cho effect\n\n## 🌿 Protect mechanisms\n- 🌱 Set Password\n- 🌱 MFA - Multi Factor Authentication\n\t- 📳 Virtual MFA device: GG Authencitator, Authy(nhiều tokens trên một device)\n\t- 🔑 Universal 2nd Factor(U2F) Security Key: YubiKey by Yubico(3rd party of AWS)(một security key dùng được cho nhiều root accounts and IAM users)\n\t- Hardware Key Fob MFA  Device.\n\t- Hardware Key Fob MFA Device for AWS GovCloud(US)\n\n## 🌿 What's the AWS CLI?\n- 🌱 Cho phép tương tác với các AWS Services thông qua terminal thay vì AWS Mangement Console.\n- 🌱 Truy cập trực tiếp đến các APIs của các AWS Services.\n- 🌱 Có thể sử dụng script để quản lý resources cũng như một số task tự động.\n\n## 🌿 What's the AWS SDK?\n- 🌱 Software Development Kit, một cách khác để tương tác với AWS Services.\n- 🌱 Được nhúng trong chương trình của chúng ta(kiểu như thư viện).\n- 🌱 Hỗ trợ nhiều program languages, mobile devices and IoT devices.\n\n\n## 🌿 IAM Roles\n- 🌱 Một vài Intance Services sẽ cần thực hiện một số hành động và chúng ta cần thêm quyền cho chúng thông qua việc tạo IAM Roles.\n- 🌱 Common roles:\n\t- EC2 Instance Roles\n\t- Lambda Function Roles\n\t- Roles for CloudFormation\n\n## 🌿 IAM Security Tools\n- 🌱 IAM Credentials Report (account-level)\n\t-  Một danh sách tất cả các users của account và trạng thái của các credentials.\n- 🌱 IAM Access Advisor (user-level)\n\t- Hiển thị những service permissions đã tạo cho một user và thời gian cuối cùng những services đó được truy cập.\n\t- -\u003e theo dõi để nhận biết những permissions nào không được sử dụng -\u003e xóa nó đi, tuân thủ phương châm **The principle least privilege**.\n\n## 🌿 IAM Best Practice\n- 🌱 Không sử dụng root account, nên tạo một IAM account và chỉ định quyền cho account.\n- 🌱 Mỗi một người(physical user) = một AWS user. \n- 🌱 Nên assign users vào groups và chỉ định quyền cho group.\n- 🌱 Tạo một password mạnh cho policy, nếu lộ người khác có thể thêm quyền tùm lum \n- 🌱 Sử dụng MFA, nâng cao tính bảo mật.\n- 🌱 Tạo và sử dụng IAM Roles để chỉ định permissions đến những AWS services.\n- 🌱 Sử dụng Access Keys khi Programatic Access(CLI/SDK).\n- 🌱 Audit lại permissions của account bằng IAM Access Advisor.\n- 🌱 Never share IAM users \u0026 Access Keys.","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/IAM-Identify-and-Access-Management/Organizations":{"title":"🥦 Organizations","content":"\n## 🌿 What?\n- Global service\n- Là dịch vụ cho phép quản lý phân cấp trên nhiều AWS accounts. Tăng khả năng quản lý cũng như nhất quán về quyền truy cập và sử dụng tài nguyên của các tài khoản.\n- Account chính sẽ là account quản lý, các accounts còn lại là account thành viên.\n- Các accounts thành viên chỉ là một phần của organization.\n- Thanh toán cho toàn bộ các accounts - thanh toán một lần.\n- Nhận được lợi ích về giá từ nhu cầu sử dụng.\n- **Chia sẻ reserved instances và saving plans giữa các accounts**.\n- Có API để tự động tạo mới một AWS account.\n\n## 🌿 Advantages\n- Multi Account vs One account Multi VPC\n- Dùng tag tiêu chuẩn để phục vụ mục đính thanh toán.\n- Enable CloudTrail cho tất cả các accounts và gửi logs tới S3 của account trung tâm.\n- Gửi logs của CloudWatch cho account trung tâm.\n- Lập được các Cross Accout Rules với mục đích quản trị.\n\n## 🌿 Security: Service Control Policies(SCP)\n- IAM Policies cho phép apply cho OU(Organization Unit) hoặc các accounts để restrict User và Roless.\n- Không thể áp dụng đối với account quản lý(management account)\n- Cần phải xác định quyền hạn rõ ràng(không cho một account dùng hết các services được).\n","lastmodified":"2023-05-11T14:57:36.701913442Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Instantiating-Applications-Quickly":{"title":"🥦 Instantiating Applications Quickly","content":"\n- Thông thường, khởi chạy một app chúng ta sẽ thường chạy stack sau: EC2 instance, EBS, RDS, làm thế nào để tăng tốc khởi chạy stack này?\n- EC2 Instance:\n\t- Sử dụng **Golden AMI** - Là Image đã thực hiện install packages cũng như config từ trước rồi, giúp tăng tốc trong việc khởi chạy một instance mới.\n\t- **Bootstrap User Data** - Sử dụng User Data để thực hiện các tác vụ config động.\n\t- **Hybrid** Kết hợp giữa **Golden AMI** và **User Data** (Elastic Beanstalk)\n- EBS vs RDS:\n\t- Lưu trữ snapshot để thực hiện restore nhanh chóng \n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-Comprehend":{"title":"🥦 Amazon Comprehend","content":"\n## 🌿 What?\n- Là dịch vụ sử dụng trí tuệ nhân tạo để xử lý ngôn ngữ tự nhiên - **Natural Language Procssing - NPL.**  Nó cho phép phân tích và xử lý dữ liệu văn bản để trích xuất thông tin và đánh giá ý kiến.\n- Được quản lý hoàn toàn bởi AWS và là dịch vụ serverless.\n- Nó có thể:\n\t- Phân tích được ngôn ngữ của text.\n\t- Trích xuất ra các thông tin quan trọng.\n\t- Hiểu bối cảnh, cảm xúc của văn bản.\n\t- Phân tích từ khoá.\n\t- Tự động tổ chức thu thập các files văn bản dựa theo chủ đề.\n- Use cases:\n\t- Phân tích email của khách hàng, xem khách hàng cảm thấy thế nào thông qua feedback.\n\t- Tạo và nhóm các bài báo, bài nghiên cứu theo các chủ đề.\n## 🌿 Amazon Comprehend Medical\n- Là dịch vụ xử lý ngôn ngữ tự nhiên với những văn bản y khoa.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-Forecast":{"title":"🥦 Amazon Forecast","content":"\n## 🌿 What?\n- Là dịch vụ được quản lý hoàn toàn bởi AWS, sử dụng trí tuệ nhân tạo để đưa ra các dự đoán về xu hướng hoặc giá trị tương lai của dữ liệu, từ đó tăng tính chính xác  đồng thời giảm thiểu rủi ro của các quyết định.\n- Nó có khả năng:\n\t- Xử lý các dữ liệu thời gian: cho phép dễ dàng nhập các loại dữ liệu thời gian khác nhau từ các nguồn khác nhau, bao gồm cả dữ liệu không đầy đủ(ngắt quãng hoặc bị thiếu).\n\t- Chuẩn bị dữ liệu.\n\t- Xây dựng và triển khai models.\n\t- Quản lý models.\n- Use cases: được sử dụng rộng rãi ở nhiều lĩnh vực như tài chính, bản lẻ hay dự báo tiêu thụ điện năng, ...\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-Kendra":{"title":"🥦 Amazon Kendra","content":"\n## 🌿 What?\n- Là dịch vụ được quản lý hoàn toàn của AWS, sử dụng trí tuệ nhân tạo để tìm kiếm và khai thác thông tin từ nhiều nguồn dữ liệu khác nhau một cách thông minh. Giống con ChatGPT.\n- Giúp giảm thời gian tìm kiếm và nâng cao hiệu suất của người dùng.\n- Có khả năng hiểu được ngôn ngữ tự nhiên để tìm kiếm câu trả lời.\n- **Học tăng cường - Incremental Learning**, học liên tục từ chính những tương tác hoặc phản hồi của người dùng.\n- Bảo mật: đảm bảo dữ liệu được bảo vệ và chỉ có thể tương tác khi có quyền.\n- Use cases: Áp dụng cho các ngành bán lẻ, tài chính, lập trình, ... \n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-Lex-Amazon-Connect":{"title":"🥦 Amazon Lex \u0026 Amazon Connect","content":"\n## 🌿 What?\n- **Amazon Lex:**\n\t- Là dịch vụ chatbot dựa trên các cuộc đối thoại, cho phép người dùng xây dựng các ứng dụng đối thoại tự động với giọng nói và văn bản.\n\t- Có thể hiểu được nhiều ngôn ngữ.\n\t- Ứng dụng tạo chatbot hoặc call center bots.\n- **Amazon Connect:**\n\t- Là dịch vụ tổng đài điện thoại trên cloud.\n\t- Nhận cuộc gọi, tạo contact flows, dựa trên **virtual contact center**\n\t- Rẻ hơn 80% các giải pháp cho contact center truyền thống khác.\n\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-Personalize":{"title":"🥦 Amazon Personalize","content":"\n## 🌿 What?\n- Là dịch vụ được quản lý hoàn toàn bởi AWS, sử dụng trí tuệ nhân tạo để đào tạo và triển khai các hệ thống đề xuất sản phẩm hoặc nội dung cá nhân(kiểu như thuật toán recommend video của tiktok)\n- Tăng trải nghiệm sử dụng ứng dụng cho người dùng.\n- Các tính năng:\n\t- Tính cá nhân hoá.\n\t- Đào tạo và triển khai mô hình.\n\t- Hỗ trợ sử dụng nhiều nguồn dữ liệu. Tích hợp được với các hệ thống khác(websites, apps, ...).\n\t- Bảo mật.\n- Use case: ứng dụng cho các lĩnh vực bán lẻ, giải trí hoặc truyền thông.","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-Polly":{"title":"🥦 Amazon Polly","content":"\n## 🌿 What?\n- Là dịch vụ sử dụng trí tuệ nhân tạo để chuyển đổi văn bản thành giọng nói. \n- Có thể custom từ vực cho Polly với **Pronunciation lexicons.**\n\t- Stylized words: St3ph4ne =\u003e 'Stephane'\n\t- Acronyms: AWS =\u003e 'Amazon Web Services'\n- Upload lexicons và sử dụng chúng trong **SynthesizeSpeech**.\n- Tạo giọng nói từ văn bản hoặc từ tài liệu với **Speech Synthesis Markup Language(SSML)**\n\t- Thêm ngắt nghỉ.\n\t- Sử dụng giọng điệu mà mình muốn ,...\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-Rekognition":{"title":"🥦 Amazon Rekognition","content":"\n## 🌿 What?\n- Là dịch vụ sử dụng Trí tuệ nhân tạo để **xử lý thông tin từ hình ảnh và videos**.\n- Nó có thể:\n\t- Phát hiện và phân tích khuôn mặt\n\t- Nhận dạng đối tượng: ô tô, xe máy, ...\n\t- Phân tích hoạt động.\n\t- Phát hiện và phân tích văn bản.\n\t- Tạo ra dữ liệu đào tạo và đối tượng chính xác.\n- Use cases:\n\t- Tìm kiếm phân tích khuôn mặt(giới tính, độ tuổi, tâm trạng, ...)\n\t- Giám sát an ning.\n\t- Quản lý nội dung.\n\t- Quản lý tài sản.\n## 🌿 Content Moderation - Kiểm duyệt nội dung\n- Tìm ra những nội dụng không cần thiết, phản cảm, ... của videos và images.\n- Sử dụng cho mạng xã hội, e-commerce, quảng cáo, ... để đem lại trải nghiệm tốt hơn cho người dùng.\n- Set Minimum Confidnce Threshold cho items để đánh dấu, những items này sẽ được đánh giá thủ công trong Amazon Augmented AI(A21), giúp nội dung tuân thủ theo đúng những quy chuẩn.\n\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-SageMaker":{"title":"🥦 Amazon SageMaker","content":"\n## 🌿 What?\n- Là dịch vụ được quản lý hoàn toàn bởi AWS, cung cấp một nền tảng đầyy đủ cho việc phát triển, đào tạo và triển khai các mô hình học máy cho các ứng dụng của nguời dùng.\n- Các tính năng:\n\t- Thu thập và chuẩn bị dữ liệu.\n\t- Xây dựng và train models.\n\t- Triển khai và quản lý models.\n\t- Giúp triển khai được cả các models đã được train ở nền tảng khác.","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-Textract":{"title":"🥦 Amazon Textract","content":"\n## 🌿 What?\n![[00 Meta/01 Attachments/Pasted image 20230406140231.png]]\n- Là dịch vụ sử dụng trí tuệ nhân tạo để trích xuất các thông tin quan trọng từ những tài liệu truyền vào.\n- Tự động hoá việc trích xuất dữ liệu, sàng lọc thông tin từ các tài liệu phức tạp, từ đó nâng cao hiệu suất làm việc.\n- Có thể đọc được nhiều định dạng tài liệu(PDFs, images, ...)\n- Thường được dùng để phân tích nhiều loại tài liệu khác nhau như hoá đơn, báo cáo tài chính, biểu mẫu, bảng tính, ...\n- Có thể tích hợp với nhiều services khác như [[40123345 posts/42 Code/42.03 AWS/S3|S3]], [[40123345 posts/42 Code/42.03 AWS/Amazon DynamoDB|DynamoDB]], [[40123345 posts/42 Code/42.03 AWS/Amazon Aurora|Aurora]], [[40123345 posts/42 Code/42.03 AWS/Machine Learning/Amazon Comprehend|Comprehend]], ...\n- Các dữ liệu này sẽ được bảo mật.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-Transcript":{"title":"🥦 Amazon Transcript","content":"\n## 🌿 What?\n- Là một dịch vụ sử dụng trí tuệ nhân tạo để nhận dạng giọng nói của các file âm thanh hoặc videos và chuyển đổi thành văn bản.\n- Gọi **ASR(automatic speech recognition)** để chuyển đổi từ các cuộc hội thoại sang văn bản một cách nhanh chóng và chính xác.\n- **Tự động bỏ những thông tin cá nhân của người(Personally Identifiable Information - PII) bằng Redaction.**\n- **Tự động detect được ngôn ngữ của các đoạn hội thoại.**\n- Use cases:\n\t- Detect văn bản từ những cuộc gọi với KH.\n\t- Làm phụ đề cho video.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Monitoring/AWS-Config":{"title":"🥦 AWS Config","content":"\n## 🌿 What?\n- Là dịch vụ quản lý cầu hình, cung cấp khả năng theo dõi và kiểm soát cấu hình tài nguyên của các AWS services.\n- Giúp kiểm tra cũng như tuân thủ các luật lệ cho mỗi account.\n- Giúp lưu lại config và có thể thay đổi bất kỳ lúc nào.\n- Các vấn đề có thể giải quyết với AWS Config:\n\t- Có cái truy cập SSH không được unsretricted truy vập vào sg không?\n\t- Buckets có bao nhiêu truy cập public?\n- Có thể nhận được thông báo ([[40123345 posts/42 Code/42.03 AWS/Amazon SNS - Simple Notification Service|SNS]]) khi có bất kỳ thay đổi nào.\n- AWS Config là một dịch vụ riêng trên từng region.\n- Có thể tổng hợp các dịch vụ từ nhiều regions và accounts.\n- Có thể lưu config vào [[40123345 posts/42 Code/42.03 AWS/S3|S3]] và dùng [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon Athena|athena]] để phân tích dữ liệu.\n\n## 🌿 Rules\n- Rules có thể được sử dụng để đánh giá/ trigger:\n\t- Cho những config thay đổi.\n\t- and/or tại một thời điểm bất kỳ\n**- Nó không được dùng với mục đích ngăn ngừa các actions có thể xảy ra.**\n- Giá: \n\t- không có free tier\n\t- 0.003$ cho từng config item lưu trên một region\n\t- 0.001$ cho từng rule đánh giá trên một region\n\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Monitoring/Amazon-CloudTrail":{"title":"🥦 Amazon CloudTrail","content":"\n## 🌿 What?\n- Là dịch vụ cung cấp khả năng ghi lại toàn bộ logs từ các hoạt động của một AWS account.\n- Giúp dễ dàng hơn trong việc kiểm tra, tuân thủ của các tài khoản AWS.\n- Dịch vụ này được bật mặc định.\n- Ghi lại logs từ:\n\t- Console\n\t- SDK\n\t- CLI\n\t- AWS Services\n- Có thể đặt logs của CloudTrail trong [[40123345 posts/42 Code/42.03 AWS/Monitoring/Amazon CloudWatch|CloudWatch]] Logs hoặc [[40123345 posts/42 Code/42.03 AWS/S3|S3]].\n- **Một trail có thể áp dụng cho All Regions(mặc định) hoặc chúng ta cũng có thể set cho một region riêng biệt.**\n- Nếu một resource bị xóa thì đầu tiên, nó sẽ được ghi vào CloudTrail.\n\n## 🌿 Events\n- **Management Events:**\n\t- Là các events thực hiện trên các resources với AWS account.\n\t- Ví dụ như:\n\t\t- Tạo Security Group\n\t\t- Config rules cho routing data(Amazon EC2 CreateSubnet)\n\t- Mặc định, Trail config là bật để log management events.\n\t- Có thể tách biệt **Read Event** từ **Write Event**\n- **Data Events:**\n\t- Mặc định cái này không được bật.\n\n## 🌿 Insights\n- Bật CloudTrail insight để có thể tìm ra được các hoạt động bất thường trong một AWS account.\n- Nó sẽ phân tích các management events bình thường để tạo ra một đường cơ sở, đánh giá được mức độ sử dụng.\n- **CloudTrail Insight liên tục phân tích các write events phát hiện sớm các patterns bất thường trong quá trình hoạt động.**\n![[00 Meta/01 Attachments/Pasted image 20230409205300.png]]\n\n## 🌿 Retension\n- Lưu trong CloudTrail: tối đa 90 ngày\n- Trong [[40123345 posts/42 Code/42.03 AWS/S3|S3]]: 4ever.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Monitoring/Amazon-CloudWatch":{"title":"🥦 Amazon CloudWatch","content":"\n## 🌿 What?\n- Là một dịch vụ giám sát, ghi log và cảnh báo trên môi trường cloud của AWS. Nó giúp chúng ta giám sát tài nguyên và ứng dụng trên AWS, thu thập và phân tích các dữ liệu khác nhau, cung cấp các thông tin về hoạt động và hiệu suất của các tài nguyên và ứng dụng của chúng ta.\n\n## 🌿 CloudWatch Metrics\n- Là tính năng của CloudWatch cung cấp các thông số hiệu suất hoạt động của tất cả các services của AWS.\n- **Metric** là một biến để giám sát(CPUUtilization, network, ...)\n- Các Metrics thuộc về các **namespaces**.\n- **Dimension** là một thuộc tính của một metric(instance id, environment, ...)\n- Tối đa là 30 dimensions cho từng metric.\n- Các metrics đều có **timestamps**.\n- Có thể tạo CloudWatcch dashboards từ các metrics.\n- Có thể tạo **CloudWatch Custom Metrics** để trích xuất dữ liệu cần thiết(ví dụ như trích xuất metric của RAM của EC2 instance, ...)\n\n### 🌱 Streams\n- Có thể liên tục stream các thông số hiệu suất của app tới các destinations khác để thực hiện các tác vụ như lưu trữ, phân tích ... với tần suất **near-real-time** và độ trễ thấp.\n- Có thể lựa chọn **filters metrics** để chỉ định stream tới destinations.\n![[00 Meta/01 Attachments/Pasted image 20230408140045.png]]\n\n## 🌿 CloudWatch Logs\n- Là tính năng của CloudWatch giúp chúng ta lưu trữ Logs của hệ thống.\n- **Log groups**: thường là đại diện cho một app.\n- **Log stream:** instances bên trong app / log files / containers.\n- Có thể xác định thời gian hết hạn của log(nerver, 30 days, ...), sau thời gian hết hạn, log sẽ tự động được xóa. Chúng ta sẽ phải trả tiền để được lưu log trên AWS.\n- **CloudWatch Logs có thể gửi logs tới:**\n\t- Amazon [[40123345 posts/42 Code/42.03 AWS/S3|S3]]\n\t- [[40123345 posts/42 Code/42.03 AWS/Amazon Kinesis|Kinesis]] Data Streams\n\t- [[40123345 posts/42 Code/42.03 AWS/Amazon Kinesis|Kinesis]] Data Firehose\n\t- AWS [[40123345 posts/42 Code/42.03 AWS/AWS Lambda|Lambda]]\n\t- [[40123345 posts/42 Code/42.03 AWS/Amazon OpenSearch Service|OpenSearch]]\n\n### 🌱 Filter \u0026 Insights\n- Có thể filter để xem log dễ dàng hơn.\n- Metric filters có thể được sử dụng để trigger CloudWatch alarms.\n- CloudWatch Logs Insight có thể được sử dụng để query logs và thêm các câu queries để làm Dashboards.\n\n### 🌱 Log Subcriptions\n- Dùng **Subcription Filter** để điều hướng đến các dịch vụ tùy theo nhu cầu sử dụng của dự án.\n![[00 Meta/01 Attachments/Pasted image 20230408141720.png]]\n\n- Kiến trúc để thu thập logs từ nhiều accounts, regions về một chỗ:\n![[00 Meta/01 Attachments/Pasted image 20230408141817.png]]\n\n## 🌿 Agent \u0026 Logs Agent\n- Mặc định sẽ không có logs từ EC2 machine tới CloudWatch. Để thu thập logs của EC2, chúng ta cần tạo một CloudWatch Agent đặt trong EC2 và nó sẽ thu thập + push log lên CloudWatch.\n- Lưu ý về IAM permissions.\n- CloudWatch log agent có thể setup được cả ở những server on-premises\n![[00 Meta/01 Attachments/Pasted image 20230408144534.png]]\n\n## 🌿 Alarms\n- Là dịch vụ dùng để trigger các thông báo của các metrics.\n- Có nhiều options(sampling, % max, min, ...) để thực hiện trigger\n- Alarm States:\n\t- OK\n\t- INSUFFICIENT_DATA\n\t- ALARM\n- Period - thời gian tính theo giây, để đánh giá metric.\n\t- có thể custom: 10s, 30s hoặc nhiều lần 60s.\n- Targets - đối tượng trigger của alarms:\n\t- Stop, Terminate, Reboot hoặc Recover EC2 Instance.\n\t- Trigger đến Auto Scaling Action.\n\t- Gửi thông báo đến [[40123345 posts/42 Code/42.03 AWS/Amazon SNS - Simple Notification Service|SNS]].\n\n### 🌱 Composite Alarms\n- CloudWatch Alarms là một metric đơn lẻ.\n- Composite alarms sẽ giúp chúng ta giám sát được trạng thái của nhiều alarms khác nhau.\n- Có thể kết hợp điều kiện AND hoặc OR để kết hợp các alarms, tránh gặp những alarm noise không cần thiết.\n\t- Ví dụ high CPU và high Network là bình thường, mình chỉ cần nó alarm lúc bất thường như high CPU những low Network. Đó chính là tác dụng của Composite Alarms.\n\n- Alarms có thể được tạo dự trên CloudWatch Logs Metrics Filters.\n\n## 🌿 Insight\n- **Container insight:**\n\t- Trích xuất, tổng hợp logs và metrics của các container trong AWS, sử dụng CloudWatch Agent.\n- **Lambda insight:**\n\t- Trích xuất, tổng hợp logs và metrics cho các ứng dụng có kiến trúc serverless.\n- **Contributes insight:**\n\t- Cung cấp các thông tin chi tiết, dễ dàng tìm kiếm các thông số có giá trị bất thường.\n- **Application insight:**\n\t- Tự động tạo bảng thống kê, phản ánh các vấn đề của hệ thống hoặc của các AWS services.\n\n\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Monitoring/Amazon-EventBridge":{"title":"🥦 Amazon EventBridge","content":"\n## 🌿 What?\n- Là dịch vụ hỗ trợ quản lý các sự kiện trigger đến các serivecs của AWS.\n- Schedule: Cron jobs\n\t- vd như mỗi giờ trigger đến [[40123345 posts/42 Code/42.03 AWS/AWS Lambda|Lambda]] Function để thực hiện tác vụ gì đó.\n- Event Pattern: Event rules xác định tới một service sẽ thực hiện một tác vụ\n\t- vd: Khi có sự kiện IAM Root User đăng nhập, [[40123345 posts/42 Code/42.03 AWS/Amazon SNS - Simple Notification Service|SNS]] sẽ gửi email. \n![[00 Meta/01 Attachments/Pasted image 20230408155728.png]]\n\n## 🌿 Rules\n![[00 Meta/01 Attachments/Pasted image 20230408155818.png]]\n\n## 🌿 Schema Registry\n- EventBridge có thể phân tích các events trong bus và suy luận được ra **schema**.\n- **Schema Registry** cho phép bạn gen code ra cho app, nó sẽ giúp chúng ta biết trước dữ liệu được cấu trúc như thế nào trong bus.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Networking-VPC/AWS-Network-Firewall":{"title":"🥦 AWS Network Firewall","content":"\n## 🌿 What?\n- Bảo vệ cho toàn bộ [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/VPC - Virtual Private Cloud|VPC]].\n- Bảo vệ từ Layer 3 và 7.\n- Nó sử dụng AWS Network Load Balancer\n- Các rules được define được quản lý toàn bộ trên [[40123345 posts/42 Code/42.03 AWS/Security \u0026 Encryption/AWS Firewall Manager|AWS Firewall Manager]], để có thể áp dụng cho nhiều VPCs của nhiều accounts.\n![[00 Meta/01 Attachments/Pasted image 20230419220255.png]]\n\n- Hỗ trợ có thể define tới 1000 rules.\n- Traffic Filtering: Allow, drop hoặc aleart nếu bắt gặp traffic match với các rules đã define.\n- Active Flow Inspection: một biện pháp bảo vệ. Ngăn chặn các truy cập bất thường(giống như Network Load Balancerr)\n- Có thể send log tới S3, Athena, ... kết hợp với các dịch vụ khác để lưu trữ hoặc phân tích tùy theo nhu cầu của hệ thống.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Networking-VPC/AWS-Site-to-Site-VPC":{"title":"🥦 AWS Site-to-Site VPC","content":"\n## 🌿 What?\n- Là kiến trúc giúp kết nối các resources trong Private Subnet tới các server on-premise.\n![[00 Meta/01 Attachments/Pasted image 20230418211559.png]]\n- Gồm 3 thành phần:\n\t- Virtual Private Gateway đặt ở VPC trên AWS, có tránh nhiệm là cổng kết nối bên Cloud.\n\t- Cổng kết nối bên on-premise là Custimer Gateway(public IP) hoặc là NAT Device.\n- **Lưu ý:**  Phải nhớ bật **Route Propagation** để kết nối Virtual Private Gateway với VPC.\n- VPN CloudHub: Sử dụng khi cần kết nối đến nhiều servers on-premise.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Networking-VPC/Bastion-Host":{"title":"🥦 Bastion Host","content":"\n## 🌿 What?\n- Vì tất cả các EC2 Instances của chúng ta đều nằm trong [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/VPC - Virtual Private Cloud|VPC]], chính vì vậy không thể để người dùng trực tiếp từ bên ngoài truy cập vào được, sẽ có nhiều rủi ro về bảo mật.\n- Để giảm thiểu rủi ro, chúng ta sẽ tạo một Bastion Host trong một EC2 Instance, nó sẽ là một pháo đài dựng trước các EC2 server của chúng ta.\n- Con Bastion đặt public để người dùng SSH vào, sau SSH vào xong, người dùng sẽ tiếp tục từ đây SSH tiếp vào các EC2 Server.\n- Để tăng thêm tính bảo mật, có thể restrict subnet IP từ con Bastion luôn.\n- Lưu ý là cần setup Security Group để các phần có thể giao tiếp được với nhau.\n![[00 Meta/01 Attachments/Pasted image 20230416213349.png]]\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Networking-VPC/CIDR-Private-and-Public-IP":{"title":"🥦 CIDR, Private and Public IP","content":"\n## 🌿 CIDR - Classless Inter-Domain Routing\n- Là một method thực hiện viêc phân bổ các địa chỉ IP.\n- Được sử dụng trong **Security Groups** và networking của AWS nói chung.\n![[00 Meta/01 Attachments/Pasted image 20230416100447.png]]\n- Giúp chúng ta define một dải địa chỉ IP:\n\t- WWW.XX.YY.ZZ/34 =\u003e một IP\n\t- WWW.XX.YY.ZZ/0 =\u003e tất cả IPs trong dải đó.\n\t- Nhưng chúng ta có thể define: 192.168.0.0/26 =\u003e đại diện cho một dải 64 IPs 192.168.0.0 -\u003e 192.168.0.63\n\n## 🌿 Ingredients\n- Gồm 2 phần:\n\t- **Base IP**\n\t\t- Đại diện cho một dải IP.\n\t\t- 10.0.0.0, 192.168.0.0, ...\n\t- **Subnet Mask**\n\t\t- Xác định số lượng bits có thể thay đổi được trên IP\n\t\t- Các dạng hay gặp:\n\t\t\t- 8 \u003c=\u003e 255.0.0.0\n\t\t\t- 16 \u003c=\u003e 255.255.0.0\n\t\t\t- 24 \u003c=\u003e 255.255.255.0\n\t\t\t- 32 \u003c=\u003e 255.255.255.255\n\n- Cách xác định dải IP từ Subnet Mask:\n![[00 Meta/01 Attachments/Pasted image 20230416102226.png]]\n\n192.168.0.0/24 2^(32-24) IP \u003c=\u003e 192.168.0.0 -\u003e 192.168.0.255\n\n## 🌿 Private \u0026 Public IP\n- **Private IP là các dải sau:**\n\t- 10.0.0.0 -\u003e 10.255.255.255 (10.0.0.0/8)\n\t- 172.16.0.0 -\u003e 172.31.255.255 (172.16.0.0/12) -\u003e dải địa chỉ IP của AWS VPC\n\t- 192.168.0.0 -\u003e 192.168.255.225 (192.168.0.0/16)\n- **Tất cả các IPs còn lại thì là Public IP.**","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Networking-VPC/Direct-Connect-DX":{"title":"🥦 Direct Connect (DX)","content":"\n## 🌿 What?\n- Là dịch vụ cung cấp kết nối mạng riêng tư để kết nối giữa Data Center của chúng ta tới AWS.\n- Để sử dụng chúng ta cần setup một Virtual Private Gateway trên VPC.\n- DX giúp chúng ta vừa có thể kết nối public(như resources của S3) và private(EC2 Instances) trong cùng một kết nối.\n- Mạng riêng tư này nó băng thông rộng, độ trễ thấp và độ tin cậy cao. Giúp nâng cao hiệu suất của hệ thống, trải nghiệm của người dùng.\n- Use Cases:\n\t- Khi ứng dụng có dataset lớn và muốn sử dụng với giá thành thấp.\n\t- Trải nghiệm mạng đồng nhất, như là các ứng dụng realtime.\n\t- Hybrid Environments - có kết hợp giữa on-premise và cloud.\n- Dữ liệu được truyền tải không mã hóa, nhưng nó private.\n\n## 🌿 Diagram\n![[00 Meta/01 Attachments/Pasted image 20230418213808.png]]\n\n## 🌿 Direct Connection Gateway\n- Nếu chúng ta muốn kết nối giữa nhiều VPC ở khác regions(same accounts), chúng ta cần setup thêm **Direct Connection Gateway**.\n![[00 Meta/01 Attachments/Pasted image 20230418214044.png]]\n\n## 🌿 Connection Types\n- **Dedicated Connection - 1Gbs, 10Gbs, 100Gbs**\n\t- Cho một cái etherner vật lý luôn.\n\t- Order thông qua AWS, AWS sẽ liên hệ đến Partner để hỗ trợ lắp đặt\n- **Hosted Connection - 50Mbps, 500 Mbps, 10Gps**\n\t- Kết nối được cung cấp do bên Partner của AWS.\n\t- Option này chúng ta có thể add hoặc remove dựa theo nhu cầu sử dụng.\n\t- Có thể tăng lên 1Gbs, 2, 5, 10.\n- Thời gian để lắp đặt cái này khá lâu, thường mất tầm 1 tháng để có thể sử dụng được Direct Connection.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Networking-VPC/IGW-Internet-Gateway-Route-Tables":{"title":"🥦 IGW - Internet Gateway \u0026 Route Tables","content":"\n## 🌿 What?\n- Là dịch vụ cho phép các resources(vd như EC2) trong một [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/VPC - Virtual Private Cloud|VPC]] có thể kết nối được với internet.\n- HA, mở rộng chiều ngang theo nhu cầu sử dụng.\n- Phải được tạo riêng biệt với một [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/VPC - Virtual Private Cloud|VPC]].\n- Một [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/VPC - Virtual Private Cloud|VPC]] chỉ có thể connect với một IGW và ngược lại.\n- Và route tables cũng phải được chỉnh sửa.\n![[00 Meta/01 Attachments/Pasted image 20230416210334.png]]\n- Kịch bản là EC2 Instance sẽ dựa vào Route Table để connect tới Router, Router sẽ điều hướng requests qua Internet Gateway, từ đây sẽ thực hiện kết nối với internet.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Networking-VPC/IPv6-for-VPC":{"title":"🥦 IPv6 for VPC","content":"\n## 🌿 What is IPv6?\n- Vì IP v4 chỉ được thiết kế để cung cấp 4.3 tỉ địa chỉ IP, và nó sẽ sớm bị sử dụng hết, chính vì vậy mà IPv6 được ra đời với nhiệm vụ chính để thay thế cho IPv4.\n- IPv6 cung cấp **3.4 x 10^38** địa chỉ IP riêng biệt.\n- Tất cả các địa chỉ IPv6 đều là public và được định tuyến với internet(không có private range).\n- Range được xác định từ 0000 -\u003e ffff, format là x.x.x.x.x.x.x.x.x(x là hexadecimal)\n- Ví dụ: \n\t- 2001:db6:3333:4444:5555:6666:7777:8888\n\t- :: -\u003e tất cả 8 phần đều là số 0\n\t- 2001:db5:: -\u003e 6 phần cuối đều có số 0\n\t- ::1234:2345 -\u003e 6 phần đầu đều là số 0\n\t- 2001:db6::1234:2356 -\u003e 4 phần ở giữa đều là số 0\n\n## 🌿 IPv6 in [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/VPC - Virtual Private Cloud|VPC]]\n- **Lưu ý: Không thể tắt được IPv4 đối với [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/VPC - Virtual Private Cloud|VPC]] và subnets**\n- Chúng ta có thể bật thêm IPv6 để làm [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/CIDR, Private and Public IP|public IP]] và sử dụng chung với IPv4.\n- Các EC2 Instances sẽ ít nhất phải có 1 public IPv6 và 1 private IPv4.\n- [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/IGW - Internet Gateway \u0026 Route Tables|Internet Gateway]] có thể tương thích với cả 2 kiểu IP này.\n![[00 Meta/01 Attachments/Pasted image 20230419211149.png]]\n\n## 🌿 IPv6 trong Private Subnet\n![[00 Meta/01 Attachments/Pasted image 20230419212743.png]]\n- Theo luồng của IPv4, cũng có thể áp dụng cho IPv6 khi muốn kết nối internet, chúng ta sẽ tạo một [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/NAT Gateway|NATGW]] ở Public Subnet để điều hướng requests tới [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/IGW - Internet Gateway \u0026 Route Tables|Internet Gateway]], từ đây sẽ gửi requests lên internet.\n- Nhưng với IPv6, có thể trực tiếp tạo một Egress-only [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/IGW - Internet Gateway \u0026 Route Tables|Internet Gateway]], không cần đi vòng qua 2 thằng trên kia nữa.\n- Lưu ý là phải config trên [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/IGW - Internet Gateway \u0026 Route Tables|route table]] để kiểm soát traffic đúng yêu cầu sử dụng.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Networking-VPC/NACL-Network-Access-Control-List":{"title":"🥦 Network Access Control List","content":"\n## 🌿 What?\n- Là tường lửa có nhiệm vụ kiểm soát traffic vào và ra của một subnet.\n- Mỗi một subnet sẽ có một NACL riêng, khi tạo mới một subnet sẽ được gán với một NACL mặc định.\n- Bạn cần phải xác định các rules cho NACL:\n\t- Mỗi rule sẽ được gắn với một số (từ 1-32766), số càng lớn càng có độ ưu tiên giảm dần.\n\t- Rule xuất hiện trước sẽ được ưu tiên áp dụng.\n\t\t- vd nếu define rule 100 Allow và rule 200 Deny, thì vẫn được Allow.\n\t- Qui tắc cuối cùng được đánh dấu hoa thị, nếu đến cái rule này thì reject hết, không nói nhiều.\n\t- AWS khuyến nghị chúng ta nên đặt rule tăng dần với step là 100.\n- Những NACLs tạo mới tinh là nó sẽ reject tất cả. Còn với NACL mặc định. sẽ allow tất cả các traffic in/out.\n- NACL là một lựa chọn phù hợp khi chúng ta muốn chặn địa chỉ IP tại tầng subnet.\n\n## 🌿 Ephemeral Ports\n- Cung cấp các cổng giao thức TCP hoặc UDP ngẫu nhiên để hình thành một kết nối mạng tạm thời giữa các ứng dụng hoặc các thiết bị trên internet.\n- Clients sẽ connect tới một **defined port** và mong đợi rằng sẽ được nhận response từ một **ephemeral port**.\n![[00 Meta/01 Attachments/Pasted image 20230417221409.png]]\n\n\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Networking-VPC/NAT-Gateway":{"title":"🥦 NAT Gateway","content":"\n## 🌿 What?\n- Giống như  [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/NAT Instance|NAT Instance]], cũng có tác dụng để định tuyến traffic từ các EC2 Instances trong private subnet để kết nối internet, nhưng NAT Gateway sẽ được AWS hỗ trợ hết, mình chỉ cần dùng thôi.\n- Vì do AWS bảo kê nên nó HA, có khả năng mở rộng theo nhu cầu sử dụng của các instances trong subnet, có thể tự động khởi động lại khi có lỗi.\n- Không cần phải quản lý Security Group\n- NATGW được tạo trên một AZ chỉ định, và được gán một ElasticIP.\n- Bắt buộc phải kết hợp cùng với [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/IGW - Internet Gateway \u0026 Route Tables|IGW]].\n![[00 Meta/01 Attachments/Pasted image 20230417214127.png]]\n- Như đã biết thì trong Private Subnet không thể kết nối được với mạng internet, vì vậy cần phải sử dụng [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/IGW - Internet Gateway \u0026 Route Tables|route table]] để định tuyến traffic tới resource(ở đây là NATGW) bên public subnet để nó trigger tới Router,  Router như cái phễu đổ hết traffic vào [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/IGW - Internet Gateway \u0026 Route Tables|IGW]] để gửi lên internet. \n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Networking-VPC/NAT-Instance":{"title":"🥦 NAT Instance","content":"\n## 🌿 What?\n- NAT - Network Address Translation\n- Là một EC2 Instance trung gian giúp các EC2 Instances trong private subnets có thể kết nối được với internet.\n- NAT Instance phải được launch public\n- Phải tắt setting trong EC2: **Source / destination check**\n- Phải attach ElasticIP cho NAT Instance.\n- Phải config thêm [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/IGW - Internet Gateway \u0026 Route Tables|Route Table]] để định tuyến traffic của các EC2 Instance trong Private Submet sang NAT Instance.\n![[00 Meta/01 Attachments/Pasted image 20230417211518.png]]\n\n- Kiến trúc tương tự như sử dụng [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/IGW - Internet Gateway \u0026 Route Tables|IGW]], những sẽ thay thế bằng NAT Instance.\n![[00 Meta/01 Attachments/Pasted image 20230417211707.png]]\n\n## 🌿 Notes\n- Không được hỗ trợ kể từ 31/12/2020\n- Không HA/ không tự động thiết lập lại nếu có lỗi.\n\t- Cần phải config thêm như sử dụng [[40123345 posts/42 Code/42.03 AWS/ASG - Auto Scaling Group|ASG]] + script để resilient setup.\n- Băng thông kết nối internet phụ thuộc vào EC2 Instance Type\n- Ngoài ra chúng ta còn cần phải quản lý thêm Security Groups và Roles của Instance.\n- Nên lựa chọn sử dụng [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/NAT Gateway|NAT Gateway]] thay vì NAT Instance, nó outdate rồi.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Networking-VPC/Networking-Costs-in-AWS":{"title":"🥦 Networking Cost in AWS","content":"\n## 🌿 Những điều cần lưu ý\n![[00 Meta/01 Attachments/Pasted image 20230419214423.png]]\n**- Khi thực hiện tạo network trên AWS cần lưu ý:**\n\t- Sử dụng private network của AWS sẽ rẻ hơn 0.01$ \u003c 0.02$ so với public. Vì private là chúng ta sẽ sử dụng mạng riêng của AWS, còn public thì AWS sẽ phải trả cho chúng ta phần chúng ta sử dụng trên mạng public.\n\t- Để tối ưu chi phí và trong trường hợp chúng ta muốn các EC2 Instances có thể giao tiếp tính toán với nhau ở tốc độ cao, hãy đặt chúng ở cùng AZ.\n\n![[00 Meta/01 Attachments/Pasted image 20230419215114.png]]\n- Egress Traffic: outbound traffics(từ AWS ra ngoài - phải trả tiền)\n- Ingress Traffic: inbound traffics(từ ngoài vào AWS - miễn phí)\n- Như trên hình, nếu chúng ta lựa chọn đặt App ở local, outbound từ query DB sẽ rất là nhiều, và chúng ta phải trả với chi phí cao.\n- Thay vì đó, chúng ta hãy tạo tất cả các tài nguyên ở trên cloud, khi các dịch vụ giao tiếp với nhau trên môi trường cloud chúng sẽ không mất phí.\n- Ngoài ra trong trường hợp này chúng ta có thể sử dụng **Direct Connection** để kết nối từ cloud tới on-premise với chi phí rẻ hơn(cơ mà cái DC này lắp đặt cũng phải hơn tháng mới xong, nên cân nhắc nếu dự án cần sử dụng gấp thì bỏ nha).\n\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Networking-VPC/Transit-Gateway":{"title":"🥦 Transit Gateway","content":"\n## 🌿 What?\n![[00 Meta/01 Attachments/Pasted image 20230418215533.png]]\n- Với rất nhiều các dịch vụ sử dụng để kết nối giữa các VPCs, từ VPCs kết nối tới on-premise, các VPCs ở khác regions, ... Chính vì thế sẽ rất dễ làm cho cấu trúc liên kết mạng của hệ thống bị phức tạp, lâu dần sẽ khó mở rộng hoặc bảo trì, chưa kế đến vấn đề chi phí.\n- Giải pháp là sử dụng Transit Gateway, như kiểu cafe 3in1, có sữa có đường có cafe, chỉ cần đổ nước nóng vào là uống thôi.\n![[00 Meta/01 Attachments/Pasted image 20230418215840.png]]\n- Có thể kết nối giữa các region.\n- Chia sẻ trên nhiều accounts, sử dụng Resource Access Manager(RAM)\n- Có thể sử dụng peer Transit Gateway trên nhiều region.\n- Khi kết nối nhiều VPCs về một mối, cần chú ý setup [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/IGW - Internet Gateway \u0026 Route Tables|route table]] để kiểm soát traffic giữa các VPCs, tránh không cho giao tiếp lung tung.\n- Hỗ trợ **IP Multicast**\n\n## 🌿 ECMP - Equal-Cost Multi-Part routing\n![[00 Meta/01 Attachments/Pasted image 20230418220403.png]]\n- Sử dụng ECMP để giải quyết khi gặp bài toán cần kết nối với nhiều VPCs.\n\n\n## 🌿 Share Direct Connection between multiple accounts\n![[00 Meta/01 Attachments/Pasted image 20230418220706.png]]\n- Tạo cái Direct Connection Gateway(ko share cho nhiều accounts được) ở ngoài, trỏ tới Transit Gateway để nó share cho các VPCs ở những accounts khác.","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Networking-VPC/VPC-Endpoint":{"title":"🥦 VPC Endpoint","content":"\n## 🌿 What?\n- Là dịch vụ giúp chúng ta có thể kết nối trực tiếp từ trong private subnet tới các services khác của AWS, thông qua một private network của AWS được gọi là **privatelink**, thay vì thông qua internet.\n- Có thể đáp ứng tốt theo nhu cầu sử dụng, nó scale theo chiều ngang.\n- Không cần phải setup thêm [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/IGW - Internet Gateway \u0026 Route Tables|IGW]], [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/NAT Gateway|NATGW]], ... để kết nối. Giảm thiểu chi phí sử dụng.\n- Khi có vấn đề, lưu ý các thông tin sau:\n\t- Kiểm tra lại DNS Setting Solution trong [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/VPC - Virtual Private Cloud|VPC]].\n\t- Kiểm tra lại [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/IGW - Internet Gateway \u0026 Route Tables|Route Table]] xem đã định tuyến đúng chưa.\n![[00 Meta/01 Attachments/Pasted image 20230418204559.png]]\n\n## 🌿 Types\n- **Interface Endpoints (sử dụng privatelink)**\n\t- Cung cấp một ENI như một entrypoint, và nó phải được gán security group để kiểm soát traffic.\n\t- Hỗ trợ cho hầu hết các services của AWS.\n\t- Thanh toán theo giờ + GB dữ liệu xử lý.\n- **Gateway Endpoints**\n\t- Cung cấp một gateway và sử dụng route table để kiểm soát traffic, không dùng security group như thằng bên trên.\n\t- Hỗ trợ cho S3 và DynamoDB.\n\t- Miễn phí\n![[00 Meta/01 Attachments/Pasted image 20230418205018.png]]\n\n- **Với S3 nên sử dụng Gateway hay Interface endpoints?**\n\t- Thông thường trong hầu hết các trường hợp, gateway luôn được ưu tiên sử dụng do nó miễn phí.\n\t- Chỉ khi chúng ta cần kết nối S3 với server on-premise, từ một VPC hoặc region khác, thì cần phải sử dụng với Interface Endpoints.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Networking-VPC/VPC-Flow-Logs":{"title":"🥦 VPC Flow Logs","content":"\n## 🌿 What?\n- Là tích năng ghi lại các thông tin về IP traffic truy cập vào tài nguyên của VPC.\n\t- VPC Flow Logs.\n\t- Subnet Flow Logs.\n\t- Elastic Interface Network(EIN) Flow Logs.\n- Giúp giám sát và xử lý kịp thời các hoạt động bất thường trong hoạt động.\n- Logs có thể được lưu trong S3, kết hợp với một số các services khác thực hiện phân tích log để có cái nhìn tổng quan cũng như chi tiết hoạt động truy cập của VPC, ví dụ như kết hợp với CloudWatch.\n![[00 Meta/01 Attachments/Pasted image 20230418210225.png]]\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Networking-VPC/VPC-Peering":{"title":"🥦 VPC Peering","content":"\n## 🌿 What?\n- Là dịch vụ để tạo một kết nối riêng tư giữa 2 [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/VPC - Virtual Private Cloud|VPC]] sử dụng network của AWS.\n- Nó giúp cho các resources của 2 [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/VPC - Virtual Private Cloud|VPC]] như cùng chung một network.\n- Để sử dụng dịch vụ này, phải chắc chắn rằng không được overlap CIDRs.\n- Không có tính chất bắc cầu.\n![[00 Meta/01 Attachments/Pasted image 20230417222859.png]]\n- Nhớ là phải update [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/IGW - Internet Gateway \u0026 Route Tables|route table]] để chúng có thể giao tiếp được với nhau.\n\n- Có thể tạo VPC Peering giữa các VPCs ở khác accounts hoặc regions.\n- Có thể reference security group trong một peered VPC. \n\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Networking-VPC/VPC-Traffic-Miroring":{"title":"🥦 VPC Traffic Miroring","content":"\n## 🌿 What?\n- Là tính năng cho phép ghi lại và kiểm tra các traffic trong VPC.\n- Sao chép các traffic từ nhiều EC2 Instances hoặc ELB, sau đó chuyển tiếp đống traffic đấy tới một EC2 Instance khác để giám sát và phân tích.\n- Là tính năng nâng cao bảo mật.\n![[00 Meta/01 Attachments/Pasted image 20230418221624.png]]","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Networking-VPC/VPC-Virtual-Private-Cloud":{"title":"🥦 VPC - Virtual Private Cloud","content":"\n## 🌿 What?\n- Là dịch vụ cho phép tạo một môi trường mạng ảo trên AWS.\n- Giúp chúng ta có thể tạo và quản lý các tài nguyên mạng của mình như route table, subnets, hay tường lửa, ...\n- Có thể có nhiều VPCs trong một region.\n- Max CIDR trên một VPC là 5 đối với từng CIDR:\n\t- Min size là /28 - 16 IPs\n\t- Max size là /16 - 65,536 IPs\n- Bởi vì VPC là private IP, nên các giải IP nó nằm trong là:\n\t- 10.0.0.0/8\n\t- 172.16.0.0/12\n\t- 192.168.0.0/16\n- VPC CIDR không nên trùng với các mạng khác.\n\n## 🌿 Default VPC\n- Tất cả các accounts AWS mới đều có một VPC mặc định.\n- Một EC2 Instance sẽ được launch trong VPC mặc định nếu không được chỉ định subnet.\n- VPC mặc định có kết nối mạng và tất cả EC2 Instances trong đó sẽ có thể địa chỉ IPv4 public.\n- Chúng ta cũng có thể lấy một public và một private IPv4 DNS names.\n\n## 🌿 Subnet VPC\n- AWS sẽ giữ lại 5 địa chỉ IP(4 cái đầu tiên và 1 cái cuối cùng) cho từng subnet.\n- Chúng ta sẽ không thể assign 5 địa chỉ IP này cho các EC2 Instances được.\n- 5 địa chỉ này được giữ lại với mục đích:\n\t- 10.0.0.0: Network address\n\t- 10.0.0.1: AWS giữ lại cho VPC router\n\t- 10.0.0.2: AWS giữ lại để mapping tới DNS\n\t- 10.0.0.3: AWS giữ lại với mục đích dự phòng, sau này cần thì lôi ra sài.\n\t- 10.0.0.255: địa chỉ dành cho broadcast, AWS không hỗ trợ cái này nên địa chỉ này vứt xó.\n- Nếu trong bài thi có hỏi là cần 29 địa chỉ IP thì có thể suy ra là subnet mask phải cung cấp số địa chỉ IP \u003e 29 + 5 = 34 -\u003e /26 ","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Placement-Groups":{"title":"🥦 Placement Groups","content":"\n## 🌿 What?\n- 🌱 Về cơ bản, placement group cho phép chúng ta quản lý vị trí - nơi khởi chạy các EC2 Instances, từ đó nâng cao hiệu suất, giảm độ trễ , ...\n- 🌱 Có 3 strategies: Cluster, Spread, Partition\n\n### 🌿 Cluster\n![[00 Meta/01 Attachments/Pasted image 20230301224923.png]]\n- Các EC2 Instances cùng nằm trong một hardware - same rack, same AZ.\n- Ưu: \n\t- Great network - độ trễ rất thấp, 10Gbps network.\n- Nhược:\n\t- Chết là chết tất. Rủi ro cao.\n- Use cases:\n\t- Những dự án yêu cầu độ trễ cực thấp và khả năng truyền tải dữ liệu nhanh.\n\n### 🌿 Spread\n![[00 Meta/01 Attachments/Pasted image 20230301225129.png|500]]\n- Các EC2 Instances không cùng một một chỗ, thay vào đó sẽ được đặt riêng ở các hardwares khác nhau, ở nhiều AZ trên cùng một Region. \n- Ưu:\n\t- Giảm rủi ro chết chùm.\n- Nhược:\n\t- Giới hạn 7 instances cho mỗi placement group trên cùng một AZ(nhược với những dự án big size).\n- Use cases:\n\t- Những dự án đề cao khả năng availability(app mạng xã hội, ...)\n\t- Những dự án quan trọng, cần đảm bảo ít rủi ro.\n\n### 🌿 Partition\n![[00 Meta/01 Attachments/Pasted image 20230301225752.png|500]]\n- Kết hợp giữa Cluster và Spread. Mỗi một AZ có thể chứa 7 partions, mỗi một partion chứa những EC2 Instances - same rack.\n- Ưu:\n\t- Đảm bảo độ trễ cực thấp + truyền tải dữ liệu cao giữa các instances.\n\t- Giảm thiểu rủi ro khi một partion chết, các partions khác vẫn hoạt động bình thường.\n\t- Có thể setup hàng trăm EC2 Instances, xịn hơn spread nhiều.\n- Có thể xem thông tin vị trí của instance thông qua metadata của instance.\n- Use cases: \n\t- Khi chúng ta có dự án có thể nhận biết phân vùng để truyền tải dữ liệu, các ứng dụng big data sử dụng: HDFS, HBase, Cassandra án Apache Kafka","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Private-vs-Public-IP":{"title":"🥦 Private vs Public IP","content":"\n## 🌿 Overview\n- 🌱 Có 2 loại IP:\n\t- IPv4: [0-255].[0-255].[0-255].[0-255], ex: 1.160.10.250\n\t- IPv6\n- 🌱 IPv4 vẫn là format phổ biến nhất dùng cho web\n- 🌱 IPv6 mới hơn và được sử dụng cho IoT.\n- 🌱 IPv4 cho phép 3.7 tỷ địa chỉ khác nhau được public trên mạng/\n\n## 🌿 So sánh Private và Public IP\n- 🌱 Public IP:\n\t- Để máy chủ có thể định danh trên internet.\n\t- Uniq, không trùng với bố con thằng nào trên internet.\n\t- Có thể định vị vị trí thông qua public IP.\n\t- Thay đổi khi reboot lại instace.\n- 🌱 Private IP:\n\t- Để định danh máy trong một mạng nội bộ.\n\t- Phải Uniq trong mạng nội bộ.\n\t- 2 Companies khác nhau có thể có cùng một IP.\n\t- Những máy trong mạng nội bộ sẽ kết nối với WWW thông qua một internet gateway(a proxy)\n\t- Chỉ một range của IP được chỉ định mới có thể sử dụng như private IP.\n\t- Không thay đổi khi reboot lại instace.\n\n## 🌿 Elastic IP\n- 🌱 Như IP bình thường, khác cái là nó độc lập với instance, vì vậy chúng ta có thể dễ dàng thay đổi instance mà không cần gán lại địa chỉ IP.\n- 🌱 Chỉ có thể có 5 Elastic IP trong 1 tài khoản(có thể yêu cầu tăng thêm)\n- 🌱 Nên tránh dùng:\n\t- Chi phí\n\t- Quản lý\n\t- Khả năng mở rộng","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Redshift":{"title":"🥦 Redshift","content":"\n## 🌿 What?\n- Là một data warehouse, cung cấp khả năng lưu trữ và phân tích lượng dữ liệu cực lớn.\n- Base trên PostgreSQL **nhưng không sử dụng OLTP mà là OLAP - online analytical processing.**\n- Hiệu suât tốt hơn x10 só với các data warehouses khác.\n- Có thể scale từ một node tới hàng trăm nodes để đáp ứng nhu cầu sử dụng.\n- Lưu trữ dữ liệu dạng cột thay vì hàng, có engine thực hiện query đồng thời.\n- Trả phí dựa theo số lượng instances đã cung cấp.\n- Có một giao diện SQL để thực hiện queries.\n- Cung cấp các BI(business Intelligence) tools như Amazon Quicksight hoặc Taubleau.\n- **vs [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon Athena|Athena]]:** truy vấn / joins / tổng hợp dữ liệu nhờ indexes nhanh hơn.\n\n## 🌿 Cluster\n- Leader node: để lên kế hoạch truy vấn, tổng hợp các dữ liệu.\n- Compute node: để thực hiện truy vấn và gửi kết quả đến leader node.\n- Bạn cân cung cấp node size.\n- Có thể sử dụng Reserved Instances để tiết kiệm chi phí.\n![[00 Meta/01 Attachments/Pasted image 20230405222056.png]]\n\n## 🌿 Snapshots \u0026 DR\n- Có thể tạo snapshot và ứng dụng như của [[40123345 posts/42 Code/42.03 AWS/EBS Volume - Elastic Block Store|EBS]].\n![[00 Meta/01 Attachments/Pasted image 20230405222723.png]]\n\n## 🌿 Readshift Spectrum\n![[00 Meta/01 Attachments/Pasted image 20230405223314.png]]\n\n- Tăng khả năng xử lý phân tích dữ liệu cho [[40123345 posts/42 Code/42.03 AWS/S3|S3]].\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Route-53-Routing-Policy":{"title":"🥦 Route 53 - Routing Policy","content":"\n## 🌿 What?\n- Định nghĩa cách Route 53 phản hồi những câu truy vấn DNS.\n- Đừng nhầm lẫn từ **routing**\n\t- Không giống routing của ALB, đấy là định tuyến lưu lượng truy vấn.\n\t- Routing của Route 53 chỉ chịu trách nhiệm phản hồi những truy vấn DNS thôi.\n\n## 🌿 Types\n- Có những loại policies sau:\n\n### 🍃 Simple\n- Tiêu biểu, định tuyến tới một resource đơn lẻ.\n- Có thể chỉ định nhiều values cho một record.\n- **Nếu có nhiều values trả về, client sẽ pick ngẫu nhiên một value để thực hiện truy cập.**\n- Khi bật Alias, phải chỉ định tới một resouce duy nhất.\n- Không liên quan tới Health Check.\n\n### 🍃 Weighted - tỉ trọng\n- Kiểm soát phần trăm nhận requests được chỉ định cho từng resource.\n- Các DNS records phải cùng tên và cùng kiểu.\n- Có liên quan đến Health Check\n- Use cases: Load balancing giữa các region, testing version mới của ứng dụng, ...\n- Assign 0% cho một record, tức là resource đó sẽ không được gửi traffic.\n- Nếu tất cả record được set = 0, thì sẽ trả về trọng số bằng nhau cho tất cả các records.\n\n### 🍃 Latency based\n- Chuyển hướng tới resource có độ trễ thấp nhất đối với client. Phù hợp với những ứng dụng mà độ trễ được ưu tiên.\n- Vd client ở Việt Nam thì sẽ được điều hướng tới resouce đặt tại Singapore(Nếu ở đấy có độ trễ thấp nhất.)\n- Có Health check(để thực hiện chuyển đổi dự phòng)\n![[00 Meta/01 Attachments/Pasted image 20230311235240.png]]\n\n### 🍃 Failover\n- Tự động chuyển đổi dự phòng tới các instance healthy nếu primary instance được đánh giá là unhealthy.\n![[00 Meta/01 Attachments/Pasted image 20230312002759.png]]\n\n### 🍃 Geolocation\n- Khác với **Latency**(ở gần chưa chắc đã có độ trễ thấp nhất).\n- **Dựa vào vị trí của user để định tuyến**.\n- Nên tạo một **default** record(sẽ được sử dụng trong trường hợp không tìm được vị trí phù hợp)\n- Usage: web định vị(kiểu baemin, ở đâu thì xác định vị trí gần để giao hàng cho nóng), giới hạn phân phối nội dung tới từng khu vực, load balancer, ...\n- Có thể kết hợp với Health Check\n\n### 🍃 Geoproximity Route\n![[00 Meta/01 Attachments/Pasted image 20230312004415.png]]\n\n- Vẫn dựa vào vị trí của user và resouce, nhưng thằng này có khả năng điều chỉnh lượng traffic tới resouce bằng thông só bias. Set **bias** càng cao thì tỉ lệ traffic đổ về càng lớn.\n\n### 🍃 Multi-value\n- Dùng khi muốn định tuyến traffic tới nhiều resources.\n- Có thể kết hợp với Health Checks( sẽ chỉ trả về các values/resources healthy)\n- Tối đa trả về 8 values healthy cho từng query.\n- **Multi-Value không thay thế cho một ELB**.\n- Nó khác với **Simple**, vì nó có health checks, **Simple** trả về nhiều values nhưng có thể trong đó có unhealthy value.\n\n## 🌿 Health Check\n- HTTP Health Check chỉ sử dụng để check cho các public resources.\n- Health Check =\u003e Tự động chuyển đổi dự phòng nếu phát hiện ra unhealth resource.\n- Health Check được kết hợp với CW(CloudWatch) metrics.\n- Có 3 kiểu health check:\n\n### 🍃 **Monitor on endpoint**\n- Có khoảng 15 health checkers sẽ check health endpoint\n\t- Ngưỡng health/unhealthy mặc định = 3\n\t- 30s gọi check một lần ( có thể set xuống 10s nhưng phí đắt hơn)\n\t- Hỗ trợ giao thức: HTTP, HTTPS và TCP\n\t- Nếu \u003e 18% health checkers báo cáo là healthy thì Route 53 sẽ đánh giá nó là healthy và ngược lại.\n- Chỉ check pass với các responses có code là 2XX và 3XX\n- Có thể đánh giá Health dựa trên 5120 bytes đầu tiên của response.\n- Phải config route/firewall cho phép nhận requests từ Route 53 để Health Check.\n### 🍃 **Calculated health checks**\n- Kết hợp kết quả của nhiều health check con cho một healthcheck cha, để đánh giá tình trạng sức khỏe của resource.\n- Có thể sử dụng **AND, OR, NOT**\n- Có thể set max 256 health check con.\n- Chỉ định số lượng health check con pass là bao nhiêu để health check cha pass.\n- Usage: thực hiện bảo trì.\n### 🍃 **Private Hosted Zones**\n- Route 53 thực hiện health check từ bên ngoài VPC.\n- Do không thể truy cập trực tiếp tới các **private endpoints**, nên cần phải tạo CloudWatch và Route 53 đọc metrics của CW để đánh giá trình trạng sức khỏe của resources.\n![[00 Meta/01 Attachments/Pasted image 20230312001849.png]]\n\n## 🌿 Domain Registar \u0026 DNS Service\n- Bạn có thể mua hoặc đăng ký tên miền ở chỗ khác và sử dụng DNS Service ở chỗ khác để quản lý.\n![[00 Meta/01 Attachments/Pasted image 20230312010504.png]]\n\n1. Tạo Hosted Zone trên Route 53\n2. Update NS record ở bên thứ 3(vd GoDaddy) sử dụng **Route 53 Name Server**.\n\n- **Domain Registar != DNS Service**\n\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/S3":{"title":"🥦 S3","content":"\n## 🌿 Introduction\n- S3 là một trong những khối xây dựng chính của AWS\n- Nó được quảng cáo là có khả năng lưu trữ vô hạn\n- Nhiều Web sử dụng S3 như Backbone\n- Nhiều services của AWS sử dụng S3 để integrate tốt hơn.\n\n## 🌿 Buckets\n- Cho phép người dùng lưu trữ **objects**(files) trong \"buckets\"(directories)\n- Một Bucket sẽ có một tên unique( trên tất cả regions của tất cả accounts)\n- Region level - S3 nhìn giống như một global service nhưng các buckets được tạo trên một region.\n- Naming convention:\n\t- Không viết hoa, không gạch dưới\n\t- 3 - 63 ký tự\n\t- Không phải là một IP\n\t- Phải bắt đầu bằng một chữ cái thường hoặc một ký tự số.\n\t- Không được đặt prefix là **xn...**\n\t- Không được đặt suffix là **...s3alias**\n\n## 🌿 Objects\n- Objects(file) có một một Key\n- Key == full path:\n\t- s3://my-bucket/my_file.txt\n\t- s3://my-bucket/another_folder/my_file.txt\n- Không có khái niệm **directories** trong s3, tất cả là key hết.\n- Object value:\n\t- Max size là 5 TB(5000 Gb)\n\t- Nếu upload file nhiều hơn 5T, phải sử dụng **multi-part upload**\n- Có metadata\n- Tags - hữu dụng cho bảo mật vào vòng đời.\n- Version ID(chỉ có khi bật versioning)\n\n## 🌿 Security\n- **User-Based**\n\t- **IAM Policies**\n- **Resource-Based**\n\t- **Bucket Policies** - áp dụng cho nhiều accounts\n\t- **Object Access Control List - ACL**\n\t- **Bucket Access Control List - ACL**\n- **Note:** Một IAM principle có thể truy cập được vào một S3 object phải thỏa mãn:\n\t- IAM permission cho phép **OR** resource policy cho phép\n\t- **AND** không có DENY\n- **Encryption:** mã hóa objects trong S3 sử dụng encryption keys.\n\n## 🌿 S3 Bucket Policies\n![[00 Meta/01 Attachments/Pasted image 20230313211733.png]]\n\n- JSON policy chứa:\n\t- Resource: resource chỉ định để phân quyền(bucket or objects)\n\t- Action: là APIs thao tác với resource\n\t- Effect: Allow/Deny\n\t- Principal: chỉ định account/user cho policy\n- Ví dụ như policy trên là: cho phép toàn bộ người dùng quyền get toàn bộ Objects trong bucket.\n\n## 🌿 Bucket settings for Block Public Access\n- Những settings này để tránh company leak dữ liệu.\n- Có thể set ở account level\n- Nếu chắc chắn các respurces sẽ không được public, chúng ta có thể giữ nguyên các thông số này.\n\n## 🌿 Static Website Hosting\n- S3 có thể host một static website và giúp chúng có thể truy cập được trên Internetmà không cần sử dụng máy chủ web riêng.\n- URL có dạng:\n\t- http://bucket-name.s3-website-aws-region.amazonaws.com\n\t- hoặc http://bucket-name.s3-website.aws-region.amazonaws.com\n- Nếu mã trả về 403, hãy chắc rằng bạn đã setup policy để cho phép việc truy cập public.\n- Ưu điểm:\n\t- Chi phí thấp\n\t- Tính sẵn sàng cao\n\t- Khả năng mở rộng vô hạn\n- Nhược điểm:\n\t- Giới hạn khả năng phát triển tính năng, ví dụ như chạy script, không dùng cho web động,...\n\n## 🌿 Versioning\n- Bạn có thể đánh phiên bản cho các files trên Amazon S3\n- Nó được bật ở **bucket level**\n- Cùng một key, nếu overwrite thì phiên bản sẽ được update.\n- Best practice để quản lý version cho bucket:\n\t- Bảo vệ từng phiên bản một -\u003e dễ đang restore về một version trước đó\n- Notes:\n\t- Các files đã tồn tại trước khi bật tính năng **versioning** sẽ được đánh version = null.\n\t- Tạm dừng tính năng **versioning** sẽ không bị xóa các phiên bản trước đó.\n\n## 🌿 Replication\n- **Phải bật Versioning** cho cả 2 Buckets ở 2 regions.\n- **Cross-Region Replication (CRR)**\n- **Same-Region Replication (SRR)**\n- Các buckets có thể thuộc về những accounts khác nhau, không nhất thiết là phải chung account thì mới thực hiện replication được.\n- Quá trình copying giữa 2 buckets là bất đồng bộ\n- Phải cung cấp IAM permissions phù hợp cho S3.\n- Use Cases:\n\t- **CRR** - dùng khi cần truy cập từ nhiều region với độ trễ thấp.\n\t- **SSR** - tổng hợp được log, live replication giữa các accounts production và test.\n- **Notes:**\n\t- Sau khi bật tính năng **replication**, chỉ những objects mới về sau mới có bản sao.\n\t- Nếu muốn tạo bản sao cho những objects đã tồn tại, sử dụng tính năng **S3 Batch Replication**\n\t\t- Tính năng này sẽ tạo bản sao cho những objects đã tồn tại ngoài ra còn tạo cho những objects đã thất bại khi tạo bản sao ở những lần trước đó.\n\t- Về cơ chế DELETE:\n\t\t- **Có thể tạo bản sao cho object xóa markers(xóa theo version)** từ bucket source sang bucket target(optional setting)\n\t\t- Xóa với một version ID(xóa vĩnh viễn) sẽ không được tạo bản sao.\n\t- **Không hỗ trợ sao chép chuỗi**\n\t\t- Tức là có 3 bucket1,2,3. Nếu muốn sao chép bucket1 đến 2 và 3 thì sao chép trực tiếp 1 -\u003e 2 và 1 -\u003e 3. Chứ không được 1 -\u003e 2 -\u003e 3.\n\n## 🌿 Tính bền bỉ(durability) và tính khả dụng(availability)\n- Durability:\n\t- Rất bền bỉ, ứng với tất cả các objects trên tất cả các regions.\n\t- Nếu bạn lưu trữ 10,000 objects trên Amazon S3, trung bình 10,000 năm chúng ta sẽ bị mất một object.\n\t- Điều này đúng với tất cả các storage class.\n- Availability:\n\t- Luôn khả dụng khi cần truy cập.\n\t- Có sự khác nhau giữa các class.\n\t- Ví dụ S3 tiêu chuẩn có 99,99% khả dụng. Tức là một năm thì nó chỉ có khoảng 53 phút không khả dụng thôi.\n\n## 🌿 Storage Class\n\n### 🍃 S3 Standard - General Purpose\n- 99,99% khả dụng\n- Sử dụng cho những dữ liệu thường xuyên được truy cập\n- Độ trễ thấp, thông lượng cao.\n- Có thể đồng thời duy trì 2 facility failures.\n- Use cases: Phân tích BigData, mobile\u0026gaming applications, content distribution, ...\n\n### 🍃 S3 Storage Classes - Infrequent Access\n- Cho dữ liệu không thường xuyên được truy cập nhưng có thể yêu cầu truy cập nhanh khi cần.\n- Giá thấp hơn S3 Standard\n- **Amazon S3 Standard-Infrequent Access (S3 Standard-IA)**\n\t- 99,9% khả dụng.\n\t- Use case: Disaster Recovery, backups\n- **Amazon S3 One Zone-Infrequent Access (S3 One Zone-IA**\n\t- Độ bền(99,999999999%) trong một AZ, dữ liệu sẽ bị mất khi AZ bị phá hủy.\n\t- 99,5% khả dụng\n\t- Use case: Lưu backups cho dữ liệu đang sử dụng hoặc dữ liệu muốn recreate.\n\n### 🍃 S3 Glacier Storage Classes\n- Chi phí thấp, là lựa chọn khi chúng ta muốn lưu trữ dữ liệu lâu dài nhưng ít được truy cập.\n- Giá  = Giá dung lượng + giá truy xuất object\n\n- **S3 Glacier Instant Retrieval**\n\t- Phù hợp với nhu cầu truy cập dữ liệu một quý một lần.\n\t- Tối thiểu lưu trữ 90 ngày\n- **S3 Glacier Flexible Retrieval**\n\t- Expected(1-5 phút), Standard(3-5 giờ), Bulk(5-12 giờ) - miễn phí\n\t- Tối thiểu lưu trữ 90 ngày\n- **S3 Glacier Deep Archive** - lưu trữ dài hạn\n\t- Standard(12 giờ), Bulk(48 giờ)\n\t- Tối thiểu lưu trữ trong 180 ngày\n\n### 🍃 S3 Intelligent-Tiering\n- Giúp chuyển đổi tự động các class dựa theo việc truy xuất dữ liệu của người dùng, từ đó tối ưu được chi phí cũng như khả năng lưu trữ và truy xuất dữ liệu phù hợp với nhu cầu sử dụng của người dùng.\n- Không phải trả phí truy xuất dữ liệu khi lựa chọn option này.\n![[00 Meta/01 Attachments/Pasted image 20230314215836.png]]\n\n### 🍃 Comparision\n![[00 Meta/01 Attachments/Pasted image 20230314220020.png]]","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/S3-Advance":{"title":"🥦 S3 Advance","content":"\n## 🌿 Lifecycle Rules\n- Có thể chuyển các objects giữa các storage classesclassescác.\n- Ví dụ với những object ít được truy cập thường xuyên, cho nó vào **Standard IA**\n- Với những object cần lưu trữ, không cần tốc độ truy cập cao, chuyển nó vào **Glacier or Glacier Deep Archive**\n- Việc chuyển các objects có thể thực hiện tự động bằng một **LifeCycle Rules**.\n- Có 2 actions chính:\n\t- **Transition Actions:** thiệt lập các điều kiện để chuyển object sang store class khác.\n\t\t- vd move objects sang Standard IA class sau 60 ngày từ ngày khởi tạo.\n\t\t- move objects sang Glacier sau 6 tháng\n\t- **Expiration actions:** thiết lập thời hạn cho objects.\n\t\t- Có thể thiết lập xoá sau 365 ngày\n\t\t- **Có thể sử dụng để xoá old versions(nếu versioning được bật)** \n\t\t- Có thể dùng để xoá những object chưa hoàn thành khi thực hiện Multi-Part uploads.\n- Rules có thể tạo cho một certain prefix, ex: s3://mybucket/mp3/*\n- Rules cũng có thể tạo cho certain objects Tags, ex: Department Finance\n\n## 🌿 Requester Pays\n- Mặc định, người dùng sở hữu buckets sẽ phải trả phí cho cả việc lưu trữ cũng như phí băng thông khi có người tải dữ liệu từ buckets.\n![[00 Meta/01 Attachments/Pasted image 20230315112349.png]]\n\n- Tuy nhiên, chúng ta có những tập dữ liệu lớn và có những người dùng muốn tải xuống để phục vụ nhu cầu cá nhân chẳng hạn, chúng ta không cần lo phần phí **networking** kia, chúng ta có thể lựa chọn option **requester pays**.\n![[00 Meta/01 Attachments/Pasted image 20230315112541.png]]\n- Khi bật tính năng này, user muốn download resources thì cần phải authen với AWS, để AWS còn tính bill cho phí **networking**.\n\n## 🌿 Event Notifications\n![[00 Meta/01 Attachments/Pasted image 20230315134320.png]]\n- Là những thông báo được gửi đến các destinations(SNS, SQS, Lambda Function) khi có một sự kiện gì đó tác động đến bucket(created , removed, restore, replication, ...)\n- Có thể filter các event, ví dụ như chỉ cần nhận thông báo các sự kiện trigger đến object có đuôi là *.jpg* chẳng hạn.\n- **Có thể tạo số lượng S3 events tuỳ thích**\n- Thường các thông báo sẽ được truyền đi trong vài giây, nhưng cũng có thể thỉnh thoảng sẽ mất vài phút hoặc lâu hơn.\n\n- Ngoài 3 destinations nhận event notifications, Amazon có thêm một tính năng mới, một destination cho event notifications, đó là **Amazon EventBridge**.\n\n### 🍃 Amazon EventBridge\n![[00 Meta/01 Attachments/Pasted image 20230315135039.png]]\n\n- Giờ là tất cả các các thông báo event đi qua **cái cầu** này trước, sau đó đi đâu thì sẽ được quyết định theo các rules.\n- Ưu điểm:\n\t- **Advanced filtering** - có thể filter theo điều kiện phức tạp hơn(metadata, object size, name, ...)\n\t- **Multiple Destinations** - có thể điều hướng event notifications tới nhiều điểm đến hơn.\n\t- **Capabilities** - Cung cấp khả năng lưu trữ, lặp lại sự kiện, truyền tải uy tín hơn.\n\n## 🌿 Baseline Performance\n- Amazon [[40123345 posts/42 Code/42.03 AWS/S3|S3]] sẽ tự động scales để đáp ứng nhu cầu sử dụng tối thiểu(tỉ lệ requests cao, độ trễ thấp 100-200ms)\n- App của bạn có thể đạt được ít nhất **3,500 PUT/COPY/POST/DELETE hoặc 5,500 GET/HEAD requests / mỗi giây / mỗi prefix trong một bucket.**\n- Điều đó có nghĩa nếu chúng ta đồng thời đọc 4 prefixs, sẽ có thể đạt được 22,000 GET/HEAD requests / mỗi giây / mỗi prefix trong một bucket.\n\n## 🌿 Performance\n![[00 Meta/01 Attachments/Pasted image 20230315142907.png]]\n- Làm sao để upload một cách tối ưu?\n\t- **Multi-Part upload:**\n\t\t- recommended nên sử dụng cho những files \u003e 100MB, bắt buộc phải dùng cho những file \u003e 5GB\n\t\t- Tính năng này sẽ chia file lớn ra thành nhiều phần sau đó upload đồng thời các phần, lên [[40123345 posts/42 Code/42.03 AWS/S3|S3]] thì sẽ tự động ghép lại thành một files như ban đầu.\n- Làm thế nào để tranfer một file một cách tối ưu?\n\t- **S3 Transfer Acceleration**\n\t\t- Tăng tốc độ truyền file bằng một AWS edge location, nó giúp gia tốc quá trình truyền file đến một region chỉ định.\n\t\t- Giảm thiểu dữ liệu truyền trên public network, sử dụng mạng private của AWS như kiểu đi xe ở làn ưu tiên, thoáng với nhanh hơn.\n\t\t- Có tương thích với tính năng **Multi-Part**\n- Làm thế nào để đọc file một cách tối ưu?\n\t- **S3 Byte-Range Fetches**\n\t\t- Thực hiện đồng thời các câu GETS cho từ byte ranges.\n\t\t- Có khả năng phục hồi tốt hơn khi request thất bại(bởi gì chia ra làm các phần nên đọc lại cũng nhanh hơn)\n\t\t- Có thể sử dụng để download nhanh hơn\n\t\t- Có thể sử dụng để hiển thị một phần thông tin cùa file, vd như phần đầu file để biết trước nội dung là gì chẳng hạn.\n![[00 Meta/01 Attachments/Pasted image 20230315143732.png]]\n\n## 🌿 Batch Operations\n- Thao tác đồng thời với nhiều dữ liệu bằng một request.\n\t- Sửa metadata, properties\n\t- **Mã hoá hoặc giải mã objects**\n\t- ...\n- Chức năng cung cấp viêc quản lý progress, thông báo gửi thành công, tạo report, ...\n- **Bạn có thể sử dụng S3 Inventory để lấy danh sách object và sử dụng S3 Select để filter đống objects đó.**\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/S3-Security":{"title":"🥦 S3 Security","content":"\n## 🌿 Object Encryption\n- Bạn có thể mã hóa objects trong S3 buckets bằng4 phương thức sau:\n\t- **Server-Side Encryption (SSE)**\n\t\t- **Server-Side Encryption with Amazon S3-Managed Keys (SSE-S3) - Enabled by Default**\n\t\t\t- Mã hóa bằng key được xử lý, quản lý và sở hữu của AWS.\n\t\t- **Server-Side Encryption with KMS Keys stored in AWS KMS(SSE-KMS)**\n\t\t\t- Tận dụng AWS Key Management Service (AWS KMS) để quản lý các keys mã hóa\n\t\t- **Server-Side Encryption with Customer-Provided Keys (SSE-C)**\n\t\t\t- Khi bạn muốn tự quản lý các keys của mình sở hữu.\n\t- **Client-Side Encryption**\n- Cần hiểu để vận dụng cho những tình huống xuất hiện trong bài thi.\n\n- **Notes: Bucket Policies được đánh giá trước(ưu tiên hơn) Default Encryption**\n![[00 Meta/01 Attachments/Pasted image 20230315214628.png]]\n- Chúng ta có thể chỉ định phương thức mã hóa ở trong **Bucket Policicy**\n\n### 🍃 SSE - S3\n- Mã hóa sử dụng keys được xử lý, quản lý cũng như sở hữu bởi AWS.\n- Object được mã hóa ở Server Side\n- Loại mã hóa là **AES-256**\n- Phải set header là **\"x-amz-server-side-encryption\":\"AES256\"**\n- **Mặc định được bật cho những buckets mới hoặc objects mới**\n![[00 Meta/01 Attachments/Pasted image 20230315211412.png]]\n\n### 🍃 SSE - KMS\n- Mã hóa sử dụng các keys được xử lý và quản lý bởi AWS KMS(Key Management Service)\n- Lợi ích: người dùng control + audit key bằng CloudTrail\n- Object mã hóa ở server-side\n- Phải set header là **\"x-amz-server-side-encryption\":\"aws:kms\"** \n- Ở cách mã hóa này, không chỉ đòi hỏi người dùng có quyền truy cập vào object mà người dùng còn cần phải có key thì mới giải mã để xem được object. \n\n![[00 Meta/01 Attachments/Pasted image 20230315211924.png]]\n- Giới hạn:\n\t- Có thể bị ảnh hưởng bởi giới hạn của KMS\n\t- Khi upload, nó sẽ gọi **GenerateDataKey** KMS API\n\t- Khi download, nó sẽ gọi **Decrypt** KMS API\n\t- Tùy từng region, mỗi giây có thể gọi được từ 5000-30000 req/s\n\t- Bạn có thể yêu cầu để tăng số lượng request/s trên Service Quotas Console\n\n### 🍃 SSE - C\n- Sử dụng các keys thuộc toàn quyền sở hữu của khách hàng ngoài AWS.\n- S3 không lưu trữ các keys mã hóa này\n- **Phải sử dụng HTTPS**\n- Key mã hóa cần phải được cung cấp trong Header, với tất cả các request, áp dụng cho cả việc đọc và ghi dữ liệu.\n![[00 Meta/01 Attachments/Pasted image 20230315213039.png]]\n\n### 🍃 Client-Side Encryption\n- Người dùng sử dụng các thư viện như **Amazon S3 Clien-Side Encryption Library** để lưu keys mã hóa.\n- Client tự phải mã hóa dữ liệu trước khi gửi lên S3 lưu trữ.\n- Client tự phải giải mã dữ liệu khi truy xuất từ S3\n- Client toàn quyền quản lý các keys cung như encryption cycle.\n\n![[00 Meta/01 Attachments/Pasted image 20230315213437.png]]\n\n## 🌿 CORS - Cross Origin Resource Sharing\n- Origin = scheme(protocol) +host(domain) + port\n- Dựa theo cơ chế này để quyết định xem có cho phép một origin khác truy cập vào tài nguyên của một origin không.\n- Một request sẽ không được hoàn thành trừ khi origin kia cho phép, sử dụng **CORS Hearder(ex: Access-Control-Allow-Origin)**\n\n## 🌿 MFA Delete\n- Một phương thức giúp ngăn ngừa sai xót khi lựa chọn xoá hoàn toàn(permanent delete), yêu cầu người dùng nhập thêm bảo mật 2 lớp để xác nhận xoá.\n- MFA sẽ được yêu cầu khi:\n\t- Xoá vĩnh viễn một object\n\t- Tắt versioning trên bucket\n- MFA sẽ không được yêu cầu khi:\n\t- Bật versioning\n\t- Liệt kê các object đã bị xoá\n- Để sử dụng MFA Delete, **Phải bật versioning** cho bucket\n- **Chỉ bucket owner(root account) mới có thể bật/tắt MFA Delete**\n\n## 🌿 Access Log\n- Tự động lưu lại toàn bộ các requests của tất cả các accounts đến bucket.\n- Dùng cho mục đích audit\n- Bucket vs bucket set logging phải chung một region\n![[00 Meta/01 Attachments/Pasted image 20230316153210.png]]\n- **Warning**\n\t- Không được set logging bucket và bucket tương tác với users là 1, vì nó sẽ dẫn đến tình trạng sinh requests vô hạn đến bucket -\u003e đốt tiền.\n![[00 Meta/01 Attachments/Pasted image 20230316155423.png]]\n\n## 🌿 Pre-Signed URLs\n![[00 Meta/01 Attachments/Screenshot 2023-03-16 at 16.12.24.png]]\n\n- Tạo ra pre-signed URLs sử dụng **S3 Console, AWS CLI, SDK**\n- **URL Expiration**:\n\t- **S3 Console**: 1 phút - 720 phút(12 giờ)\n\t- **AWS CLI**: thiết lập thời gian hết hạn với tham số *--expires-in*, đơn vị là giây(mặc định là 3,600s, max là 604800s ~ 168 giờ)\n- User nhận pre-signed URL như sẽ kế thừa permission, trong thời gian quy định, cho phép thực hiện GET/PUT với bucket.\n\n- Ex: như Insta, cho phép xem ảnh một thời gian nhất định.\n\n## 🌿 Glacier Vault Lock\n- Đáp ứng cho những object có mô hình WORM(Write Once Read Many). Ý tưởng là object được ghi vào bucket sẽ không được modify hoặc delete, chỉ đọc được thôi.\n\n## 🌿 Object Lock\n- Cũng dùng cho mô hình WORM\n- Chặn việc xoá một version object theo số lần chỉ định(set 2 lần, xoá đến lần thứ 3 mới được)\n- **Retention mode - Compliance** \n\t- Object version không thể bị overwrite hoặc delete bởi bất kỳ user nào, kể cả root user.\n\t- Retension mode không thể bị thay đổi.\n- **Retention mode - Governance**\n\t- Hầu hết user không thể orverwrite hoặc delete một object version hoặc sửa đổi lock settings của nó.\n\t- Một số users có quyền đặc biệt có thể thay đổi retention hoặc xoá object.\n- **Retention Period**\n\t- Bảo vệ object trong một khoảng thời gian cố định, có thể extend.\n- **Legal Hold**\n\t- Bảo vệ object vô thời hạn, không phụ thuộc vào retention period.\n\t- Có thể tự do thêm hoặc xoá bằng cách sử dụng quyền *s3:PutObjectLegalHold* của IAM\n\n## 🌿 Access Point\n- Một bucket sẽ có nhiều folders, **access point** sẽ xác định quyền truy cập của từng user đối với từng folder.\n![[00 Meta/01 Attachments/Pasted image 20230316165829.png]]\n- Mỗi một **Access Point** có:\n\t- DNS name(Internet Origin hoặc VPC Origin)\n\t- Một access point policy(giống bucket policy)\n\n![[00 Meta/01 Attachments/Pasted image 20230316170258.png]]\n\n## 🌿 S3 Object Lambda\n- Sử dụng khi cần format lại dữ liệu trước khi trả về cho người dùng.\n- Ví dụ như cần sắp xếp lại theo thứ tự nhất định hay convert tử XML -\u003e JSON, ...\n![[00 Meta/01 Attachments/Pasted image 20230316171258.png]]\n- Lambda hiểu đơn giản là service cho phép chạy code mà không cần có server, phù hợp cho những tác vụ kiểu xử lý dữ liệu trước khi trả về cho người dùng như trên hoặc chạy các tác vụ định kỳ kiểu cuối ngày tổng kết xem hôm nay có bao nhiêu objects mới, ...","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Scalability-High-Availability":{"title":"🥦 Scalability \u0026 High Availability","content":"\n## 🌿 Scalability\n- Khả năng mở rộng linh hoạt dự theo yêu cầu của khách hàng. Hệ thống có khả năng thích nghi tốt với trạng thái của ứng dụng.\n- Scalability có liên quan đến High Availability.\n- Có 2 loại scalability:\n\t- Vertical scalability\n\t- Horizontal scalabilily\n\n### 🍃 Vertical scalability\n![[00 Meta/01 Attachments/Pasted image 20230305175947.png]]\n- Mở rộng về phần cứng của instance để xử lý các yêu cầu nhanh và chính xác hơn.\n- Vd t2.micro -\u003e t2.large\n- Vertical scalability rất thường được sử dụng với những hệ thống không phân tán, ví dụ như database.\n- RDS, ElasticCache là những services có thể sử dụng để thực hiện scale vertically.\n- Thường có giới hạn về khả năng scale vertically(hardware limit)\n\n### 🍃 Horizontal scalability\n![[00 Meta/01 Attachments/Pasted image 20230305180205.png]]\n- Mở rộng về số lượng instances, số lượng hệ thống của ứng dụng để có thể đáp ứng được nhiều yêu cầu của người dùng hơn.\n- Dành cho những hệ thống phân tán.\n- Thường được xử dụng cho web applications / modern applications.\n- Dễ dàng để scale horizontally với EC2 service.\n\n## 🌿 High Availability\n- High Availability thường sẽ được hiểu như scale horizontally.\n- HA là ứng dụng của chúng ta được chạy trên ít nhất 2 data centers(AZs) mục đích để hệ thống luôn sẵn sàng sử dụng ngay cả khi có sự cố ở một data center nào đó.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Security-Encryption/AWS-Certificates-Manager":{"title":"🥦 AWS Certificates Manager","content":"\n## 🌿 What?\n- Là dịch vụ tạo, lưu trữ và quản lý các chứng chỉ SSL/TLS được cung câp bởi AWS.\n- Giúp dễ dàng sử dụng cũng như lưu trữ cho việc vận hành các services hoặc trang web của người dùng.\n- Cung cấp tính năng quản lý vòng đời của các chứng chỉ. Cho phép cập nhật, xoá hoặc tái phát hành các chứng chỉ theo nhu cầu sử dụng của hệ thống. Tự động hóa việc thực hiện các tác vụ trên có thể giúp chúng ta tránh được những lỗ hổng bảo mật tiềm ẩn.\n- Miễn phí với các chứng chỉ TLS public.\n- Có khả năng tích hợp với những services cần in-flight encryption như ELB, CloudFront, API Gateway, ...\n- Không tích hợp được với EC2 Instances.\n\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Security-Encryption/AWS-Firewall-Manager":{"title":"🥦 AWS Firewall Manager","content":"\n## 🌿 What?\n- Là dịch vụ cung cấp khả năng lưu trữ tường lửa của AWS.\n- Cho phép chúng ta tạo, chỉnh sửa và áp dụng các chính sách tường lửa trên nhiều accounts khác nhau ở một nơi duy nhất.\n- Thuận tiện hơn trong việc quản lý, áp dụng cũng như tracking các chính sách.\n- **Các chính sách được áp dụng cho các resources mới được tạo ra của(tốt cho việc tuân thủ các quy tắc) tất cả các accounts hiện có hoặc tương lai được tạo trong một Organization **\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Security-Encryption/AWS-KMS-Key-Management-Service":{"title":"🥦 AWS KMS - Key Management Service","content":"\n## 🌿 What?\n- Là dịch vụ lưu trữ keys encrypt trên AWS.\n- Bất cứ khi nào nhắc về encrypt, hầu hết sẽ đề cập đến KMS.\n- Được tích hợp với IAM để thực hiện authorization.\n- Giúp việc quản lý truy cập dữ liệu dễ dàng hơn.\n- Có thể audit các KMS keys được sử dụng ntn thông qua [[40123345 posts/42 Code/42.03 AWS/Monitoring/Amazon CloudTrail|CloudTrail]].\n- Có khả năng tích hợp với nhiều services của AWS như [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon RDS - Relational Database Service|RDS]], [[40123345 posts/42 Code/42.03 AWS/S3|S3]], [[40123345 posts/42 Code/42.03 AWS/EBS Volume - Elastic Block Store|EBS]], ...\n- **Không bao giờ được lưu trữ các khóa bằng text thường, đặc biệt là ở trong code, lưu trong biến môi trường thôi.**\n\n## 🌿 Types\n- **KMS Key có tên mới là KSM Customer Master Key**\n- **Symmetric(AES-256 keys)**\n\t- Một khóa duy nhất dùng cả cho encrypt và decrypt\n\t- Các services AWS sẽ được tích hợp trực tiếp với KMS để sử dụng Symmetric key.\n\t- Chúng ta sẽ không thể truy cập được vào Symmetric Key để lấy dữ liệu unencrypt(bắt buộc phải thông qua API của KMS)\n- **Asymmetric(RSA \u0026 ECC key pair)**\n\t- Có một cặp khóa public/private, khóa public để encrypt, khóa private để decrypt.\n\t- Public key chúng ta có thể download và lưu trữ được, còn private thì không.\n\t- Sử dụng với các trường hợp người dùng không thể call API của KMS.\n\n## 🌿 Policies\n- Kiểm soát truy cập tới các KMS Keys.\n- **Default KMS Key Policy**\n\t- Được tạo nếu chúng ta không chỉ địng policy nào.\n\t- Cho phép toàn bộ AWS accounts truy cập\n- **Custom KMS Key Policy**\n\t- Xác định users, roles nào được truy cập vào KMS Key.\n\t- Xác định quản trị viên cho KMS Key.\n\t- Phù hợp để sử dụng với trường hợp xài chung cho nhiều accounts.\n\n## 🌿 Multi-Region Key\n- Một khóa chính và được nhân rộng(sao chép) khóa cho các regions còn lại.\n- Giúp dễ dàng quản lý key, giảm thiểu thao tác tạo key trên nhiều region. \n- Sử dụng với các service trên nhiều region vd như Global [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon DynamoDB|DynamoDB]], Global Aurora...","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Security-Encryption/AWS-Secrets-Manager":{"title":"🥦 AWS Secrets Manager","content":"\n## 🌿 What?\n- Là dịch vụ lưu trữ và quản lý các thông tin bí mật của app(thông tin connect vào database, khóa mã hóa dữ liệu, ...)\n- Dịch vụ này sẽ chịu trách nhiệm lưu trữ, bảo mật và cung cấp cho các dịch vụ tích hợp những thông tin bí mật này một cách an toàn.\n- Các thông tin bảo mật được lưu trữ trong dịch vụ hoàn toàn được mã hóa bằng KMS.\n- Có khả năng quản lý vòng đời của các thông tin bí mật này.\n- Thường sẽ được sử dụng để tích hợp với RDS.\n\n## 🌿 Multi-Region Secrets\n- Tính năng cho phép sao chép, nhân rộng Secret Manager trên nhiều Region.\n- Bao gồm một Secret Manager chính, các Secret Manager trên region khác sẽ được đồng bộ.\n- Có thể promote một Secret Manager trên region khác trở thành một phiên bản độc lập.\n![[00 Meta/01 Attachments/Pasted image 20230416003249.png]]\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Security-Encryption/AWS-Shield":{"title":"🥦 AWS Shield","content":"\n## 🌿 What?\n- Là dịch vụ giúp bảo vệ hệ thống của chúng ta tránh khỏi những cuộc tấn công phân tán phân tán dữ liệu(DDoS).\n- DDoS - Distributed Denial of Service: tấn công hệ thống bằng cách gửi thật nhiều requests lên hệ thống một lúc, mục đích làm hệ thống quá tải và bị treo.\n- Có 2 loại chính:\n\t- **AWS Shield Standard:**\n\t\t- Bản này miễn phí\n\t\t- Cung cấp một số giải pháp để bảo vệ một số kịch bản tấn công như Reflection attacks hoặc là layer3/4 attacks.\n\t- **AWS Shield Advance:**\n\t\t- 3000$ một tháng cho từng organization.\n\t\t- Xịn xò hơn, cung cấp nhiều giải pháp bảo mật ngon hơn.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Security-Encryption/AWS-WAF-Web-Application-Firewall":{"title":"🥦 AWS WAF - Web Application Firewall","content":"\n## 🌿 What?\n- Là dịch vụ cung cấp tường lừa của AWS.\n- Tường lửa có tác dụng ngăn ngừa các cuộc tấn công tới trang web của chúng ta thông qua việc lọc các requests HTTP/HTTPS.\n- Triển khai trên:\n\t- ALB\n\t- API GateWay\n\t- CloudFront\n\t- AppSync GraphQL API\n\t- Cognito User Pool\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Security-Encryption/Amazon-GuardDuty":{"title":"🥦 Amazon GuardDuty","content":"\n## 🌿 What?\n- Là một dịch vụ bảo mật, sử dụng trí tuệ nhân tạo để phát hiện ra khác hoạt động độc hại hoặc bất thường trên hệ thống của chúng ta.\n- Data input sẽ là các phần logs của hệ thống để AI có thể training.\n- Có thể tích hợp với các services khác để tăng hiệu quả bảo mật\n\t- vd như tích hợp với [[40123345 posts/42 Code/42.03 AWS/Monitoring/Amazon EventBridge|EventBridge]] để gửi thông báo tới [[40123345 posts/42 Code/42.03 AWS/Amazon SNS - Simple Notification Service|SNS]], từ [[40123345 posts/42 Code/42.03 AWS/Amazon SNS - Simple Notification Service|SNS]] gửi thông báo tới [[40123345 posts/42 Code/42.03 AWS/AWS Lambda|Lambda]] để thực hiện các actions phù hợp.\n- **Có thể chống lại được cuộc tấn công CryptoCurrency**\n\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Security-Encryption/Amazon-Inspector":{"title":"🥦 Amazon Inspector","content":"\n## 🌿 What?\n- Là dịch vụ cung cấp khả năng tự động đánh giá các lỗ hổng bảo mật.\n- Inspector sẽ sử dụng các quy tắc được thiết lập trước đó để phân tích và đánh giá các vấn đề bảo mật của hệ thống.\n- Có khả năng cung cấp các báo cáo phân tích về các lỗ hổng bảo mật, giúp người dùng đưa ra các quyết định đúng đắn khi hệ thống gặp vấn đề.\n- Ngoài ra có thể chỉ định dịch vụ để Inspector thực hiện phân tích và đánh giá.\n- **Chỉ thực hiện phân tích và đánh giá được trên:**\n\t- **EC2 Instances**\n\t- **Container Images**\n\t- **Lambda Functions**\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Security-Encryption/Amazon-Macie":{"title":"🥦 Amazon Macie","content":"\n## 🌿 What?\n- Là dịch vụ dựa vào trí tuệ nhân tạo và các patterns cho trước để thực hiện phục hồi hoặc bảo vệ các thông tin nhạy cảm của hệ thống.\n\t- Các thông tin như thông tin người dùng, thông tin ngân hàng, ...\n- Dịch vụ sẽ tự động detect được đâu là thông tin nhạy cảm. Từ đó thực hiện giám sát các hoạt động thao tác với các dữ liệu này.\n- Cung cấp báo cáo chi tiết về các hoạt động trên những dữ liệu nhạy cảm.\n- Cung cấp khả năng giám sát cũng như thông báo khi có bất kỳ các hoạt động bất thường nào đối với các dữ liệu nhạy cảm của hệ thống.\n- Giúp nâng cao khả năng bảo mật của hệ thống với các thông tin quan trọng này.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Security-Encryption/SSM-Parameter-Store":{"title":"🥦 SSM Parameter Store","content":"\n## 🌿 What?\n- Là dịch vụ lưu trữ các thông tin câu hình, khóa bí mật. Bảo mật thông qua IAM.\n- Có thể sử dụng [[40123345 posts/42 Code/42.03 AWS/Security \u0026 Encryption/AWS KMS - Key Management Service|KMS]] để mã hóa dữ liệu.\n- [[40123345 posts/42 Code/42.03 AWS/Some Solution Architectures/Serverless|Serverless]], có khả năng mở rộng, bền bỉ và sử dụng dễ dàng với SDK.\n- Quản lý version của các thông tin như cấu hình hay khóa bí mật.\n- Gửi thông báo tới AWS [[40123345 posts/42 Code/42.03 AWS/Monitoring/Amazon EventBridge|EventBridge]].\n- Tích hợp với CloudFormation.\n![[00 Meta/01 Attachments/Pasted image 20230415111940.png]]\n\n## 🌿 Hierarchy\n![[00 Meta/01 Attachments/Pasted image 20230415112058.png]]\n\n## 🌿 Tier\n| |Standard|Advance|\n|------|---------|---------|\n|tổng số param lưu trữ(cho 1 account/region) | 10,000| 100,000|\n|size tối đa của 1 param | 4Kb | 8Kb |\n|param policy available | No | Yes |\n| Chi phí | không cần cọc | phải cọc |\n| Chi phí lưu trữ | miễn phí | 0.05$ cho mỗi param/ tháng|\n\n## 🌿 Parameters Policy\n- Có thể assign TTL để thực hiện update hoặc xóa các thông tin nhạy cảm ví dụ như mật khẩu chẳng hạn.\n- Có thể assign một lúc nhiều policies.\n![[00 Meta/01 Attachments/Pasted image 20230415112851.png]]","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Serverless-Architectures-Myblog.com":{"title":"🥦 Serverless Architectures - Myblog.com","content":"\n## 🌿 Requirements\n- Một web viết blog có khả năng mở rộng toàn cầu.\n- Các bài blogs hiếm khi được viết nhưng thường hay được đọc.\n- Caching\n- Khi người dùng mới đăng ký phải gửi một email chào mừng người dùng.\n- Khi có ảnh được upload sẽ tự động tạo thumbnail.\n\n## 🌿 Architecture\n![[00 Meta/01 Attachments/Pasted image 20230331162606.png]]\n\n- Vẫn sử dụng kiến trúc [[40123345 posts/42 Code/42.03 AWS/AWS API Gateway|API Gateway]] + [[40123345 posts/42 Code/42.03 AWS/AWS Lambda|Lambda]] + DAX + [[40123345 posts/42 Code/42.03 AWS/Amazon DynamoDB|DynamoDB]] để đáp ứng yêu cầu như expose API HTTP, truy vấn các bài posts tăng hiệu suất đọc dữ liệu.\n- Để app global, sử dụng CloudFront để phân phối. Các edge location sẽ nhận request của người dùng, giảm độ trễ, nâng cao trải nghiệm của người dùng.\n- [[40123345 posts/42 Code/42.03 AWS/S3|S3]] thiết lập OAC - Origin Access Control để các edge location có thể truy cập được vào [[40123345 posts/42 Code/42.03 AWS/S3|S3]].\n- Tiếp đến là vụ gửi mail. Bật [[40123345 posts/42 Code/42.03 AWS/Amazon DynamoDB|DynamoDB]] Stream để nhận được sự kiện khi có người dùng được tạo mới trong db. Sau đó dùng [[40123345 posts/42 Code/42.03 AWS/AWS Lambda|Lambda]] để thực hiện gửi mail qua dịch vụ Simple Email Service(SES)\n- Về vụ gen ra thumbnail, sau khi ảnh được upload vào [[40123345 posts/42 Code/42.03 AWS/S3|S3]], gửi sử kiện đến [[40123345 posts/42 Code/42.03 AWS/AWS Lambda|Lambda]] để tạo thumbnail và import vào [[40123345 posts/42 Code/42.03 AWS/S3|S3]].\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Serverless-Architectures-todo-list-mobile-app":{"title":"🥦 Serverless Architectures - Todo list mobile app","content":"\n## 🌿 Requirements\n- Tạo một mobile app:\n\t- Expose REST API với HTTPS\n\t- Kiến trúc [[40123345 posts/42 Code/42.03 AWS/Serverless|serverless]].\n\t- User có thể tương tác trực tiếp với folder của họ trên [[40123345 posts/42 Code/42.03 AWS/S3|S3]]\n\t- User cần xác thực thông qua một service quản lý không máy chủ.\n\t- User có thể đọc và ghi mới các to-do, nhưng thường chủ yếu là họ sẽ đọc.\n\t- Database có thể scale và có thông lượng có khả năng đọc cao.\n\n## 🌿 Serverless Architecture \n![[00 Meta/01 Attachments/Pasted image 20230331160701.png]]\n\n- Sử dụng [[40123345 posts/42 Code/42.03 AWS/AWS API Gateway|API Gateway]] để expose các HTTP API và để gọi đến các [[40123345 posts/42 Code/42.03 AWS/AWS Lambda|Lambda]] function.\n- [[40123345 posts/42 Code/42.03 AWS/AWS Lambda|Lambda]] function dùng để xử lý logic và query vào database\n- Database sử dụng [[40123345 posts/42 Code/42.03 AWS/Amazon DynamoDB|DynamoDB]] để đáp ứng kiến trúc không máy chủ.\n- Về vụ xác thực sử dụng [[40123345 posts/42 Code/42.03 AWS/Amazon Cognito|Amazon Cognito]] để định danh cho người dùng. Sử dụng [[40123345 posts/42 Code/42.03 AWS/Amazon Cognito|Cognito]] Indentity pool để cung cấp certificate cho người dùng. Người dùng có thể sử dụng nó để thực hiện các tác vụ với [[40123345 posts/42 Code/42.03 AWS/S3|S3]].\n- Để nâng cao khả năng đọc dữ liệu từ trong DB, sử dụng DAX làm lớp layer giữa [[40123345 posts/42 Code/42.03 AWS/AWS Lambda|Lambda]] và [[40123345 posts/42 Code/42.03 AWS/Amazon DynamoDB|DynamoDB]]. Giúp cache lại các thông tin hay được sử dụng, từ đó nâng cao hiệu suất đọc cũng như giảm thiểu các câu queries tới [[40123345 posts/42 Code/42.03 AWS/Amazon DynamoDB|DynamoDB]].\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Blocking-an-IP-Address-in-AWS":{"title":"🥦 Blocking an IP Address in AWS","content":"\n![[00 Meta/01 Attachments/Pasted image 20230424210838.png]]\n- Trong thực tế, các dự án không phải là public, việc phải restrict traffic truy cập là việc làm quan trọng, tránh cho hệ thống có tác nhân không được phép sử dụng truy cập ảnh hưởng đến vấn đề bảo mật của hệ thống.\n- Có một số cách như:\n\t- Sử dụng [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/NACL - Network Access Control List|NACL]]: chặn traffic ở tầng [[40123345 posts/42 Code/42.03 AWS/Networking - VPC/VPC - Virtual Private Cloud|VPC]] bằng cách defind ra các deny rules.\n\t- Security Group của EC2 Instance: defind những traffic nào được phép truy cập vào server.\n\t- Đặt ALB, chặn trước một EC2 Instance. Nếu sử dụng Network Load Balancer thì phải sài thêm [[40123345 posts/42 Code/42.03 AWS/Security \u0026 Encryption/AWS WAF - Web Application Firewall|WAF]], tường lửa chặn truy cập ở tầng network.\n\t- Hoặc khi có sử dụng Cloudfront thì cũng cần cài thêm [[40123345 posts/42 Code/42.03 AWS/Security \u0026 Encryption/AWS WAF - Web Application Firewall|WAF]] nếu muốn filter IP addresses mà chúng ta cho phép truy cập vào hệ thống.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Caching-Strategies-in-AWS":{"title":"🥦 Caching Strategies in AWS","content":"\n![[00 Meta/01 Attachments/Pasted image 20230424204731.png]]\n- AWS cũng cấp nhiều dịch vụ hỗ trợ caching.\n- Việc lựa chọn dịch vụ caching một cách hiệu quả sẽ liên quan rất nhiều đến cách thức hoạt động của hệ thống.\n- Ví dụ nếu app yêu cầu độ trễ thấp, không cần đồng bộ real-time dữ liệu hoặc những thay đổi từ bên BE, có thể lựa chọn CloudFront để caching\n- Cache trên từng khu vực thì có thể chọn [[40123345 posts/42 Code/42.03 AWS/AWS API Gateway|API Gateway]].\n- Với app nào mà không quan tâm đến độ trễ lắm, nhưng cần dữ liệu phải có tính thống nhất cao thì có thể sử dụng cache ở [[40123345 posts/42 Code/42.03 AWS/Databases/Amazon ElastiCache|ElastiCache]], DAX.\n- Nói chung là có nhiều dịch vụ hỗ trợ caching, cần phải làm rõ được các yêu cầu như về độ trễ, thời gian lưu trữ, giá cả, ... để chọn được cách hoạt động hiệu quả nhất cho dự án.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Event-Processing-in-AWS":{"title":"🥦 Event Processing in AWS","content":"\n\u003e Bài viết tổng hợp lại các kiến trúc thường được áp dụng cho hệ thống xử lý sự kiện trên AWS.\n\n## 🌿 Lambda, SNS and SQS\nCó 3 kiến trúc thường được sử dụng:\n1. SQS + Lambda\n![[00 Meta/01 Attachments/Pasted image 20230421210356.png]]\n- Events push vào SQS queue\n- Lambda pull mess từ SQS về để xử lý, nếu xử lý không thành công thì push ngược trở lại SQS.\n- Tránh trường hợp message có vấn đề, mãi không được xử lý thành công, gây ra vòng lặp vô hạn -\u003e Chuyển message vào DLQ(Dead Letter Queue) sau số lần retry nhất định, không xử lý nó nữa\n\n2. SQS FIFO + Lambda\n![[00 Meta/01 Attachments/Pasted image 20230421210929.png]]\n- Giống cái bên trên, khác là các messages trong Queue có thứ tự FIFO - First In First Out.\n\n3. SNS + Lambda\n![[00 Meta/01 Attachments/Pasted image 20230421211044.png]]\n- Notification đc gửi bất đồng bộ tới Lambda để xử lý.\n- Luồng retry + đẩy vào DLQ giống 2 cái bên trên.\n\n## 🌿 Fan Out Pattern - delivery to multi SQS\n![[00 Meta/01 Attachments/Pasted image 20230421211812.png]]\n- Fan Out Pattern: được sử dụng với mục đích phân phối thông điệp tới nhiều đối tượng cùng lúc.\n- Đảm bảo tính đúng đắn và tin cậy của các thông điệp.\n- Tăng khả năng chịu lỗi.\n- Có khả năng mở rộng linh hoạt.\n- Sử dụng SNS - SNS hỗ trợ nhiều định dạng như email, tin nhắn, văn bản, ... Tùy nhu cầu chúng ta có thể lựa chọn 2 options trên.\n\n- Option1:\n\t- Cơ chế sẽ là một message sẽ được put lần lượt tới các Queue\n\t- Nhưng có thể xảy ra trường hợp put Queue2, message bị lỗi, thế là nó ko put đến Queue3 nữa -\u003e Không đáng tin cậy\n- Option2:\n\t- Tăng cường độ tin cậy bằng cách thông qua SNS, kiêu gì nó cũng gửi message lên cả 3 Queue.\n\n## 🌿 Events of S3\n\n### 🍃 With EventBridge\n![[00 Meta/01 Attachments/Pasted image 20230424202403.png]]\n- **Filter Advance** - có thể tạo JSON rules, hỗ trợ cho việc tìm kiếm các thông tin của objects(metadata, size, ...)\n- **Multiple Destinations** - Có thể gửi các event tới nhiều AWS services khác, dễ dàng xử lý nhiều tác vụ theo nhu cầu sử dụng của hệ thống.\n- **Capabilities** - Ngoài ra EventBridge hỗ trợ lưu trữ, replay event, reliable delivery\n\n![[00 Meta/01 Attachments/Pasted image 20230424202857.png]]\n- Ngoài ra nó còn được sử dụng để nhận các events từ các API được call. Từ đó có thể gửi tới các service khác ví dụ như SNS trong trường hợp khi người dùng xoá một bảng sẽ gửi mail tới tất cả các AWS accounts trong organization.\n\n### 🍃 With API Gateway\n![[00 Meta/01 Attachments/Pasted image 20230424203103.png]]\n- Mô hình thường được sử dụng để người dùng có thể lưu dữ liệu lên S3.","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/High-Performance-Computing-in-AWS":{"title":"🥦 High Performance Computing in AWS","content":"\n## 🌿 What is HPC - High Perfomance Computing?\n- Là thuật ngữ để chỉ các hệ thống yêu cầu khả năng tính toán cao.\n\t- vd như các hệ thống dự báo thời tiết, machine learning, deep learning, mô hình hoá rủi ro tài chính, ...\n- Và cloud là một môi trường vô cùng thuận lợi cho việc phát triển các hệ thống HPC.\n\t- Chúng ta có thể tạo rất nhiều resource trên cloud.\n\t- Nhanh chóng áp dụng, mở rộng theo nhu cầu của hệ thống.\n\t- Đầy đủ services để hỗ trợ cho việc phát triển, mối lo duy nhất chỉ là tài chính thôi =))\n\nVậy, AWS cung cấp những dịch vụ nào để hỗ trợ phát triển dự án HPC?\n\n## 🌿 Data Management \u0026 Transfer\n- **AWS Direct Connect** - Có thể chuyển GB/s data lên Cloud, thông qua một private secure network.\n- **Snowball \u0026 Snowmobile** - Có thể chuyển PB data lên cloud, sử dụng các thiết bị lưu trữ vật lý, dump dữ liệu và chuyển về datacenter để migrate.\n- **AWS DataSync** - Đồng bộ dữ liệu lớn giữa on-premise và các dịch vụ lưu trữ trên cloud. \n\n## 🌿 Computing \u0026 Networking\n- **EC2 Instances**\n\t- Tối ưu CPU, GPU.\n\t- Có thể lựa chọn các options thuê dịch vụ là Spot Instances / Spot Fleets để tiết kiệm giá cũng như thực hiện tự động mở rộng hệ thống.\n\t- EC2 Placemenet: lựa chọn chiến lược đặt vị trí của các EC2 Instances phù hợp với yêu cầu của hệ thống.\n- **EC2 Enhanced Networking(SR-IOV)**\n\t- Băng thông cao hơn, PPS(packet per second) cao hơn, độ trễ thấp hơn.\n\t- Option1: sử dụng **ENA - Elastic Network Adapter** có thể hỗ trợ băng thông tối đa là 100Gbs\n\t- Option2: Intel 82599 VF hỗ trợ tối đa là 10GBs\n- **Elastic Fabric Adapter - EFA**\n\t- Phiên bản cải tiến của ENA để hỗ trợ cho hệ thống HPC, chỉ hỗ trợ với hệ điều hành **Linux**.\n\t- Hỗ trợ khả năng giao tiếp tuyệt vời giữa các node của hệ thống, phù hợp với các hệ thống yêu cầu khả năng tính toán kết hợp giữa nhiều Instances.\n\t- Tận dụng Message Passing Interface tiêu chuẩn.\n\n## 🌿 Storage\n- Instance Storage\n\t- **EBS**\n\t- **Instance Storage**\n- Network Storage\n\t- **S3**\n\t- **EFS**\n\t- **Amazon FSx for Lustre**\n\n## 🌿 Automation \u0026 Orchetration\n- **AWS Batch**\n\t- Hỗ trợ đồng thời chạy các jobs.\n\t- Dễ dàng lập lịch\n- **AWS ParallelCluster**\n\t- Một tool quản lý dùng để delpoy HPC lên AWS.\n\t- Thiết lập sử dụng text files.\n\t\t- Tự động tạo VPC, Subnets, cluster type hoặc instance type.\n\t\t- **Có khả năng bật EFA trên các cluster.**","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Highly-Available-EC2-Instance":{"title":"🥦 Highly Available EC2 Instance","content":"\nMột điều quan trọng cần lưu ý khi thiết kế hệ thống, đó là tính sẵn sàng cao, hệ thống luôn luôn sẵn sàng để truy cập, thời gian downtime hầu như là không có.\n\n![[00 Meta/01 Attachments/Pasted image 20230424215507.png]]\n- Sử dụng ElasticIP để gắn cho một EC2 Instance.\n- Tạo một Standby EC2 Instance.\n- Sử dụng [[40123345 posts/42 Code/42.03 AWS/Monitoring/Amazon CloudWatch|CloudWatch]] Event để theo dõi các thông số của EC2 Instance chính, nếu có nó có vấn đề gì bất thường(vd CPU nhảy lên 100% -\u003e lỗi rồi) -\u003e Gửi cho [[40123345 posts/42 Code/42.03 AWS/AWS Lambda|Lambda]] Function để thực hiện attach ElasticIP qua EC2 Instance. Thế là hệ thống đỡ mất thời gian để launch lại EC2 vì có sẵn rồi.\n\n![[00 Meta/01 Attachments/Pasted image 20230424215827.png]]\n- Sử dụng [[40123345 posts/42 Code/42.03 AWS/ASG - Auto Scaling Group|ASG]] để tự động mở rộng hệ thống tuỳ theo lưu lượng. Giảm khả năng bị quá tải của hệ thống.\n- Có thể bật Multi-AZs, tránh khả năng datacenter đang sử dụng gặp sự cố.\n\n![[00 Meta/01 Attachments/Pasted image 20230424220328.png]]\n- Có một vấn đề là khi Terminate EC2 Instance, cả [[40123345 posts/42 Code/42.03 AWS/EBS Volume - Elastic Block Store|EBS]] Volume sẽ bị xoá theo, để có thể giữ lại nó, [[40123345 posts/42 Code/42.03 AWS/ASG - Auto Scaling Group|ASG]] sẽ sử dụng lifecycle hook, nó sẽ triggerd khi [[40123345 posts/42 Code/42.03 AWS/EBS Volume - Elastic Block Store|EBS]] Volume bị terminate -\u003e tạo ra một [[40123345 posts/42 Code/42.03 AWS/EBS Volume - Elastic Block Store|EBS]] Snapshot, khi [[40123345 posts/42 Code/42.03 AWS/ASG - Auto Scaling Group|ASG]] launch một EC2 Instance mới, [[40123345 posts/42 Code/42.03 AWS/EBS Volume - Elastic Block Store|EBS]] cũng sẽ được tạo từ [[40123345 posts/42 Code/42.03 AWS/EBS Volume - Elastic Block Store|EBS]] Snapshot. Dữ liệu vẫn sẽ được giữ nguyên.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Micro-Services-Architecture":{"title":"🥦 Micro Services Architecture","content":"\n## 🌿 What?\n![[00 Meta/01 Attachments/Pasted image 20230404195416.png]]\n- Bạn có thể tự do thiết kế từng micro-service theo cách bạn muốn.\n- Patterns đồng bộ: API Gateway, Load Balancers.\n- Patterns bất đồng bộ: SQS, Kinesis, SNS, Lambda triggers (S3)\n- Thách thức với micro-services:\n\t- Chi phí\n\t- Tối ưu\n\t- Phức tạp khi phải quản lý nhiều versions của nhiều services.\n\t- Yêu cầu code nhiều hơn để tích hợp với nhiều services.\n- Một số thách thức được giải quyết với kiến trúc serverless.\n\t- API Gateway, Lambda tự động scale và chúng ta phải trả theo nhu cầu sử dụng.\n\t- Có thể dễ dàng clone API, Dùng lại được các môi trường.\n\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Serverless":{"title":"🥦 Serverless","content":"\n## 🌿 What?\n- Là một mô hình mới, các developers không cần phải quản lý bất kỳ một cái server nào.\n- Chúng chỉ để deploy code, functions.\n- FaaS = Function as a Service\n- Serverless được triển khai đầu tiên với AWS Lambda những hiện tại mô hình này đã có thể kết hợp với bất kể cái gì có thể quản lý được: databases, messaging, storage, ...\n- **Serverless không phải là hoàn toàn không có servers nào**, nó chỉ có nghĩa là chúng ta không cần quản lý, cung cấp hay nhìn thấy các servers thôi.\n\n## 🌿Mô hình serverless trong AWS\n- Trong AWS, các services hỗ trợ chúng ta build một mô hình serverless bao gồm:\n\t- AWS Lambda\n\t- DynamoDB\n\t- AWS Cognito\n\t- AWS API Gateway\n\t- Amazon [[40123345 posts/42 Code/42.03 AWS/S3|S3]]\n\t- AWS [[40123345 posts/42 Code/42.03 AWS/Amazon SNS - Simple Notification Service|SNS]] \u0026 [[40123345 posts/42 Code/42.03 AWS/Amazon SQS - Simple Queue Service|SQS]]\n\t- AWS Kinesis Data Firehose\n\t- Aurora Serverless\n\t- Step Functions\n\t- Fargate\n![[00 Meta/01 Attachments/Pasted image 20230327214338.png]]\n\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Solution-Architect-Discussion-Whattimeisit.com":{"title":"🥦 Solution Architect Discussion - Whattimeisit.com","content":"\n- Đề bài: Tôi cần build kiến trúc cho một web xem thời gian, có domain là **whattimeisit.com**\n\n1. Đây là một app hỏi giờ thôi nên không cần database để lưu dữ liệu. Đầu tiên tôi cần launch một EC2 Instance + ElasticIP để người dùng có thể truy cập để hỏi giờ.\n![[00 Meta/01 Attachments/Pasted image 20230312115417.png]]\n\n2. Sau đó, app được người dùng trải nghiệm tốt, họ giới thiệu cho bạn bè, một vài người sử dụng thử và lượng truy cập tăng lên. Tôi cần phải năng cấp Instance để đáp ứng nhu cầu sử dụng, lúc đầu là T2 -\u003e M5.\n\t1. Stop Instance đang chạy\n\t2. Đổi thủ công từ T2 -M5\n\t3. Lauch lại Instance, vì sử dụng Elastic IP nên không ảnh hướng đến địa chỉ truy cập.\n![[00 Meta/01 Attachments/Pasted image 20230312121026.png]]\n- Trong thời gian upgrade, người dùng không thể truy cập để hỏi giờ được, thời gian downtime sẽ ảnh hưởng đến trải nghiệm của người dùng. Nhưng vì giờ app nó vẫn còn nhỏ, nên thôi cứ dùng tạm vậy đã.\n\n3. Sau đó app thật sự nổi tiếng, lượng truy cập ồ ạt, tiếp theo tôi sẽ thực hiện scaling horizontal.\n![[00 Meta/01 Attachments/Pasted image 20230312165841.png]]\n\n4. Vấn đề là người dùng sẽ phải nhớ địa chỉ IP tương ứng với từng instance để truy cập, về sau càng scale lên càng nhiều instances, việc nhớ IPs là rất bất tiện. Để giải quyết vấn đề này, tôi sử dụng **Route 53** để điều hướng địa chỉ IP cho người dùng. \n![[00 Meta/01 Attachments/Pasted image 20230312171324.png]]\n\n5. Nhưng hiện tại, nhu cầu scale là thường xuyên, việc add instance thêm hoặc đặc biệt là remove sẽ gây bất tiện. Do TTL được set là 1 giờ, nếu instance bị xóa thì trong một giờ nhóm user có response DNS sẽ không thể sử dụng được app, ảnh hưởng đến trải nghiệm. Ở bước này, tôi đầu tư thêm tiền để thực hiện scale horizontal bằng **ELS - Elastic Load Balancer**.\n\t- Vì ELB sẽ có IP thay đổi nên tôi bật alias trong DNS record lên, trỏ về ELB.\n6. Cơ mà thấy phải scale thủ công cũng hơi bất tiện, thế là tôi dùng thêm dịch vụ **ASG - Auto Scaling Group** để tự động scale.\n7. Bật thêm **Multi-AZ** để phòng tránh trường hợp bất ngờ như động đất sóng thần gì đấy làm hỏng một AZ, các AZ còn lại sẽ vẫn hoạt động bình thường.\n8. Ok, giờ thì optimize cost một chút, tôi biết rằng chắc chắn mỗi năm sẽ cần ít nhất 2 instances để chạy app, tôi sẽ lựa chọn option **reserved instance** để thuê 2 instances cho 2 AZs, còn lại phát sinh tôi sẽ dùng option **spot instances** để tiết kiệm chi phí.\n\n\u003e [!note] Summary\n\u003e \n\u003e Các bước bên trên là các bước để tạo nên một kiến trúc tốt trên nền tảng AWS, nó bao gồm 5/6 trụ cột\n\u003e 1. operation pillar - vận hành tốt, đáp ứng nhu cầu mở rộng tự động và hợp lý cho hệ thống\n\u003e 2. reliability pillar - uy tín, luôn định tuyến tới các healthy instance cũng như có dự phòng ngay khi xảy ra lỗi.\n\u003e 3. performance pillar - đáp ứng khả năng xử lý, tính toán tốt cho hệ thống\n\u003e 4. security pillar - các rules được thiết lập chặt chẽ, các requests sẽ được đi qua đúng các điểm chỉ định để đảm bảo tính an toàn cho hệ thống.\n\u003e 5. optimize cost pilllar - chi phí sử dụng được tối ưu với những options của các dịch vụ phù hợp với nhu cầu sử dụng của ứng dụng.\n\n\n\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Solution-Architect-Discussion-mywordpress.com":{"title":"🥦 Solution Architect Discussion - mywordpress.com","content":"\n## 🌿Đề bài\n- Một website viết blog\n- Yêu cầu phải show được ảnh, content của các bài blog cho các users.\n- Có khả năng scale\n- Toàn bộ thông tin về users hay các blogs sẽ đươc lưu trong MySQL.\n\n## 🌿 Kiến trúc áp dụng\n![[00 Meta/01 Attachments/Pasted image 20230312230204.png]]\n- Vẫn kiến trúc cũ như **theclothes.com**, nhưng web không cần lưu thông tin trạng thái giỏ hàng nên không cần sử dụng **ElastiCache**.\n- Thay **RDS -\u003e Aurora**, scale tốt hơn, performance tốt hơn, khả năng read scale tốt gấp 3 lần.(option tham khảo, dùng RDS thì cũng không sao, chi phí thấp hơn, tương đương với hiệu suât cũng thấp hơn thôi)\n\n![[00 Meta/01 Attachments/Pasted image 20230312230434.png]]\n- Về vụ lưu ảnh, nếu dự án chỉ có một **EC2 Instance**, không mở rộng thì lưu luôn vào **EBS - Elastic Block Store** thì cũng được. Cơ mà lúc scale thêm một instance thì kèm với đó là một **EBS mới**. Lúc gửi ảnh vào **EBS cũ** xong lúc sau **ELB** định tuyến qua **EBS mới** thế là mất ảnh.\n- Để tránh tình trạng trên, chúng ta sẽ xuống tiền để sử dụng **EFS - Elastic File System** để lưu ảnh. Tạo thêm **ENI - Elastic Network Interface** để giao tiếp giữa **EC2 Instances** và **EFS**. Lưu ảnh vào một mối nên không sợ tinh trạng thất lạc ảnh như bên trên.","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Solution-Architect-Discussion-theclothes.com":{"title":"🥦 Solution Architect Discussion - theclothes.com","content":"\n## 🌿 Đề bài\n- Một web bán quần áo, cho phép người dùng mua bán quần áo online.\n- Website có cả trăm người dùng truy cập một lúc.\n- Cần scale, và luôn giữ trạng thái sử dụng của toàn bộ người dùng.\n- Cần lưu thông tin cá nhân của người dùng vào database.\n\n## 🌿 Kiến trúc áp dụng\n![[00 Meta/01 Attachments/Pasted image 20230312223816.png]]\n- Áp dụng kiến trúc cũ của web **whattimeisit.com**.\n- Muốn giữ trạng thái của người dùng, ý tưởng đầu tiên là cần định tuyến đến đúng instance đã truy cập trước đó -\u003e Có thể bật Stick Session cho con ELB. Tuy nhiên cách này sẽ làm mất độ cân bằng tài do có thể có quá nhiều users cùng stick trên một instance.\n- Đổi qua dùng kiểu lưu trạng thái mua hàng của user vào cookie và lưu dưới trình duyệt của user. Tuy nhiên cookie dễ bị thay đổi, thêm nữa chỉ có thể lưu trong 4Kb, quá ít, chả lưu được gì.\n- Đến tầm này thì thuê luôn một con **ElastiCache** dùng cho nó máu. Chúng ta sẽ lưu thông tin mua bán hàng của user tại đây. Ở bên phía user sẽ lưu một session_id, khi truy cập vào bất kì instance nào, chỉ cần mã session_id là hợp lệ, hệ thống sẽ tìm trong **ElasticCache** để trả về thông tin cho user.\n- Trong trường hợp session_id không hợp lệ hoặc cache lâu quá hết hạn bị xóa đi, hệ thống sẽ tìm trong **RDS - Relational Database System** để lấy thông tin, lưu lại vào trong **ElasticCache** để dùng lại cho những lần sau.\n- Về vấn đề, cùng một thời điểm có cả trăm người dùng truy cập vào trang web, chúng ta sẽ scale read cho **RDS** để thực hiện đọc dữ liệu nhanh hơn.\n- Phòng tránh thiên tai, bật Multi-AZ cho ELB, ElastiCache, RDS, đặt EC2 Instance ở nhiều AZs.\n- Cuối cùng là cần tạo đầy đủ các rules cho **Security Group** của từng phần một.\n\t- ELB - Nhận HTTP/HTTPS từ 0.0.0.0(every requests)\n\t- EC2 Instance - Chỉ nhận requests từ ELB\n\t- ElastiCache - Chỉ nhận requests từ EC2 Instances\n\t- RDS - Chỉ nhận requests từ EC2 Instances\n- ElastiCache:\n\t- Lưu session\n\t- Lưu dữ liệu cần sử dụng lại từ RDS\n\t- Bật Multi-AZ\n- RDS:\n\t- Lưu thông tin của người dùng\n\t- Scale read để cải thiện tốc độ đọc của website\n\t- Bật Multi-AZ để tránh thảm họa.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Trusted-Advisor":{"title":"🥦 Trusted Advisor","content":"\n## 🌿 What?\n![[00 Meta/01 Attachments/Pasted image 20230503212335.png]]\n- Là dịch vụ đưa ra các khuyến nghị để hệ thống của chúng ta hoạt động tốt hơn theo 5 tiêu chí:\n\t- **Cost Optimization**\n\t- **Performance**\n\t- **Security**\n\t- **Fault tolerance**\n\t- **Service limits**\n\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/42.03-AWS/Well-Architected-Framework-Tool":{"title":"🥦 Well-Architected Framework \u0026 Tools","content":"\n## 🌿 Well-Architected Framework\n- Là tập hợp các nguyên tắc (best practice) để thực hiện việc build một kiến trúc trên AWS.\n- Không dự đoán trước traffic của hệ thống, thay vào đó hãy sử dụng các service linh động hơn như [[40123345 posts/42 Code/42.03 AWS/ASG - Auto Scaling Group|ASG]].\n- Nên thực hiện test hệ thống cả trên môi trường production, trên môi trường cloud việc này được hỗ trợ thực hiện dễ dàng và đảm bảo.\n- Nên xây dựng để mọi người dễ tiếp cận với kiến trúc(phát triển, thay đổi, ...) vd như sử dụng [[40123345 posts/42 Code/42.03 AWS/AWS CloudFormation|CloudFormation]].\n- Cho phép cải tiến kiến trúc. \n- Kiến trúc đảm bảo cho dữ liệu(đồng bộ, lưu trữ, ...)\n- Luôn thử nghiệm để phát triển(vd như giả định tình huống flash sale cho app, xem kiến trúc có hoạt động tốt không)\n- https://aws.amazon.com/architecture/well-architected\n\n## 🌿 Six Pillars\n![[00 Meta/01 Attachments/Pasted image 20230503205022.png]]\n- Operational Excellent\n- Reliability\n- Security\n- Performance Efficiency\n- Cost Optimization\n- Sustainability\n\n-\u003e Chúng ta không cần phải đánh đổi hay lựa chọn mức độ ưu tiên, tất cả sẽ liên kết và phụ thuộc lại để tổng hoà thành một hệ thống tốt.\n\n## 🌿 Well-Architected Tool\n- Là một công cụ miễn phí được giúp chúng ta review hệ thống dựa trên 6 trụ cột của Well-Architected Framework bằng cách trả lời các câu hỏi. Từ đó, công cụ này sẽ đưa ra những gợi ý để cải thiện hệ thống theo đúng chuẩn.","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/42-Code/CSS-Learning":{"title":"🥦 CSS Learning","content":"\n## 🌿 Resources\n1. [CSS- Tricks]([https://css-tricks.com/snippets/css/](https://css-tricks.com/snippets/css/))\n\n## 🌿 Refer \n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/43-Psychology/T%C6%B0-duy-nhanh-v%C3%A0-ch%E1%BA%ADm":{"title":"📘 Tư duy nhanh và chậm","content":"\n---\n\nChào mọi người, thời tiết hôm nay nó cứ bị mưa mưa, mát mẻ làm mình lười viết về mấy bài công nghệ khô khan quá =)) Chắc để đổi gió nay mình sẽ viết về quyển sách mà dạo này mình đang đọc nha. Quyển sách này giúp chúng ta nhìn cách vận hành suy nghĩ một cách rất dễ hiểu thông qua những diễn đạt của tác giả - một người đã dành cả cuộc đời để nghiên cứu về Tâm lý học hành vi.\n\n![[00 Meta/01 Attachments/tu-duy-nhanh-va-cham.png]]\n\n## Tác giả\n---\n`Daniel Kahneman` sinh năm 1934, nhà Tâm lý học người Mỹ gốc Israel, giành giải Nobel kinh tế năm 2002. Ông dành cả đời để nghiên cứu về Tâm lý học hành vi. Cùng với người động sự đã qua đời là Amos Tversky, hai ông đã có những nghiên cứu sâu sắc về con đường tư duy và nhận thức của con người.\n\nCuốn sách đã dành được nhiều giải thưởng danh giá như: Sách khoa học hay nhất của Học viện Khoa học Quóc gia năm 2012, Sách hay nhất nhất năm 2011 do Thời Báo New York bình chọn, cuốn sách được quan tâm nhất năm 2021 của tạp chí Los Angeles. \n## Nội dung\n---\nXuyên suốt quyển sách hai khái niệm được nhắc đến nhiều nhất đó là `Hệ Thống 1` và `Hệ Thống 2`. Hai nhân vật chính này là xuất phát điểm cho tất cả những suy nghĩ, quan sát, hành vi, trải nghiệm, hay quyết định, ... của mỗi chúng ta.\n`Hệ Thống 1` hoạt động với cơ chế suy nghĩ nhanh, tự động, cảm tính, bản năng, rập khuôn và kiểu giác quan thứ 6 mà chị em phụ nữ hay được trải nghiệm =))\n`Hệ Thống 2` thì ngược lại, suy nghĩ chậm, sở hữu sự điềm tĩnh, logic, tính toán, ý thức và đòi hỏi một sự nỗ lực khi hoạt động.\n\nKhông phải tự nhiên mà ca sĩ Tóc Tiên đã hát:\n\t`Chọn con \u003c3 hay là nghe lý trí, chọn yêu anh hay chọn phút giây biệt ly.`\n\nPhần lớn chúng ta thường lười kích hoạt `Hệ Thống 2`, để mặc cho `Hệ Thống 1` 'tự do tác oai tác quái' :D. Bạn nhớ lại xem bạn đã từng đột nhiên nổi hứng lên mua một món đồ đắt tiền nhưng khi nhận về bạn lại bỏ xó. Nếu tại thời điểm nổi hứng đó `Hệ Thống 2` xuất hiện có phải đã tốt hơn rồi không =))) Nhưng nếu chúng ta kích hoạt liên tục `Hệ Thống 2` thì sao? Cẩn thận bộ não của bạn sẽ bị quá tải đấy =)) 'Hội trầm cảm sau sinh' sẽ ko quên mời bạn gia nhập đâu :D   \n\nChúng ta luôn luôn suy nghĩ, lựa chọn, quyết định với mọi vấn đề trong cuộc sống và những điều đó đôi khi sẽ thay đổi cả cuộc đời của chính chúng ta hay nhiều người khác nữa. Hiểu được các cơ chế hoạt động, tránh được `những lỗi sai hệ thống` là điều vô cùng cần thiết. Cuốn sách này sẽ giúp chúng ta hiểu được những 'dòng chảy' của não bộ, hai Hệ Thống giao tiếp với thế giới xung quanh ntn, ... từ đó giúp chúng ta sẽ phần nào hiểu được năng lực tư duy của chính mình và phát huy nó một cách hiệu quả \u003c3\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/44-Finance/9-sai-l%E1%BA%A7m-t%C3%A0i-ch%C3%ADnh-c%E1%BB%A7a-ng-tr%E1%BA%BB":{"title":"💵 9 sai lầm tài chính của ng trẻ","content":"\n## 🌱 9 sai lầm tài chính của người trẻ\n\n![[00 Meta/01 Attachments/Pasted image 20221021224059.png]]\n\n### Nguồn\n- https://www.youtube.com/watch?v=2EyGqvZrbyc\u0026ab_channel=HieuNguyen\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/44-Finance/C%C4%83ng-th%E1%BA%B3ng-B%E1%BA%A5t-an":{"title":"🥶 Giai đoạn căng thẳng \u0026 Bất an","content":"\n✍️ Các kiến thức trong bài viết này được tổng hợp từ những chia sẻ của chú Hiếu Nguyễn trong [podcast](https://www.youtube.com/watch?v=rqtDSOCUEj0\u0026list=PL1bLXQ3Ow2laRk3IFEqbDLM_l6YHNPp8W\u0026index=3\u0026ab_channel=HieuNguyen).\n\n## 🌿 Nợ nần (level ⚠️) \n\n🌱 Thường sẽ là giai đoạn xuất phát điểm của các bạn trẻ bên nước ngoài. Vì bên này họ phát triển tư duy tự lập từ rất sớm, nên khi học đại học, các sinh viên sẽ phải tự trả số tiền học của mình. Nhưng vì hầu như các bản trẻ lúc này chưa có bất kỳ khoản tích lũy nào nên chính phủ sẽ hỗ trợ cho vay , khoản vay này có tên là [Student Loan](https://en.wikipedia.org/wiki/Student_loan)\n- Khoản nợ này ở Mỹ có thể lên đến vài chục nghìn đô.\n- Thường sẽ mất vài năm, có thể lâu hơn mới có thể trả được hết món nợ này.\n\n\u003e Là món nợ lớn.\n\n## 🌿 Ăn bám gia đình (level 0️⃣)\n\n🌱 Tự bản thân chưa nuôi được mình, phụ thuộc hoàn toàn vào chu cấp của gia đình.\n\n🌱 Nên đi làm sớm để biết **Quý trọng đồng tiền**. Từ đó có thể dần dần hình thành cảm nhận về tài chính =\u003e Nền tảng để xây dựng về sau.\n\n\u003e Đến năm 18 tuổi, nên kiếm việc làm thêm(phù hợp, lương thấp xíu cũng được). \n\u003e Cố gắng chuyển sang level 1️⃣ sớm nhất có thể.\n\n## 🌿 Tự nuôi bản thân (level 1️⃣)\n\n🌱 Tự làm được tiền, nuôi bản thân, không phụ thuộc vào gia đình nữa.\n\n🌱 Sống theo kiểu có tháng nào tiêu hết tháng đó. Có rất nhiều người chỉ dừng lại ở bước này đến cuối đời.\n\n🌱 Tiềm ẩn rủi ro bị lùi về level 0️⃣ hoặc tệ hơn level ⚠️. Khi bản thân có tiền, nếu không có cách quản lý tài chính hợp lý + tâm lý có thể dùng lương để trả thì rất có thể sẽ bị vướng vào nợ nần - báo nhà :v\n\n\u003e Rất bấp bênh, không thể xử lý được các biến cố bất ngờ xảy ra(mất việc, đau ốm, có việc đột xuất, ...). Có thể tụt level bất cứ lúc nào.\n\u003e \n\u003e Đạt được level này, hay ngay lập tức chuyển qua giai đoạn tiếp theo đó là [[40123345 posts/44 Finance/Theo dõi \u0026 Kiến tạo| Theo dõi \u0026 Kiến tạo]]\n\n## ⛔ Ảnh hưởng của nợ nần\n\nCó 2 kiểu nợ phổ biến:\n\n### 🌱 Nợ không có lãi suất\n- Thường sẽ là nợ người thân, bạn bè. Mà để từ level 1️⃣ về đến level ⚠️ thì chúng ta cũng đã phải nợ nhiều nguồn, nhiều tiền rồi.\n- Không trả được đúng hạn =\u003e Mất uy tín.\n- Nhiều quá không trả nổi =\u003e Mất tư cách.\n\n\u003e Cái mất nhiều nhất chính là mất những mối quan hệ chất lượng.\n\n### 🌱 Nợ có lãi suất\n\nLoại này thì lại có 2 kiểu =))\n\n- Nợ tử tế\n\t- Nợ kiểu vay ngân hàng, nợ tín dụng =\u003e lãi suất cao, thường sẽ là 2%-4%/tháng =\u003e ~24%-42%/năm 😱.\n\n- Nợ không tử tế\n\t- Vay nóng, nợ xã hội đen, ... thì thôi 🥵 \n\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/44-Finance/Each-step-to-the-Financial-Freedom":{"title":"🗺️ Each step to the Financial Freedom","content":"\n![[00 Meta/01 Attachments/Pasted image 20221119163052.png]]\n\n📂 Ảnh được lấy từ [podcast](https://www.youtube.com/watch?v=GlUvl-MWn6E\u0026list=PL1bLXQ3Ow2laRk3IFEqbDLM_l6YHNPp8W\u0026index=2\u0026ab_channel=HieuNguyen) của chú Hiếu Nguyễn và bài viết này là tổng hợp những kiến thức mà chú đã chia sẻ trong podcast đó.\n\nNhư đã thấy ở bức ảnh trên, có bốn cột mốc chính đánh dấu cho từng giai đoạn trong hành trình ***Tự do tài chính***. \n\n## 🌿 [[Căng thẳng \u0026 Bất an]]\n\n🌱 Nợ nần: trạng thái thấp nhất (level ⚠️) \n- Đây thường sẽ là xuất phát điểm của hầu hết các bạn trẻ bên nước ngoài. Khi ra trường họ sẽ phải gách 1 món nợ - [Student Loan](https://en.wikipedia.org/wiki/Student_loan)\n- Còn ở VN thường sẽ có xuất phát điểm ở cột mốc thứ 2\n\n🌱 Ăn bám gia đình (level 0️⃣)\n- Chưa có gì trong tay, phụ thuộc hoàn toàn vào gia đình.\n\n🌱 Tự nuôi bản thân (level 1️⃣)\n- Bắt đầu có thu nhập và có thể tự nuôi bản thân nhưng vẫn theo kiểu lương tháng nào tiêu hết tháng đấy.\n\n\u003e Điểm chung ở giai đoạn này là bản thân sẽ luôn ở trong trạng thái căng thằng và bất an. Nếu có những biến cố(mất việc, ốm đau, ...) xảy ra sẽ hoàn toàn không có khả năng đối ứng được.\n\n## 🌿 [[Theo dõi \u0026 Kiến tạo]]\n\n🌱 Theo dõi chi tiêu (level 2️⃣ - trạng thái hiện tại của tôi)\n-  Theo dõi chi tiết từng chi tiêu hàng ngày của bản thân. Từ đó tính toán được mức ***Chi tiêu tối thiểu*** và ***Chi tiêu tiêu chuẩn***. \n- Bước này cực kì quan trọng, 2 mức độ chi tiêu xác định được ở trên sẽ là tiền đề để chúng ta tính toán những cột mốc tiếp theo.\n- Hiện tại tôi đã và đang tập hình thành thói quen lưu lại chi tiêu hằng ngày bằng app Money Lover.\n\n\u003e Tạo cho bản thân thói quen theo dõi chi tiêu. Các mức chi tiêu sẽ thay đổi theo thời gian nên thói quen này vô cùng quan trọng.\n\u003e \n\u003e Xác định được mức ***Chi tiêu tối thiểu*** và ***Chi tiêu tiêu chuẩn***. \n\nSau quá trình **theo dõi** 👀, tiếp đến sẽ là **hành động** 👷‍♂️.\n\n🌱 Xóa nợ (level 3️⃣)\n- Là nền móng quan trọng để chúng ta có thể xây dựng vững chắc mô hình tài chính của bản thân sau này. \n- Ở level này, chúng ta cần xác định những khoản nợ xấu, khoản nợ tốt, thứ tự ưu tiên của từng khoản nợ. Kết hợp với kết quả của việc theo dõi chi tiêu =\u003e Có một kế hoạch rõ ràng cho việc trả nợ dứt điểm.\n- Đừng nóng vội khi vừa muốn trả nợ vừa muốn tích góp và vừa muốn đầu tư. Bạn sẽ phải hối hận vì phải xử lý nhiều những tasks khó cùng một lúc đấy.\n\n\u003e Tâm lý thoải mái, không lo đến nợ nần nữa, tập trung hoàn toàn tâm trí cũng như nguồn tiền cho việc xây dựng tài chính cá nhân.\n\nTrả nợ đời xong rồi thì tập trung xây dựng mô hình tài chính của bản thân thôi 💪\n\n🌱 Setup dòng tiền (level 4️⃣)\n- Không nên để tiền ở một chỗ, dễ dẫn đến việc tiêu tiền lấn sang những quỹ có mục đích khác.\n- Ở bước này chúng ta sẽ thiết lập Dòng chảy cho nguồn tiền của bản thân. Tiếp cận những định nghĩa mới như Quỹ Khẩn Cấp (Emergency Fund), Rainy Day Fund, Every Day Fund, Saving Account, ... được sử dụng như thế nào? Cách xác định tỉ lệ cho từng quỹ là bao nhiêu?\n- Sau khi Setup xong, tôi có thể xác định được runway của mình là bao nhiêu. Khi có biến cố, chất lượng cuộc sống của tôi vẫn được đảm bảo trong thời gian bao lâu. \n\n\u003e Tạo ra một hành lang an toàn về tài chính cho bản thân. Tránh bản thân gặp phải những bất an khi có biến cố xảy đến.\n\u003e \n## 🌿 Tích lũy \u0026 Đầu tư (Well Building)\n\nMượn cách ví von của [Kevin O'Leary](https://en.wikipedia.org/wiki/Kevin_O%27Leary) - một trong những Shark xuất hiện trong chương trình Shark Tank của Mỹ chia sẻ:\n\u003e Tôi coi tiền của mình là những chiến binh 💂. Mỗi ngày tôi thả những chiến binh của mình ra trận và cuối ngày tôi muốn những chiến binh đó sẽ đem lại cho mình thật nhiều tù binh 💵💵💵.\n\nSau khi đạt được level 4️⃣, chúng ta đã xây dựng được một hậu phương vững chắc. Công việc bây giờ sẽ là tuyển mộ quân sĩ để bắt đầu ra trận chinh chiến ⚔️.  \n\n🌱 Trương mục đầu tư (level 5️⃣)\n- Xây dựng trương mục đầu tư và có cho mình những phương châm để quản lý những trương mục này.\n\n🌱 Thu nhập thụ động (Passive Incomes - level 6️⃣)\n- Xây dựng và phát triển những nguồn thu nhập thụ động.\n\n\u003e Level 5️⃣ \u0026 6️⃣ sẽ đi liền với nhau, giúp chúng ta chiêu mộ thêm nhiều binh lính 💂 (gia tăng nguồn vốn).\n\u003e Nguyên tắc căn bản của giai đoạn này đó là tăng thu và giảm chi.\n\n![[00 Meta/01 Attachments/Pasted image 20221119225431.png]]\n\nSau 2 level trên, khi đã tích lũy được một nguồn vốn nhất định, bây giờ chúng ta có thể chuyển qua bước **Đầu tư**.\n\n🌱 Đầu tư (level 7️⃣)\n- Tìm cách chọn những mô hình đầu tư hiệu quả.\n- Học hỏi, trau dồi, nâng cao kiến thức, kinh nghiệm đầu tư.\n\n\u003e Ở gian đoạn này, chúng ta có thể xen kẽ thực hiện các bước với nhau, không cần tuần tự như giai đoạn 2.\n\u003e Giai đoạn này sẽ là giai đoạn dài hơi nhất trong hành trình.  Liên tục tích góp và đầu tư thì sẽ đến lúc chúng ta sẽ bước đến giai đoạn thứ 4(tôi không muốn dùng từ giai đoạn cuối cùng vì đây không phải là điểm kết thúc).\n\n## 🌿 Tự do tài chính\n\nCó 3 cột mốc khi chúng ta đạt đến giai đoạn `chính quả` này, đó là:\n\n🌱 An toàn tài chính (Finacial Security - level 8️⃣)\n- Có được số tiền có thể đảm bảo mức sống cơ bản của bản thân cho đến cuối đời, kể cả khi chúng ta vì một lý do nào đó mà không thể làm việc được nữa.\n- Có quyền bỏ đi(ở mọi lĩnh vực)\n\n🌱 Độc lập tài chính (Financial Independence - level 9️⃣)\n- Khái niệm FIRE - Financal Independence Retire Early - Ngưng làm việc nhưng vẫn đáp ứng được những nhu cầu liên quan đến tài chính theo mức chúng ta mong muốn.\n\n🌱  [[40123345 posts/44 Finance/What is the Financial Freedom?|Tự do tài chính]]  (Financial Freedom - level 🔟)\n- Khi đã ở level 9️⃣ đủ lâu chúng ta sẽ dần cảm nhận được sự tư do khi không phải lệ thuộc vào tiền bạc.\n- Lúc này tiền sẽ là công cụ để chúng ta thực hiện những mục tiêu khác.\n-  Có thể tự tin nói: ***Fuckyou Money!!!***\n\n\n \n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/44-Finance/Stock-and-related-stuff":{"title":"🥦 Stock and related stuff","content":"\n### 🌿 Các khái niệm\n- 🌱 Giả sử mình có một ý tưởng kinh doanh, ban đầu mình sẽ xoay vốn từ người thân trong gia đình, bạn bè để hiện thực hóa ý tưởng kinh doanh đó. Sau một thời gian phát triển, mô hình kinh doanh của mình có kết quả vô cùng khả quan và mình muốn mở rộng nó ra hơn nữa. Nhưng lúc này, số tiền mình cần lại quá lớn, không thể vay từ người thân, bạn bè như lúc đầu nữa nên mình đã vay vốn ngân hàng hoặc từ các quỹ đầu tư. Lúc này các bên cho vay sẽ cần mình thế chấp tài sản hoặc như Shark Tank, mình sẽ phải đổi 10% **cổ phần** để lấy 500.000$ để tiếp tục phát triển doanh nghiệp.\n\n![[00 Meta/01 Attachments/Pasted image 20221203213542.png]]\n\n\u003e [!info] Cổ phần (Share)\n\u003e \n\u003e  Là phần vốn nhỏ nhất của một công ty. Vốn điều lệ của một công ty cổ phần được chia thành nhiều phần bằng nhau được gọi là cổ phần.\n\n\n- 🌱 Cơ mà sau đấy công ty lại càng tiềm năng và mình tham vọng 😎 muốn mở rộng nó ra phạm vi cả nước, xa hơn là toàn cầu nên số tiền 500.000$ là không đủ. Lúc này mình cần phải tìm đến nơi có nguồn vốn dồi dào hơn - đó là sàn chứng khoán. Có hai cách tăng vốn đó là sử dụng:\n\t- 💰 Công cụ vốn (**Cổ phiếu - Stock**)\n\t- 💰 Công cụ nợ (Trái phiếu - Bond)\n\n\u003e [!info] Cổ phiếu (Stock)\n\u003e \n\u003e  Cổ phiếu hay vốn cổ phần, là một loại **chứng khoán** đại diện cho việc sở hữu một phần của tổ chức phát hành.\n\n![[00 Meta/01 Attachments/Pasted image 20221203205809.png]]\n\n\u003e [!info] Chứng khoán (Security)\n\u003e\n\u003e Là một bằng chứng tài sản hoặc phần vốn của tổ chức phát hành. Chứng khoán có thể là Cổ phiếu, Trái phiếu, Chứng chỉ quỹ và các hình thức khác.\n\n- 🌱 Lúc này, mình sẽ phải liên tục chia nhỏ ra thành nhiều **cổ phần** để các **cổ đông** có thể sở hữu, qua đó mình sẽ nhận được thêm tiền để đầu tư và phát triển các dự án mới. \n\n![[00 Meta/01 Attachments/Pasted image 20221203220524.png]]\n\n\u003e [!info] Cổ đông (Shareholder)\n\u003e \n\u003e  Cổ đông là những người nắm giữ cổ phần của công ty. Cổ đông nắm giữ càng nhiều cổ phần thì sẽ càng có sức ảnh hưởng đến đường lối phát triển hoặc các quyết định của công ty.\n\n- 🌱 Sau đó, doanh nghiệp của mình làm ăn có lãi, mình sẽ trả cho những **cổ đông** của mình một số tiền thưởng - gọi là **cổ tức**.\n\n\u003e [!info] Cổ tức (Dividend)\n\u003e \n\u003e  Là một phần lợi nhuận sau thuế được chia cho các cổ đông. Có thể là tiền hoặc cổ phiếu.\n\n\n### 🌿 Phân loại cổ phiếu\n\n- 🌱 **Cổ phiếu thường(common) 💢 Cổ phiếu ưu đãi(preferred)**\n\t- Phân loại theo luật\n\n| **Cổ phiếu thường(common)** | **Cổ phiếu ưu đãi(preferred)**|\n|---------------- | ---------------|\n|Sở hữu cổ phần doanh nghiệp|Sở hữu cổ phần doanh nghiệp|\n|**Có** quyền biểu quyết tương đương với sổ cổ phần nắm giữ|**Không có** quyền biểu quyết tương đương với sổ cổ phần nắm giữ|\n|Được nhận cổ tức thường|Được nhận cổ tức thường + cổ tức ưu đãi|\n\n- 🌱 **Cổ phiếu tăng trưởng(growth stock) 💢 Cổ phiếu giá trị(value stock)**\n\t- Phân loại theo cổ tức\n\n| **Cổ phiếu tăng trưởng(growth stock)** | **Cổ phiếu giá trị(value stock)**|\n|---------------- | ---------------|\n|Là những cổ phiếu thuộc các tổ chức có khả năng tăng trưởng mạnh trong thời gian ngắn sắp tới|Là những cổ phiếu thuộc các tổ chức đã lớn tuổi, hướng đến sự ổn định bền vững|\n|Rủi ro cao|Ổn định|\n|Lợi nhuận lớn|Lợi nhuận trung bình|\n|Sử dụng lợi nhuận để tái đầu tư|Nhận được cổ tức|\n|Là những công ty phát triển lĩnh vực mới(như sinh học, FinTech, AI,...)|Là những tổ chức thâm niên trên thị trường như Hòa Phát, Vin, ...|\n\n- 🌱 **Cổ phiếu Large Cap/Bluechip 💢 Cổ phiếu Mid Cap 💢 Cổ phiếu Small Cap/Penny 💢 Cổ phiếu Micro Cap**  \n\t- Phân loại theo vốn hóa thị trường\n\n| **Name** | **Volumn** |\n| --------------- | --------------- |\n| **Large Cap/Bluechip** | 10,000 \u003e= Vốn hóa \u003e 1,000 tỷ|\n| **Mid Cap** | 10,000 \u003e= Vốn hóa \u003e 1,000 tỷ|\n| **Small Cap/Penny** | 1,000 \u003e= Vốn hóa \u003e 100 tỷ |\n| **Micro Cap** | 100 tỷ \u003e= Vốn hóa |\n\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/44-Finance/The-4-Rule":{"title":"🗺️ The 4% Rule","content":"![[00 Meta/01 Attachments/Pasted image 20221118220330.png]]\n🌱 Quy tắc 4% trong lĩnh vực tài chính cá nhân được sử dụng để xác định tương đối 3 cột mốc quan trọng trong hành trình [[40123345 posts/44 Finance/What is the Financial Freedom?|Tự do tài chính]], đó là:\n- An toàn tài chính (Financial Security)\n- Độc lập tài chính (Financial Independent)\n- Tự do tài chính (Financial Freedom)\n\n## 🌿What?\nQuy tắc 4% được hình thành trong quá trình nghiên cứu và phân tích thị trường trong suốt 75 năm của William P. Bengen. Ông nhận ra rằng trong chu kì 30 năm, 90% các nhà đầu tư có thể bảo toàn được tài sản của mình nếu mỗi năm rút ra 4% trong tổng số đó, cùng với với mức lạm phát trung bình là 3%.\n\n## 🌿 Issue\nTuy nhiên, vẫn có điểm yếu đối với quy tắc này. Theo Bob Dockendorff - chuyên gia tư vấn tài chính cá nhân người Mỹ, Phó chủ tịch Công ty tư vấn tài chính Claro Advisors đã nêu ra khá nhiều điểm bất cập có thể bị ảnh hưởng như:\n- Mức lạm phát hiện nay biến động vô cùng khó đoán\n- Các yếu tố vĩ mô như suy thoái kinh tế, biến động chính trị(Nga X Ucraina), bệnh tật(Covid 19), ...\n\n\u003e Chính vì vậy, chúng ta cần chuẩn bị những phương án quản lý số tiền của mình một cách hợp lý hơn.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/44-Finance/Theo-d%C3%B5i-Ki%E1%BA%BFn-t%E1%BA%A1o":{"title":"✍️ Giai đoạn Theo dõi \u0026 Kiến tạo","content":"\n✍️ Các kiến thức trong bài viết này được tổng hợp từ những chia sẻ của chú Hiếu Nguyễn trong [podcast](https://www.youtube.com/watch?v=lKhIompb0M0\u0026list=PL1bLXQ3Ow2laRk3IFEqbDLM_l6YHNPp8W\u0026index=4\u0026ab_channel=HieuNguyen).\n\n## 🌿 Theo dõi chi tiêu (level 2️⃣ )\n\n🌱 Là bước quan trọng nhất! Nếu trong toàn bộ hành trình, chỉ làm duy nhất một bước theo dõi chi tiêu thì nó chắc chắn vẫn sẽ ảnh hưởng rất lớn đến vấn đề tài chính cá nhân của chúng ta.\n\n###  Bước 1 - Ghi lại chi tiêu\n\n🌱 Sử dụng một app điện thoại(hay bất cứ tool gì tiện nhất) như tôi đang sử dụng Money Lover để ghi chú lại tất cả những chi tiêu hàng ngày của mình. Cấu trúc ghi chú:\n- Ngày.                     Vd: 2022-11-20 \n- Mục đích chi tiêu. Vd: Đổ xăng\n- Số tiền.                  Vd: 70,000\n\n\u003e Quan trọng nhất là ghi chép đầy đủ tất cả chi tiêu. Từ đó mới có đủ dữ liệu để chúng ta đánh giá cho những bước tiếp theo.\n\n### Bước 2 - Phân loại chi tiêu\n\n🌱 Sử dụng Excel thống kê toàn bộ dữ liệu chi tiêu của chúng ta đã log lại theo từng tháng. Cấu trúc thống kê:\n\n![[00 Meta/01 Attachments/Pasted image 20221120145932.png]]\n\n- **Must have**: Các khoản thiết yếu, bắt buộc phải chi tiêu.\n- **Nice to have**: Các khoản có thì tốt mà không có cũng chả làm sao.\n- **Wasted**: Chi tiêu lãng phí, không có mục đích(Ăn nhậu, mua sắm linh tinh, ...).\n\n\u003e Nên làm ít nhất 1 tháng, lí tưởng là vài tháng. Phân loại càng lâu sẽ cover được càng đầy đủ những chi tiêu của chúng ta\n\n🌱 ***Chi tiêu tối thiểu*** =  **Must have**\n\n🌱 ***Chi tiêu tiêu chuẩn*** = **Must have** + **Nice to have**\n\nNếu trong sheet phân loại của chúng ta không có dòng nào là trả nợ, thì chúng ta có thể skip qua bước tiếp theo.\n\n## 🌿 Trả nợ (level 3️⃣)\n\nTháng trước do ăn cơm Thố nhiều quá nên tôi có dùng ví trả sau Momo, mà tôi trả xong rồi nên trộm vía giờ tôi đang không có khoản nợ nào cả 😆.\n\nNhưng kiến thức không thừa, xem trước để nếu sau này có ăn cơm Thố quá liều thì còn biết đường mà trả nợ. Let's gooo 💪!!\n\n![[00 Meta/01 Attachments/Pasted image 20221120152632.png]]\n\n### Bước 1 - Tách nguồn tiền\n \n 🌱 Setup thành 2 nguồn tiền\n - **Everyday account**: là số tiền phục vụ cho chi tiêu tối thiểu của bản thân(= **Must have**)\n - **Emergency Fund**:  quỹ khẩn cấp, theo đúng tên gọi, trong giai đoạn này, khẩn cấp nhất chính là trả nợ.\n\n\u003e Nên tách riêng ra 2 tài khoản ở hai ngân hàng, cho cái quỹ Emergency khuất mắt đi, không nghĩ gì đến nó nữa.\n \n### Bước 2 - Xác định các khoản nợ \u0026 Đánh độ ưu tiên\n- Lãi suất cao trả trước.\n- Cố gắng sống ở mức tối thiểu, chỉ tập trung trả nợ thôi.\n\n## 🌿 Setup dòng tiền (level 4️⃣)\n\n🌱 Setup thành 4 tài khoản:\n\n![[00 Meta/01 Attachments/Pasted image 20221120155605.png]]\n\n### 💰 Everyday Account\n- Mỗi tháng sẽ để ở đây mức sống tối thiểu.\n- Ép bản thân chỉ được chi tiêu với số tiền trong tài khoản này thôi.\n\n### 💰 Emergency Fund\n- Quỹ khẩn cấp dùng khi có những việc bất khả kháng như mất việc, bệnh tật, ...\n- Ưu tiên đổ đầy quỹ khẩn cấp trước tiên(nếu có những nguồn thu nhập khác sẽ đổ vào đây trước, khi đầy rồi mới đổ vào những quỹ tiếp theo).\n- ***Target*** = ***Chi tiêu tối thiểu*** x ***runway***(số tháng quỹ cover)\n\n\u003e Tối thiểu là 6 tháng, lý tưởng là 12 tháng.\n\n### 💰 RainyDay Fund\n- Quỹ dùng cho những việc có kế hoạch trước như mua điện thoại mới, sửa nhà, ...\n- Có 2 kiểu xác định ***target*** cho quỹ này:\n\t- Dựa theo kế hoạch, ví dụ như xác định trước cần mua điện thoại 30tr, sửa nhà 50tr, chúng ta sẽ set **target** cho RainyDay Fund là 80tr\n\t- Dựa theo runway. Nếu chúng ta chưa có kế hoạch gì thì có thể set ***target*** với runway từ 3-6 tháng x ***Chi tiêu tối thiểu***.\n\n### 💰 Investment Account\n- Không có ***target*** cho tài khoản này. Bỏ tiền vào càng nhiều càng tốt.\n\n\u003e Ở giai đoạn này, bất cứ khi nào chúng ta có thêm nguồn thu nhập, ngay lập tức phân phối tiền theo mô hình đã setup ở trên. Hạn chế tối đa việc để tiền rảnh ở ***Everyday Account*** nếu không muốn hối hận khi thấy tiền nó cứ bay đi mất 💸\n\u003e \n\u003e Sau giai đoạn này chúng ta đã có thêm quyền lựa chọn. Vd nếu môi trường làm việc hay công việc hiện tại không còn chất lượng, chúng ta hoàn toàn có thể xin nghỉ 👋, bỏ ra vài tháng để tìm cho mình công việc tốt hơn.\n\u003e \n\u003e ✨ Loại bỏ cảm giác bất an, có đủ khả năng đối ứng với những biến cố trong cuộc sống.","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/44-Finance/Vai-tr%C3%B2-c%E1%BB%A7a-ti%E1%BB%81n":{"title":"🥦 Vai trò của tiền","content":"\n## 🌿 Câu chuyện\n\n![[00 Meta/01 Attachments/Pasted image 20221217160714.png]]\n\n![[00 Meta/01 Attachments/Pasted image 20221217161149.png]]\n\n![[00 Meta/01 Attachments/Pasted image 20221217164030.png]]\n\n- Loài người đã sử dụng mô hình trên trong hàng ngàn năm. Cách để chúng ta tồn tại và hạnh phúc đó là:\n\t- Hiểu rõ giá trị của mình là gì.\n\t- Biết được nhu cầu thực sự của bản thân.\n\t- Tìm được thị trường phù hợp.\n\t- Đạt được thỏa thuận tốt, win-win giữa hai bên.\n\n\u003e [!info] Note\n\u003e \n\u003e Bản chất, Tiền không tồn tại!\n\n## 🌿 Vấn đề về trao đổi\n\n![[00 Meta/01 Attachments/Pasted image 20221217175513.png]]\n\n- Vấn đề:\n\t- Giá trị của Mea không phù hợp với nhu cầu của Fru.\n\t- Khi Mea có nhiều thịt nhưng chưa có nhu cầu, nếu cứ tích góp lâu dần thịt sẽ bị kém chất lượng.\n\n\u003e [!Info] Tiền\n\u003e \n\u003e Loài người đã phát mình ra tiền để làm vật trao đổi trung gian.\n\n- Nếu muốn hiểu thêm về khái niệm của tiền, mọi người có thể xem ở [đây](https://vi.wikipedia.org/wiki/Ti%E1%BB%81n).\n\n![[00 Meta/01 Attachments/Pasted image 20221217184857.png]]\n\n\u003e [!info] Giá trị\n\u003e \n\u003e Tiền có thể là Giá trị, nhưng Giá trị chưa chắc đã là tiền! \n\n\n## 🌿 Tiền đã làm thay đổi mọi thứ\n\n![[00 Meta/01 Attachments/Pasted image 20221217191232.png]]\n\n![[00 Meta/01 Attachments/Pasted image 20221217192115.png]]\n\n![[00 Meta/01 Attachments/Pasted image 20221217194353.png]]\n\n![[00 Meta/01 Attachments/Pasted image 20221217213754.png]]\n\n![[00 Meta/01 Attachments/Pasted image 20221217220651.png]]\n\n![[00 Meta/01 Attachments/Pasted image 20221217220913.png]]\n\n## 🌿Ngẫm\n\n- Câu chuyện trên không có ý nói Tiền là xấu nhưng Tiền có khả năng chi phối chúng ta nếu chúng ta không có đủ khả năng để kiểm soát nó.\n- Suy cho cùng Tiền cũng chỉ là công cụ giúp cho quá trình vận hành trao đổi được thuận tiện hơn. Để không lệ thuộc vào Tiền hãy quay về mô hình nguyên thủy và phát huy những giá trị cốt lõi.\n\t1. Xác định được đúng giá trị của bản thân.\n\t2. Biết được nhu cầu thật sự của mình là gì.\n\t3. Tìm được đúng thị trường để trân trọng những giá trị và đáp ứng được những nhu cầu của chúng ta.\n\t4. Tạo ra những thỏa thuận chất lượng, thể hiện giá trị bản thân một cách trung thực đáp ứng được nhu cầu của người khác trên thị trường. Từ đó thỏa mãn những nhu cầu thật sự của bản thân.\n\n\u003e [!info] Biết đủ\n\u003e \n\u003e “Biết đủ” chính là cách nắm giữ hạnh phúc trong tay.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/44-Finance/What-is-the-Financial-Freedom":{"title":"🗺️ What is the Financial Freedom?","content":"\n\u003e 🚀 Khi bắt đầu muốn tìm hiểu bất kì lĩnh vực gì, chúng ta nên có thói quen chủ động đặt ra 2 câu hỏi `What?` và `Why?` trước khi thực sự theo đuổi. Trong suốt hành trình đó, liên tục làm rõ câu hỏi `How?`. \n\u003e \n\u003e Câu hỏi `How?` thường sẽ mất rất nhiều thời gian, chúng ta cần có nhiều trải nghiệm, kinh nghiệm để đúc kết. Quá trình này có thể là một vài năm, chục năm hay có khi là cả đời. Chính vì vậy làm rõ  `What?` và `Why?` thật sự quan trọng nếu không chúng ta sẽ lãng phí thời gian và công sức của mình. \n\u003e \n\u003e 🌱 What? : làm rõ cái chúng ta muốn thực hiện, theo đuổi là gì?\n\u003e \n\u003e 🌱 Why? : tại sao chúng ta nên thực hiện, theo đuổi nó, chúng ta sẽ \n\u003e nhận được gì?\n\u003e \n\u003e 🌱 How? : tôi cần làm như thế nào để cải thiện kết quả?\n \n## 🌿 What?\n\u003e 🤔 Tự do tài chính là gì?\n\n![[00 Meta/01 Attachments/Pasted image 20221119145610.png]]\n\n🌱 Theo ý hiểu ở thời điểm hiện tại của tôi, ***tự do tài chính*** là trạng thái đạt được khi chúng ta đã thoát khỏi sự ràng buộc của đồng tiền. \n\n🌱 Tiền sẽ là công cụ để chúng ta thực hiện những mục tiêu khác.\n\n🌱 Là khi chúng ta có thể tự tin nói: \n\u003e Fuckyou Money 😏😏😏\n\n\n## 🌿 Why?\n\u003e 🤔 Tại sao tôi phải bỏ ra rất nhiều thời gian và công sức để đạt được ***Tự do tài chính***?\n\n\u003e Đồng tiền không có xấu. Chỉ có 2 sự lựa chọn: ***Mình quản lý Tiền*** hoặc ***Tiền quản lý Mình***.\n\n🌱 Không phải Tự do tài chính là **~~Sự giàu có~~**. Gốc rễ thật sự của hành trình này chính là ***Tự Do***. Đây là thứ xa xỉ nhất mà đến cả những người có rất nhiều tiền cũng chưa chắc đã có được. \n\n🌱 Lúc này đồng tiền chỉ là công cụ giúp chúng ta thoải mái hơn trong mọi quyết định mà thôi.\n\n🌱 Là hành trình giúp chúng ta thay đổi và trau dồi mindset.\n\n🌱 Mang lại chất lượng cho cuộc sống - một cuộc đời đáng sống.\n\n## 🌿 How?\n\u003e 🤔 Làm thế nào để đạt đuợc ***Tự do tài chính***?\n\n🌱 Loại bỏ những lối suy nghĩ sai lệch về tài chính.\n- Đánh đồng chi tiêu phóng khoáng và chi tiêu không có kiểm soát.\n- Không có quản lý chi tiêu, lương tháng nào tiêu hết tháng đấy.\n- Cẩn thận khi chưa kịp ***Giàu*** đã ***Già***.\n\n🌱 Trang bị kiến thức:\n- **Mindset \"biết đủ\"**.\n- **Escape Velocity** - Vận tốc thắng được trọng lực của Trái Đất để có thể đưa được vệ tinh ra ngoài vũ trụ. Trong lĩnh vực tài chính, **là một con số (dựa trên [[40123345 posts/44 Finance/The 4% Rule|The 4% Rule]] thắng được sức cản của đồng tiền** giúp chúng ta mở rộng danh sách lựa chọn của bản thân(Tự do).\n- [[40123345 posts/44 Finance/Each step to the Financial Freedom|Xác định từng cột mốc nhỏ]] cho hành trình này.","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/40123345-posts/45-Mindset/L%C3%A0-%C4%91%C3%A0n-%C3%B4ng-...":{"title":"🥦 Là đàn ông ...","content":"\n*Vì thấy hay nên mình lưu lại để đối chiếu với những trải nghiệm của cá nhân sau này. Nguồn lầy từ [post này](https://ngochieu.com/neu-ban-la-dan-ong/) của chú Hiếu Nguyễn, chú đã dịch từ một bài viết của Tiến sĩ Lý Khai Phục ([Kai-Fu Lee](http://en.wikipedia.org/wiki/Kai-Fu_Lee)) – ông từng là Phó tổng giám đốc Microsoft toàn cầu trong thập kỷ 90, rồi đảm nhận Phó tổng giám đốc Google châu Á năm 2005. Ông sinh năm 1961 tại Đài Bắc, thường gây sóng gió bởi những phát ngôn sáng suốt nhưng ngôn từ trần trụi khó nghe*\n\n🌿 Nếu bạn là đàn ông, nếu bạn đã hai mươi, nhưng bạn chưa hai lăm tuổi, bạn buộc phải tìm được một thứ gì đó ngoài tình yêu, giúp đôi chân bạn đứng vững vàng trong cuộc đời này. Bạn phải bắt đầu nghĩ cách để kiếm ĐỦ và sống ĐƯỢC.\n\nTôi chưa từng bao giờ nghĩ bằng cấp là thứ quan trọng, thiên tài với danh nhân đâu phải từ lò luyện và trường lớp mà ra. Nhưng nếu bạn không học tới nơi tới chốn, thì dù có đi làm cửu vạn, ngay cả bao cát cũng sợ rằng chẳng biết cách mà vác.\n\nBạn buộc phải làm cho những suy nghĩ văn vẻ và cảm xúc màu mè thị dân của mình dần trở thành lối tư duy sáng sủa, rõ ràng và những ngôn từ giản tiện ngắn gọn. Bởi những thứ màu mè và bồng bột sẽ không thể tồn tại lâu. Bạn phải biết rằng, những sự thích thú khi khi đọc văn hay, nghe lời bay bướm mang lại sẽ chẳng mấy giá trị, trong khi thứ quan trọng nhất lại nằm ở trí tuệ, tinh thần, tâm hồn, nội dung, tư duy của bạn.\n\nLà đàn ông, làm ơn đừng đọc văn của những nhà văn nữ cùng thời với bạn.\n\nLà đàn ông, làm ơn đừng trách người khác, đừng nhỏ nhặt, làm ra vẻ đáng thương.\n\nLàm ơn đừng nghĩ đến cái gì là viết về cái đó.\n\nVà chớ tiếc rẻ đôi chút cảm động bé nhỏ, đôi chút thương xót nhỏ nhoi.\n\nBạn phải tin vào cái đẹp, tin vào hơi ấm, vào lòng tin con người, sự tự trọng của mỗi người, bạn hãy giữ gìn những phẩm chất xưa cũ này. Tôi không muốn bạn bốc đồng, vô vị, mù mờ, chà đạp chính mình và làm thương tổn người khác. Bạn không nên nhào nặn đời bạn thành một đống hỗn độn tổng hợp đủ thứ.\n\nKhi bạn thay đổi con người bạn, hãy cố nâng niu những giá trị bản thân, cho dù bạn biết rõ, không phải ai cũng ưa những gì bạn đang có.\n\nLàm ơn đừng chấp nhận thỏa hiệp với những con người đang ngụy trang là họ thức thời, cấp tiến. Họ chỉ là những kẻ vô công rồi nghề đang tìm cách biện minh cho sự thua kém của bản thân họ. Sự mạnh mẽ, bản lĩnh đàn ông nằm ở tận trong trái tim bạn, bạn có sức mạnh và vẻ đẹp từ trong tim, từ niềm tin mà dù thời gian và tuổi trẻ có trôi qua cũng không khuất phục được.\n\nBạn không có quyền ngồi trong cái tháp ngà của trường học, rồi bảo tôi yêu thế giới này tươi đẹp. Bạn phải nhìn thấy cái đen tối của thế giới, sự bẩn thỉu của cuộc đời, sự xấu xa của con người, sau đó mới nói rằng tôi vẫn yêu thế giới này, tôi vẫn yêu cuộc sống và tôi sống.\n\nTuổi trẻ ngắn ngủi thế, nhưng đừng sợ tuổi già.\n\nĐôi khi, bạn có thể dừng lại nghỉ ngơi, nhưng đừng quỳ xuống.\n\nKhi đi một con đường, bạn chớ ngoái đầu nhìn lại, hoặc tự hỏi, mình đang làm cái gì?\n\nKhi đau và nhục, đàn ông có thể khóc và gào. Khóc đi, rồi rửa mặt, vỗ má mình, rồi áp má mình để trên gương mặt bạn có một nụ cười. Chứ bạn đừng dụi mắt hay lấy tay lau nước mắt. Bởi có thể sớm mai bạn sẽ mang một đôi mắt trũng và sưng vì khóc. Chớ để sớm mai ai cũng nhận ra bạn từng khóc.\n\nĐàn ông hãy xác định cho mình một mục tiêu xa hơn và một lộ trình dài hơn. Hãy nhớ thỉnh thoảng ngửa đầu nhìn trời xanh, và lúc nhìn lên trời xanh hãy nhớ cúi xuống nhìn đất dưới chân mình.\n\nVào bất kỳ lúc nào, bất kỳ người nào hỏi bạn, bạn yêu mấy lần, đáp án của bạn phải luôn là Hai.\n\nMột lần, cô ấy yêu tôi nhưng tôi không cảm xúc, một lần là tôi yêu cô ấy nhưng không được đáp lại. Hãy luôn nhớ rằng, tình yêu đẹp vẫn luôn đang đợi bạn ở lần yêu sau. Nên đừng luyến tiếc, đừng để một người đàn bà nào có cơ hội làm bạn bị tổn thương tới lần thứ hai.\n\nLàm đàn ông, đừng giao du với văn nghệ sĩ hay bọn văn sĩ trẻ, cũng như đừng làm bạn với những kẻ bất đắc chí, thiếu tâm huyết với đời, cũng tuyệt đối không được bạn bè với những người đàn ông không có nghề nghiệp chính thức, kiêm quá nhiều nghề.\n\nCũng đừng yêu người phụ nữ nào hy sinh vì bạn. Khi có một cô nàng tự chà đạp bản thân nàng, tự hy sinh, tự chịu thiệt vì bạn, bạn chớ nên vì thế mà cảm động hoặc yêu kẻ lụy tình ấy. Bởi một người đàn ông nghiện hút trộm cắp đầy mình thân với bạn, có thể kẻ nghiện hút trộm cắp tiếp theo sẽ là chính bản thân bạn. Tình yêu cũng tương tự như vậy, khi một người phụ nữ vì yêu mà cầm dao cứa tay mình đau, có thể kẻ tiếp theo bị nàng cứa chính là bạn.\n\nKhông bao giờ đặt niềm tin vào một gã đàn ông chỉ định giao du với mình bạn chứ không cho bạn biết hắn đang chơi bời với những bạn bè nào khác.\n\nKhi một cô nàng định gọi bạn là “anh yêu, baby, chồng yêu ơi”, bạn hãy bắt buộc cô nàng gọi bạn bằng tên bạn, bởi bạn là một người đàn ông, bạn không phải thú cưng của ai.\n\nKhi một người đàn ông hoặc một người đàn bà tự nhiên không tới tìm bạn nữa, bạn hãy dứt khoát đừng gọi tới làm phiền họ.\n\nĐừng tin những kẻ dùng tiểu xảo trong tình yêu. Và đừng ác miệng sau khi chia tay người tình. Nghe lời khuyên của người khác, nhưng đừng hối hận, bởi hối hận chưa từng mang lại cho đàn ông bất cứ thứ gì hay ho.\n\nĐàn ông thì không xé ảnh, đốt thư, xé nhật ký, làm những việc mà chỉ diễn viên ba xu trên phim truyền hình mới làm. Bởi bạn tin vào tình yêu. Tin rằng trên đời vẫn còn những người đàn ông tốt và những người phụ nữ tốt đẹp, có thể họ cũng chưa kết hôn, họ cũng vẫn đang vượt trùng trùng biển người trong đời để tìm đến bạn. Nên đừng nói những câu đại loại như: “Thời này làm gì có đàn bà tử tế” hoặc “Làm gì có đàn ông tốt!”. Những câu như thế thường làm người ta hiểu rằng, bạn đã no xôi chán chè, hời hợt với vô số người, vơ đũa cả nắm và không hề sống nghiêm túc, chưa trưởng thành.\n\nHãy yêu tiền, yêu vật chất, dùng tiền để sống cho ra sống. Nhưng vẫn hiểu rằng những giá trị tinh thần cũng quan trọng biết bao. Và con người bạn, một người đàn ông đầy sức sống, háo hức sống vẫn luôn có giá trị và đẹp đẽ hơn những đồng hồ hàng hiệu, thời trang, phụ kiện sành điệu bạn đang mang. Nếu đã hơn hai mươi tuổi nhưng mỗi phút bạn sống, bạn vẫn phải ngửa tay xin tiền bố mẹ, thì những tiền bạc bạn có, đồ hiệu bạn mặc chỉ làm cho sự vô liêm sỉ của bạn nổi bật hơn mà thôi. Nên đồ hiệu không làm bạn có giá hơn. Bản thân người đàn ông không có giá trị bản thân, thì dù có bọc vàng, được bố mẹ nâng đỡ sự nghiệp chức này tước kia, cũng vẫn chỉ là một kẻ ăn bám bọc vàng. Một con lừa dù có đóng yên cương vàng khối cũng không thể trở thành tuấn mã.\n\nBạn còn trẻ, có thể chưa đủ tuổi để bắt đầu một sự nghiệp riêng, một tương lai huy hoàng. Nhưng bạn đã đủ tuổi thành niên, nên ít nhất, cũng không thể làm một cái gánh nặng đeo trên lưng bố mẹ, để bố mẹ mất hai mươi năm nuôi dạy, cái gánh nặng đã sống ký sinh trên lưng chỉ nặng thêm và nhiều đòi hỏi hơn.\n\nBạn đừng tưởng bạn trẻ, bạn làm một kiểu tóc có màu khác người, mặc một bộ quần áo dở nam dở nữ Unisex, rồi phun lên người một thứ mùi nước hoa, thì người khác sẽ tôn trọng bạn. Cái ngước nhìn của người khác không mang ý trầm trồ ngưỡng mộ, mà là cái nhìn khi đi ngang qua sở thú. Rất nhiều đàn ông khác chỉ bởi họ được giáo dục tốt nên họ sẽ không bày tỏ thái độ gì với bạn đâu, họ sẽ tôn trọng sự “cá tính” của bạn, nhưng không có nghĩa rằng, họ không nhận ra sự xấu xí của người đàn ông trước mặt.\n\nXin bạn đừng coi rẻ những người lao động nghèo. Đừng xấu hổ vì phải làm việc nặng nhọc. Đất không bẩn, mồ hôi không hôi hám. Xin hãy tôn trọng những người có thể không giàu bằng bạn, nhưng họ đang nuôi cả gia đình bằng đôi tay lương thiện và cần cù của họ. Bạn tôn trọng họ, bạn mới biết giá trị của bạn nằm ở đâu.\n\nLàm đàn ông, hãy tha thứ, nhưng đừng quên. Và hãy khoan dung với cả thế giới cũng như với chính bản thân bạn. Để luôn tự nhủ rằng, ta là đàn ông, ta xứng đáng để có được những thứ tốt đẹp hơn.\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.01-Style/SOLID":{"title":"💪 What is SOLID?","content":"\n🌱 SOLID là cụm từ  tạo thành từ những chữ cái viết tắt của 5 nguyên tắc được đúc kết từ 'xương máu' của rất nhiều lập trình viên đi trước =)) Nếu đã từng làm dự án thực tế, mọi người sẽ đều biết là gần 80% thời gian sẽ là bảo trì hệ thống(thêm tính năng, sửa lỗi, ...). Áp dụng SOLID, công việc bảo trì  và mở rộng sẽ dễ dàng hơn rất nhiều. Cùng xem những nguyên tắc 'thần thánh' nhưng vô cùng 'thân thuộc' này là gì nha! \n\n## 🌿 Single Responsibility Principle\n\nMỗi class chỉ nên thực hiện **một nhiệm vụ** đơn lẻ!\n\n![[00 Meta/01 Attachments/Single Responsibility Principle.png]]\n\n\n## 🌿 Open/Closed Principle\n\nKhi thêm tính năng cho class, nên viết những class mới kế thừa class cần mở rộng.\n\n![[00 Meta/01 Attachments/Open-Closed Principle.png]]\n\n## 🌿 Liskov Substitution Principle\n\n\n![[00 Meta/01 Attachments/Liskov Subtitution Principle.png]]\n\n## 🌿 Interface Segregation Principle\n\n![[00 Meta/01 Attachments/Interface Segregation Principle.png]]\n\n\n## 🌿 Dependency Inversion Principle\n\n![[00 Meta/01 Attachments/Dependency Inversion Principle.png]]","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.02-Git/Create-bio-on-my-github":{"title":"🥦 Create bio on my github","content":"\n- 🌱 Github cho phép hiển thị README trên profile github cá nhân. Chúng ta chỉ cần tạo một repo có tên trùng với account github, sau đó thỏa sức sáng tạo thôi 🥳 \n\n![[00 Meta/01 Attachments/Pasted image 20221128185803.png]]\n\n\u003e [!info] Info\n\u003e \n\u003e File README.md sử dụng chuẩn markdown của Git, mọi người có thể tham khảo ở [đây](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github)\n\n- 🌱 Chức năng này đã được các lập trình viên hưởng ứng sôi nổi sau khi ra mắt. Có cả một repo tổng hợp lại những profiles ấn tượng, mọi người có thể tham khảo ở [đây](https://github.com/abhisheknaiidu/awesome-github-profile-readme)  \n\n\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.02-Git/Delete-gits-branchs-safely":{"title":"🥦 Delete git's branchs safely","content":"\n## 🌿 What?\n\n- 🌱 Sau một thời gian làm việc trên 1 repo git, chắc chắn chúng ta sẽ cần xóa đi những merged branchs hoặc những branchs không cần sử dụng tới nữa. Dưới đây là cách mình dùng để xóa đồng thời nhiều branchs có các partterns chung dưới local:\n\n```sh\n\u003e git branch -D `git branch -a | grep merge`\n```\n\n- 🌱 Nhưng khi xóa các nhánh remote, cần bảo đảm an toàn, cẩn thận hơn nên mình sẽ bó cẩn thêm phần `confirmation`.\n\n```sh\n\u003e git branch -a | grep remotes/anhnh-3008/deleted_branch | xargs -I % -p git push origin :%\n\n\u003e git push origin :remotes/sun/fixbug/game_room_controller ?... # y- Yes, n- No\n```\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.02-Git/Git-config-for-multi-accounts":{"title":"⚙️ Git config for multi accounts","content":"\n## 🌿 Vấn đề\n - Bài viết này ra đời khi mình bị các anh ngồi cạnh 'cười chê' do dùng nhiều accounts git trên cùng một máy nhưng lại switch bằng cơm =))) Sau khi khóc xong thì mình có tìm hiểu cách config để thuận tiện hơn cho việc sử dụng.\n\n## 🌿 Giải pháp\n- 🌱 Ý tưởng là mình sẽ chia ra làm 2 thư mục **work** và **personal**  để sử dụng cho các repo tương ứng.\n- 🌱 Ở file **.gitconfig** global set user mặc định và điều hướng config riêng cho từng folder.\n``` git\n# .gitconfig\n\n[user]\n  name = anhnh-1028\n  email = nguyen.hoang.anh-c@sun-asterisk.com\n\n[includeIf \"gitdir:~/personal/\"]\n  path = ~/personal/.gitconfig-personal\n\n[includeIf \"gitdir:~/work/\"]\n  path = ~/work/.gitconfig-work\n```\n- 🌱 Set user cho từng folder\n```git\n# ~/work/.gitconfig\n\n[user]\n  name = anhnh-1028\n  email = nguyen.hoang.anh-c@sun-asterisk.com\n\n# ~/personal/.gitconfig\n[user]\n  name = anhnh-3008\n  email = mail-personal@gmail.com\n```\n- 🌱 Xong phần config thông tin, giờ đến phần ssh. Skip bước gen ssh-key + add key lên git, giờ mình set [[50 til/51 Code/51.06 Servers/Config SSH]] thôi.\n\n```git\n# ~/.ssh/config\n\nHost git-work\n  HostName github.com\n  User git\n  IdentityFile ~/.ssh/ssh-key-work\n\nHost git-personal\n  HostName github.com\n  User git\n  IdentityFile ~/.ssh/ssh-key-personal\n```\n\n- 🌱 Thế là xong rồi, giờ mình chỉ cần set-url remote theo tên Host đã config thôi là chạy phà phà rồi.\n\n```sh\ngit@github.com:anhnh-3008/app.git -\u003e git@git-personal:anhnh-3008/app.git\n```\n\n- 🌱 Ngoài ra trong file .gitconfig còn có thể setup được cả color branch, alias, editor, ... Mình có chôm được mấy cái [settings](https://github.com/ttuan/dotfiles/blob/master/git/gitconfig) hay hay của một anh ở công ty, mọi người có thể tham khảo nhé =)) nếu thấy hay thì cho anh mình một ⭐ nha \u003c3\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.02-Git/Git-hooks-with-pre-commit":{"title":"🥦 Git hooks with pre-commit","content":"\n- 🌱 Để tránh tình trạng gặp phải **stupid mistakes** như push code lên mà có cả `byebug`, `binding.pry`, `debugger`, ... Git cho phép chúng ta sử dụng `hooks` để kiểm tra tự động những vấn đề ntn 🥳\n\n- 🌱 Tất cả các hooks của 1 repo được lưu trong folder `.git/hooks`\n\n![](00%20Meta/01%20Attachments/Pasted%20image%2020221121182121.png)\n\n- 🌱 Tạo file `.git/hooks/pre-commit`. Có thể viết bằng bất kỳ `script language(như Ruby, Python, JS, ...)` nào chúng ta muốn.\n\n```sh\n#!/bin/sh\n\nFILES_PATTERN='\\.?$'\n\nFORBIDDEN='binding.pry\\|byebug\\|console.log'\n\ngit diff --cached --name-only | \\\n    grep -E $FILES_PATTERN | \\\n    xargs grep --color --with-filename -n $FORBIDDEN \u0026\u0026 \\\n    echo 'COMMIT REJECTED' \u0026\u0026 \\\n    exit 1\n\nexit 0\n```\n\n- 🌱 Bạn có thể custom những từ khóa không muốn push lên repo thông qua biến `FORBIDDEN`.\n\n![](00%20Meta/01%20Attachments/Pasted%20image%2020221121182849.png)","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.02-Git/Highlight-Note-and-Warning-with-Git-MarkdownBeta-feature":{"title":"🥦 Highlight Note and Warning with Git Markdown(Beta)","content":"\n- 🌱 Git cung cấp syntax markdown highlight `Note` và `Warning`. Giúp chúng ta viết tài liệu hay description cho PR long lanh hơn ✨\n\n```md\n\u003e **Note**\n\u003e This is a note\n\n\u003e **Warning**\n\u003e This is a warning\n```\n\n- ✨ Kết quả:\n\n![[00 Meta/01 Attachments/Pasted image 20221130103107.png]]\n\n- 🌱 Topic thảo luận: https://github.com/orgs/community/discussions/16925","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.03-Operating-System/Exit-code-on-terminal":{"title":"🥦 Exit code on terminal","content":"\n## 🌿 Run multi commands in on line on terminal\n\n```bash\n$\u003e command1; command2; command3\n```  \n\n-   Sẽ luôn excute hết các câu lệnh, kể cả khi các câu lệnh ở trước nó bị lỗi.\n\n-    Nhưng nếu cần sự ràng buộc **phải đúng** ở các câu lệnh trước thì mới được chạy tiếp, vd như `apt-get update`  và `apt-get install package` , dùng dấu `\u0026\u0026`\n\n```bash\n$\u003e apt-get update \u0026\u0026 apt-get install package\n```  \n\n## 🌿 Exit code in shell\n\n-   Như bên trên có nói đến việc check đúng - các câu lệnh chạy thành công được xác định bởi **Exit Code.**\n\t-   **Exit code** trả về 0 -\u003e success\n\t-   **Exit code** trả về khác 0, có giá trị từ 1-255 -\u003e nghĩa là câu lệnh chạy có lỗi\n-   Check Exit Code của câu lệnh gần nhất:\n\n```bash\n$\u003e who\n=\u003e hoanganh8999 :1           2022-12-14 19:24 (:1)\n\n$\u003e echo $?\n=\u003e 0\n\n$\u003e wo\n=\u003e wo: command not found\n\n$\u003e echo $?\n=\u003e 127\n```\n\n## 🌿 Refer \n\n- [https://mazer.dev/en/linux/tips/how-to-determine-error-and-exit-main-shell-script/](https://mazer.dev/en/linux/tips/how-to-determine-error-and-exit-main-shell-script/)","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.03-Operating-System/Permission-in-Linux":{"title":"🥦 Permission in Linux","content":"\n## 🌿 What?\n\n- Bình thường mình hay chạy lệnh `chmod 777` khi thấy báo lỗi không có quyền tương tác, mà 777 là cái gì?\n- Làm sao để biết File hay Folder mình muốn thao tác có những quyền gì? Tài khoản nào được quyền tương tác?\n\n![[00 Meta/01 Attachments/Pasted image 20221218133654.png]]\n\n## 🌿 Refer \n- https://blog.bytebytego.com/","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.03-Operating-System/Pipe-Data-between-Programs":{"title":"🥦 Pipe Data between Programs","content":"\n- 🌱 Trong Shell, The Pipe cho phép kết hợp giữa nhiều commands trên cùng một dòng. Được kí hiệu bằng ký tự ASCII 124 ( | ), dấu gạch dọc.\n\n```sh\nVD1:\n🌱 kết hợp câu lệnh tìm kiếm theo pattern và đếm có bao nhiêu lines trả về từ grep\n\n\u003e grep /bin/bash$ [PATTERN] | wc -l\n```\n\n![](https://lh3.googleusercontent.com/P_MDCWdC8VPh8ZMVK3p-MxX8uWYP2w2XFv9mEeMoIudE4x9hJw4S5OaAMjaIRn6Utr8gjNVSSVg89VtDzlL5TI-PUwcDJEM24e-ylJUzcIMpeNFSvTnbrDbctMs8FHrnp_xQ8Mz-jf4pNJzsGQ-79Tf1hTenyIh1fAGdLqz5DS4X9KAtvQVhaVv358Qi)\n\n### Nguồn\n- LPIC - 1 - trang 105 ","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.03-Operating-System/Some-Tips-for-irb-rails-console":{"title":"🥦 Some Tips for irb/rails console","content":"\n### 🌿 Lấy giá trị output cuối cùng\n- 🌱 `_` được gán giá trị là output mới nhất của irb/rails console.\n\n```sh\n\u003e 1 + 1 \n=\u003e 2\n\u003e _\n=\u003e 2\n```\n\n### 🌿 Sandbox\n- 🌱 Khi dùng option `--sandbox` các thay đổi đối với `atabase` sẽ được `rollback` khi thoát `rails console`.  \n\n```sh\nrails c --sandbox\n\n\u003e Account.first.destroy\n=\u003e true\n\u003e Account.find(1)\n=\u003e ActiveRecord::RecordNotFound: Could not find Account with id=1\n\u003e exit\n\nrails c\n\u003e Account.find(1)\n=\u003e #\u003cAccount id: 1, ...\u003e\n```\n\n### Tham khảo\n- https://pragmaticstudio.com/tutorials/rails-console-shortcuts-tips-tricks","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.03-Operating-System/Why-must-run-apt-update-before-install-any-lib-for-Linux":{"title":"🥦 Why must run apt update before install any lib for Linux?","content":"\n[Câu trả lời](https://askubuntu.com/questions/337198/is-sudo-apt-get-update-mandatory-before-every-package-installation)\n\n- 🌱 Lệnh `apt update` sẽ cập nhật danh sách mới nhất các packages có trong kho Ubuntu.\n\n\u003e [!info] Info\n\u003e \n\u003e Danh sách repo được lưu trong file **/etc/apt/sources.list**\n\n- 🌱 Lệnh `apt install` sẽ đọc trong danh sách packages được cập nhật ở lệnh `apt update` gần nhất.\n\n- 🌱 Nếu chắc chắn package chuẩn bị install đã nằm trong danh sách cập nhật, việc chạy `apt update` có vẻ là hơi thừa 😶 Cơ mà thay vì ngồi xác định như thế thì mình chọn chạy `apt update` cho đỡ mệt mọi 😆\n\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.03-Operating-System/create-multi-folders-linux":{"title":"🥦 Create multi folders linux","content":"\n- 🌱 Create multi foders in Linux with command below:\n\n```sh\nmkdir /path/{folder1, folder2, folder3}\n\ntree /path/\n \n├── folder1\n├── folder2\n├── folder3\n```\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.03-Operating-System/visudo":{"title":"🥦 visudo","content":"\n- 🌱 Cấp quyền(cho user root, lệnh sudo, group admin) được cấu hình trong file `/etc/sudoers` .\n\t- Không bao giờ sử dụng trình soạn thảo văn bản thông thường(nano, vim, ...) để sửa `/etc/sudoers` , thay vào đó hãy dùng `visudo` .\n\t-  `visudo` validate cú pháp trước khi save file còn nano, vim, .... thì không, save mà sai syntax là oẳng luôn đó 🥵\n\n- 🌱 Xem thêm: [https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file](https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file)","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Add-custom-flash-keys":{"title":"🥦 Add custom flash keys","content":"\n- 🌱 `ActionController::Base` mặc định cung cấp key `:notice` cho `#redirect_to`   \n```ruby\n  class flash_demo\n    if true\n      redirect_to root_path, notice: \"Notice\"\n    else\n      flash[:error] = \"Error\"\n      redirect_to root_path\n    end\n  end\n```\n\n- 🌱 Nhưng nếu bạn muốn thêm `:error` như `:notice` thì có thể thử cách này nhé!\n```ruby\n  class flash_demo\n    add_flash_types :error\n    \n    if true\n      redirect_to root_path, notice: \"Notice\"\n    else\n      redirect_to root_path, error: \"Error\"\n    end\n  end\n```\n\n- 🌱 Refer: [add_flash_keys](https://til.hashrocket.com/posts/ouyfd1cpfu-add-custom-flash-keys)","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Config-warning-when-fetched-a-lot-of-records":{"title":"🥦 Config warning when fetched a lot of records","content":"\n - 🌱 Từ Rails 5 chúng ta đã có thể thêm config `warn_on_records_fetched_greater_than`:  hiển thị cảnh báo trong `rails server` hoặc `rails console` khi có số lượng câu queries lớn hơn số lượng chúng ta đã chỉ định.\n\n```rb\n# config/environments/development.rb\n\n# Show warn if fetch greater than 50 records\nconfig.active_record.warn_on_records_fetched_greater_than = 50\n```\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Config warning when fetched a lot of records/Pasted image 20221020091559.png]]","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Credentials-file-in-Rails":{"title":"🥦 Credential file in Rails","content":"\n\u003e [!question] Question\n\u003e \n\u003e Khi khởi tạo một project, Rails sẽ tự động tạo ra file **credentials.yml.enc** trong folder **config**. Khi click vào xem nội dung thì chỉ có mỗi một dòng hash dài ngoằng ngoẵng. Thế nó sinh ra để làm gì nhỉ 🤔\n\n- 🌱 Từ sau Rails 5.2, khi init project sẽ tự động tạo file `config/credentials.yml.enc` chứa hash được mã hóa bởi [aes-128-gcm](https://www.cryptosys.net/pki/manpki/pki_aesgcmauthencryption.html)  để lưu những thông tin \"nhạy cảm\" của dự án. \n\n- 🌱 Rails sẽ dùng `config/master.key` hoặc `ENV[\"RAILS_MASTER_KEY\"]` để mã hóa nội dung. Vì đã được mã hóa nên file `config/credentials.yml.enc` vẫn có thể public, miễn là chúng ta không làm lộ `master key` là được.\n\n- 🌱 Mặc định file tạo ra sẽ chỉ lưu `secret_key_base` của Rails app. Tuy nhiên chúng ta có thể edit thêm thông tin bằng command:\n\n```sh\n$ rails credentials:edit\n```\n\n\u003e [!info] Info\n\u003e \n\u003e 📝 Câu lệnh trên sẽ tạo file **config/credentials.yml.enc** và   **config/master.key** nếu chưa tồn tại hoặc chưa được định nghĩa.\n\u003e \n\u003e Tìm hiểu thêm: **rails credentials:help**  \n\n- 🌱 Đọc thông tin mã hóa bằng câu lệnh:\n\n```sh\n\u003e Rails.application.credentials\n```\n\n![[00 Meta/01 Attachments/Pasted image 20221202152110.png|800]]\n\n\u003e [!danger] Danger\n\u003e \n\u003e Tuyệt đối không được làm mất hay public master key! \n\n- 🌱 Source: https://guides.rubyonrails.org/security.html#custom-credentials\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Custom-condition-sign-in-for-devise":{"title":"🥦 Custom condition sign-in for devise gem","content":"\nMặc định khi đăng nhập, Devise sẽ tìm User dựa theo scope đã được thiết lập trong `config/initializers/devise.rb` \nVd như đăng nhập theo email:\n\n```rb\nDevise.setup do |config|\n  config.authentication_keys = [:v_code]\nend\n```\n\n### 🌿  Vấn đề\n- 🌱 Thế nhưng cuộc sống thường lắm gian truân và cuộc đời của mình cũng không ngoại lệ. \n- 🌱 Dự án của mình có đồng thời 2 cơ chế đăng nhập 1 là qua Devise, 2 là SSO thông qua bên thứ 3. Khi thực hiện SSO, hệ thống sẽ lưu user đó vào DB chung luôn và phân biệt bằng trường `provider`. Vấn đề là giờ phải xử lý sao cho khi đăng nhập với Devise, những thằng user do bên thứ 3 cung cấp không thể login vào được hệ thống.\n\n### 🌿 find_for_database_authentication(warden_conditions)\n- 🌱 Chúng ta có thể overwrite lại method `find_for_database_authentication` của Devise.\n\t- Method nhận vào scope chứa `authentication_keys`.\n\t- Output trả về một record tồn tại trong DB hoặc `nil`.\n\n```rb\ndef find_for_database_authentication(warden_conditions)\n  conditions = warden_conditions.dup\n  # trim space and downcase\n  email = conditions.delete(:email).strip.downcase\n  find_by(email: email, provider: :traditional)\nend\n```\n\n\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Custom-direct-URL-by-Routes-in-Rails":{"title":"🥦 Custom direct URL by Routes in Rails","content":"\n### 🌿 What?\n- 🌱 Rails cung cấp `direct` giúp chúng ta xác định một `route` `redirect` đến một URL bất kỳ. \n\n```rb\n# config/routes.rb\nRails.application.routes.draw do\n\tdirect :get_to_my_blog do\n\t\t\"https://nhanh.netlify.app\"\n\tend\nend\n```\n\n- 🌱 Trong Rails ta sẽ có route `get_to_my_blog_url` gọn gàng đẹp đẽ. \n- 🌱 Ngoài ra có thể thêm điều kiện để  get URL.\n\n```rb\n# config/routes.rb\nRails.application.routes.draw do\n\tdirect :get_to_the_goog, search: nil do |options| \n\t\t\"https://google.com/search?q=#{options[:search]}\"\n\tend\nend\n\nget_to_the_goog_url(search: \"stackoverflow\")\n```\n\n- 🌱 `Direct` sẽ không hiển thị routes khi chúng ta gõ `rails routes`. Chúng ta sẽ vẫn có `_path` helper nhưng ko nên sử dụng vì nó cắt mất cái tên miền đấy 😂. \n- 🌱 Ngoài ra `direct` không dùng được trong `namespace` hoặc `scope`. Nếu đặt nhầm thì rails sẽ `raise exception`.\n\n### 🌿 Refer\n- https://guides.rubyonrails.org/v5.2/routing.html#direct-routes","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Custom-order-in-SQL-with-RoR":{"title":"🥦 Custom order in SQL with RoR","content":"\n- 🌱 `in_order_of` cho phép order theo thứ tự chỉ định trong SQL.\n\n```rb\nUser.in_order_of(:id, [1, 5, 3])\n# SELECT \"users\".* FROM \"users\"\n#   ORDER BY FIELD(\"users\".\"id\", 1, 5, 3)\n#   WHERE \"users\".\"id\" IN (1, 5, 3)\n```\n\n- 🌱 [source code](https://github.com/rails/rails/blob/8015c2c2cf5c8718449677570f372ceb01318a32/activerecord/lib/active_record/relation/query_methods.rb#L447)\n\n- 📑 FYI: Cách này trong SQL sẽ sort mà không sử dụng index. \n\n![[00 Meta/01 Attachments/Pasted image 20221114184148.png|800]]\n","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Delegate-in-Rails":{"title":"🥦 Delegate in Rails","content":"\n## 🌿 Issues\n\n- Khi code RoR, mình thường xuyên sử dụng delegate trong các dự án. Nhưng nay tự nhiên có anh hỏi mình mấy câu như delegate là cái gì? tại sao phải dùng? nên dùng thế nào cho hợp lý? thì mình lại có sự ngập ngừng nhẹ 😅. Tiện đây mình lược lại một lần sau đi khè cho trôi chảy 😆 Let's gooo!!  \n\n## 🌿 What?\n\n- Theo APIdock:\n\u003e Provides a [delegate](https://apidock.com/rails/Module/delegate) class method to easily expose contained objects’ public methods as your own.\n\n- `Delegate` hỗ trợ một object truy xuất dễ dàng các public methods của một object khác như chính các methods của nó.\n\n\n## 🌿 Why?\n\n\u003e The Law of Demeter Principle – LoD, còn gọi khác là nguyên tắc Demeter hay nguyên tắc “càng biết ít càng tốt” hay nguyên tắc “Một dấu chấm”. Nó **là một nguyên tắc thiết kế để phát triển phần mềm, đặc biệt là các chương trình hướng đối tượng**\n\n- Delegate giúp code của cta tuân thủ theo nguyên tắc trên.\n\n## 🌿 How?\n\n- Có 3 options:\n1. `:to` - chỉ định object cần truy xuất public methods(có thể nhận nhiều giá trị).\n\n```rb\nclass A \u003c ActiveRecord::Base\n\thas_many :Bs\nend\n\nclass B \u003c ActiveRecord::Base\n\tbelongs_to :A\n\n\tdelegate :name, :description, to: :A\nend\n\npry(main)\u003e B.first.name\n=\u003e \"A\"\npry(main)\u003e B.first.description\n=\u003e \"Description of A\"\n```\n\n2. `:prefix` - chỉ định tiền tố.\n\n```rb\nclass A \u003c ActiveRecord::Base\n\thas_many :Bs\nend\n\nclass B \u003c ActiveRecord::Base\n\tbelongs_to :A\n\n\tdelegate :name, :description, to: :A, prefix: 'A'\nend\n\npry(main)\u003e B.first.A_name\n=\u003e \"A\"\npry(main)\u003e B.first.A_description\n=\u003e \"Description of A\"\n```\n\n3. `:allow_nil` - nếu flag=true, không raise [DelegationError](https://apidock.com/rails/Module/DelegationError)\n\n```rb\nclass A \u003c ActiveRecord::Base\n\thas_many :Bs\nend\n\nclass B \u003c ActiveRecord::Base\n\tbelongs_to :A\n\n\tdelegate :name, :description, to: :A, prefix: 'A', allow_nil: true\nend\n\n# allow_nil: false - default\npry(main)\u003e B.first.A_name\n=\u003e Module::DelegationError: B#A_name ...\n\n# allow_nil: true\npry(main)\u003e B.first.A_name\n=\u003e \"A\"\n```\n\n## 🌿 Refer \n- https://apidock.com/rails/Module/delegate","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Encrypt-attribute-in-Rails-7":{"title":"🥦 Encrypt attribute in Rails 7","content":"\n\u003e [!question] Question\n\u003e \n\u003e Rails 7 vừa ra mắt **Active Record Encryption**, cho phép **encrypt data** ở trên tầng **Application**. Nhưng nó đem lại tác dụng gì khi chúng ta đã **encrypt data** ở tầng **Database** rồi nhỉ 🤔. \n\n## 🌿 Why?\n- 🌱 Khi có hacker chiếm được quyền hệ thống, snapshot database hoặc application logs sẽ chỉ hiển thị dữ liệu đã được mã hóa.\n\n- 🌱 Ngăn ngừa lập trình viên sơ xuất để lộ dữ liệu nhạy cảm thông qua application logs.\n\n- 🌱 Ngăn truy xuất dữ liệu trong Rails console nếu không có bộ keys để giải mã.\n\n## 🌿 How?\n### Setup\n- Tạo keys:\n\n```sh\n$ rails db:encryption:init\n```\n\n- Thêm keys vào [[50 til/51 Code/51.04 Rails/Credentials file in Rails| credentials file]].\n\n### Declare attribute\n- Định nghĩ trong modal trường encrypts.\n\n```rb\nclass User \u003c ApplicationRecord\n  encrypts :email\nend\n```\n\n- Khi tạo user, giá trị của email đã được mã hóa.  \n\n![[00 Meta/01 Attachments/Pasted image 20221202182529.png|800]]\n\n\u003e [!info] Info\n\u003e \n\u003e Không thể find_by theo thuộc tính được mã hóa. \n\u003e \n\u003e Nếu vẫn muốn truy vấn theo thuộc tính, hãy thêm option \n**deterministic: true**\n\n```rb\nclass User \u003c ApplicationRecord\n  encrypts :email, deterministic: true\nend\n```\n\n### 🌿 Refer\n- 🌱 https://guides.rubyonrails.org/active_record_encryption.html","lastmodified":"2023-05-11T14:57:36.705913443Z","tags":null},"/50-til/51-Code/51.04-Rails/How-to-safely-remove-a-column-in-Rails":{"title":"🥦 How to safely remove a column in Rails? ","content":"\n### 🌿 What?\n- 🌱 Rails cung cấp method `ignored_columns` để xóa tạm thời một cột trong DB, sau khi sửa logic xong xuôi chúng ta mới thực hiện migrate, tránh việc migrate đi migrate lại, deploy nhiều lần(nếu cột đã có trên môi trường STG/PROD).\n\n### 🌿 How?\n- 🌱 Step 1️⃣: Set ignore cột cần xóa trong model.\n\n```rb\nclass User \u003c ActiveRecord::Base\n  self.ignored_columns = [:username]\nend\n```\n\n- 🌱 Step 2️⃣: Kiểm tra xem cột `username` đã được xóa tạm thời chưa.\n\n```rb\nUser.first.username\n\n=\u003e raises exception NoMethodError\n```\n\n- 🌱 Step 3️⃣: Thay đổi logic code liên quan đến trường `username`.\n\n- 🌱 Step 4️⃣: Deploy lên các môi trường, test/fix những \"lỗi lầm\" nếu có.\n\n- 🌱 Step 5️⃣: Thêm migrate xóa cột `username` .\n\n### 🌿 Refer\n🌵 [https://newsletter.shortruby.com/p/how-to-safely-remove-a-column-in](https://newsletter.shortruby.com/p/how-to-safely-remove-a-column-in)","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Kill-rails-server-quickly":{"title":"🥦 Kill rails server quickly","content":"\n### 🌿 Vấn đề\n- 🌱 Khi làm việc với rails, chắc hẳn đã có lần chạy server bạn đã gặp lỗi này.\n\n![[00 Meta/01 Attachments/Pasted image 20221129232330.png]]\n\n- 🌱 Sau khi chạy `rails s`, file `tmp/pids/server.pid` được tự động sinh ra, lưu Process ID(PID) của server đang chạy. Nguyên nhân xảy ra lỗi trên có thể là do chẳng may crash server(mất điên, máy lag) hay bất kì tình huống nào khác mà rails chưa kịp kill server cho chúng ta.\n\n### 🌿 Giải pháp\n\n- 🌱 Để giải quyết, tôi hay xóa xừ cái file `server.pid`.\n\n```sh\nrm -rf tmp/pids/server.pid\n```\n\n- 🌱 Sau đó thêm alias trong `.bashrc` để đỡ phải gõ nhiều 😄\n\n```sh\n# /.bashrc\n\nalias kars=\"rm -rf tmp/pids/server.pid\"\n```","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Quick-delete-a-record-in-rails":{"title":"🥦 Quick delete a recond in rails","content":"\n## 🌿 What?\n- Trước đây khi muốn xóa một record, mình thường phải find trước xong mới xóa.\n\n```rb\nuser = User.find(1)\n\nuser.destroy # xóa dependent và check callback\nuser.delete # xóa luôn, chả check chiếc gì hớt\n```\n\n- Nhưng từ Rails 6, nếu chúng ta chỉ muốn xóa record, có thể viết gọn hơn như sau:\n\n```rb\nUser.destroy_by(id: 1) # xóa dependent và check callback\nUser.delete_by(id: 1) # xóa luôn, chả check chiếc gì hớt\n```\n\n- Cả hai không có khác nhau gì về hiệu suất. Đây chỉ là một phiên bản rút gọn cách viết thôi. \n\n## 🌿 Refer\n\n- Mọi người có thể xem thêm code trong [Pull](https://github.com/rails/rails/pull/35316/files) này ạ.","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Quick-open-source-of-gem":{"title":"🥦 Quick open source of gem","content":"\n- 🌱 Nếu bạn muốn debug hoặc sửa gem, có thể truy cập đến thư mục gem một cách nhanh chóng bằng command:\n\n```sh\nbundle open GEM_NAME\n```\n\n- 🌱 Trình soạn thảo văn bản sẽ được mở theo `$EDITOR` hoặc `$BUNDLER_EDITOR`\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Run-Rspec-save-your-time":{"title":"🥦 Run Rspec save your time","content":"\n### 🌿 What?\n- 🌱 If you want to run rspec for a specific example, context or describe without having to care about path file, line number, you can try it:\n\n```ruby\n# spec/rails_helper.rb\n\nRSpec.configure do |config|\n  config.filter_run_when_matching focus: true\nend\n```\n- 🌱 Then you add f to example, context or describe, Rspec will only focus it.\n\n```ruby\n#example\nfit 'should tell height' do\n  expect(@person.height).to eq(160)\nend\n\n# as well\n\nit 'should tell height', focus: true do\n  expect(@person.height).to eq(160)\nend\n```\n\n- 🌱 You can add focus for multi examples\n\n### 🌿 Refer\nhttps://manny.codes/7-ways-to-selectively-run-rspec-tests/","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Save-serialized-object-to-the-database":{"title":"🥦  Save serialized object to the database","content":"\n## 🌿 What?\n- Như mọi người đã biết, chỉ trong Postgresql chúng ta mới có thể lưu Array vào db còn MySQL thì chịu chết. Trong Rails nếu muốn làm việc trên, tôi thường viết custom attribute trong model để xử lý dữ liệu.\n\n```rb\n# models/user.rb\n\nclass User\n  def codes\n    codes.split(',') #phone_numbers in db = \"123,345,567\" \n  end \nend\n```\n\n## 🌿 Serialization of ActiveRecord\n-   Rails cung cấp một  Instance Public methods là serialize để giúp chúng ta thực hiện việc lưu serialized object(như Array, Hash, YAML, JSON) và tự động convert về đúng kiểu dữ liệu khi truy xuất.\n-   Params của method:\n\t-   **attr_name:** Tên attribute cần lưu serialized object\n\t-   **class_name_or_coder:** Optional, chỉ định kiểu dữ liệu\n\t\t-   Mặc định là YAML, ngoài ra có thể chọn Array, Hash, và JSON\n\t\t- **_custom coder:_** _Có thể tự define kiểu dữ liệu (xem them ở_ _[doc](https://api.rubyonrails.org/classes/ActiveRecord/AttributeMethods/Serialization/ClassMethods.html#method-i-serialize)__)_\n-\n```rb\n# models/user.rb\n\nclass User\n  serialize:codes\nend\n\n3.1.2 :001 \u003e Comment.create! user_id: 1, content: [1,2,3]\n#\u003cComment:0x00007fdf8dd6dac0                                   \n id: 1,                                                        \n content: [1, 2, 3],\n ...\n```\n\n## 🌿 Refer\n-   [Serialize Document](https://api.rubyonrails.org/classes/ActiveRecord/AttributeMethods/Serialization/ClassMethods.html#method-i-serialize)","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Show-entire-length-of-output-in-Rspec":{"title":"🥦 Show entire length of output in Rspec","content":"\n## 🌿 Issues\n- Khi chạy test case compare 2 objects, trong trường hợp không match + object dài, output lỗi sẽ hiển thị rút gọn như dưới đây(mặc định sẽ hiển thị 200 kí tự cho từng object).\n\n![[00 Meta/01 Attachments/Pasted image 20221223163807.png]]\n\n## 🌿 Solution \n- Set `RSpec::Support::ObjectFormatter.default_instance.max_formatted_output_length = nil`  để show đầy đủ thông tin của 2 objects.\n- Hoặc\n```rb\nRSpec.configure do |rspec|\n  rspec.expect_with :rspec do |config|\n    config.max_formatted_output_length = nil\n  end\nend\n```\n\n![[00 Meta/01 Attachments/Pasted image 20221223163953.png]]\n\n## 🌿 Refer\n\n- [Code Rspec xử lý độ dài output](https://github.com/rspec/rspec-expectations/blob/ae06ba1535fca7c0ce4014d7d05fae823e6be9d4/lib/rspec/expectations/configuration.rb#L70)\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Show-schema-and-relationships-of-Model":{"title":"🥦 Show schema and relationships of Model","content":"\n## 🌿 What?\n- 🌱 Gem pry-rails cung cấp method `show-models` hiển thị schema và relationships của tất cả Model trong DB.\n\n```rb\n\u003e pry(main)\u003e show-models\n\u003e WhitelistedJwt\n\t  id: integer\n\t  jti: string\n\t  aud: string\n\t  exp: datetime\n\t  refresh_token: string\n\t  account_id: integer\n\t  device_id: integer\n\t  created_at: datetime\n\t  updated_at: datetime\n\t  refresh_token_exp: datetime\n\t  active_flag: boolean\n\t  belongs_to :account\n\t  belongs_to :device\n\u003e Schedule\n\t  id: integer\n\t  jti: string\n\t  aud: string\n\t  exp: datetime\n\t  refresh_token: string\n...\n```\n\n- 🌱 Nếu DB nhiều model, chúng ta có thể chỉ định riêng model cần xem.\n\n```rb\npry(main)\u003e show-model Project\n```\n\n- 🌱 Dùng `--grep` để tìm theo partial. Trả về Model chưa partial truyền vào.\n\n```rb\npry(main)\u003e show-models --grep aud\n```\n\n## 🌿 Refer \nMình quên mất tiêu 😅","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Sidekiq-Beta-7.0-available":{"title":"🥋 Sidekiq Beta 7.0 available","content":"\nHôm 2022-09-26 Author and Maintainer của Sidekiq **Mike Perham** đã cho ra mắt bản beta version 7.0 của **Sidekiq**. Đây được giới thiệu là một đợt big update với một vài tính năng siêu to và mới =)) một vài tính năng bị loại bỏ, một số API được cấu trúc lại và requirements được update.\n\n### 🌿 Version Support\n- Required Redis 6.2+\n- Required Ruby 2.7+\n- Support for Rails 6.0+\n\n### 🌿 Upgrade\nNếu bạn muốn upgrade lên ver 7.0 để trải nghiệm và có cơ hội trở thành contributer cho **sidekiq** thì đừng ngần ngại mà hãy thêm dòng này vào Gemfile của mình nhé =))\n```ruby\ngem 'sidekiq', '\u003c 8'\n```\n\n### 🌿 What's new?\n\n#### Job Metrics\nVersion 7.0 sẽ add một tab metrics trên Web UI với high-resolution data cho thời gian excute job cũng như là khả năng đánh dấu thời điểm deploy. \nMọi người có thể xem chi tiết tính năng này ở [Metrics](https://github.com/mperham/sidekiq/wiki/Metrics) \n\n#### Embedding\n---\nTrước đây mọi người chỉ có thể khởi động **Sidekiq** bằng câu lệnh \n```sh\nbundle exec sidekiq\n```\nTính năng này theo tác giả có nói là một cách thử nghiệm để chạy **Sidekiq** thông qua việc gọi trực tiếp bằng những dòng code Ruby. Nó được gán nhãn thử nghiệm là vì có khả năng xung đột với plugins bên thứ 3 hay với chính hệ thống của bạn.\nMọi người có thể xem chi tiết tính năng này ở [Embedding](https://github.com/mperham/sidekiq/wiki/Embedding)\n\n#### Capsules\n---\n...\n\n#### redis-client\n---\n- **redis-client** là một Rubygem mới sử dụng giao thức RESP3 có trong Redis 6.0+.\n- Sidekiq 6.5 đã giới thiệu về việc hỗ trợ cho gem **redis-client**  trong khi vẫn sử dụng gem **redis** là mặc định. Đến sidekiq 7.0 đã hoàn thiện việc chuyển đổi này và đã không còn sử dụng **redis** là mặc định nữa.\n- **App của bạn vẫn có thể tiếp tục sử dụng redis**. \n- Hiện tại nếu bạn sử dụng **Sidekiq.redis** để truy cập vào kết nối Redis, API đó sẽ expose một connection dựa trên **redis-client**.\n\n#### redis-namespace\n- 7.0 đã bỏ phần support cho **redis-namespace**. \n\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Truncate-by-amount-of-word-in-Rails":{"title":"🥦 Truncate by amount of word in Rails","content":"\n- 🌱 Rails cung cấp method truncate một chuỗi dựa theo số lượng từ. Ví dụ như chỉ muốn hiển thị 3 chữ đầu:\n\n```rb\nmy_string = \"một hai ba bốn năm!\"\nmy_string.truncate_words(3)\n\n#=\u003e \"một hai ba...\"\n```\n\n- 🌱 Dấu 3 chấm tự động được thêm vào sau chuỗi đã được truncate. Chúng ta có thể custom bằng arg `omission` .\n\n```rb\nmy_string.truncate_words(3, omission: \" ... more\")\n\n#=\u003e \"một hai ba ... more\"\n```\n\n- 🌱 Đương nhiên là cũng có truncate theo ký tự nữa, mọi người có thể đọc thêm ở [đây](https://apidock.com/rails/String/truncate).","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Validate-number-of-association":{"title":"🥦 Validate number of association","content":"\n### 🌿 What?\n- 🌱 If you have a People model and a Vehicle model, every people has_many vehicles but you want to set maximum for number of vehicles which a people can has. You can use following command below:\n\n```ruby\n# vehicle.rb\nclass Vehicle\n  belongs_to :people\nend\n\n# people.rb\nclass People\n  has_many :vehicles\n\n  validates :vehicles, length: { maximum: 2 }\nend\n```\n\n### 🌿 Refer\nhttps://til.hashrocket.com/posts/egegrgsdnj-limiting-object-counts-in-rails-associations-\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Validate-numeric-in-Rails":{"title":"🥦 Validate numeric in rails","content":"## 🌿 Issues\n- Option `only_integer` được dùng để validate chỉ nhận giá trị integer. Nhưng mình muốn nhận được cả giá trị float và integer cơ 😅\n\n## 🌿 Solutuion\n- Theo [doc](https://edgeguides.rubyonrails.org/active_record_validations.html#numericality), option `only_integer` validate format theo regex `/\\A[+-]?\\d+\\z`.\n- Nếu muốn pass các giá trị float, có thể thay thế format regex `/\\A-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)\\z/`\n\n```ruby\nvalidates :number, format: { with: /\\A-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)\\z/ }\n```\n\n- Hoặc Rails 7 đã thêm option `only_numeric` để giải quyết vấn đề trên.\n\n```ruby\nvalidates :number, numericality: { only_numeric: true }\n```\n\n## 🌿 Refer \n- [Pull add opion to numericality validator](https://github.com/rails/rails/pull/43914/files)","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.04-Rails/Why-is-must-run-bundle-exec-before-any-command":{"title":"🥦 why is must run bundle exec before any command?","content":"\n## 🌿 Issue\n\n- 🌱 Trước làm dự án, lúc đầu mình chạy mỗi  `rspec` hay `rubocop` thì vẫn ô's kê mà sau lại phải thêm `bundle exec` ở đầu thì mới chạy được 🥵\n\n## 🌿 Why?\n\n- 🌱 Nếu chạy chay không dùng `bundle exec` hệ thống sẽ tìm trong PATH, nếu trong PATH có nhiều versions của 1 gem, nó có thể xảy ra việc sử dụng sai version.\n- 🌱 `bundle exec`  để đảm bảo rằng version gem được sử dụng đúng với version gem chỉ định trong Gemfile chứ không phải là một version khác đã được cài trong hệ thống của chúng ta.\n\n\u003e Ví dụ như `rspec` trước đây mình chạy được là do máy của mình mới reset, chỉ có duy nhất 1 gem `rspec` được cài đặt cho dự án đang làm =\u003e chạy không bị lỗi. Vấn đề xảy ra khi mình cài thêm các versions `rspec` cho các projects khác =\u003e lệch version.\n\n- 🌱 Theo mục đích trên, các câu lệnh không liên quan đến version gem, mình ko cần phải thêm `bundle exec` nữa. Ví dụ như `rails s` hoặc `rails db:create` ,...\n\n## 🌿 Refer \n- [https://bundler.io/v2.4/man/bundle-exec.1.html](https://bundler.io/v2.4/man/bundle-exec.1.html)\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.04-Rails/_in_-and-_out_-of-Pry":{"title":"🥦 _in_ and _out_ of Pry","content":"\n### 🌿 What?\n- 🌱 Trong Pry, các giá trị `input`, `output` sẽ tự động được lưu trong 2 array có thể truy cập được đó là `_in_` và `_out_`. Số lượng phần tử cache của 2 cu này được định nghĩa ở `Pry.config.memory_size`(mặc định là 100 phần tử). Nếu hết dung lượng, những giá trị mới sẽ được ghi đè.\n\n```sh\npry(main)\u003e 1\n=\u003e 1\npry(main)\u003e 2\n=\u003e 2\npry(main)\u003e 3\n=\u003e 3\npry(main)\u003e _in_\n=\u003e #\u003cPry::Ring:0x0000562f98b2ce88 @buffer=[nil, \"1\\n\", \"2\\n\", \"3\\n\", \"_in_\\n\"], @count=5, @max_size=100, @mutex=#\u003cThread::Mutex:0x0000562f98b2ce60\u003e\u003e\npry(main)\u003e _out_\n=\u003e #\u003cPry::Ring:0x000055d4e3002b80 @buffer=[nil, 1, 2, 3, #\u003cPry::Ring:0x000055d4e3002b80 ...\u003e], @count=5, @max_size=100, @mutex=#\u003cThread::Mutex:0x000055d4e3002b58\u003e\u003e\npry(main)\u003e _out_.to_a[1] + _out_.to_a[2]\n=\u003e 3\n```\n\n### 🌿 Refer\n- 🌱 Mọi người có thể đọc thêm ở  [document](https://github.com/pry/pry/wiki/Special-Locals#the-input-and-output-cache)\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.04-Rails/frozen_string_literal-in-rails":{"title":"🥦 frozen_string_literal in rails","content":"\n### 🌿 What?\n- 🌱 Rubocop có rule check khai báo `frozen_string_literal: true` cho từng file, nhưng nó để làm gì?\n\n- 🌱 `frozen_string_literal` là một **magic comments** có từ Ruby 2.3, nó giúp tối ưu bộ nhớ cũng như cải thiện performance bằng việc **cung cấp vùng nhớ dựa theo nội dung của string**(nội dung giống nhau sẽ chung 1 vùng nhớ), tương tự như `:symbol`. Ngoài ra, sử dụng comment trên cũng sẽ ngăn chặn việc thay đổi string.\n\n```rb\n# test.rb\n# frozen_string_literal: true \np 'name'.object_id\np 'name'.object_id\n\nstr  =  'hello'\nstr  \u003c\u003c  ' world'\n\np str\n```\n\n```sh\n\u003e ruby test.rb\n60\n60\nTraceback (most recent call last):\ntest.rb:6:in `\u003cmain\u003e': can't modify frozen String: \"hello\" (FrozenError)\n```\n\n- 🌱 Nếu trong file `frozen`, chúng ta vẫn muốn một string động, có thể khai báo:\n\n```rb\nstr = String.new('hello')\nstr \u003c\u003c ' world'\n```\n\n### 🌿 Refer\n- 🌱 [Tham khảo](https://www.mikeperham.com/2018/02/28/ruby-optimization-with-one-magic-comment/)\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.05-Ruby/Awesome-Ruby-Repository":{"title":"💎 Awesome-Ruby Repository","content":"\n### 🌿 What?\n- 🌱 Được khởi xướng bởi Marc Anguera - Lead engineer \u0026 CTO tại Crisalix(cung cấp dịch vụ xuất hình ảnh 3D, 4D cho những người muốn nhìn thấy trước những thay đổi như phẫu thuật thẩm mỹ chẳng hạn, em **cảnh báo** là không nên xem web này ở trên cty nha 😂), repo hiện tại đã nhận được 12.4k sao và nhiều phản hồi tích cực từ cộng đồng Ruby Dev.\n- 🌱 [Awesome-ruby](https://github.com/markets/awesome-ruby) là repo phân loại tổng hợp những `thư viện cho Ruby`, những `tools`, `frameworks`, `best practice` và `phần mềm` có chất lượng `awesome` có thể sẽ cần thiết để chúng ta xây dựng những `modern Apps` hay `Web Apps` .\n\n### 🌿 Điều kiện tiêu chuẩn:\n- 🌱 Để được thêm vào repo, cần đạt những chất lượng tiêu chuẩn sau:\n\t- Thường được sử dụng(tối thiểu là 20k lượt tải) và hữu ích với cộng đồng.\n\t-   Chủ động bảo trì, cập nhật thường xuyên(chỉ cần là vẫn giải quyết các issues cho version hiện tại cũng là đạt yêu cầu rồi).\n\t-   Ổn định.\n\t-   Được tài liệu hóa.\n\t-   Có tests.\n\n\u003e [!note]\n\u003e \n\u003e Với những điều kiện trên thì mọi người có thể yên tâm mấy thứ được suggests trên repo toàn là hàng chất lượng thôi nhé :v\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.05-Ruby/Changes-in-Class-Variable-behavior-in-Ruby3":{"title":"🥦 Changes in Class Variable behavior in Ruby3","content":"\n## 🌿 What?\n- 🌱 Ở Ruby 2.7, class variable được sử dụng chung giữa class cha và các class con. Do có thể overwrite ở bất cứ đâu nên sẽ khó để tracking hoặc debug.\n\n- 🌱 Đến Ruby 3.0, class variable chỉ có thể overwrite ở các Class con kế thừa hoặc ở chính Class đó.\n\n```ruby\nclass Dog\n  @@color = ['yellow']\n\n  # bad practice\n  def self.overwrite_legs!\n    @@legs = 4\n  end\n  \n  def self.overwrite_legs!\n    @@color\n  end\nend\n\nclass Husky \u003c Dog\n  @@legs = 2\n\n  def self.show_legs\n    @@legs\n  end\n\n  # good practice\n  def self.add_color\n    @@color.push 'green'\n  end\nend\n\n#=\u003e Dog.overwrite_legs!\n#=\u003e 4\n#=\u003e Husky.show_legs\n#=\u003e in `show_legs': class variable @@legs of Husky is overtaken by Dog (RuntimeError)\n\n--------------------------\n\n#=\u003e Husky.add_color\n#=\u003e [\"yellow\", \"green\"]\n#=\u003e Dog.show_color\n#=\u003e [\"yellow\", \"green\"]\n```\n\n\n## 🌿 Refer \n- Document: https://rubyreferences.github.io/rubychanges/3.0.html#changes-in-class-variable-behavior","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.05-Ruby/Check-prefix-of-string":{"title":"🥦 Check prefix of string","content":"\n### 🌿 What?\n- 🌱 Trong Ruby, class `String` cung cấp method `start_with?` nhận vào những tiền tố mà bạn muốn xác định, trả về `true` nếu chuỗi kiểm tra bắt đầu bằng một trong những tiền tố đó.\n\n```rb\nstring = \"hello world\"\n\nstring.start_with?(\"abc\", \"mentor\") # =\u003e false\nstring.start_with?(\"zys\", \"hell\")   # =\u003e true\n```\n\n- 🌱 Tham số:  \n\t- Phân biệt chữ Hoa và chữ thường\n\t- Nhận regex\n\n```rb\nstring = \"hello world\"\n\nstring.start_with?(\"zys\", \"Hell\") # =\u003e false\nstring.start_with?(/[\\s\\S]*/)     # =\u003e true\n```\n\n### 🌿 Refer\n[https://til.hashrocket.com/posts/rettwv4dgl-check-if-string-starts-with-prefixes](https://til.hashrocket.com/posts/rettwv4dgl-check-if-string-starts-with-prefixes)","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.05-Ruby/Combine-arrays-in-Ruby":{"title":"🥦 Combine arrays in Ruby","content":"\n## 🌿 What?\n\n- 🌱 Trong quá trình làm dự án, mình cần build dữ liệu cho `f.select` từ 2 mảng lấy được từ server, ruby cung cấp method `.zip` để kết hợp mảng.\n\n```rb\nids = [1,2,3,4]\naddress = ['a', 'b', 'c', 'd']\n\nids.zip(address)\n=\u003e [[1,'a'],[2,'b'],[3,'c'], [4,'d']]\n```\n\n- 🌱 Trường hợp cần kết hợp đầy đủ tất cả các cases từ các phần tử của mảng, sử dụng `Enumerator.product`.\n- Ví dụ như web bán quần áo, cta có mảng Size và mảng Brand, vì mới bán nên các Brand vẫn còn đủ các size.\n\n```rb\nsizes = ['small', 'medium', 'large']\nbrands = ['adidas', 'nike', 'puma', 'lv']\n\nEnumerator.product(sizes, brands)\n=\u003e [\n  ['small', 'adidas'],\n  ['small', 'nike'],\n  ['small', 'puma'],\n...\n  ['large', 'puma'],\n  ['large', 'lv']\n]\n```","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.05-Ruby/Comment-multi-lines-in-ruby":{"title":"🥦 Comment multi lines in ruby","content":"\n- 🌱 Comment nhiều dòng(thay vì dùng # ở mỗi dòng) trong Ruby như sau:\n\n```rb\n=begin\n  this is first comment!\n  this is sencond comment!\n=end\n\ndef func; end\n```\n\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.05-Ruby/Endless-method-in-Ruby3":{"title":"🥦 Endless method in Ruby3","content":"\n## 🌿 What?\n- 🌱 Từ vesion 3.0, Ruby cho phép định nghĩa những method đơn giản trên cùng một dòng giống endless condition.\n\n```ruby\ndef isMan?(sex) = sex == 'man'\n\n# isMan('man') =\u003e true\n# isMan('female') =\u003e false\n\n------------------------------------------------\n\n# Method Setter không áp dụng được syntax này.\nclass A\n  def attr=(val) = @attr = val\nend\n# =\u003e SyntaxError \"setter method cannot be defined in an endless method definition\"\n\n------------------------------------------------\n\n# Có thể  viết được nhiều dòng\ndef read(name) = File.read(name)\n                     .split(\"\\n\")\n                     .map(\u0026:strip)\n                     .reject(\u0026:empty?)\n                     .uniq\n                     .sort\n```\n\n- 🌱 Ruby 3.0, endless method cần phải viết đầy đủ dấu ngoặc (, ), {, }. Vấn đề này đã được cải thiện ở version 3.1\n\n```ruby\ndef log = puts \"logging\"\n# 3.0: syntax error, unexpected string literal, expecting `do' or '{' or '('\n# 3.1: successfully defined\n```\n\n## 🌿 Refer \n- Doc 3.0: https://rubyreferences.github.io/rubychanges/3.0.html#endless-method-definition\n- Doc 3.1: https://rubyreferences.github.io/rubychanges/3.1.html#inside-endless-method-definitions-method-calls-without-parenthesis-are-allowed","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.05-Ruby/Floating-point-error":{"title":"🥦 Floating-point error","content":"\n## 🌿 What?\n\n-   Trong các ngôn ngữ lập trình, khi tính toán với float hoặc double thì sẽ gặp sai số. VD:\n\n```rb\n1.9 + 1.2\n=\u003e 3.0999999999999996\n```\n\n- Với những ngành như tài chính, tiền bạc mà tính lệch một số sau dấu phẩy thôi là tới công chiện liền 🥵\n\n## 🌿 Solution\n\n- Trong DB chúng ta hay dùng `decimal` với 2 thông số `precision(số lượng chữ số tính cả sau dấu ,)` và `scale(số lượng chữ số sau dấu ,)` để tính toán.\n- Còn khi chúng ta thao tác ở bên ngoài, ví dụ như trong code hoặc console thì có thể sử dụng BigDecimal.\n\n```rb\nBigDecimal(\"1.2\") + BigDecimal(\"1.9\")\n=\u003e 0.31e1\n\n_.to_f\n=\u003e 3.1\n```\n\n\n## 🌿 Refer \n\n-   [https://spin.atomicobject.com/2014/08/14/currency-rounding-errors/](https://spin.atomicobject.com/2014/08/14/currency-rounding-errors/)\n-   [https://ttuan.xyz/til/computer/floating_point_math/](https://ttuan.xyz/til/computer/floating_point_math/)\n-   https://www.youtube.com/watch?v=PZRI1IfStY0\u0026ab_channel=Computerphile","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.05-Ruby/Get-last-occurrence-of-value-in-an-array":{"title":"🥦 Get last occurrence of value in an array","content":"\n- 🌱 Trong Ruby, hàm `rindex` nhận vào một giá trị và trả về index cho lần cuối cùng giá trị đó xuất hiện trong array.\n\n```rb\narr= ['b', 'a', 'a', 'a']\narr.rindex('a')\n#=\u003e 3\n\narr.rindex('b')\n#=\u003e 0\n```\n\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.05-Ruby/Operator-+-and-with-string":{"title":"🥦 Operator += and \u003c\u003c with string","content":"\n- 🌱 Trong Ruby, hãy nối chuỗi bằng `\u003c\u003c` thay vì `+=`!\n\t- `+=` sẽ tạo ra một object mới sau khi nối chuỗi.\n\n```rb\nname = \"Hoang\"\n\nname.object_id\n=\u003e 71860\n\nname += \" Anh\"\n\nname.object_id\n=\u003e 71880\n```\n\n- 🌱 `\u003c\u003c` sẽ nối chuỗi trực tiếp trên object cũ, không tạo ra object mới. Cải thiện performance khi thao tác với những chuỗi lớn.\n\n```rb\nname = \"Hoang\"\n\nname.object_id\n=\u003e 71900\n\nname \u003c\u003c \" Anh\"\n\nname.object_id\n=\u003e 71900\n```\n\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.05-Ruby/Pattern-matching-in-Ruby":{"title":"🥦 Pattern matching in Ruby","content":"\n## 🌿 What?\n\n- 🌱 Pattern matching là feature được thử nghiệm từ Ruby2.7 và được áp dụng chính thức từ version 3.0, cho phép dễ dàng match giá trị với pattern.\n\n```ruby\nif \"123\" in /\\A\\d+\\z/\n  p \"It's a string of only digits\"\nend\n\n# =\u003e It's a string of only digits\n```\n\n### Các pattern được hỗ trợ:\n1. 🌱 Array pattern: `[\u003csubpattern\u003e, \u003csubpattern\u003e, \u003csubpattern\u003e, ...]`.\n\n- Kiểm tra mảng chỉ chứa pattern 2 integers liền kề không:\n\n```ruby\ncase [1, 2, 3]\nin [Integer, Integer]\n  \"matched\"\nelse\n  \"not matched\"\nend\n#=\u003e \"not matched\"\n```\n\n- Hoặc chỉ cần phần tử đầu tiên là integer:\n\n```ruby\ncase [1, 2, 3]\nin [Integer, *]\n  \"matched\"\nelse\n  \"not matched\"\nend\n#=\u003e \"matched\"\n```\n\n2. 🌱 Find pattern: `[*variable, \u003csubpattern\u003e, \u003csubpattern\u003e, \u003csubpattern\u003e, ..., *variable]`. **(Find pattern is experimental)**\n\n- Kiểm tra mảng có chứa 2 chuỗi liền kề không:\n\n```ruby\ncase [\"a\", 1, \"b\", \"c\", 2]\nin [*, String, String, *]\n  \"matched\"\nelse\n  \"not matched\"\nend\n#=\u003e matched\n```\n\n3. 🌱 Hash pattern: `{key: \u003csubpattern\u003e, key: \u003csubpattern\u003e, ...}`.\n\n```ruby\ncase {a: 1, b: 2, c: 3}\nin {a: Integer}\n  \"matched\"\nelse\n  \"not matched\"\nend\n#=\u003e \"matched\"\n```\n\n4. 🌱 One-line pattern matching with `=\u003e`.\n\n- Gán giá trị cho một biến nếu phần tử match với pattern:\n\n```ruby\ncase [1, 2]\nin Integer =\u003e a, Integer\n  \"matched: #{a}\"\nelse\n  \"not matched\"\nend\n#=\u003e \"matched: 1\"\n\ncase {a: 1, b: 2, c: 3}\nin a: Integer =\u003e m\n  \"matched: #{m}\"\nelse\n  \"not matched\"\nend\n#=\u003e \"matched: 1\"\n```\n\n## 🌿 Refer \n- Document: https://docs.ruby-lang.org/en/3.0/syntax/pattern_matching_rdoc.html","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.05-Ruby/Ruby-Module-Include-Prepend-and-Extend":{"title":"🥦 Ruby Module: Include, Prepend and Extend","content":"\n## 🌿 Ancestors chain\n- Khi khởi tạo một Class, mỗi Class sẽ có một `ancestors chain` - là danh sách các classes và modules mà nó được kế thừa hoặc imported.\nTrong Ruby có 3 cách để import Module cho 1 Class.\n\n### 🌱 Include\n- Method trong module sẽ trở thành `instance method` của Class.\n- Thứ tự trong `ancestors chain`: `Class` \u003e `Module/Class imported` \u003e `Superclass`.  \n\n```rb\nmodule A\n\tdef say\n\t\tp 'hello'\n\tend\t\nend\n\nclass B\n\tinclude A\nend\n```\n\n``` sh\n\u003e B.new.say\n=\u003e \"hello\"\n\u003e\n\u003e B.ancestors\n=\u003e [B, A, ..., Object, ..., BasicObject]\n```\n\n### 🌱 Prepend\n- Giống `include`, khác thứ tự được thêm vào trong `list ancestors`.\n- Thứ tự trong `ancestors chain`: `Module/Class imported` \u003e `Class` \u003e `Superclass`.\n\n```rb\nmodule A\n\tdef say\n\t\tp 'hello'\n\tend\t\nend\n\nclass B\n\tprepend A\nend\n```\n\n``` sh\n\u003e B.new.say\n=\u003e \"hello\"\n\u003e\n\u003e B.ancestors\n=\u003e [A, B, ..., Object, ..., BasicObject]\n```\n\n### 🌱 Extend\n- Method trong module trở thành `class method` của Class.\n- Import methods của module vào `ancestors chain` của `singleton class` của class extend.\n\n```rb\nmodule C\n\tdef say\n\t\tp 'hello'\n\tend\t\nend\n\nclass D\n\textend C\nend\n```\n\n``` sh\n\u003e D.new.say\n=\u003e undefined method 'say' ...\n\u003e\n\u003e D.say\n=\u003e \"hello\"\n\u003e\n\u003e D.ancestors\n=\u003e [D, ..., Object, ..., BasicObject]\n\u003e\n\u003e D.singleton_class.ancestors\n=\u003e [#\u003cClass:D\u003e, C, ...] \n```\n\n\n### 🌿 Tham khảo\n- https://medium.com/@leo_hetsch/ruby-modules-include-vs-prepend-vs-extend-f09837a5b073","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.05-Ruby/Some-Change-in-Ruby3":{"title":"🥦 Some Change in Ruby3","content":"\n- 🌱 Do dự án đang được yêu cầu nâng ruby từ 2.7.6 -\u003e 3.0 nên mình đọc cần đọc lại những highlight changes của version 3.0, tiện mình sẽ note một vài cái hay ho ở bài này.  Lẹt Go 💪🏻\n\n## 🌿 Language changes\n\n### 1. Tách biệt keyword arguments \u0026 positional arguments\n- Chưa hiểu mục đích thay đổi.\n\n### 2. Endless method\n- [[50 til/51 Code/51.05 Ruby/Endless method in Ruby3|Endless method in Ruby3]]\n\n### 3. Pattern matching\n- [[50 til/51 Code/51.05 Ruby/Pattern matching in Ruby|Pattern matching in Ruby]]\n\n### 4. Changes in Class Variable behavior\n- [[50 til/51 Code/51.05 Ruby/Changes in Class Variable behavior in Ruby3|Changes in Class Variable behavior in Ruby3]]\n\n## 🌿 Refer \n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.05-Ruby/Splat-in-ruby":{"title":"🥦 Splat in ruby","content":"\n- 🌱 Splat array in ruby with syntax below:\n\n```rb\narray = [1,2,3]\nsplat_array = [*array, 4, 5] # =\u003e [1,2,3,4,5]\n```\n\n- 🌱 Splat hash in ruby with syntax below:\n\n```rb\nhash = {a: 1, b: 2}\nsplat_hash = { **hash, c: 3} # =\u003e {:a=\u003e1, :b=\u003e2, :c=\u003e3}\n```","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.05-Ruby/Split-array-by-condition-in-Ruby":{"title":"🥦 Split array by condition in Ruby","content":"\n### 🌿 What?\n- 🌱 Từ 2.5.1, Ruby cung cấp method `partition`, chia 1 mảng thành 2 mảng con dựa theo điều kiện truyền vào.\n\n```rb\n(1..6).partition { |v| v.even? }\n#=\u003e [[2, 4, 6], [1, 3, 5]]\n\n['', '1', '12', '123', '1234'].partition { |v| v.length \u003e 2 }\n#=\u003e [['123', '1234'], ['', '1', '12']]\n```\n\n### 🌿 Refer\n- 🌱 Link doc: [Enumerable#partition](https://ruby-doc.org/core-2.5.1/Enumerable.html#:~:text=partition%20%7B%20%7Cobj%7C%20block%20%7D%20%E2%86%92%20%5B%20true_array%2C%20false_array%20%5D)\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.05-Ruby/each_with_object-method-in-ruby":{"title":"🥦 each_with_object in ruby","content":"\n## 🌿 What?\n\n- 🌱 `each_with_object` là method viết gọn cho TH chúng ta cần khởi tạo biến để lưu giá trị sau từng lần lặp. Tương tự như [[50 til/51 Code/51.05 Ruby/reduce() method in Ruby|reduce()]].\n\n```rb\nnumbers = [1, 2, 3, 4, 5]\n\ndef specify_array(array)\n  array.each_with_object([]) { |n, arr| arr \u003c\u003c n if n \u003e 3 }\nend\n\nspecify_array(numbers)\n=\u003e [4, 5]\n```\n\n## 🌿 Compare with reduce()\n\n- 🌱 Khác nhau về thứ tự tham số.\n\n```rb\nnumbers = [1, 2, 3, 4, 5]\n\n# initial object is first arg, second arg is array's element\nsum_by_reduce = numbers.reduce(0) { |sum, num| sum + num }\n\n# opposite to reduce() method\nsum_by_each_with_object = numbers.each_with_object(0) { |num, sum| sum += num }\n```\n\n- 🌱 Thêm nữa là reduce sẽ trả về đối giá trị tích lũy còn each_with_object trả về object khởi tạo. Để ý syntax của 2 ví dụ trên, `each_with_object` phải sử dụng `+=` còn `reduce` thì không.\n## 🌿 Refer \n\n- [https://ruby-doc.org/core-3.0.1/Enumerable.html#method-i-each_with_object](https://ruby-doc.org/core-3.0.1/Enumerable.html#method-i-each_with_object)","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.05-Ruby/instance_eval-in-ruby":{"title":"🥦 instance_eval() in ruby","content":"\n## 🌿 What?\n\n- 🌱 Trong Ruby, class Object có public method là `instance_eval()`, method này cấp quyền truy cập tới các biến instance của object, nhận vào string chứa code Ruby hoặc block và excute theo context của object.\n\n```rb\nclass Klass\n  def initialize\n    @secret = 99\n  end\nend\n\nirb(main):001:0\u003e k = Klass.new\nirb(main):002:0\u003e k.instance_eval { @secret }\n=\u003e 99\n```\n\n```rb\n# add method\nstring = \"String\"\nstring.instance_eval do\n  def new_method\n    self.reverse\n  end\nend\n\nirb(main):033:0\u003e string.new_method\n=\u003e \"gnirtS\"\n```\n\n- 🌱 Tương tự với module và class sẽ có `module_eval()` và `class_eval()`\n\n## 🌿 Refer \n- [https://apidock.com/ruby/Object/instance_eval](https://apidock.com/ruby/Object/instance_eval)\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.05-Ruby/reduce-method-in-Ruby":{"title":"🥦 reduce() method in Ruby","content":"\n## 🌿 What?\n\n- 🌱 `reduce` là method viết gọn cho TH chúng ta cần khởi tạo biến để lưu giá trị sau từng lần lặp.\n\n```rb\nnumbers = [1, 2, 3, 4, 5]\n\ndef specify_array(arr)\n  array = 0\n  arr.each do |num|\n    arr \u003c\u003c num if num \u003e 3\n  end\n  array\nend\n\nspecify_array(numbers)\n=\u003e [4, 5]\n```\n\n- Sử dụng `reduce()`\n\n```rb\nnumbers = [1, 2, 3, 4, 5]\n\ndef specify_array(array)\n  array.reduce([]) { |arr, n| arr \u003c\u003c n if n \u003e 3 }\nend\n\nspecify_array(numbers)\n=\u003e [4, 5]\n```\n\n## 🌿 Refer \n- https://apidock.com/ruby/Enumerable/reduce","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.05-Ruby/w-and-W-in-Ruby":{"title":"🥦 %w and %W in Ruby","content":"\n## 🌿 What?\n\n- 🌱 `%w` return an splited array from a input string by space.\n\n```sh\nirb\u003e %w(I am from Vietnam)\n#=\u003e [\"i\", \"am\", \"from\", \"Vietnam\"]\n```\n\n- 🌱 `%W` is similar `%w` but allows receive interpolation value.\n\n```sh\nirb\u003e country = \"Vietnam\" \nirb\u003e %w(I am from #{country})\n#=\u003e [\"i\", \"am\", \"from\", \"\\#{country}\"]\n\nirb\u003e %W(I am from #{country})\n#=\u003e [\"i\", \"am\", \"from\", \"Vietnam\"]\n```\n\n- 🌱 Similar with %q, %Q, %i, %I, ...\n\n## 🌿 Refer \n- [https://til.hashrocket.com/posts/aqkz0yqdky-the-difference-between-w-and-w-in-ruby](https://til.hashrocket.com/posts/aqkz0yqdky-the-difference-between-w-and-w-in-ruby)","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.06-Servers/Bastion-Host-l%C3%A0-g%C3%AC":{"title":"🥦 Bastion Host là gì?","content":"\n## 🌿 What?\n\n![[00 Meta/01 Attachments/Pasted image 20221124184306.png]]\n\n🌱 **Bastion Host(máy chủ pháo đài)** đúng như tên gọi, là một server sinh ra với sứ mệnh phòng vệ trước những mối hiểm họa có thể tấn công vào mạng lưới nội bộ của chúng ta.\n\n🌱 **Theo định nghĩa của AWS**, **Bastion Host** là một server có mục đích cung cấp quyền truy cập vào mạng nội bộ từ mạng bên ngoài, chẳng hạn như Internet.\n\n🌱 Hoạt động như cầu nối, đứng giữa **private instance** và những truy cập từ bên ngoài. Vì vậy khi tắt **Bastion**, người ngoài cũng sẽ không có cách nào có thể truy cập vào **private instance** của chúng ta.\n\n## 🌿 Why?\n\n🌱 Tăng khả năng bảo mật trong việc quản lý truy cập vào **private instance**.\n\n## 🌿 Architect\n\n![[00 Meta/01 Attachments/Pasted image 20221124183444.png]]\n\n- **Bastion Host** đặt ở Public subnet, để bên ngoài truy cập vào được. \n- **Linux Instance** đặt ở Private subnet, chỉ có thể truy cập thông qua Bastion.\n\n🌱 Về mặt lý thuyết, hành trình thật sự để từ ngoài có thể vào được Linux Instance đó là:\n-   Internet Gateway\n-   Route Table\n-   Network ACL\n-   Security Group\n-   Bastion Host\n\n## 🌿 Refer\n📑 https://aws.amazon.com/blogs/security/how-to-record-ssh-sessions-established-through-a-bastion-host/","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.06-Servers/Config-SSH":{"title":"⚙️ Config SSH","content":"\n## 🌿 Issue\n- 🌱Chắc hẳn là một dev BE, các bạn ít nhiều cũng từng có lần ssh lên server để check log, xem db, hay là config dự án, ... Quy trình đểcó thể ssh được lên  server sẽ gồm có những bước cơ bản như sau:\n\t- Tạo một bộ khóa tại máy local.\n\t- Đưa public key cho bên infra hoặc người có thể lên được server, để họ thêm key của chúng ta vào 1 file - file này sẽ chứa các keys có thể ssh.\n- 🌱 Sau đó mỗi lần ssh chúng ta sẽ cần phải gõ command:\n\n```sh\nssh user_name@ip\n```\n\n- 🌱 Vấn đề ở đây là, chúng ta khó có thể nhớ chính xác 2 thông tin trên cho mỗi lần ssh. Trước đây mình sẽ note những thông tin này vào một chỗ nào đấy bí mật, khi nào cần ssh thì bật lên và copy vào, rất là mất thời gian. Đã thế khi gen ra nhiều key ssh, mình còn phải set -i để chỉ định ssh-key nào sẽ được dùng để ssh nữa.\n\n## 🌿 Solution\n\n- 🌱 Khi search vấn đề này, mình thấy mọi người thường sẽ không dùng cách stupid trên kia của mình mà sẽ sử dụng file  ~/.ssh/config. Và nó giải quyết hoàn toàn được 2 vấn đề mình gặp phải ở trên.\n\t1. Không cần nhớ thông tin ssh: user_name, ip\n\t2. Không cần chỉ định bằng cơm ssh-key khi ssh nữa\n- 🌱 Mọi người chỉ cần thêm vào file ~/.ssh/config như ở dưới:\n\n```sh\nHost project-dev\n  Hostname 1.0.5.374\n  User deployer\n  IdentityFile ~/.ssh/project-dev-ecdsa\n\nHost project-prod\n  HostName 1.12.6.52\n  User deployer\n  IdentityFile ~/.ssh/project-pro-ecdsa\n```\n\n- Host: tên tắt dùng để ssh, có thể đặt tên theo project để dễ nhớ nhé. \n- Hostname: ip server\n- User: user trên server\n- IndentityFile: chỉ định ssh-key sẽ dùng để ssh cho Host\n\n🌱 Việc đơn giản bây giờ là chúng ta ssh theo Host thôi 💪🏻 !!\n\n```sh\nssh project-dev\n```\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.06-Servers/Layer-3-Network-Layer":{"title":"🥦 Layer-3: Network Layer","content":"\n## 🌿 What?\n- Là lớp thứ 3  trong kiến trúc mạng [OSI(Open Systems Interconnection)](https://www.cloudflare.com/learning/ddos/glossary/open-systems-interconnection-model-osi/)\n![[00 Meta/01 Attachments/Pasted image 20230305204236.png]]\n\n- Network layer chịu trách nhiệm về định tuyến dữ liệu giữa các mạng khác nhau bằng cách sử dụng các giao thức định tuyến như IP, ICMP và các công nghệ liên quan khác. Hiểu đơn gian thì lớp này sẽ quyết định dữ liệu sẽ đi theo đường nào là chính xác và hiệu quả.\n- Các thiết bị của lớp này là router, firewall, ...\n\n## 🌿 Refer \n- https://www.cloudflare.com/learning/ddos/glossary/open-systems-interconnection-model-osi/\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.06-Servers/Remote-Desktop-Protocol":{"title":"🥦 Remote Desktop Protocol","content":"\nBình thường các server mình được làm trước đây đều là Ubuntu Server, muốn truy cập lên thì dùng ssh-key là được. Nhưng do spec của dự án hiện tại mình làm có yêu cầu sử dụng Window Server. Khi gửi thông tin Server(IP, users, pass) anh PSM có gợi ý dùng `RDP Client` để truy cập vào. Cơ mà `RDP Client` là cái khỉ gì 😅\n\n## 🌿 What?\n- 🌱`RDP` là một giao thức độc quyền được phát triển bởi Microsoft, cung cấp cho người dùng giao diện để truy cập đến một máy tính khác thông qua kết nối internet. Bạn có thể làm mọi thứ với PC remote như một PC vật lý bình thường. Ví dụ như:  \n\t- Sử dụng các ứng dụng của PC remote.\n\t- Truy cập file và các tài nguyên mạng của PC remote.\n\t- Tắt các ứng dụng khi bạn thoát khỏi `RDP Client` (giống shut down PC vật lý.)\n- 🌱 `Remote Desktop Protocol severs` được dùng để các clients kết nối, severs mặc định của RDP là `TCP port 3389` và `UDP port 3389`.\n- 🌱 **Remote Desktop Connection** được tích hợp cho `RDP Clients` trong hệ điều hành Windows.\n\n## 🌿 Quick connect to a Windows Server from Ubuntu using RDP Client\n\n- 1️⃣ Step 1: Đảm bảo PC hoặc server Windows mà bạn muốn truy cập đã được bật Remote Desktop Connections. \n- 🌱 Nếu chưa bạn có thể xem cách bật ở [đây](https://www.digitalcitizen.life/enable-remote-desktop-windows/).\n- 2️⃣ Step 2: Mặc định Ubuntu cung cấp `Remmina` để hỗ trợ RDP. Turn on!\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Remote Desktop Protocol/Pasted image 20221017142240.png]]\n\n- 3️⃣ Step 3: Tạo một connect mới.\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Remote Desktop Protocol/Pasted image 20221017171736.png]]\n\n- 4️⃣ Step 4: Điền thông tin server.\n\t- Tiếp theo là setting độ phân giải và color depth của màn hình desktop remote. Mặc định sẽ chọn độ phân giải và color depth ở mức cao nhất. Tuy nhiên, setting 2 thông số này thấp hơn sẽ cải thiện khá nhiều perfomance đấy.\n\t- Nếu muốn chia sẻ folder với Windows Server, check folder box và chỉ định folder cần chia sẻ.\n\t- Ngoài ra ở mục Advanced, bạn có thể bật/tắt tiếng, chia sẻ máy in, tắt đồng bộ cho bộ nhớ tạm, ...\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Remote Desktop Protocol/Pasted image 20221017172232.png]]\n\n- 5️⃣ Step 5: Lưu và chạy thôi!\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Remote Desktop Protocol/Pasted image 20221017174839.png]]\n\n\n## 🌿 Góc so sánh\n\n- 🌱 Theo định nghĩa, công dụng của thằng này nghe cũng khá giống TeamView nhỉ 😀 So sánh thôi 😗\n\nRemote Desktop Protocol | TeamView\n------------ | ------------\nLà giao thức được tích hợp sẵn trong hệ điều hành Windows và được phát triển độc quyền bởi công ty Microsoft  | Là một phần mềm chia sẻ quyền điều hành máy tính được phát triển bởi TeamViewer GmbH\nKhông cho phép người dùng theo dõi tác vụ trên máy remote | Cho phép người dùng dõi tác vụ trên máy remote\nYêu cầu cấu hình port chuyển tiếp trên `firewall` hoặc route của máy remote | Chỉ cần cài đặt là dùng bình thường\n\n- 🌱 Nhìn chung TeamView ngon và dễ sử dụng hơn RDP nhưng TeamView lại tiềm ẩn rủi ro bị lộ dữ liệu,  thông tin, như ở công ty mình TeamView được liệt vào danh sách đen không được cài đặt ấy.\n- 🌱 Tùy theo bối cảnh mọi người có thể cân nhắc sử dụng giữa 2 này nhé. \n\n## 🌿 Tham khảo\n- https://learn.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/remote-desktop-clients\n- https://www.techrepublic.com/article/teamviewer-vs-remote-desktop/","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.06-Servers/The-paradigms-that-generually-applied-when-release":{"title":"🥦 The paradigms that generually applied when release","content":"\n\nVới những dự án đã có cộng đồng người dùng lớn, việc deploy những tính năng mới lên môi trường `production` cần phải có những phương pháp để giảm thiểu tối đa những rủi ro cũng như đạt được trải nghiệm tốt nhất dành cho người dùng.  Những mô hình thường được áp dụng thực tế: `A/B Testing`, `Canary Deployments`  và  `Blue-Green Deployments`.\n\n### 🌿 A/B Testing\n- 🌱 Sử dụng để review độ hiệu quả và phản ứng của người dùng đối với những thay đổi mới.\n- 🌱 Những thay đổi mới sẽ chỉ được `rolled out` với một bộ phận người dùng nhất định. So sánh đánh giá của người dùng để đưa ra những chiến lược phát triển phù hợp hơn trong tương lai.\n- 🌱 Mô hình này được áp dụng cả cho phát triển web, bán hàng, quảng cáo, vv... \n\n![[00 Meta/01 Attachments/Pasted image 20221025184727.png]]\n\n\n### 🌿 Blue-Green Deployments\n- 🌱 Là một chiến lược deploy dùng để kiểm thử những tính năng mới của dự án.\n- 🌱 Deploy without downtime.\n- 🌱 Mô hình này gồm 2 servers chạy đồng thời là Blue và Green, đều là môi trường `production` nhưng một server có status `live` - nhận reqs của users còn server kia là `idle` - không hoạt động.\n\n![[00 Meta/01 Attachments/Blue-Green Deployments.excalidraw.png]]\n\n### 🌿 Canary Testing\n- 🌱 Cũng giống 2 ý đầu của  `Blue-Green Deployments`.\n- 🌱 Thay vì switch toàn bộ users truy cập giữa Blue và Green, `Canary Testing` sử dụng cân bằng tải, cho phép một số users có thể sử dụng version code mới, sau khi chạy ngon lành thì dần dần áp dụng cho toàn bộ users của hệ thống.\n\n![[00 Meta/01 Attachments/Pasted image 20221025184522.png]]\n\n### 🌿 Tham khảo\n- https://www.oreilly.com/library/view/spring-50-microservices/9781787127685/6fab55ad-8897-42b7-b509-dd90850c861b.xhtml\n- https://circleci.com/blog/canary-vs-blue-green-downtime/\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.07-Utils/%C4%90%C3%A1nh-s%E1%BB%91-hi%E1%BB%87u-phi%C3%AAn-b%E1%BA%A3n-ph%E1%BA%A7n-m%E1%BB%81m":{"title":"🌿 Đánh số hiệu phiên bản phần mềm","content":"\n### 🌿 What?  \n- 🌱 Là quy tắc để xác định và phân biệt tên của phần mềm ở mỗi giai đoạn phát triển. \n- 🌱 Sematic Versioning  \n\t- Là quy tắc thường được sử dụng nhất. Do [Tom Preston-Werner](https://tom.preston-werner.com/) (ng sáng lập và là cựu CEO của Github) tạo ra.\n\t- Có format là `[major].[minor].[patch]` , vd: 5.6.8\n\t\t-   `major`  - tăng lên khi có những thay đổi **không tương thích với phiên bản cũ** (vd thay đổi cấu trúcc response).\n\t\t-   `minor`  - tăng lên khi thêm tính năng mới **nhưng vẫn tương thích với phiên bản cũ** (vd thêm trường trả về trong response).\n\t\t-   `patch`  - tăng lên khi fix bug **nhưng vẫn tương thích với phiên bản cũ**.\n\n### 🌿 Refer\n[https://viblo.asia/p/semantic-versioning-OeVKBN2EKkW](https://viblo.asia/p/semantic-versioning-OeVKBN2EKkW)","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.07-Utils/Cron-job-notify-drink-water":{"title":"🥂 Tạo background job nhắc nhở uống nước đều đặn","content":"\nKhông biết mọi người có giống mình không, mỗi khi làm việc mình cứ bị quên uống nước ấy, có khi cả buổi mình còn chả uống được 250ml nước =((. Tác hại của việc uống ít nước mọi người có thể gg nha, nhưng ncl uống nước đủ mỗi ngày là thói quen rất có lợi cho sức khỏe cũng như làn da của chúng ta =)).\n\nHôm trước mình có gặp anh mentor ở cty, anh ấy chia sẻ là vì hay ngồi gù lưng nên anh ấy viết một script để sau một khoảng thời gian, thông báo kiểu như 'Thẳng lưng lên!' được hiển thị trên Touch Bar. 🤩, hay thế!!! Sao mình ko áp dụng để improve khả năng uống nước của bản thân nhỉ 🤔 Thế nên tranh thủ cuối tuần, mình có tìm cách để setup cronjob cho Ubuntu.\n\n### 🌿 How?\n- 🌱 Đầu tiên là setup cronjob, mình có xài `cron`, mn có thể dùng apt để install và enable nó lên nhé.\n\n```sh\nsudo apt update\n# Check if cron package is installed\ndpkg -l cron\n\n# install cron\nsudo apt install cron\n\n# enable cron\nsystemctl start cron\n\n# check status cron\nsystemctl status cron\n\n# stop cron\nsystemctl stop cron\n```\n\n- 🌱 Để thêm job, sử dụng command:\n\n```sh\ncrontab -e\n```\n\n- 🌱 Trong file đã có hướng dẫn cụ thể, về cơ bản cũng giống như setup cron-sidekiq, nếu chưa quen settings thời gian chạy job mọi người có thể sử dụng [cron-time](https://crontab.guru/) cho trực quan nhé!\n\nVí dụ mình set 20p là phải nhắc t uống nước đó nha Ubuntu =))\n\n```sh\n20 * * * * cd ~/personal \u0026\u0026 ./script-notify-myself.sh\n```\n\n- 🌱 Tạo script:\n```sh\n#!/bin/bash\n\nexport DBUS_SESSION_BUS_ADDRESS=\"${DBUS_SESSION_BUS_ADDRESS:-unix:path=/run/user/${UID}/bus}\"\nnotify-send \"Uống nước đii!!!\"\n```\n\n- 🌱 Và kết quả là:\n\n\n### 🌿 Update\n- 🌱 Sau một thời gian thêm cronjob, mình khá là khó chịu vì cái bảng thông báo của mình nó cứ hiển thị chất đống `Uống nước đii!!!`, rất là mất mỹ quan đô thị.\n\n![[00 Meta/01 Attachments/Notifi Trash.png]]\n\n- 🌱 Để khắc phục vấn đề này, mình có thêm một script chịu trách nhiệm để clear-all tất cả những thông báo hiện tại. \n\n```sh\n# ./remove-all-notify-tray.sh\n\n#!/bin/bash\ngdbus call --session --dest org.gnome.Shell --object-path /org/gnome/Shell --method org.gnome.Shell.Eval 'Main.panel.statusArea.dateMenu._messageList._notificationSection._list.remove_all_children()'\n```\n\n- 🌱 Mình có viết scripts ở [đây](https://github.com/anhnh-3008/dotfiles/tree/main/cronjob)  để sau dùng lại cho tiện, nếu thấy hứng thú mọi người có thể pull về chạy thử nha ❤️\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.07-Utils/DATE_SUB":{"title":"🥦 DATE_SUB - ngược về quá khứ","content":"\n- 🌱 Trong SQL, hàm `DATE_SUB()` trả về ngày sau khi đã lùi một khoảng thời gian chỉ định.\n\n```sql\nDATE_SUB(date, INTERVAL value unit)\n\n# date: Ngày làm mốc.\n# value: thời gian bị trừ(có thể chỉ định giá trị âm || dương)\n# unit: đơn vị thời gian(ngày, giờ, phút, ...)\n```","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.07-Utils/Find-by-Regex-in-VsCode":{"title":"🥦 Find by Regex in VsCode","content":"\n\n## 🌿 Vấn đề\n\n🌱 Tôi có một file cần xóa nhiều dòng thừa có cấu trúc giống nhau (dòng trống, dòng comment ,...) trong VsCode.\n\n## 🌿 Giải pháp\n\n- 🌱 Trong thanh tìm kiếm của VsCode, có option tìm kiếm theo regex. Nếu muốn xóa dòng trống,  `Ctrl + H` -\u003e thêm regex `^$\\n` -\u003e `Ctrl + Alt + Enter ` là xong.\n\n![[00 Meta/01 Attachments/Pasted image 20221130152936.png]]\n\n- 🌱 Option rất tiện khi chúng ta muốn tìm những giá trị có format giống nhau(số điện thoại, email, etc ...) ","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.08-System-Design/CORS-Cross-origin-Resource-Sharing":{"title":"📑 CORS - Cross-origin Resource Sharing","content":"\n## 🌿 What?\n- 🌱 `CORS`  là một cơ chế cho phép chia sẻ nhiều tài nguyên(images, files, fonts, javascript,...) giữa nhiều trang web khác nhau.\n\n## 🌿 Why?\n- 🌱 CORS ra đời do sự xuất hiện của [[50 til/51 Code/51.08 System Design/Same-origin policy]].\n\n## 🌿 How?\n- 🌱 `CORS` sử dụng các HTTP Header để thông báo với trình duyệt nhận request là 'Em là con ông A nhà bà B ở cuối làng, anh cho em vào lấy ít đồ cho bố em nhé ' =))\n- 🌱 `Access-Control-Allow-Origin`  ở header mà trường này ko có giá trị hoặc giá trị ko hợp lệ thì sẽ bị báo lỗi.\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.08-System-Design/Open-ID-ConnectOIDC":{"title":"🔐 Open ID Connect(OIDC)","content":"\nLà một loại cơ chế xác thực kiểu [[50 til/51 Code/51.08 System Design/Single Sign-On(SSO)]] dựa trên thuật toán **mật mã hóa khóa bất đối xứng**. Có 2 khóa đảm nhiệm riêng từng nhiệm vụ là mã hóa và giải mã.\n**![](https://lh5.googleusercontent.com/1cxM7BkCmyzrm0Q17OIv7x3GcMzfyLhaHnExHl6foJLIL0e0nruB8tWPJu4RwoZNlLn1XFNlieM0gG2JiCHff760sQ87LyzxX1GJobxyoPGE0i72olWaxzLasNXmm3_iC4NEYfsKheuPVME_LxigUMArWVomwIKfbCD1Gt82o_Hs3Vh2d_HKWweu3A)**\n**![](https://lh4.googleusercontent.com/ku-PU5gsE-WnRbitam-zVKFWzcmYPxsst_bfbtVlU3KhmKcIbJ9qB5-TVBnoxQHkOfWRWEVLmV_fwQk7lgiU_t8-UYHti_T4ZBSXxh3k-Ei_2Gm_oufq8LKosdEVYrjenxEnkzPqNYCKAA_3vggJT2XeD8_Rj_ud8g6gNCTWO_0qtfKY_kfMFiD66g)**\n\nẢnh trên mô tả cơ chế hoạt động của [Mật mã hóa khóa công khai](https://vi.wikipedia.org/wiki/M%E1%BA%ADt_m%C3%A3_h%C3%B3a_kh%C3%B3a_c%C3%B4ng_khai), hiểu đơn giản thì 2 cái này sẽ giống nhau nhưng với 1 cái thì cả 2 khóa phải được giữ bí mật còn lại thì một khóa bí mật một khóa công khai.\n\nOIDC là phiên bản mở rộng của Oauth 2.0, thay vì là Access-Token chúng ta sẽ nhận được một Id Token từ Auth Server. Với [access-token](https://oauth.net/id-tokens-vs-access-tokens/#:~:text=Access%20tokens%20are%20what%20the,read%20by%20the%20OAuth%20client.), mỗi lần qua một trang web khác chúng ta sẽ cần request lại access-token mới nhưng với id-token có thể dùng lại thoải mái, [id-token](https://oauth.net/id-tokens-vs-access-tokens/#:~:text=Access%20tokens%20are%20what%20the,read%20by%20the%20OAuth%20client.) có thể xác thực được user cũng như đảm bảo được các thông tin thuộc về User là ko thể bị giả mạo.\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.08-System-Design/Robustness-Diagram":{"title":"🥦 Robustness Diagram","content":"\n## 🌿 What?\n- 🌱 Là một dạng UML diagram nằm trong `ICONIX Process`, xác định tất cả những objects và mối liên hệ của từng `use case`.\n\t- Giảm sự mơ hồ của phần mô tả `use case`, dễ dàng hơn cho việc thiết kế, kiểm tra và estimate. \n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/Robustness Diagram/Robustness reponsibility.excalidraw.png]]\n\n\u003e [!info] ICONIX Process\n\u003e \n\u003e `ICONIX Process` là một phương pháp luận phát triển phần mềm, mục tiêu là để tránh [analysis paralysis](https://en.wikipedia.org/wiki/Analysis_paralysis). Chỉ sử dụng 4 UML cơ bản ứng với 4 bước trong quá trình chuyển đổi từ `Use Case text` thành `Code` .\n\n- 🌱 Mỗi diagram sẽ trả lời cho từng câu hỏi:\n\t- `Use Cases` - Users đang làm gì?\n\t- `Domain Models` - Có những Objects nào?\n\t- `Robustness Diagrams` - Những Object nào tham gia trong từng `use case`?\n\t- `Sequence Diagrams` - Những Object tương tác với nhau như thế nào?\n\n## 🌿 How?\n- 🌱 Sử dụng khuôn mẫu `boundary/control/entity class`.\n\n- 🌱 4 nguyên tắc cơ bản:\n\t- `Actors` chỉ có thể giao tiếp với `Boundary objects`.\n\t- `Boundary objects` chỉ có thể giao tiếp với `Control objects` hoặc `Actors`.\n\t- `Entity objects` chỉ giao tiếp được với `Control objects`.\n\t- `Control objects` có thể giao tiếp với `Boundary objects`, `Entity objects` và một số `Control objects` khác, nhưng cấm chơi với `Actors`.\n\u003e [Ý nghĩ của các khuôn mẫu](https://docs.nomagic.com/display/MD190/Robustness+diagram#:~:text=Boundary%20or%20Interface,and%20entity%20objects.)\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/Robustness Diagram/Object Rubustness.excalidraw.png|500]]\n\n\n- 🌱 Ví dụ:\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/Robustness Diagram/Robustness of use case access to homepage.excalidraw.png]]\n\n## 🌿 Tham khảo\n- https://en.wikipedia.org/wiki/ICONIX\n- https://docs.nomagic.com/display/MD190/Robustness+diagram","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.08-System-Design/Same-origin-policy":{"title":"📑 Same-origin policy","content":"\n\n## 🌿 What?\n-  Là một cơ chế bảo mật hạn chế việc `documents` hoặc `script load` thuộc một `origin` có thể tương tác với những `resources` thuộc một `origin` khác.\n-  Được cài đặt vào toàn bộ  các trình duyệt hiện nay.\n-  Chính sách này giúp trang web của chúng ta không bị truy cập bừa bãi từ những tác nhân lạ.\n\t- Ví dụ nếu bạn vào một trang web bất kỳ được cài sẵn một mã độc truy cập đến trang web VCB, nếu bạn đã đăng nhập vào VCB, vẫn còn hiệu lực đăng nhập và không có chính sách này, hacker sẽ chiếm được quyền sử dụng tài khoản ngân hàng của bạn.\n\t- Còn bình thường mn sẽ nhận được message này ở console browser\n\n```js\nAccess to XMLHttpRequest at 'https://vietcombank.com/profile' from origin 'xxx' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.\n```\n\n- 🌱 Nhưng thực hiện truy vấn giữa nhiều trang web với nhau là việc rất thường xuyên đối với một lập trình viên, đặc biệt là vụ call API. Và thế là Cross-origin Resource Sharing - CORS ra đời =))","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.08-System-Design/Sequence-Diagram-l%C3%A0-g%C3%AC":{"title":"🥦 Sequence Diagram là gì?","content":"\nSắp tới mình được giao tasks là vẽ lại `sequence diagram` cho toàn bộ tính năng của một con dự án ở cty, mà nghe đâu là gần 40 chục cái hay sao ấy 🤢 Thế nên tranh thủ cuối tuần mình ngồi ôn lại chút để tuần sau vào việc cho lẹ 💪 Let's go!!!\n\n## 🌿  What?\n- `Sequence Diagram`  -Biểu đồ tuần tự là một dạng biểu đồ `UML - Unified Modeling Language` dùng để xác định trình tự diễn ra của một nhóm đối tượng nào đó.\n- Biểu đồ miêu tả chi tiết các thông điệp được gửi và nhận của từng đối tượng đồng thời cũng chú trọng cả việc xác định thứ tự của những thông điệp đó.\n\n## 🌿  Các thành phần\n\nGồm 4 thành phần chính:\n- Đối tượng (Object or Class)\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Đối tượng.excalidraw.png]]\n\n- Đường đời đối tượng (Lifelines)\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Đường đời đối tượng.excalidraw.png]]\n\n\n- Thông điệp (messages)\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp.excalidraw.png]]\n\n- Các dạng thông điệp\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp đồng bộ.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp không đồng bộ.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp trả về.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp nội tại.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp tạo mới.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp cập nhật.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp xóa.excalidraw.png]]\n\n- Tiến trình xử lý (process)\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Tiến trình xử lý.excalidraw.png]]\n\n\n\n## 🌿 Ví dụ\n\n![[00 Meta/01 Attachments/Sequence Diagram chức năng đăng nhập.excalidraw.png]]\n\n## 🌿 Tham khảo\n- https://www.smartdraw.com/uml-diagram/\n\n\n\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.08-System-Design/Single-Sign-OnSSO":{"title":"🔐 Single Sign-On(SSO)","content":"\n## 🌿  Issue\nHiện nay hầu hết các dịch vụ web đều yêu cầu người dùng đăng nhập trước khi sử dụng. Nhu cầu sử dụng dịch vụ ngày càng nhiều đồng nghĩa chúng ta càng phải nhớ nhiều thông tin đăng nhập, giả sử nếu chúng ta dùng 10 webs khác nhau, việc nhớ thông tin đăng nhập cũng khá là 'vất vả' đúng ko nào =))\n- Chính vì vậy mà đã lòi ra cu SSO này =))\n\n## 🌿  What?\n![[00 Meta/01 Attachments/Single Sign-On.png]]\n\n- `Single Sign-On` là cơ chế giúp người dùng đăng nhập một ID cho một vài trang webs hoặc hệ thống liên quan nhưng độc lập với nhau. Kiểu như Google dùng tài khoản Gmail đăng nhập cho các services độc lập(Driver, Clouds, ...). Một khóa mở được nhiều chìa 🤞\n\n## 🌿  Why?\n### Ưu điểm\n- Giảm thời gian nhập lại thông tin đăng nhập\n- Giảm [password fatigue](https://en.wikipedia.org/wiki/Password_fatigue) cho hệ thống\n- Giảm effort phát triển chức năng log-in\n- Giảm thiểu rủi ro việc lộ thông tin của người dùng\n- Nâng cao hiệu suất cho người dùng. Người dùng ko phải nhớ nhiều thông tin đăng nhập.\n- Quản lý dễ dàng hơn. Giả sử bạn có 3 trang webs và bạn muốn ban account A, nếu dùng SSO bn chỉ cần setting banned một lần cho cả 3 webs.\n\n### Nhược điểm:\n- Phụ thuộc vào bên thứ 3\n\n\n🌱 Lắm ưu ít nhược nên SSO khá là ngon, hiện tại cũng có khá nhiều service thứ 3 cung cấp dịch vụ SSO miễn phí(Facebook, Google, Github, ...) mọi người có thể cân nhắc sử dụng theo nhu cầu phát triển của dự án nhé =))\n\n## 🌿  How?\nSSO là một phần của [[50 til/51 Code/51.08 System Design/System Identification Link]], có liên quan chặt chẽ với việc xác thực thông tin người dùng. Nó sẽ định danh người dùng, và sau đó chia sẻ thông tin định danh được với các hệ thống con.\n\n### Cơ chế\nTheo luồng bình thường user đăng nhập web A sẽ sinh ra cookie để xác thực cho những request sau, nếu mang cookie đó sang web B để xác thực thì sẽ tạch do các trình duyệt hiện nay chỉ có thể truy cập cookie do chính nó tạo ra.\n![[00 Meta/01 Attachments/Auth SSO.png]]\nHiểu đơn giản giữa các web sẽ có một **browser cookie storage** chung và sử dụng cơ chế Cross-origin resource sharing. Khi Web nào đăng nhập thì sẽ truy cập vào **browser cookie storage** để lấy cookie lên **server auth**(của bên thứ 3) để xác thực.\n\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.08-System-Design/Store-passwords-safely-in-the-database":{"title":"🛡️ Store passwords safely in the database","content":"\n## 🌿 Những điều không nên làm\n- Không được lưu passwords dạng text trong db, vì bất cứ người nào có quyền connect vào db đều sẽ xem được nó.\n- Lưu password hashes trực tiếp cũng không an toàn vì nó có thể vị vô hiệu hóa bởi những cuộc tấn công tính toán trước(`precomputation attacks`), vd như là `rainbow tables`.\n- Để hạn chế `precomputation attacks`, chúng ta hãy `salt the passwords`.\n\n### What is salt?\n- Theo như hướng dẫn của OWASP, `salt` là một chuỗi duy nhất, được sinh ra ngẫu nhiên và được thêm cho từng password như là một phần của quá trình mã hóa.\n\n\n## 🌿 How to store?\n![[00 Meta/01 Attachments/Pasted image 20221004102412.png]]\nTheo hình trên, mọi người có thể hình dung các bước để lưu password vào DB như sau:\n\t1. User cung cấp password.\n\t2. Hệ thống sinh ra `salt` cho password.\n\t3. Trong DB sẽ lưu cả `salt` và `hash` được mã hóa từ `password + salt`. \n\n## 🌿 How to validate?\n**![](https://lh5.googleusercontent.com/VT3b8cvDZ6idbl8D3zYpTNiHhiBp72vR4CLfjAvJx0-Tjp7ZIGy63DtQeMfbtsjwfh5Q8uk3ch16YIMp4wCVwmzyb1A9-aTZ0cSFgyb3kVjvr9X3N_ZmP7-iD_Akoh7TqveaTkM-jBZG1084xwwNqYUs5RaI7GwfxiV7fxYwQngMrmgirVgS9lHk)**\nCác bước hệ thống thực hiện validate:\n\t1. User cung cấp validate.\n\t2. Lấy mã `salt`  của user được lưu trong DB.\n\t3. Thực hiện mã hóa từ `password + salt` =\u003e `hash`\n\t4. So sánh `hash` tạo từ bước 3 và `hash` lưu trong DB. \n\nP/s:  Ngoài ra mọi người có thêm cơ chế nào khác để có thể lưu trữ pasword an toàn trong DB không? Nếu có hãy cmt cho mình biết với nha \u003c3\n\n## 🌿 Tham khảo\n- Free System Design - ByteByteGo - Trang 13\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.08-System-Design/System-Identification-Link":{"title":"📑 Hệ thống nhận diện liên kết","content":"\nHệ thống nhận dạng liên kết( Federated Identity Glossary) là nơi tập trung và liên kết thông tin người dùng. Có 4 yếu tố nền tảng cấu thành nên hệ thống này:\n-   **Xác thực (Authentication):** kiểm tra thông tin đăng nhập và tiến hàng định danh người dùng.\n-   **Phân quyền (Authorization):** dựa trên thông tin định danh để kiểm tra quyền truy cập của user.\n-   **Trao đổi thông tin người dùng (User attributes exchange):** Mỗi hệ thống con sẽ cần và lưu trữ các thông tin khác nhau của người dùng, tuy nhiên sẽ có các thông tin bị lặp lại, ví dụ như tên, họ.... Do đó, cần có một nơi để tổng hợp lại các thông tin này, và trao đổi cho các hệ thống con.\n-   **Quản lí người dùng (User management):** admin có thể quản lí người dùng bằng các thao tác thêm, sửa, xóa... ở các hệ thống con.\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.08-System-Design/Why-is-RAM-access-faster-than-hard-disk-drive":{"title":"♻️ Why is RAM access faster than hard disk drive?","content":"\nKhi sử dụng Redis, mọi người thường hay nói Redis thực hiện thao tác dữ liệu trên Ram nên có tốc độ truy xuất nhanh hơn rất nhiều so với truy cập vào HDD. Vậy tại sao lại như thế? \n \n## 🌿 Why?\n\n![[00 Meta/01 Attachments/Communication between CPU - RAM - Hard Storage.png]]\n\n\n- HDD nằm cách xa CPU, được kết nối với bảng điều khiển thông qua cổng SATA. 6Gb/s là tốc độ tiêu chuẩn của SATA III, HDD chỉ có thể đọc hoặc viết chứ không thể làm cả hai trong cùng một thời điểm.\n- RAM nằm rất gần CPU và có kết nối băng thông rất cao. Thông lượng của DDR4 là khoản 40Gb/s, ngoài ra RAM còn có thể thực hiện đọc và viết cùng lúc. Khi sử dụng dual channel, RAM sẽ đọc/đọc, viết/đọc, viết/viết chính vì vậy mà nó có thể thao tác một lượng dữ liệu vô cùng lớn trong cùng một thời điểm.\n\n\n## 🌿 Câu hỏi\nThế tại sao người ta lại không thiết kế để HDD lại gần CPU?\nVấn đề lớn nhất là chi phí. Tốc độ xử lý cao tương ứng với giá thành sản xuất cũng sẽ đắt. Và tùy theo mục đích nên mỗi phần sẽ có thiết kế phù hợp -\u003e đạt được cả hiệu năng và giá thành tốt nhất.\n-   Đối với những tác vụ lưu trữ file, đọc/ ghi đơn giản, không yêu cầu xử lý nhanh thì người ta dùng HDD cho rẻ. (ổ cứng lưu trữ)\n-   Các tác vụ cần xử lý nhanh hơn 1 chút, như load hệ điều hành, người ta ưu tiên dùng SSD (ổ cài win ý :v )\n-   Thằng nào cần cache, xử lý tốc độ bàn thờ (làm bộ nhớ tạm cho các phần mềm đang chạy) thì người ta dùng tới RAM, CPU.\n\n![[00 Meta/01 Attachments/Why is RAM access faster than hard disk drive acess.png]]\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.08-System-Design/Why-is-Redis-so-Fast":{"title":"♻️ Why is Redis so Fast?","content":"\n🌱 Có 3 lý do chính giải thích điều này:\n\n![[00 Meta/01 Attachments/3 Reasons why Redis is fast.png]]\n\n- Redis là một cơ sở dữ liệu lưu trữ trên RAM. Tốc độ truy cập RAM đểu nhất cx nhanh hơn 1000 lần so với tốc độ truy cập ổ cứng. Mọi người có thể xem thêm \n- Redis sử dụng `IO multiplexing` và `single-threaded`. IO multiplexing là cơ chế đọc/ghi liên tục của RAM. RAM nhận tất cả các yêu cầu đọc/ghi dữ liệu, để vào một chỗ, sau đó dùng single-threaded lặp qua từng event để tiếp tục xử lý.\n- Redis sử dụng một vài cấu trúc dữ liệu `lower-level`(String lưu thành SDS, ...).\n\n\n## 🌿 Câu hỏi\n- 🌱 Tại sao truy cập từ RAM lại nhanh hơn từ HDD?\n[[50 til/51 Code/51.08 System Design/Why is RAM access faster than hard disk drive?]]\n\n\nP/s: Memcached cũng là một giải pháp khá phổ biến để giải quyết vấn đề cached dữ liệu, mọi người có thể tìm hiểu thêm nhé.\n\n## 🌿  Tham khảo\n- Free System Design - ByteByteGo - Trang 76","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.09-Docker/Best-practice-when-build-Dockerfile":{"title":"🥦 Best practice when build Dockerfile","content":"\n## 🌿 I. Chỉ định rõ version của Base Image\n\n- 🌱 Bad\n\n```Dockerfile\nFROM ruby\n...\n```\n\n- 🌱 Good\n\n```Dockerfile\nFROM ruby:3.1.2\n...\n```\n\n- Nên chỉ định rõ version để có thể tái sử dụng. Cũng tiện theo dõi khi chúng ta muốn upgrade \u0026 maintain. \n\n## 🌿 II. Chỉ nên sử dụng trusted or official base images\n\n- 🌱 Bad\n\n```Dockerfile\nFROM random-dude-on-the-internet/ruby:3.1.2\n```\n\n- 🌱 Good\n\n```Dockerfile\nFROM ruby:3.1.2\n\n# hoặc \n\nFROM random-dude-on-the-internet/ruby:3.1.2\n\n# giả sử chúng ta biết chắc rằng random-dude-on-the-internet uy tín/tín.\n```\n\n- Vì chúng ta không thể chắc rằng Base Image có được sửa đổi hay không. Với những nguồn không uy tín, nếu người viết không ghi change log rõ ràng có thể gây ảnh hưởng đến hệ thống.\n\n## 🌿 III. Chỉ định rõ version của dependencies\n\n- 🌱 Bad\n\n```Dockerfile\nFROM ruby:3.1.2\n\nRUN gem install sinatra\n```\n\n- 🌱 Good\n\n```Dockerfile\nFROM ruby:3.1.2\n\nRUN gem install sinatra -v 2.0.5\n```\n\n- Tương tự như base image, chúng ta cũng nên chỉ định rõ version cho dependencies. Hầu hết các trình quản lý package như `Gemfile.lock`, `package-lock.json`, `yarn.lock` đều chỉ định rõ, dễ dàng quản lý, theo dõi cũng như thuận tiện tái sử dụng.\n\n## 🌿 IV. Đưa những commands ít thay đổi lên trước  \n\n- 🌱 Bad\n\n```Dockerfile\nFROM ruby:3.1.2\n\n# Source code\nCOPY my-code/ /srv/\n\n# Application dependencies\nCOPY Gemfile Gemfile.lock ./\nRUN bundle install\n```\n\n- 🌱 Good\n\n```Dockerfile\nFROM ruby:3.1.2\n\n# Application dependencies\nCOPY Gemfile Gemfile.lock ./\nRUN bundle install\n\n# Source code\nCOPY my-code/ /srv/\n```\n\n- Docker sẽ build lại tuần tự từ trên xuống dưới, bắt đầu từ câu lệnh có 'thay đổi'. Ví dụ như trên, source code sẽ được thay đổi thường xuyên hơn Gemfile, nếu đặt source code ở trên, Docker sẽ build lại cả phần `COPY` với `RUN bundle install` nữa. \n\n\u003e [!note] Note \n\u003e \n\u003e Đặt các lệnh ít có khả năng thay đổi nhất ở trên cùng để tận dụng cache, giảm thời gian build Image.\n\n## 🌿 V. Tránh chạy container với quyền root\n\n- 🌱 Bad\n\n```Dockerfile\nFROM ruby:3.1.2\n\nRUN gem install sinatra -v 2.0.5\n\nRUN echo 'require \"sinatra\"; run Sinatra::Application.run!' \u003e config.ru\n\n# By default this is run as root\nCMD rackup\n```\n\n- 🌱 Good\n\n```Dockerfile\nFROM ruby:3.1.2\n\nRUN gem install sinatra -v 2.0.5\n\n# Tạo user riêng để chạy container\nRUN adduser -D my-sinatra-user\n\n# Chỉ định User thực hiện các câu lệnh RUN, CMD hoặc ENTRYPOINT ở dưới\nUSER my-sinatra-user\n\n# Chỉ định thư mục riêng\nWORKDIR /home/my-sinatra-user\n\nRUN echo 'require \"sinatra\"; run Sinatra::Application.run!' \u003e config.ru\n\n# Các câu lệnh sẽ chạy với quyền của user my-sinatra-user\nCMD rackup\n```\n\n- Mặc định container run với quyền root.\n- Container của chúng ta sẽ tạo ra một process chạy với quyền root trong Linux kernel, điều này có thể gây ra lỗ hổng bảo mật, cho phép attackers thoát khỏi container và thực hiện quyền root trên thiết bị của chúng ta.\n\n## 🌿 VI. Sử dụng -chown khi run COPY hoặc ADD\n\n- 🌱 Bad\n\n```Dockerfile\nFROM ruby:3.1.2\n\n# Tạo user riêng để chạy container\nRUN adduser -D my-sinatra-user\n\n# Chỉ định User thực hiện các câu lệnh RUN, CMD hoặc ENTRYPOINT ở dưới\nUSER my-sinatra-user\n\n# Chỉ định thư mục riêng\nWORKDIR /home/my-sinatra-user\n\n# File copy sẽ thuộc sở hữu của root user\nCOPY Gemfile Gemfile.lock ./\n\nRUN bundle install\n\nCMD rackup\n```\n\n- 🌱 Good\n\n```Dockerfile\nFROM ruby:3.1.2\n\n# Tạo user riêng để chạy container\nRUN adduser -D my-sinatra-user\n\n# Chỉ định User thực hiện các câu lệnh RUN, CMD hoặc ENTRYPOINT ở dưới\nUSER my-sinatra-user\n\n# Chỉ định thư mục riêng\nWORKDIR /home/my-sinatra-user\n\n# File copy sẽ thuộc sở hữu của my-sinatra-user user\nCOPY --chown=my-sinatra-user Gemfile Gemfile.lock ./\n\nRUN bundle install\n\nCMD rackup\n```\n\n- `USER` chỉ chỉ định user thực hiện `RUN`, `CMD` hoặc `ENTRYPOINT`. Còn với `COPY` và `ADD` chúng ta cần sử dụng `--chown`.\n\n## 🌿 VII. Tránh làm lộ thông tin nhạy cảm trong Dockerfile\n\n- 🌱 Bad\n\n```Dockerfile\nFROM ruby:3.1.2\n\nENV DB_PASSWORD \"real password\"\n```\n\n- Các thông tin như trên không bao giờ được hiện diện trong Dockerfile của chúng ta dưới dạng text thô. Thay vào đó, chúng ta có thể sử dụng thông qua những cách sau:\n\t- Lệnh `ARG` và truyền giá trị thông qua flag `--build-arg` khi run.\n\t- Biến môi trường.\n\n\u003e [!warning] Lưu ý\n\u003e Hai cách trên vẫn có rủi ro vì các giá trị thô sẽ vẫn được ghi lại trong lịch sử build.\n\n## 🌿 VIII. Xóa luôn những thông tin nhạy cảm sử dụng để build\n\n- 🌱 Bad\n\n```Dockerfile\nFROM ruby:3.1.2\n\nARG PRIVATE_SSH_KEY\n\n# Bước này sẽ lưu lại PRIVATE_SSH_KEY\nRUN echo \"${PRIVATE_SSH_KEY}\" \u003e /root/.ssh/id_rsa\n\n# Đến bước này vẫn sẽ còn giá trị của PRIVATE_SSH_KEY\nRUN bundle install\n\nRUN rm /root/.ssh/id_rsa\n```\n\n- 🌱 Good\n\n``` Dockerfile\nFROM ruby:3.1.2\n\nARG PRIVATE_SSH_KEY\n\nRUN echo \"${PRIVATE_SSH_KEY}\" \u003e /root/.ssh/id_rsa \u0026\u0026 \\\n  bundle install \u0026\u0026 \\\n  rm /root/.ssh/id_rsa\n```\n\n- Nếu có ai truy cập được vào lịch sử build thì có thể lấy được giá trị của PRIVATE_SSH_KEY. Chúng ta nên xóa luôn trong cùng một step để tránh trường hợp trên.\n\n## 🌿 IX. Tối ưu size của base image nếu có thể\n\n- 🌱 Bad\n\n```Dockerfile \nFROM ruby:3.1.2\n\nCMD ruby -e \"puts 1 + 2\"\n```\n\n- 🌱 Good\n\n```Dockerfile \nFROM ruby:3.1.2-alpine\n\nCMD ruby -e \"puts 1 + 2\"\n```\n\n- Base Image có nhiều version(chủ yếu khác nhau về base OS), chúng ta nên lựa chọn phù hợp với nhu cầu sử dụng. Mọi người có thể xem thêm ở [[50 til/51 Code/51.09 Docker/What is mean the tag suffix of an image on docker hub?|đây]]\n- Khi lựa chọn Image base từ OS thu gọn, cần để ý:\n\t- Phải có package manager và các gói có sẵn.\n\t- Xem OS đó sử dụng Shell gì.\n\t- Tránh các môi trường thử nghiệm, dễ gây rủi ro về mặt bảo mật hoặc tính ổn định.\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.09-Docker/Docker":{"title":"🐬 Docker","content":"\n## 🌿 I. Bối cảnh\n\n**![](https://lh6.googleusercontent.com/l1T2krPv068MLPC1J8jYFIDgQ47_VT1VmUcFofBWypN-Kb-EX6IBfULvpeD4TsBh40meAUN-7A6erjR-s48nkuQxA8xWOxAC4GiFLLWPoyLHEViSScy14ABVJP0VPY8sT1MMUFNDBp8yTOQWxEZcgS0erEK4qO9orhKcrRJEv_6KlyPbbjl-Pmca)**\n🌱 Trước đây mô hình máy chủ được tạo thành bởi ba yếu tố:\n* Máy chủ vật lý (Physical Server)\n- Hệ điều hành ([[50 til/51 Code/51.03 Operating System/Linux Basic|Operating System]])\n- Các ứng dụng (Application)\n\nMô hình trên có những nhược điểm:\n-   Một máy chủ chỉ cài được 1 OS\n-   Cho dù ổ cứng khủng, ram khủng thì cũng không thể tận dụng hết được\n\n🌱 Vì những nhược điểm đó, công nghệ ảo hóa **Virtualization** được ra đời, ưu điểm so với mô hình cũ là:\n-   Trên một máy chủ vật lý, có thể cài được nhiều hệ điều hành, tận dụng được tài nguyên tốt hơn do có thể phân chia tài nguyên cho từng máy ảo\n\nNhưng vẫn có những thứ chưa được tối ưu:\n-   Về tài nguyên:\n\t-   Khi thiết lập máy ảo chúng ta sẽ cần cấu hình để cung cấp tài nguyên từ ổ cứng và ram từ máy thật cho máy ảo. Những tài nguyên được phân ra sẽ là cố định. Dẫn đến việc, khi bật máy ảo, kể cả khi không làm gì thì máy thật cũng sẽ mất một lượng tài nguyên mà ban đầu chúng ta đã cung cấp.\n-   Về thời gian:\n\t-   Thời gian bật/tắt máy ảo khá lâu(mấy phút lận)\n\n🌱 Để khắc phục những nhược điểm còn tồn đọng đó, công nghệ **Containerization**, ưu điểm của công nghệ này đó là:\n\n![](https://lh4.googleusercontent.com/mUbQaVuvrz58iy4ySacviA8nGD1-MNeX6TzY3sSxY982frJtmsICy3JZplo52qHH4ffyiy01eKZpH9x0oE2nMgnkLT7l2iAHkSzoucvthQsozcYFAt1soJAmHPjftBXcQ8x5EGPJYzYV5GvZJ9LTZ1XfFTvNzMf8K6wBMei84RzAicKTG0fBsVLk)\n\n-   Thừa hưởng khả năng tạo được nhiều máy ảo trên cùng một máy chủ vật lý như **Virtualization** , nhưng tốt hơn ở chỗ những máy ảo này sẽ dùng chung phần nhân và cùng chia sẻ với nhau tài nguyên của máy mẹ. Máy ảo dùng bao nhiêu tài nguyên sẽ được cấp bấy nhiêu, chứ ko có tình trạng tài nguyên bị rảnh rỗi nữa, như vậy thì việc tận dụng tài nguyên sẽ tối ưu hơn.\n-   Đặc trưng của công nghệ này là sử dụng các **containers**.    \n\n![](https://lh6.googleusercontent.com/r4-OlfYsbR1dZ0M_NkB6e49MefZWZUR2RZK2kppihpj1PTkebxA_C-cT4SIRJuKiNuSBYxpWO46t_-U16KCSHJNiYD9P1Mdr1SEIomyw9fi5gEga5srvhymPoJoOpx_sOtR2KJsytnhTDk6fhS-3O-7yfFuRPy5Oh6Tsi48i-BYiU999MuwBsSZ7)\n\n\n🌱 Với công nghệ **Virtualization**, chúng ta có thể dùng các công cụ tiêu biểu như **Virtualbox** hay **VMware**, còn với **Containerization** đó chính **Docker**.\n\n![](https://lh3.googleusercontent.com/tc5QldwzU46Kx0zuTQZ8inuJax19jfTODrl5z6Wo8KnYXExUbuEA1hKcQ6Os6R_RWv9qU0knCYzlFdOspkgtuE7LRgqrKEYqwdSfXOh7dCw1l3-7RYuKg6BqN_X22_JcGxJNA2Z1NFmMwEqI8mjspbvD6X8XWj7S86edsc-s269_XqNFF--EIkHb)\n\n\n## 🌿 II. What Docker?\n\n- Là mã nguồn mở\n- Mục đích develop, deploy and run applications bằng những containers\n\nXem hướng dẫn cài Docker tại [đây](https://docs.docker.com/engine/installation/)\n\n## 🌿 III. Why Docker?\n\n- Build một lần dùng được nhiều lần và nhiều chỗ\n- Bật/tắt nhanh chóng\n\n## 🌿 IV. Những khái niệm phổ biến\n\n### 1. Container\n- Là một quá trình chạy trên **[[50 til/51 Code/51.03 Operating System/Linux Basic|Linux kernel]]**. \n\tĐược cấp phát tài nguyên riêng: CPU, bộ nhớ và hệ thống tập tin. Chính vì vậy, Docker độc lập với những tiến trình đang chạy của máy tính và không ảnh hưởng đến các containers/processes khác đang chạy.\n\n### 2. Image\nLà tệp chứa mọi thứ cần để thực thi: dependencies, binaries, source code, ... Xây dựng bằng cách thực thi các câu lệnh trong **Dockerfile**. Một **Image** có thể được sử dụng để tạo nhiều **containers** giống nhau. Mỗi **container** là một **instantiation** của **image**.\n\n### 3. Dockerfile\nLà một tệp chứa các câu lệnh cần thiết để xây dựng một **Image**.\n\n## 🌿 V. Một vài câu lệnh hay được sử dụng\n\n- **docker pull image_name**: pull một image từ Docker Hub.\n\n- **docker build**: build một container từ Dockerfile và một context(bao gồm các folders|files được đặt ở PATH/URL).\n\n- **docker run**: chạy container từ một image.\n\n- **docker ps**: list ra những containers đang chạy. **-a/--all** để lấy tất cả containers hoặc -q/--quite nếu chỉ muốn lấy cấc ids của containers.\n\n- **docker logs [container_id/container_name]**: xem logs của 1 container, **-f/--follow** để xem log output.\n\n- **docker volume ls**: list ra các volumes được dùng để lưu trữ data được sinh ra và sử dụng bởi các containers.\n\n- **docker rm [container_id/container_name]**: xóa 1 hoặc nhiều containers.\n\n- **docker rmi [image_id]**: xóa 1 hoặc nhiều images.\n\n- **docker stop**: dừng 1 hoặc nhiều containers.\n\n- **docker kill**: kill 1 hoặc nhiều containers.\n\n- **docker kill $(docker ps -q)**: kill tất cả containers đang chạy\n```cmd\n$(docker ps -q) #lấy ra id của các containers đang chạy.\n\n$(docker ps -a -q) #lấy id của toàn bộ các containers.\n```\n\n- **docker system prune**: Dọn toàn bộ resources(images, containers, volumes, networks) đang bị treo(không liên kết với bất kì container nào).\n\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.09-Docker/Docker-Compose":{"title":"🦑 Docker Compose","content":"\n**![](https://lh6.googleusercontent.com/xSCCWpZ4m29JV6UPl9zCuNj4pDxdGD9shUACJ1auetH158BOcrCYKdtuETCxhgwHVjVrR4BFAeSCXAlz3-QfkhJ9tQoipVV2Taq0O64Bu_TITkvRfVM9io8uUNuc3Mf0amW_Z_mbRVEWhivppaEnymHpucB7YKB08UqkzUzYxoEp8SfG0pysEEpq-g)**\n\n## 🌿 I. What?\n🌱 Chúng ta muốn ứng dụng [[50 til/51 Code/51.09 Docker/Docker]] cho:\n\t- Dự án mới\n\t- Dự án đang phát triển\n\n🌱 Chúng ta có thể dùng [[50 til/51 Code/51.09 Docker/Dockerfile]] cài chung tất cả vào một container duy nhất sau đó chạy project trên container đó.\n**![](https://lh4.googleusercontent.com/mS7LvI78YjVqb9jh1QY0K_KR_n_9jQJm_XLUhq-cVmKhgbj2KKqqA0xczpkSxfDPIf8Z85lI5J9-h1MDb2CLtR2Nod47XYNQFGtwwQ7qr0QqakS5hf9kGHoZ-05xQ46PG6vQI9z0RGCmfrTOe5HrezDmZkzdPnQY5yEMf28vQnubyKVXS0AcyTakDQ)**\n🌱 Tuy nhiên cách này không hợp lý cho việc mở rộng cũng như sử dụng lại cho nhiều projects.\n-\u003e docker-compose ra đời để kết nối những containers riêng lẻ với nhau.\n\u003e - Có thể hiểu docker là con cá voi đang vận chuyển nhiều containers đến cảng Project A.\n\u003e \n\u003e - Còn docker-compose sẽ là con bạch tuộc sử dụng các xúc tua của mình để lấy những containers cần thiết cho Project A.\n\nXem hướng dẫn cài docker-compose tại [đây](https://docs.docker.com/compose/install/)\n\n## 🌿 II. Xây dựng docker-compose\n\n### 1. Cấu trúc thư mục\n🌱 Mình sẽ chỉ làm một project demo nên cấu trúc đơn giản gồm:\n- [x] docker/entrypoint.sh\n- [x] Dockerfile\n- [x] docker-compose.yml\n\n🌱 Khi làm dự án thật, do phải build cho từng môi trường(development, staging, production) nên cấu trúc sẽ có khác hơn một chút, nhưng về cơ bản vẫn là vẫn có đủ thành phần cấu trúc như trên.\n\n### 2. Xác định những containers cần thiết\n🌱 Mình làm demo trên Rails app và những công nghệ mình thấy hay được sử dụng nhất là:\n- [x] Web\n\t- Ruby\n\t- Rails(là Ruby framework nên chỉ cần pull image của ruby thôi)\n- [x] Mysql (hoặc postgret)\n- [x] Redis (lưu cache, backgournd job)\n- [x] Sidekiq (chạy background job)\n\nok triển thôi!!\n\n## 🌿 3. Viết docker-compose\n1. **version**: những version sẽ có vài điểm khác nhau như:\n\t- về cấu trúc và các keys config\n\t- về Docker Engine version thấp nhất mà bạn cần đáp ứng\n\t- networking\nTại thời điểm viết bài này, trên trang chủ cập nhật version mới nhất là 3.8 hỗ trợ cho Docker Engine 19.03.0+\nChi tiết hơn về sự khác nhau của từng version hay các năng cấp từ 2.x lên 3.x thì mọi người có thể đọc thêm ở [đây](https://docs.docker.com/compose/compose-file/compose-versioning) nhé.\n2. **services**: những containers chúng ta định nghĩa sẽ nằm ở đây.\n3. những config trong từng container:\n\t- [x] **image**: chỉ định image được dùng để build container\n\t- [x] **build**: khi muốn build container bằng Dockerfile\n\t- [x] **container_name**: chỉ định tên tùy chỉnh của container nếu ko muốn dùng tên mặc định\n\t- [x] **restart**: mặc định là **no**, nếu set **always** container sẽ khởi động lại khi có lỗi\n\t- [x] **environment**: chỉ định biến mối trường, có thể chỉ định từng biến hoặc file chứa các biến môi trường\n\t- [x] **volumes**: chia sẻ dữ liệu từ máy ảo tới máy thật hoặc giữa nhiều containers với nhau\n\t\t- Ví dụ như container mysql, dữ liệu được tạo ra sẽ được lưu ở thư mục **var/lib/mysql**  trong container, nếu xóa container thì dữ liệu sẽ bị mất sạch.\n\t\t- Chính vì thế nên chúng ta dùng volumes để dữ liệu của container được mount ra ngoài host, nếu có xóa container thì dữ liệu vẫn còn, và khi khởi động lại, dữ liệu được mount ngược vào container và sử dụng bình thường.\n\t- [x] **ports**: Cấu hình cổng kết nối\n\t\t- có thể chỉ định cả 2 cổng **host:container** \n\t\t- vd 123:345 cổng 123 của máy thật sẽ trỏ đến cổng 345 của container\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.09-Docker/Docker-Network":{"title":"🐬 Docker Network","content":"\n## 🌿 What? \n\n🌱 Là mạng sử dụng cho các **containers** có thể kết nối và giao tiếp với nhau. Mỗi **container** có một vùng chứa riêng biệt nên cũng sẽ có mạng, port, IP riêng.\n\n🌱 **[[50 til/51 Code/51.09 Docker/Docker]]** cung cấp sẵn một số mạng mặc định cho các **container**, chúng ta có thể gom một nhóm **[[50 til/51 Code/51.09 Docker/Docker|container]]** vào một mạng chung. Điều này khá là tiện lợi trong trường hợp chúng ta muốn chỉ định một stack phù hợp cho dự án.\n\n## 🌿 What type of network?\n\n- 🌱 Bridge network\n\t- Mạng **Bridge** cho phép kết nối giữa các **container** cùng mạng và sử dụng một dải ip được cấp ngẫu nhiên hoặc tự thiết lập.\n\t- Mạng Bridge đáp ứng hầu hết các usecase nếu triển khai các container trên cùng một host. Nhưng nếu chạy một môi trường đa host, **Bridge** sẽ không làm được điều này, đây sẽ là nhược điểm của mạng **Bridge**.\n\t- Driver của mạng **Bridge** là **bridge**.\n\n- 🌱 Host network\n\t- **Host network** cho phép mạng **container** kết nối với **host**. Và sử dụng IP có cùng dải mạng với **host**.\n\t- Driver của mạng **Host** là **host**.\n\n- 🌱  None network\n\t-   Tắt tất cả kết nối mạng.\n\t-   Driver của mạng **None** là **null**.\n\n- 🌱  Overlay network\n\t-   Nhược điểm của mạng **Bridge** được **Overlay network** và **Macvlan** khắc phục.\n\t-   **Overlay network** thực hiện kết nối nhiều **Docker daemon** với nhau để tạo một mạng ảo trên các máy chủ. Nơi có thể thiết lập kêt nối giữa **swarm service** và **container** độc lặp hoặc hai **container** trên các host khác nhau.\n\t-   Driver của mạng **Overlay** là **overlay**.\n\n- 🌱  Macvlan netwrok\n\t-  **Macvlan network** cho phép bạn gán địa chỉ MAC cho một **container**, biến **container** như một thiết bị vật lý trên mạng.\n\t-   Driver của mạng **Macvlan** là **macvlan**.\n\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.09-Docker/Dockerfile":{"title":"🐬 Dockerfile","content":"\n\n## 🌿 I. Config\n\n- **FROM**: chỉ định image gốc. [[50 til/51 Code/51.09 Docker/Docker]] Hub nơi lưu trữ và chia sẻ các images. Chúng ta có thể lấy các image gốc trên này và về xào nấu lại để phù hợp với nhu cầu sử dụng của mình.\n\n- **MAINTAINER**: optional để đặt tên cho tác giả viết Dockerfile\n\n- **RUN**: thực thi 1 câu lệnh trong quá trình build image.\n\n- **CMD**: thực thi 1 câu lệnh trong quá trình bật [[50 til/51 Code/51.09 Docker/Docker|container]].\n\n\t- Mỗi **Dockerfile** chỉ chạy một câu lệnh CMD, nếu có nhiều hơn sẽ chỉ chạy câu lệnh **CMD** cuối cùng.\n\t\n\t- Nếu muốn khởi động nhiều ứng dụng khi start container, hay sử dụng **ENTRYPOINT**.\n\n- **ENTRYPOINT**: thực thi một số câu lệnh trong quá trình bật container, những câu lệnh này sẽ được viết trong file script có đuôi .sh.\n\n- **EXPOSE**: chỉ định cổng mà container sẽ nghe khi chạy.\n\n- **ADD**: Copy file, thư mục, hoặc remote file thêm chúng vào filesystem của image.\n\n- **COPY**: Copy file, thư mục từ host machine vào image. Có thể sử dụng url cho tập tin cần copy(chưa dùng baoh =))).\n\n- **WORKDIR**: chỉ định directory cho câu lệnh CMD\n\n- **VOLUME**: mount thư mục từ máy host vào container.\n\n\nMình sẽ build những gì học được về docker ở repo này : [app-demo-rails-docker]( https://github.com/anhnh-3008/app-demo-rails-docker), mọi người có thể theo dõi các steps theo pulls cho tiện nhé. \n\nPull mình build Dockerfile: [pull build Dockerfile](https://github.com/anhnh-3008/app-demo-rails-docker/pull/1)\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/51-Code/51.09-Docker/What-is-mean-the-tag-suffix-of-an-image-on-docker-hub":{"title":"🥦 What is mean the tag suffix of an image on docker hub?","content":"\n### 🌿 Vấn đề\n- Khi chạy apt-get update , gặp lỗi KEYEXPIRED như dưới đây.\n\n```sh\nStep 3/15 : RUN apt-get update -qq \u0026\u0026 apt-get install -y build-essential libpq-dev nodejs vim cron\n ---\u003e Running in 8437242de6eb\nW: GPG error: http://deb.debian.org jessie-updates InRelease: The following signatures were invalid: KEYEXPIRED 1668891673\nW: GPG error: http://deb.debian.org jessie Release: The following signatures were invalid: KEYEXPIRED 1668891673\n```\n\n### 🌿 Nguyên nhân\n- Lỗi trên được xác định là do Dockerfile đang base theo Image `ruby:2.4.2` , sử dụng `debian:jessie` , đã hết hạn LTS.\n\n\u003e [!info] LTS (Long Term Time)\n\u003e \n\u003e 🌱 [LTS (Long Term Support)]([https://wiki.debian.org/LTS](https://wiki.debian.org/LTS)) là một dự án hỗ trợ(cập nhật repo, vá lỗi, ...) các versions Debian ổn định đã được release trong vòng ít nhất là 5 năm. LTS không phải do Team Security Debian phát triển mà do một bộ phận những lập trình viên + công ty \"tình nguyện\" triển khai.\n\n### 🌿 Giải pháp\nCó 2 cách\n1. 🌱 Sửa file `/etc/apt/sources.list`, replace repo `jessie-updates` bằng tay. Xem chi tiết hơn ở [đây](https://github.com/docker-library/ruby/issues/394).\n\n 2. 🌱 Đổi Image `ruby:2.4.2 -\u003e ruby:2.4.2-stretch`\n\t- Khi sử dụng Image, mọi người nên để ý phần tag xem nó đang được base theo version OS nào(nhất là các dự án thâm niên). Một số suffix thường gặp:\n\t\t- [-jessie](https://wiki.debian.org/DebianJessie) - Mã phát triển của Debian 8. Có LTS từ ngày 26/04/2015, hết hạn 30/06/2020.\n\t\t-  [-stretch](https://wiki.debian.org/DebianStretch) - Mã phát triển của Debian 9. Team Security Debian ngừng update bảo mật từ 06/07/2020 và đổi qua LTS -\u003e đến khoảng 2025 là hết hạn LTS.\n\t\t-  [-buster](https://wiki.debian.org/DebianBuster) - Mã phát triển của Debian 10, released từ ngày 06/07/2019. Vẫn được Team Security Debian support.\n\t\t-  [-bullseyes](https://wiki.debian.org/DebianBullseye) - Mã phát triển của Debian 11, released từ ngày 14/08/2021. Vẫn được Team Security Debian support.\n\t\t- [-slim](https://github.com/docker-slim/docker-slim) - Tối ưu containers tốt hơn, nhỏ hơn, bảo mật hơn. Cân nhắc khi dùng, vì đây là phiên bản rút gọn, sẽ không đầy đủ bằng bản offical.\n\t\t- [-alpine](https://alpinelinux.org/) - Image được base theo Alpine Linux, đây là một OS thiết kế đặc biệt để chạy trong container. Có size rất bé, vài Mb(\u003c slim). Highly recommended nếu bộ nhớ là tiêu chí ưu tiên. Xem thêm ở [đây](https://stschindler.medium.com/the-problem-with-docker-and-alpines-package-pinning-18346593e891).\n\n### 🌿 Tham khảo\n- Mọi người có thể đọc thêm những thông tin khác(bash, package management, ...) của các versions tag ở đây:\n\t- [https://stackoverflow.com/questions/52083380/in-docker-image-names-what-is-the-difference-between-alpine-jessie-stretch-an](https://stackoverflow.com/questions/52083380/in-docker-image-names-what-is-the-difference-between-alpine-jessie-stretch-an)","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/52-Journey/C%C3%A1c-th%C3%B3i-quen-gi%C3%A0u-c%C3%B3":{"title":"🥦 Các thói quen giàu có","content":"\n## 🌿 What?\n- 🌱 [Thói quen](https://vi.wikipedia.org/wiki/Th%C3%B3i_quen) là một chuỗi phản xạ có điều kiện do rèn luyện mà có. Chuỗi phản xạ này là những hành vi định hình trong cuộc sống và được coi là bản chất thứ hai của con người. \n- 🌱 Xây dựng và kỷ luật bản thân với những thói quen tốt sẽ cải thiện rất nhiều đến chất lượng cuộc sống cũng như xác suất thành công của bản thân.\n\n\u003e [!info] Thói quen tốt\n\u003e \n\u003e Thói quen tốt mang lại cho bản thân sự thịnh vượng cả về sức khỏe, các mối quan hệ, nghề nghiệp, tài chính, và nhiều khía cạch khác trong cuộc sống.\n\n- 🌱 Post này mình sẽ update những thói quen mình đã và đang áp dung với bản thân 💪 để lưu lại bản chất thứ hai của con người mà mình muốn hướng tới ✨ Let's gooooo!!!\n\n### 1. Tập thể dục ít nhất 30p mỗi ngày\n\n![[00 Meta/01 Attachments/Pasted image 20221210173912.png]]\n\n\u003e [!info] Sức khỏe\n\u003e \n\u003e Nằm ở tầng thấp nhất trong [tháp tài sản](https://www.dnse.com.vn/hoc/thap-tai-san-la-gi). Củng cố vững chắc nền móng, về lâu về dài tòa tháp của chúng ta mới có thể xây thật cao và kiên cố.\n\n### 2. Tiết kiệm ít nhất 10% thu nhập hàng tháng\n\n![[00 Meta/01 Attachments/Pasted image 20221210162937.png]]\n\n\u003e [!Info] Tiết kiệm\n\u003e \n\u003e Hãy luôn trả lương cho mình đầu tiên!\n\n- 🌱 Mọi người thường chi tiêu sinh hoạt trước, sau đó còn dư bao nhiêu sẽ tiết kiệm. Vấn đề là ít khi có \"dư\" lắm 😄\n\n### 3. Kiểm soát cảm xúc\n\n![[00 Meta/01 Attachments/Pasted image 20221210170148.png]]\n\n\u003e [!info] Cảm xúc\n\u003e \n\u003e Cảm xúc ảnh hưởng rất nhiều đến những quyết định và hành vi.\n\n### 4. Rèn luyện kỹ năng đọc mỗi ngày\n\n![[00 Meta/01 Attachments/Pasted image 20221211155042.png]]\n\n\u003e [!info] Đọc sách\n\u003e \n\u003e Ai cũng biết đọc sách quan trọng nhưng quan trọng là ko phải ai cũng cố gắng đọc sách (mình đấy 🤣). \n\n\n### 5. Rèn luyện kỹ năng viết mỗi ngày\n\n![[00 Meta/01 Attachments/Pasted image 20221211160225.png]]\n\n\u003e [!info] TIL - Today I Learn\n\u003e \n\u003e Não bộ là nơi suy nghĩ và đưa ra quyết định, không phải là nơi lưu trữ những kiến thức. Việc viết TIL để đảm nhiệm công việc này là vô cùng cần thiết. Khi viết mình có thể hệ thống kiến thức lại một cách rõ ràng, dễ hiểu với bản thân hơn.  \n\n\n### 6. Updating\n\n## 🌿 Refer \n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/52-Journey/C%C3%A1ch-ph%C3%A2n-bi%E1%BB%87t-r%C6%B0%E1%BB%A3u-gi%E1%BA%A3":{"title":"🥦 Cách phân biệt rượu giả(kém chất lượng)","content":"\n## 🌿 What?\n\n- 🌱 Theo TS. Nguyễn Duy Thịnh - Viện Công nghệ sinh học và Công nghệ thực phẩm, Đại học Bách khoa Hà Nội, rượu giả không được kiểm soát trên thị trường Việt Nam đa phần là loại rượu có pha chế `**methanol - một loại cồn công nghiệp**`.  \n- 🌱 Cách phân biệt:  \n\t- Đổ 1 ít rượu ra lòng bàn tay rồi xoa xoa hai bàn tay vào nhau. Nếu hai bàn tay còn dính dính thì là rượu không tốt vì `**andehit dầu Fugien**`  còn đọng lại trong rượu. Rượu tốt sẽ  bay hơi hết khi có tác động của ma sát (cách này hợp lý, dễ áp dụng, để tết em thử).\n\t- Ngửi - nếu mùi cồn thơm cay nồng thì là rượu tốt (cách này hơi khó áp dụng).\n\t- Nếm - rượu chứa `**methanol**` vị sẽ hơi ngọt (cái này cũng khó).\n\t- Thử với lửa - nếu mẫu đốt lên lửa màu vàng thì là rượu chưa `**methanol**` .\n\t- Dùng giấy quỳ đỏ - nhúng giấy vào rượu 2-3 phút nếu giấy đổi màu xanh nước biển -\u003e bỏ ngay không chơi.\n\n## 🌿 Refer\n- Nguồn: VTV24\n\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/52-Journey/Kh%C3%A1m-ph%C3%A1-V%C4%83n-h%C3%B3a-Ngh%E1%BB%87-thu%E1%BA%ADt":{"title":"🥦 Khám phá Văn hóa \u0026 Nghệ thuật","content":"\n## 🌿 What?\n- 🌱 https://artsandculture.google.com/\n- 🌱 Một trang web rất thú vị cho những ai có hứng thú tới Văn hóa \u0026 Nghệ thuật. Google Arts \u0026 Culture là một sáng kiến phi thương mại. GG đã kết nối với rất nhiều tổ chức văn hóa và các nghệ sĩ trên toàn thế giới để có được tài nguyên phong phú cho chủ đề này.\n\n\u003e [!info] Thông điệp\n\u003e \n\u003e Sứ mệnh của chúng ta, đó là bảo tồn và đưa những giá trị văn hóa\u0026nghệ thuật Thế Giới lên Internet để có thể tiếp cận đến bất kỳ ai, ở bất cứ đâu. \n\u003e \n\n- 🌱 Mình lưu cái này zô, khi nào đi du lịch ở đâu thì lên đây tìm hiểu trước, khè mọi người trong đoàn cho zui :v\n- 🌱 Mọi người có thể xem thử [Dấu ấn của một vương triều](https://artsandculture.google.com/story/WQLy5ELTLuXLLQ?hl=vi) nao mà có dịp đi Huế thì đỡ bỡ ngỡ 😆\nObsidian\n\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/53-Psychology/Prisoners-Dilemma":{"title":"🥦 Prisoner’s Dilemma","content":"\n## 🌿 What?\n\n![[00 Meta/01 Attachments/Pasted image 20230203171527.png]]\n\n- 🌱 Prisoner’s Dilemma - Thế lưỡng nan của tù nhân là một thuyết trò chơi(game theory) dùng để nghiên cứu hành vi hợp tác của con người.\n- 🌱 Luật chơi đơn giản như sau: Có 2 người A và B cùng bị bắt vì tình nghi là băng cướp ngân hàng(do cảnh sát phát hiện 2 người họ có súng). Có 3 TH có thể xảy ra:\n\t1. Nếu cả 2 cùng thú tội thì mỗi người sẽ ngồi tù 5 năm.\n\t2. Nếu cả 2 cùng im lặng thì mỗi người sẽ chỉ ngồi tù 1 năm do tàng trữ vũ khí trái phép.\n\t3. Nếu B khai báo và A im lặng thì B sẽ được thả còn A sẽ ngồi tù 20 năm và ngược lại.\n- 🌱 Đứng từ góc nhìn của A, nếu A im lặng thì ít nhất sẽ ngồi tù 1 năm, có thể là 20 năm nếu B khai báo. Còn khi A khai báo có thể sẽ được thả hoặc nhiều nhất chỉ phải ngồi tù 5 năm. -\u003e Vậy chọn khai báo vẫn là có lợi hơn đúng không?\n- 🌱 Có thể thấy trong trò chơi này, nếu là A, bất kể B có chọn phương án nào, việc chọn **khai báo** sẽ mang lại kết quả **có vẻ tốt hơn** cho bản thân. Và đương nhiên B cũng sẽ nghĩ như vậy -\u003e Với sự lựa chọn ích kỉ, cuối cùng thì mỗi người nhận 5 năm tù và đây không phải là kết quả **tốt nhất** mà cả 2 bên có thể đạt được.\n\n\u003e [!note] Note\n\u003e \n\u003e Trong một nhóm, hợp tác sẽ mang lại lợi ích tổng thể tốt nhất cho tất cả. Tuy nhiên nó chỉ có thể tồn tại dựa trên sự tin tưởng và cùng hướng về lợi ích chung.\n\u003e \n\n- 🌱 Thuyết trò chơi này được dùng để nghiên cứu những quyết định liên quan đến lợi ích của những cá nhân hoặc tổ chức với nhau. Được áp dụng cho nhiều lĩnh vực như kinh tế, khoa học chính trị, tâm lý, ...\n- 🌱 Ví dụ như thực tế trong lĩnh vực kinh doanh, thuyết sẽ được sử dụng để phân tích khả năng cạnh tranh thị trường, chiến lượng định giá sản phẩm hoặc hành vi của những doanh nghiệp có thị trường độc quyền. \n- 🌱 Năm 1980, Robert Axerold, một giáo sư chính trị trường đại học Michigan mời 14 nhà toán học và kinh tế học để chơi Prisoner’s Dilemma, mục đích để tìm ra chiến lược tốt nhất.  Kết quả là chiến thuật đơn giản của giáo sư Anatol Rapoport từ Đại học Toronto, Canada, đã dành được số điểm cao nhất. Chiến thuật tên là **ăn miếng trả miếng(Tit For Tat)**, bao gồm 2 nguyên tắc:\n\t1. Lượt đầu chọn hợp tác.\n\t2. Từ lượt sau chọn giống như đối thủ đã chọn ở lượt trước.\n\n\u003e [!note]  Kết luận rút ra từ chiến thuật trên\n\u003e \n\u003e - Luôn hợp tác đầu tiên.\n\u003e - Tự vệ nhưng biết tha thứ(phản công khi đối thủ không hợp tác, hợp tác khi đối thủ hợp tác lại)\n\u003e - Luôn duy trì hợp tác(không đố kị hay để lợi ích cá nhân tác động).\n\u003e - Luôn phải nhớ, đối tác(đối thủ) cũng nắm được luật chơi.\n\n- 🌱 Ngoài ra mọi người có thể chơi thử game [The evolution of Trust](https://github.com/ncase/trust) để có cái nhìn trực quan hơn về vấn đề này nhé.\n\n## 🌿 Refer \n- https://vi.wikipedia.org/wiki/Song_%C4%91%E1%BB%81_t%C3%B9_nh%C3%A2n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/53-Psychology/S%E1%BB%B1-ng%E1%BB%A5y-bi%E1%BB%87n-c%E1%BB%A7a-tay-thi%E1%BB%87n-x%E1%BA%A1-Texas":{"title":"🧠 Sự ngụy biện của tay thiện xạ Texas","content":"\n### 🌿 What?\nMột gã cao bồi bắn bừa lên trên một bức tường, sau đó anh ta vẽ một vòng tròn bao quanh chỗ có nhiều lỗ đạn nhất và tự nhận mình là thiện xạ.\n\n![[00 Meta/01 Attachments/Pasted image 20221026172307.png]]\n\nĐây là cơ chế tâm lý phổ biến ở con người. Chúng ta thường sẽ có xu hướng bỏ qua sự ngẫu nhiên khi kết quả có vẻ có ý nghĩa. \n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/50-til/54-Mindset/L%C3%B9i-l%E1%BA%A1i-m%E1%BB%99t-b%C6%B0%E1%BB%9Bc":{"title":"🥦 Lùi lại một bước ...","content":"\n## 🌿 What?\n\n\u003e [!question] Question\n\u003e \n\u003e Theo bạn, khi nào là thời điểm tốt nhất để bắt đầu một ngày mới?\n\u003e \n\n- Theo mình, thời điểm bắt đầu tốt nhất chính là ngay từ tối hôm trước, khi chúng ta chủ động chuẩn bị cho mình một giấc ngủ đủ và chất lượng thì tự khắc ngày hôm sau sẽ rất là chè tươi ✨\n- Khi đi làm mình cũng có gặp nhiều hoạt động ảnh hưởng bởi tư tưởng này, đơn cử như 5Whys meeting khi một dự án có incident. Mục tiêu của buổi họp là tìm ra lý do gốc rễ gây ra incident. Để làm được điều đó, tất cả các thành viên cần đưa ra các câu hỏi - câu trả lời để dẫn từ ngọn(incident) đến lý do gốc. \n\n```\n                    incident\n                   /        \\\n            lý do 1(issue)  lý do 2(issue)\n                   |          |\n            lý do 3(issue)  lý do 4(root)\n              .....................\n```\n\n- Áp dụng tư duy này vào các vấn đề trong cuộc sống, mình cần suy nghĩ lùi lại một hoặc nhiều bước trước khi đánh giá mọi việc. Tư duy này giúp chúng ta xác định rõ những vấn đề cũng như các bước cần chuẩn bị để đạt được kết quả tốt. \n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/C%C3%A1c-n%E1%BB%81n-kinh-t%E1%BA%BF-v%E1%BA%ADn-h%C3%A0nh":{"title":"🥦 Các nền kinh tế vận hành","content":"\n## 🌿 Chương I - Bàn tay vô hình\n- **Tư bản là những công cụ tạo ra tài sản**\n\t- vd như thóc giống, tàu thuỷ, như grab thì là xe máy, ô tô, ...\n\t- hay tư bản còn là dòng tiền chúng ta sử dụng để trả phí mua tàu, xe máy, hay thuê đất, thuê lao động -\u003e chi tiền vào tư bản gọi là **đầu tư**\n- Nhà tư bản là những người kiếm lợi nhuận từ đầu tư.\n\n- **Bản chất thị trường sẽ tự điều chỉnh, tìm ra những món hàng với giá cả phù hợp nhất**.\n\t- Bán giá cao -\u003e người khác nhảy vào bán cạnh tranh.\n\t- Đồ không chất lượng so với giá -\u003e không ai mua -\u003e bị đào thải khỏi thị trường.\n\t- Bản chất này tồn tại vì nó là **thị trường tự do, mọi người được tự quyết định(mua cái gì, kinh doanh cái gì, ...)**\n\n\u003e [!note] Note\n\u003e \n\u003e Tóm lại là cứ để thị trường từ vận hành, nó sẽ tự điều chỉnh để đạt được trạng thái cân bằng nhất.\n\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/Nguy%C3%AAn-t%E1%BA%AFc-c%C6%A1-b%E1%BA%A3n-ti%E1%BA%BFp-c%E1%BA%ADn-b%C3%A1o-c%C3%A1o-t%C3%A0i-ch%C3%ADnh":{"title":"🥦 Nguyên tắc cơ bản để tiếp cận báo cáo tài chính","content":"\n## 🌿 What?\n\n- Như một bức tranh để thể hiện tài chính, kinh tế, dòng tiền của một doanh nghiệp tại một thời điểm.\n- Khác với báo cáo thường niên, báo cáo thường niên sẽ bao gồm báo cáo tài chính.\n- Một báo cáo tài chính bao gồm:\n\t- Cân đối kế toán(Balance Sheet): phản ánh toàn bộ *tài sản* hiện có của doanh nghiệp và *nguồn vốn* hình thành lên những tài sản đó.\n\t- Báo cáo kết quả hoạt động kinh doanh(Income Statement): báo cáo về *doanh thu* và *chi phí* trong từng thời kỳ nhất định.\n\t- Báo cáo lưu chuyển tiền tệ(Cash Flow Statement): báo cáo phản ánh việc *thu - chi* tiền tệ, ứng với các mục *kinh doanh, đầu tư và tài chính*.\n\t- Thuyết minh báo cáo tài chính(yêu cầu về BCTC ở VN): báo cáo giải thích chi tiết hơn về tình hình kinh doanh và tài chính của doanh nghiệp mà các báo cáo nêu trên chưa thể hiện rõ.\n\n## 🌿 Phục vụ đối tượng nào?\n- Ngân hàng - họ sẽ đọc báo cáo tài chính để quyết định xem nên cho doanh nghiệp vay bao nhiêu, với lãi suất thế nào là hợp lý.\n- Các nhà đầu tư, các nhà phân tích kinh tế - xem khả năng kinh doanh của công ty đó, quyết định xem có nên đầu tư hay không.\n- Cơ quan quản lý - kiểm tra xem cty có đang báo cáo chính xác hay không, có đóng thuế đúng hay chưa, ...\n\n## 🌿 Có đáng tin không?\n- Nói chung là cũng không nên tin 100%, tuy nhiên đây vẫn là bức tranh gần đúng nhất với tình hình tài chính của doanh nghiệp, chúng ta vẫn có thể dựa vào để phân tích nhưng đừng quá bias.\n\n## 🌿 Nguyên tắc cơ bản khi đọc báo cáo tài chính\n\n### 🌱 Nguyên tắc giá gốc\n- Chưa hiểu lắm, xem lại. \n\n### 🌱 Thiếu thông tin định tính\n- Hiểu BCTC chỉ là một phần vì nó chỉ báo cáo về những thông tin định lượng, cần phải quan tâm tới những thông tin định tính khác của doanh nghiệp như:\n\t- Ảnh hưởng của nền kinh tế lên doanh nghiệp (vĩ mô)\n\t- Triển vọng ngành trong tương lai.\n\t- Khả năng cạnh tranh với đối thủ cùng ngành.\n\t- Chất lượng lãnh đạo và nhân viên.\n\t- Đổi mới và ứng dụng công nghệ.\n\n### 🌱 Không có cách đọc BCTC cụ thể\n- Với từng đối tượng đọc BCTC sẽ có những tiếp cận khác nhau.\n- Nhưng nhìn chung khi đọc sẽ vẫn có 2 nguyên tác:\n\t- Nhìn xu hướng phát triển của một doanh nghiệp trong nhiều năm.\n\t- So sánh doanh nghiệp với những doanh nghiệp khác trong ngành.\n\n\n\n## 🌿 Refer \n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/Synthetic-some-questions-interview-mid-level-web-backend":{"title":"🥦 Synthetic some questions interview mid-level web backend","content":"\n## 🌿 About Ruby\n\n### 🌱 Question \u0026 Answer\n\n\n### 🌱 Resources\n\n\n## 🌿 About Rails\n\n### ❓Question \u0026  🌱 Answer\n\n1. ❓ Can you explain how Rails uses ActiveRecord to interact with the database and how you would handle database relationships in a Rails application?\n\t- Rails sử dụng ActiveRecord như là một thư viện ORM để giao tiếp với database. ActiveRecord ánh xạ các bảng trong DB tới các classes trong Ruby, mỗi hàng trong một bảng là instance của class. Hỗ trợ lập trình viên có thể làm việc với DB thông qua `object-oriented interface` thay vì phải viết các câu SQL queries.\n\t- ActiveRecord cung cấp một số methods để giao tiếp với DB như là `find`, `where`, `create`, `update`, ... ánh xạ tới những câu lệnh SQL tương ứng. Ngoài ra AR còn cung cấp cách để xác định các mối quan hệ giữa các bảng(1-1, 1-n, n-n).\n\t- Để xác định mối quan hệ giữa các bảng, AR cùng cấp một số nhưng method sau:\n\t\t- `has_many`\n\t\t- `belongs_to`\n\t\t- `has_one`\n\t\t- `has_and_belongs_to_many`\n\t- AR cho phép chỉ định `foreign key`.\n\t- AR cho phép chỉ định những `association options` như là `dependent`, `autosave` và `inverse_of` để kiểm soát hành vi của các mối quan hệ.\n\t- Khi đã xác định mối quan hệ giữa các bảng, có thể dễ dàng truy xuất các records liên quan, vd như một user có nhiều posts: `@user.posts`.\n\t- Tuy nhiên AR cũng có những hạn chế. Ví dụ như chúng ta cần thực hiện những câu queries phức tạp hoặc số lượng dữ liệu lớn, lúc này sử dụng rawSQL sẽ hiệu quả hơn. Thêm nữa, khi làm dự án, có thể những quy ước của AR không phù hợp với spec của dự án, chúng ta sẽ phải override.\n\t- Trong TH cần viết raw SQL, AR cung cấp một số cách để build, vsi dụ như `find_by_sql`, `execute`, `select_all` và Arel(ActiveRecord Relation).\n\t- Tóm lại, AR là một công cụ mạnh mẽ và tiện lợi trong việc tương tác với DB trong một dự án Rails, nhưng quan trọng chúng ta cần hiểu những quy ước, giới hạn và các phương pháp thay thế hiệu quả để sử dụng.\n\n### 📁 Resources\n\n1. https://guides.rubyonrails.org/active_record_basics.html\n\n## 🌿 About Database\n\n\n## 🌿 About Optimize\n\n\n## 🌿 About Infrastructure\n\n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null},"/What-happens-when-add-acts_as-into-model":{"title":"🥦 What happens when add acts_as into model?","content":"\n\u003e [!question] Q?\n\u003e \n\u003e Khi dùng gem paranoia để xóa mềm, chúng ta phải thêm acts_as_paranoid vào model. Vậy acts_as_paranoid tác động gì đến model của chúng ta?  \n\n## 🌿 What?\n\n- 🌱 Trong Rails, `acts_as_xyz` sẽ bổ sung thêm những methods(thường sẽ là method class) cho model chứa nó thông qua các modules và mixins, ví dụ như sắp xếp thứ tự của list, filter theo điều kiện nào đó, ...\n- 🌱 Các acts_as gems sẽ cần chỉ định trước các cột trong bảng, ví dụ như gem `paranoia` mặc định là cột `deleted_at`.\n- \n\n## 🌿 Refer \n","lastmodified":"2023-05-11T14:57:36.709913443Z","tags":null}}