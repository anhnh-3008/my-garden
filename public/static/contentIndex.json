{"40123345-posts/42-Code/42.01-Ruby/Display-Hardcode-Value":{"title":"🌱 Display Hardcode Value","links":[],"tags":["ruby","rails"],"content":"\nTrong quá trình phát triển các dự án Ruby on Rails, mình thấy gem config rất hay được sử dụng để lưu các giá trị hardcode.\nVấn đề mình gặp đó là mỗi lần muốn xem giá trị từ một key ví dụ như Settings.status.unprocessable_entity là mình phải mở cái file settings.yml lên dò dò trong đấy rất mất thời gian. Nên mình có viết một extension trên VsCode, khi mình hover vào đoạn text có cú pháp của gem config, VsCode sẽ hiển thị 1 popup chứa giá trị hardcode trong file setting.\n\nNếu thấy có ích, bạn có thể download trên VsCode với ID là anhnh-3008.display-hardcode-value nha.\nVersion require của VsCode là &gt;= 1.72.0"},"40123345-posts/42-Code/42.01-Ruby/RubyCritic":{"title":"🌱 RubyCritic","links":[],"tags":["ruby"],"content":"\n🌱 RubyCritic cung cấp báo cáo trực quan về những vấn đề như code thối, cấu trúc code, tính dễ kiểm tra, và độ phủ của test case cho app Ruby.\n🌱 Đang liên tục phát triển và release tính năng mới. Có trong danh sách Ruby Awesome.\n🌱 Bài viết này sẽ giới thiệu về một số những lợi ích mà RubyCritic đem lại, các dependencies của nó và cách để đọc code reports.\n🌿Why? §\n🌱 Bạn có thể xem xét sử dụng RubyCritic nếu muốn có một nơi có thể theo dõi sự phát triển của code trong dự án. Áp dụng RubyCritic vào process dự án chắc chắn sẽ giảm được thời gian của team dev cho việc khắc phục Technical debts. Hầu hết các technical debts đều sẽ được phát hiện sớm và ‘trả nợ’ trong giai đoạn phát triển luôn.\n\ntechnical debts là gì?\n…\n…\n…\n\n🌱 Một số những lợi ích của RubyCritic khi chúng ta áp dụng cho dự án hay process phát triển:\n\nThống nhất thông tin về một nơi duy nhất.\nBáo cáo trực quan\nCài đặt dễ dàng\nKhông config\nCho phép tùy chỉnh theo nhu cầu sử dụng\nCó thể mở rộng - Là open-source chúng ta có thể tích hợp thêm tính năng của mình.\nMột trình tạo huy hiệu.\n\nĐể hiểu hơn về cách RubyCritic hoạt động, hãy xem những internal dependencies được sử dụng để tạo một report mặt mũi như thế nào nhé!\n🌿 Internal dependencies trong Rubycritic §\n\nKhi bạn thêm RubyCritic, một số dependencies cũng được thêm kèm.\nĐiểm qua những dependencies chủ chốt: The Reek, Flay, và Flog. Đây đều là những gem cho phép RubyCritic hiển thị những thông tin hữu ích liên quan đến những code của bạn. Hiểu được cách hoạt động của bọn này sẽ thuận tiện hơn trong việc sử dụng RubyCritic.\n\n🌱 Reek: Tìm code Ruby bốc mùi 💩 §\n\nReek là một gem dùng để tìm những dòng code 💩 trong Ruby. Code thối không phải là code sai, nó là những dòng code có thể được viết dễ đọc hơn, dễ bảo trì hoặc phát triển hơn nhưng vẫn đúng logic với ban đầu.\nReek sẽ phân tích xem có chỗ nào bốc mùi nhưng sẽ không gợi ý là sửa như thế nào vì hầu như code ‘có mùi’ đều liên quan đến business logic hoặc dựa theo kinh nghiệm của lập trình viên đối với một ngôn ngữ lập trình.\n\n\nReek chỉ đánh giá được theo hướng chủ quan, nên chúng ta cũng nên cân nhắc thêm dựa theo logic của dự án cũng như kinh nghiệm của bản thân trước khi quyết định sửa code.\n\n\n\nReek cung cấp  extensive list of smells. Kiểm tra và chỉ ra những chỗ bốc mùi trong:\n\nClasses\nAttributes\nMethods\nParameters\nModuldes\nIterators\nThe implementation of polymorphism\n\n\n\nNhờ đó chúng ta sẽ chủ động trong việc làm cho code dễ đọc và dễ bảo trì hơn.\n\n\nCho phép config để:\n\nTắt kiểm tra những rule ko phù hợp với dự án.\nChỉ định các thư mục không cần kiểm tra.\nSử dụng filter để tắt tiếng cảnh báo.\n\n\n\n🌱 Flay: Kiểm tra code lặp §\n\n\nFlay xác định những điểm tương đồng trong cấu trúc code, bao gồm:\n\nTìm ra code bị lặp lại trong dự án.\nCho điểm để đánh giá mức độ tốt của code(điểm càng thấp, code càng ngon).\nChecking the difference at any code level.\n\n\n\nNếu Flay báo cáo có sự trùng lặp trong code, khả năng cao chúng ta nên sửa nó. Đừng  bỏ qua vì nó rất có khả năng dẫn đến bugs. Khi bạn fix thêm gì đó ở một chỗ nhưng quên sửa những chỗ còn lại thì có khả năng bug sẽ xuất hiện đó.\n\n\n# lib/flay.rb:80\nopts.on(&quot;-m&quot;, &quot;--mass MASS&quot;, Integer, &quot;Sets mass threshold (default = #{options[:mass]})&quot;) do |m|\n  options[:mass] = m.to_i\nend\n \n# lib/flay.rb:105\nopts.on(&quot;-t&quot;, &quot;--timeout TIME&quot;, Integer, &quot;Set the timeout. (default = #{options[:timeout]})&quot;) do |t|\n  options[:timeout] = t.to_i\nend\nKiểm tra:\n$ flay lib/flay.rb\nTotal score (lower is better) = 36\n \n1) Similar code found in :iter (mass = 36)\n  lib/flay.rb:80\n  lib/flay.rb:105\nMặc dù nội dung bên trong không giống nhau hoàn toàn nhưng cấu trúc code có thể được cấu trúc lại để tránh trùng lặp. Đó là magic của Flay.\n\nFlay đánh giá trùng lặp dựa trên cấu trúc code, nếu điểm trùng lặp càng thấp có nghĩa code chúng ta càng ngon(dry). Tuy nhiên, chúng ta vẫn cần đánh giá thêm cả về logic của dự án trước khi sửa nhé.\n\n🌱 Flog: Kiểm tra độ phức tạp trong code §\nFlog kiểm tra xem độ phức tạp của code(code khó đọc). Flog gán điểm phức tạp cho từng dòng sau đó tính tổng cho mỗi method hoặc class.\ndef validate_expiration\n  return if exp_month.blank? || exp_year.blank?\n \n  ...\nend\nKiểm tra:\n$ flog app/models/credit_card.rb\n \n5.2: CreditCard#validate_expiration   app/models/credit_card.rb:12-15\n\nĐộ phức tạp đang là 5.2, giờ mình sẽ sửa để nó dễ đọc hơn một chút\n\ndef validate_expiration\n  return if exp_month.blank?\n  return if exp_year.blank?\n \n  ...\nend\nKiểm tra:\n$ flog app/models/credit_card.rb\n \n4.8: CreditCard#validate_expiration app/models/credit_card.rb:12-15\n\nViết code là trò chơi đơn giản, nhưng để viết code đơn giản, dễ hiểu thì lại khó nhất trên đời 😆 Đừng cố viết cao siêu làm gì, hãy viết code thật dễ hiểu, hiệu quả để những người đồng nghiệp đọc code của bạn không phải chửi thầm nhé ❤️\n\n🌱 Other Dependencies §\n\nNgoài ra RubyCritic còn có nhiều dependencies khác, có cả những gem phổ biến mà chúng ta vẫn thường dùng như buybug, simpleCov, rubocop. Mọi người có thể xem đầy đủ các dependencies ở đây.\n\n🌿Áp dụng cho dự án Ruby on Rails §\n\nRubyCritic cung cấp tài liệu chi tiết để bắt đầu mà không cần config nhiều. Trong khuôn khổ bài viết này, chúng ta sẽ tập trung cho việc phân tích những thông số có trong những báo cáo của RubyCritic.\nCó 3 vấn đề được báo cáo là Code, Smells và Coverage. Cùng lược qua từng tính năng này nhé!\n\n🌱 Overview §\nSau khi chạy rubycritic xong, tự động redirect tới một trang html chứa các reports của dự án.\n\n\nMàn Overview hiển thị tổng điểm của dự án trên một cái biểu đồ donut, xếp hạng theo A là tốt nhất và F là tệ nhất.\nPhần Summary hiển thị chi tiết của từng rating (A -&gt; F) bao gồm số lượng files, số lượng commit(churns) và số lượng smell code được tìm thấy.\nChurn vs Complexity hiển thị vị trí các Class/Module là một điểm, ứng với 2 chỉ số độ phức tạp và số lượng commit =&gt; phản ánh chính xác những điểm chưa tốt của dự án.\n\n🌱 Code Report §\n\nHiển thị điểm của từng Class/Module bao gồm churn, complexity, duplication and smells.\nBạn có thể sort theo từng chỉ số để tiện đánh giá.\nCó thể search tên của Class/Module.\n\n\n\n\nClick vào một Class/Module bất kỳ sẽ hiển thị chi tiết source code và các số liệu đi kèm như:\n\nCode line\nChất lượng code\nChurn\nĐộ phức tạp của method\nĐiểm phức tạp(tổng của class)\nSố lượng code bị duplicates.\nSố lượng smells tìm thấy.\n\n\n\nNhững dòng code có vấn đề sẽ được highlight(Dựa theo thông tin cả Reek gem cung cấp)\n\n\n\n🌱 Smells Report §\n\nHiển thị smell type, vị trí chính xác nơi bốc mùi và tình trạng khắc phục.\nNhư đã nói ở trên, Smells được cung cấp bởi gem Reek, và màn này chúng ta cũng có thể search và sort được như Code Report.\nBạn có thể nhìn thấy các class/module được nhóm theo smell type.\n\n\n🌱 Coverage Report §\n\n\nChỉ hiển thị thông số độ bao phủ của kiếm thử đối với những class/module.\nKhông thể sắp xếp hoặc tìm kiếm như 2 trang bên trên.\nNếu tích hợp SimpleCov thì sẽ chi tiết và trực quan hơn, nhưng với hầu hết trường hợp chỉ cần một báo cáo đơn giản để đánh giá độ phủ của dự án, Coverage Report đã hoàn toàn đáp ứng được rồi.\n\n☘️Tham khảo §\n\nhttps://github.com/whitesmith/rubycritic\nhttps://blog.appsignal.com/2022/10/19/improve-code-in-your-ruby-application-with-rubycritic.html\n"},"40123345-posts/42-Code/42.02-Vuejs/Vue3---Essentials":{"title":"🌱 Vue3 - Essentials","links":[],"tags":["vuejs"],"content":"🌿 I. Creating the Vue App §\n\nTạo Vue App(được khởi tạo một lần, tất cả đều config ở đây).\n\nconst app = Vue.createApp({ // Heart of the Vue App\n  data() { // data option\n    return {\n      product: &#039;Socks&#039;\n    }\n  }\n})\n\nMount App to DOM - như ví dụ ở dưới, mount tới div tag có id là app, tất cả DOM element bao trong div đó sẽ có thể truy cập tới Vue App.\n\n&lt;script&gt;\n  const mountedApp = app.mount(&#039;#app&#039;)\n&lt;/script&gt;\n\nSử dụng Mustache Syntax để call dữ liệu từ Vue App.\n\n&lt;h1&gt;{{ product }}&lt;/h1&gt;\n\nMultiple application instances\n\nconst app1 = createApp({\n  /* ... */\n})\napp1.mount(&#039;#container-1&#039;)\n \nconst app2 = createApp({\n  /* ... */\n})\napp2.mount(&#039;#container-2&#039;)\n\ndoc: https://vuejs.org/guide/essentials/application.html\npull https://github.com/anhnh-3008/Vue3/pull/1\n\n🌿 II. Template syntax §\n\nMuốn call dữ liệu cho các attribute của DOM element, sử dụng v-bind.\n\n&lt;img v-bind:src=&quot;image&quot;&gt;\n \n&lt;!-- Shorthand: --&gt;\n&lt;img :src=&quot;image&quot;&gt;\n \n&lt;!-- Use cases: --&gt;\n&lt;img :alt=&quot;description&quot;&gt;\n&lt;a :href=&quot;link&quot;&gt;\n&lt;div :class=&quot;isActive&quot;&gt;\n&lt;span :style=&quot;isActive&quot;&gt;\n\nDynamically Binding Multiple Attributes\n\ndata() {\n  return {\n    objectOfAttrs: {\n      id: &#039;container&#039;,\n      class: &#039;wrapper&#039;,\n      disabled: &#039;false&#039;\n    }\n  }\n}\n&lt;div v-bind=&quot;objectOfAttrs&quot;&gt;&lt;/div&gt;\n&lt;!-- &lt;div id=&quot;container&quot; class=&quot;wrapper&quot; disabled=&quot;false&quot;&gt;&lt;/div&gt; --&gt;\n\nCalling functions\n\n\nCó thể gọi function trong v-bind, function chỉ được một lần khi init component nên không sử dụng cho những case cần data động như changing data hoặc triggering asynchronous operations.\n\n&lt;span :title=&quot;toTitleDate(date)&quot;&gt;\n  {{ formatDate(date) }}\n&lt;/span&gt;\n\nDynamic Arguments\n\n&lt;a :[someAttr]=&quot;value&quot;&gt; ... &lt;/a&gt;\n\nsomeAttr - giá trị thay đổi theo data mount từ Vue App, với những giá trị phức tạp, có thể sử dụng computed properties, xem thêm ở mục VIII.\n\n\nModifiers\n\n\nKhái niệm hiểu như trong JQuery. Vd .prevent có nghĩa là v-on sẽ call event.preventDefault() trong quá trình trigger sự kiện.\n\n&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;\n\n\ndoc: https://vuejs.org/guide/essentials/template-syntax.html\npull https://github.com/anhnh-3008/Vue3/pull/2\n\n🌿 III. Condition rendering §\n\nv-show: luôn render DOM element, condition chỉ toggle display CSS property\nv-if - v-eles-if - v-else: đúng condition thì mới render DOM, logic giống với các ngôn ngữ lập trình khác.\n\n&lt;p v-if=&quot;condition&quot;&gt;Condition is true&lt;/p&gt;\n&lt;p v-else&gt;Condition is false&lt;/p&gt;\n\nSo sánh v-if và v-show:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nv-ifv-showLà chuẩn conditional rendering vì nó đảm bảo sẽ xóa và render lại toàn bộ listener events or components nằm trong block khi toggles điều kiệnToggle điều kiện thì chỉ thay đổi duy nhất display: none thôiLazy - chỉ render DOM khi condition == trueLuôn render DOMhigher toggle costs - dùng với những điều kiện ít thay đổihigher initial render costs - dùng với những element cần toggle điều kiện thường xuyên\n\n\nKhi v-if và v-for được sử dụng trên cùng một object, v-if sẽ được gọi đầu tiên.\n\n\ndoc: https://vuejs.org/guide/essentials/conditional.html\n\n\npull https://github.com/anhnh-3008/Vue3/pull/3\n\n\n🌿 IV. List rendering §\n\nv-for: lặp một mảng.\n\n&lt;ul&gt;\n  &lt;li v-for=&quot;user in users&quot;&gt;\n    &lt;p&gt;{{user.id}}&lt;/p&gt;\n    &lt;p&gt;{{user.name}}&lt;/p&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n\nNested loop:\n\n&lt;li v-for=&quot;item in items&quot;&gt;\n  &lt;span v-for=&quot;childItem in item.children&quot;&gt;\n    {{ item.message }} {{ childItem }}\n  &lt;/span&gt;\n&lt;/li&gt;\n\nCó thể dùng of thay in.\n\n&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt;\n\nNgoài mảng, có thể lặp Object, cơ chế lặp qua các keys base theo Object.keys().\n\ndata() {\n  return {\n    myObject: {\n      title: &#039;How to do lists in Vue&#039;,\n      author: &#039;Jane Doe&#039;,\n      publishedAt: &#039;2016-04-10&#039;\n    }\n  }\n}\n&lt;ul&gt;\n  &lt;li v-for=&quot;value in myObject&quot;&gt;\n    {{ value }}\n  &lt;/li&gt;\n&lt;/ul&gt;\n\nfor with a range\n\n&lt;span v-for=&quot;n in 10&quot;&gt;{{ n }}&lt;/span&gt;\n\ndoc: https://vuejs.org/guide/essentials/list.html\npull https://github.com/anhnh-3008/Vue3/pull/4\n\n🌿 V. Event handling §\n\nv-on:event: bắt sự kiện\n\n&lt;!-- shorthand: @event --&gt;\n&lt;div v-for=&quot;variant in variants&quot; :key=&quot;variant.id&quot; @mouseover=&quot;updateImage(variant.image)&quot;&gt;{{ variant.color }}&lt;/div&gt;\n \n&lt;button class=&quot;button&quot; @click=&quot;addToCart&quot;&gt;Add to Cart&lt;/button&gt;\n\nInline handlers\n\n\nVới logic ngắn, đơn giản có thể truyền thẳng.\n\ndata() {\n  return {\n    count: 0\n  }\n}\n&lt;button @click=&quot;count++&quot;&gt;Increase&lt;/button&gt;\n&lt;p&gt;Count is: {{ count }}&lt;/p&gt;\n\nMethod handlers\n\n\nLogic dài + phức tạp thì có thể xử lý thông qua method\n\ndata() {\n  return {\n    count: 0\n  }\n},\nmethods: {\n  alertCount() {\n    if (count &gt; 0) {\n      alert(&#039;Count is positive&#039;);\n    } else {\n      alert(&#039;Count is negative&#039;);\n    }\n  }\n}\n&lt;button @click=&quot;alertCount&quot;&gt;Alert&lt;/button&gt;\n\nEvent Modifiers\n\n\nChúng ta thường xuyên phải sử dụng event modifiers(chỉ định những common event ví dụ như không reload khi submit form, …). Có thể định nghĩa  Event Modifiers trong method nhưng theo quan điểm của Vue, method chỉ để xử lý logic thôi. Nên trong Vue, chúng ta có thể chỉ định trực tiếp như sau:\n\n&lt;!-- the click event&#039;s propagation will be stopped --&gt;\n&lt;a @click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;\n \n&lt;!-- the submit event will no longer reload the page --&gt;\n&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;\n \n&lt;!-- modifiers can be chained --&gt;\n&lt;a @click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;\n \n&lt;!-- just the modifier --&gt;\n&lt;form @submit.prevent&gt;&lt;/form&gt;\n \n&lt;!-- only trigger handler if event.target is the element itself --&gt;\n&lt;!-- i.e. not from a child element --&gt;\n&lt;div @click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;\n\nKey Modifiers\n\n\nKhi xử lý event theo các keys đặc biệt, Vue cho phép chỉ định nhanh như sau:\n\n&lt;!-- only call `submit` when the `key` is `Enter` --&gt;\n&lt;input @keyup.enter=&quot;submit&quot; /&gt;\n\nVới TH xử lý combo(vd: Ctrl + Enter), Vue cho phép thực hiện thông qua 4 keys bắt đầu :\n\n.ctrl\n.alt\n.shift\n.meta\n\n\n\n&lt;!-- Alt + Enter --&gt;\n&lt;input @keyup.alt.enter=&quot;clear&quot; /&gt;\n \n&lt;!-- Ctrl + Click, mặc định sẽ + với click --&gt;\n&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;\n\nexact - xem vd\n\n&lt;!-- chỉ cần có ấn ctrl (có thể là ctrl + shift) method sẽ được gọi --&gt;\n&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;\n \n&lt;!-- chỉ gọi method khi hệ thống nhận duy nhất key ctrl --&gt;\n&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;\n \n&lt;!-- chỉ gọi method khi hệ thống không có event modifiers nào --&gt;\n&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;\n\ndoc: https://vuejs.org/guide/essentials/event-handling.html\npull https://github.com/anhnh-3008/Vue3/pull/5\n\n🌿 VI. Class &amp; Style binding §\n🌱 Class binding §\n\n:class: xử lý tên class\n\n&lt;button class=&quot;button&quot;\n:class=&quot;{ disabledButton: inventories &lt;= 0 }&quot;\n:disable=&quot;inventories &lt;= 0&quot;&gt;Add to Cart&lt;/button&gt;\n\nBinding to Object\n\n\nNgoài cách truyền điều kiện boolean như trên, có thể truyền object để dễ quản lý.\n\nconst classObject = reactive({\n  active: true,\n  &#039;text-danger&#039;: false\n})\n&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;\n \n&lt;!-- render --&gt;\n \n&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;\n\nBinding to Array\n\n\nTruyền một mảng, kết quả cũng giống bên trên.\n\nconst activeClass = ref(&#039;active&#039;)\nconst errorClass = ref(&#039;text-danger&#039;)\n&lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;\n\n\n                  \n                  Note \n                  \n                \nTrong doc có giới thiệu inline handle nhưng mình thấy không hợp lý lắm, có gì cần xử lý logic cứ nhét hết vào file Js, trong HTML để biến boolean thôi.\n\n\nWith Components\n\n\nChỉ định :class cho component sẽ merge cho những class của child DOMs trong component(những DOM có define class)\n\n&lt;!-- child component template --&gt;\n&lt;p class=&quot;foo bar&quot;&gt;Hi!&lt;/p&gt;\n \n&lt;!-- when using the component --&gt;\n&lt;MyComponent class=&quot;baz boo&quot; /&gt;\n \n&lt;!-- child rendered will be --&gt;\n&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt;\n\nclass của component được lưu trong biến $attrs, có thể chỉ định trực tiếp cho child DOM:\n\n&lt;!-- child component template --&gt;\n&lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt;\n \n&lt;!-- when using the component --&gt;\n&lt;MyComponent class=&quot;baz&quot; /&gt;\n \n&lt;!-- child rendered will be --&gt;\n&lt;p class=&quot;baz&quot;&gt;Hi&lt;/p&gt;\n🌱 Style binding §\n\n:style: xử lý style\n\n&lt;div\nclass=&quot;color-circle&quot;\n:style=&quot;{ backgroundColor: variant.color }&quot;\n&gt;&lt;/div&gt;\n\nGiống với Class, cũng nhận Object và Array\nSupport cả camelCase và kebab-cases(để trong nháy kép)\n\n&lt;!-- camelCase --&gt;\n&lt;div :style=&quot;{ color: activeColor, fontSize: fontSize + &#039;px&#039; }&quot;&gt;&lt;/div&gt;\n \n&lt;!-- kebab-cases --&gt;\n&lt;div :style=&quot;{ &#039;font-size&#039;: fontSize + &#039;px&#039; }&quot;&gt;&lt;/div&gt;\n\ndoc: https://vuejs.org/guide/essentials/class-and-style.html\npull: https://github.com/anhnh-3008/Vue3/pull/6\n\n🌿 VII. Computed Properties §\n\nCác thuộc tính cần dùng thêm logic để tính toán, khai báo trong computed.\n\nconst app = Vue.createApp({\n  data() {\n    return {\n      product: &#039;Socks&#039;\n    }\n  },\n  computed: {\n    productWithBrandTilte() {\n      return &#039;Brand Vue - &#039; + this.product // Brand Vue - Socks\n    }\n  },\n})\n\nTại sao không dùng function mà phải dùng computed làm gì?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComputed propertyFunctioncache dựa trên reactive dependencies, như vd trên nếu product không thay đổi khi gọi lại sẽ return ngay lập tứckhông cache, luôn gọi lại getter\n🌱 Best practice §\n\nChỉ nên tính toán, xử lý trả về giá trị, đừng có nhét cả logic thay đổi DOM hay gọi bất đồng bộ lấy dữ liêu, … Trách nhiệm duy nhất của computed chính là tính toán và trả về giá trị - S(Single Responsibility Principle) in SOLID.\nTránh trực tiếp thay đổi giá trị computed. Chỉ nên thay đổi những variables nằm trong logic xử lý của computed property.\n\n\ndoc: https://vuejs.org/guide/essentials/computed.html\npull: https://github.com/anhnh-3008/Vue3/pull/7\n\n🌿 VIII. Component basic §\n🌱 Components §\n\nCho phép chia UI thành những phần nhỏ độc lập, có khả năng tái sử dụng, dễ quản lý hơn.\nKhông chỉ nhóm các DOM elments, Vue còn cho phép đóng gói dữ liệu, logic cho từng component.\n\n\n\nDefining a component:\n\napp.component(&#039;product-detail&#039;, {\n  // options\n  template:, // define DOM elements\n  data() {return {} }, // define data\n  methods {}, // define methods\n  computed {}, // define computed properties\n})\n&lt;product-display&gt;&lt;/product-display&gt;\n \n&lt;!-- Import Component --&gt;\n&lt;script src=&quot;./components/ProductDisplay.js&quot;&gt;&lt;/script&gt;\n\nCó thể sử dụng lại nhiều lần một component, mỗi khi một component được khởi tạo, toàn bộ data, computed properties sẽ được tạo mới, độc lập không liên quan gì đến nhau. Nếu muốn trigger đến một biến chung cho những components con, hãy define variable ở component cha và truyền vào component con thông qua props.\n\n🌱 Props §\n\nProps - Là option chỉ định những tham số nhận từ thằng cha vào component.\nVí dụ một trang web bán hàng có nhiều sản phẩm, nếu sản phẩm được gắn premium thì sẽ free ship ngược là phí ship sẽ là 2.99$. Biến premium sẽ dùng chung cho nhiều sản phẩm cùng category nên chúng ta sẽ define premium riêng và truyền vào component sản phẩm.\n\nconst app = Vue.createApp({\n  data() {\n    return {\n      premium: false\n    }\n  }\n})\n&lt;product-display :premium=&quot;premium&quot;&gt;&lt;/product-display&gt;\n \n&lt;!-- Import Component --&gt;\n&lt;script src=&quot;./components/ProductDisplay.js&quot;&gt;&lt;/script&gt;\napp.component(&#039;product-detail&#039;, {\n  // define property recieve from parent component\n  props: {\n    premium: {\n      type: Boolean,\n      required: true\n    }\n  }\n  template:, // define DOM elements\n  data() {return {} }, // define data\n  methods {}, // define methods\n  computed {\n    shipping() {\n      if (this.premium) return &#039;free&#039;\n      \n      return &#039;2.99$&#039;\n    }\n  }\n})\n\ndoc: https://vuejs.org/guide/essentials/component-basics.html\npull: https://github.com/anhnh-3008/Vue3/pull/8\n\n🌱 Communicating events §\n\nTrong quá trình phát triển, TH chúng ta muốn method trong component con tương tác được với varibale define trong component cha, có thể giao tiếp thông qua $emit.\n\n&lt;!-- index.html --&gt;\n&lt;product-display @add-to-cart=&quot;updateCart&quot;&gt;&lt;/product-display&gt;\n \n&lt;!-- Import Component --&gt;\n&lt;script src=&quot;./components/ProductDisplay.js&quot;&gt;&lt;/script&gt;\n// main.js\nmethods: {\n  updateCart() {\n    this.cart += 1\n  }\n}\n// ProductDisplay.js\ntemplate:\n  /*html*/\n  `&lt;button\n  class=&quot;button&quot;\n  @click=&quot;addToCart&quot;&gt;\n  Add to Cart\n  &lt;/button&gt;`,\nmethods: {\n  addToCart() {\n    this.$emit(&#039;add-to-cart&#039;)\n    // this.$emit(&#039;add-to-cart&#039;, params)\n  }\n}\n\ndoc: https://vuejs.org/guide/essentials/component-basics.html#listening-to-events\npull: https://github.com/anhnh-3008/Vue3/pull/9\n\n🌿 X. Form Input Bindings §\n\nv-model - liên kết element trong form tới các biến trong data.\n\n&lt;p&gt;Message is: {{ message }}&lt;/p&gt;\n&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot; /&gt;\n\ndoc: https://vuejs.org/guide/essentials/forms.html\npull: https://github.com/anhnh-3008/Vue3/pull/10\n"},"40123345-posts/42-Code/42.02-Vuejs/What-is-Vue?":{"title":"🌱 What is Vue?","links":[],"tags":["vuejs"],"content":"🌿 What is Vue? §\n\n\nVuejs là một open source Javascript framework hướng tới việc xây dựng giao diện người dùng(UI), được tạo ra bởi Evan You. Như trên Landing page có giới thiệu, Vuejs là một phiên bản cấp tiến của Javascript framework với những đặc điểm nổi bật như dễ tiếp cận, linh hoạt và hiệu quả.\n\n🌿 Why use it? §\n🌱 Progressive - Cấp tiến §\n\nVue được công nhận là progressive vì nó thường có thể scale down cũng như up. Với đa số những trường hợp sử dụng phổ thông, chúng ta có thể tích hợp Vue như jQuery - thêm một script tag như sau:\n\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;\n\nKhi nhu cầu sử dụng của chúng ta phát triển, Vue cũng sẽ cung cấp thêm những công cụ có trong hệ sinh thái giúp nâng cao hiệu quả sử dụng.\n\n🌱 Approachable - Dễ tiếp cận §\n\nVue rất dễ tiếp cận miễn là chúng ta có hiểu biết HTML, CSS, và JS tiêu chuẩn. Vậy là bạn có thể bắt đầu làm việc với Vue được rồi.\n\n🌱 Versatile - Linh hoạt §\n\n\n\nVue linh hoạt vì xung quanh thư viện có đầy đủ các tools support, muốn dùng gì thì mình tích hợp thêm, chứ không cần phải cài hết một lượt. Các tools phổ biến:\n\nvue-cli (i.e. Vue Command Line Interface) - như cli của những framwork khác, cho phép giao tiếp nhanh cong với Vue app.\nvue-router - chỉ định routes giao tiếp dễ dàng giữa client-side và server-side.\nvuex - hỗ trợ quản lý dữ liệu.\nvue-test-utils - cung cấp đa dạng các helpers cũn như functions hỗ trợ chúng ta trong quá trình viết UT.\n\n\n\nCác tools trên đều được created and maintained bởi chính đội Vue core nên việc tích hợp sẽ vẫn là trơn chu, mượt mà.\n\n\n🌱 Performant - Hiệu quả §\n\n\nCuối cùng, Vue hiệu quả vì nó tận dụng virtual DOM để có được thời gian re-render lại cực nhanh. Thư viện lõi của Vue cũng được phát triển với tiêu chí là tối ưu hiệu suất.\n"},"40123345-posts/42-Code/42.03-AWS/AMI---Amazon-Machine-Image":{"title":"🌱 AMI - Amazon Machine Image","links":[],"tags":["aws"],"content":"🌿 What? §\n\nAMI - Amazon Machine Image\nCó chứa những thông tin về OS, phần mềm cài đặt, volumes, cấu hình, hay các thiết lập khác của một EC2 Instance.\n\nDễ dàng triển khai. Nhất quán về cấu hình cũng như  thiết lập của các EC2 Instances.\nFast boot vì Image đã được chuẩn bị trước về phần mềm cài đặt, thiết lập, …\n\n\nAMI thuộc về một Region chỉ định( chúng ta có thể copy để sử dụng ở những Region khác)\nCác Options để có một AMI:\n\nA public AMI: AWS cung cấp một số AMI mẫu, mỳ ăn liền.\nYour own AMI: tự tạo và thiết lập để phù hợp với nhu cầu sử dụng của bản thân.\nAn AWS Marketplace AMI: Có thể mua/bán AMI trên market. Có thể khởi nghiệp bằng công việc bán AMI luôn 😍\n\n\n\n🌿 AMI Process( từ một EC2 Instance) §\n\nTạo một EC2 Instance và tùy chỉnh nó.\nDừng Instance(Data được toàn vẹn)\nTạo AMI - Giống tạo EBS snapshots\nLaunch Instance từ AMIs\n"},"40123345-posts/42-Code/42.03-AWS/ASG---Auto-Scaling-Group":{"title":"🌱 ASG - Auto Scaling Group","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà một service của AWS hỗ trợ việc tự động mở rộng hay thu nhỏ số lượng instances để phù hợp với lượng tải của ứng dụng.\nMục đích:\n\nThêm số lượng EC2 Instances để đáp ứng lượng tải tăng cao.\nGiảm số lượng EC2 Instances để phù hợp với lượng tải ít đi.\nXác định được số lượng lớn nhất cũng như nhỏ nhất của các EC2 Instances.\nTự động đăng ký instances mới để cân bằng tải.\nTự động tạo lại một EC2 Instance thay thế trong trường hợp instance trước đó bị đánh giá là unhealthy.\n\n\nASG are free (chỉ phải trả tiền thuê các EC2 instances)\n\n🌿 Attributes §\n\nGọi là một Launch Template, bao gồm:\n\nNhưng thông tin về EC2 Instance:\n\nAMI + Instance Type\nEC2 User Data\nEBS Volumes\nSecurity Groups\nSSH Key Pair\nIAM Roles cho EC2 Instances\nNetwork + Subnet\n\n\nThông tin Load Balancer\n\n\nMin Size/ Max Size/ Initial Capacity\nScaling Policy\n\nKhả năng auto scale dựa vào báo động CloudWatch - cái mà dùng để theo dõi metric(như Average CPU, …) và từ đó có thể tính toán scale.\n\n\n\n🌿 Scaling Policies §\n\nDynamic Scaling policies\n\nTarget Tracking Scaling\n\nĐơn giản về dễ setup nhất\nVD: tôi muốn trung bình ASG CPU ở khoảng 40%\n\n\nSimple/Step Scaling\n\nScale dự theo thông tin của CloudWatch báo. Điều chỉnh mở rộng theo ngưỡng(min - max)\nVd nó báo CPU &gt; 70% -&gt; tự động add thêm 2 instances\nvd nó bảo CPU &lt; 30% -&gt; tự động remove 1 instance\n\n\nScheduled Actions\n\nThực hiện mở rộng dựa theo lịch lên sẵn.\nVí dụ app dùng nhiều vào cuối tuần thì sẽ tăng instance lên vào thứ 7 và CN\n\n\nPredictive Scaling\n\nDựa trên lịch sử khai thác dữ liệu của ứng dụng, ASG sẽ tự động điều chỉnh trước resources để luôn có để đáp ứng nhu cầu sử dụng.\n\n\n\n\n\n🌿 Các chỉ số chính để đánh giá scale §\n\nChỉ số trung bình CPU của các instances\nSố requests trên từng Target\nTrung bình network in/out\nAny custom metric\n\n🌿 Scaling cooldowns §\n\nSau mỗi hoạt động scale, ASG sẽ phải đợi cooldown period( thời gian hồi chiêu ), mặc định là 300s.\nTrong thời gian này, ASG sẽ không lauch hoặc terminate bất kỳ instance nào, việc này để đảm bảo các chỉ số được ổn định sau đó mới tiếp tục thực hiện các hoạt động scale khác.\nSử dụng ready-to-use AMI để giảm thời gian config, từ đó giảm được quá trình hồi chiêu của ASG.\n"},"40123345-posts/42-Code/42.03-AWS/AWS-API-Gateway":{"title":"🌱 AWS API Gateway","links":["40123345-posts/42-Code/42.03-AWS/AWS-Lambda"],"tags":["aws"],"content":"🌿 What? §\n\nKết hợp với AWS Lambda: kiến trúc không có server.\nExpose REST API.\nHỗ trợ giao thức WebSocket\nXử lý API versioning(v1,v2,…)\nXử lý giữa các môi trường phát triển khác nhau(dev, test, prod, …)\nXử lý bảo mật(Authen &amp; Authori)\nTạo API keys\nKết hợp được với Swagger/Open API để nhanh chóng tạo ra doc.\nCó thể transform và validate requests và responses.\nGen ra SDK và API specifications.\nCache lại responses của API.\n\n🌿 Integrations §\nKết hợp được với:\n\nLambda Function\nHTTP\n\nDùng để add rate limit, caching hoặc authen cho users, …\n\n\nAWS Service\n\n🌿 Endpoint Types §\n\nEdge-Optimized(default)\n\nCho global clients\nRequests sẽ được định tuyến tới các edge location(độ trễ thấp)\nAPI Gateway chỉ tồn tại trên một region nhưng users ở những chỗ khác vẫn truy cập với độ trễ thấp.\n\n\nRegion\n\nCho những clients ở cùng một region\nCó thể kết hợp thủ công với CloudFront\n\n\nPrivate\n\nChỉ có thể kết nối từ VPC thông qua ENI.\nSử dụng policy để xác định quyền truy cập.\n\n\n\n🌿 Security §\n\nDùng để xác thực người dùng:\n\nIAM roles(phù hợp với các app nội bộ)\nCognito (xác định các user bên ngoài - vd như mobiles user)\nCustom Authorizer (cho logic của chúng ta)\n\n\nCustom Domain Name HTTPS bằng việc tích hợp AWS Certificate Manager(ACM)\n\nNếu sử dụng Edge-Optimized endpoint, certificate phải thuộc về us-east-1\nNếu sử dụng Regional endpoint, certificate phải nằm trong API Gateway region\nNếu dùng với Route53, phải sử dụng CNAME hoặc A-alias.\n\n\n"},"40123345-posts/42-Code/42.03-AWS/AWS-App-Runner":{"title":"🌱 AWS App Runner","links":[],"tags":["aws"],"content":"🌿 What? §\n\n\nLà một service giúp chúng ta dễ dàng hơn trong việc triển khai web applications và APIs.\nKhông cần yêu cầu có kinh nghiệm với cơ sở hạ tầng(infrastructure).\nĐầu tiên cần có source code hoặc container image.\nThiết lập các thông số như vCPU, RAM, Auto Scaling, Health Check, …\nSau đó service tự động build và deploy web app.\nTự động scaling, HA, load balancer, mã hoá.\nHỗ trợ truy cập VPC.\nKết nối với các dịch vụ database, cache và message queue.\nUse cases: web apps, APIs, microservices, triển khai nhanh.\n"},"40123345-posts/42-Code/42.03-AWS/AWS-Batch":{"title":"🌱 AWS Batch","links":["40123345-posts/42-Code/42.03-AWS/Elastic-Beanstalk","50-til/51-Code/09-Docker/Docker","40123345-posts/42-Code/42.03-AWS/Databases/Amazon-ECS---Elastic-Container-Service"],"tags":["aws"],"content":"🌿 What? §\n\nDo AWS quản lý hoàn toàn.\nHỗ trợ chạy các tác vụ theo lô(kiểu như xử lý ảnh khi người dùng gửi lên S3, …)\nBatch sẽ linh động tạo ra các EC2 Instances hoặc Spot Instances để xử lý logic, nó sẽ tự biết lựa chọn về compute/memory phù hợp.\nCác Batch jobs được định nghĩa như là các Docker Imaged và sẽ chạy trên ECS.\nPhù hợp khi chúng ta muốn tối ưu chi phí cũng như đơn giản hoá kiến trúc của hệ thống.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAWS LambdaAWS BatchTime limitNo time limitLimit runtimeCứ chạy cái docker là sử dụng tẹt gaGiới hạn bộ nhớ tạmPhụ thuộc vào EBS/instance storeServerlessCó launch EC2 Instance(được AWS quản lý)"},"40123345-posts/42-Code/42.03-AWS/AWS-CloudFormation":{"title":"🌱 AWS CloudFormation","links":["40123345-posts/42-Code/42.03-AWS/S3","40123345-posts/42-Code/42.03-AWS/Databases/Amazon-DynamoDB"],"tags":["aws"],"content":"🌿 What? §\n\nLà một bản phác thảo cho kiến trúc hạ tầng trên AWS, cho hầu hết các resources trên AWS.\nVí dụ, chúng ta cần một kiến trúc bao gồm:\n\nSecurity Group\n2 EC2 Instances sử dụng SG trên\nMột S3 Bucket\nMột ELB\n\n\nCloudFormation sẽ tạo tất cả theo đúng trình tự như trên và đúng theo những thông số mà chúng ta đã chỉ định.\n\n🌿 Benefits §\n\nInfrastructure as code\n\nKhông phải tạo resources thủ công nữa.\nCác thay đổi về resources sẽ được review thông qua code.\n\n\nChi phí:\n\nDễ dàng theo dõi chi phí theo stack build trong code.\nCó thể ước lượng được chi phí sử dụng nhờ CloudFormation template.\nSaving strategies: ở môi trường dev, có thể dễ dàng tự động xoá template vào lúc 6 giờ chiều(khi mn tan làm) và bật lại vào lúc 8 giờ sáng(khi mọi người bắt đầu làm việc).\n\n\nHiệu suất:\n\nCó khả năng xoá, tự động tạo infrastructure ở bất cứ đâu.\nTự động tạo biểu đồ cho template\nLập trình khai báo(không cần thực hiện theo thứ tự, vd như cần tạo một DynamoDB thì phải tạo trước một EC2 Instance, … CloudFormation tự tìm được cách thực hiện)\n\n\nKhông chế tạo lại bánh xe(tận dụng những cái có sẵn)\n\nTận dụng những templates sẵn có trên web.\nTận dụng lại các tài liệu.\n\n\nHỗ trợ hầu như tất cả các AWS resources\n\nCó thể sử dụng “custome resources” cho những resources không được hỗ trợ.\n\n\n\n🌿 Stack Designer §\n\n\nChúng ta có thể thấy được toàn bộ resouces được áp dụng cho infrastructure.\nNgoài ra còn có thể thấy được quan hệ của chúng.\n"},"40123345-posts/42-Code/42.03-AWS/AWS-CloudFront":{"title":"🌱 AWS CloudFront","links":["40123345-posts/42-Code/42.03-AWS/S3"],"tags":["aws"],"content":"🌿 What? §\n\nLà một dịch vụ CDN(Content Delivery Network)\nTăng hiệu suất đọc, content được cache ở edge location.\n\nVí dụ S3 đặt ở Singapore, có user truy cập dữ liệu từ Mỹ, dữ liệu sẽ được fetch về một edge location ở Mỹ và cache lại, sau đấy, người dùng khác ở Mỹ muốn truy cập dữ liệu thì sẽ đọc ở edge location đấy luôn.\n\n\nNâng cao trải nghiệm của người dùng.\nDDoS protection(bởi vì là toàn thế giới), tích hợp với Shield, AWS Web Applocation Firewall\n\n🌿 Origins §\n\nS3 Bucket\n\nĐể phân phối files và caching chúng ở các edge\nTăng cường bảo mật với CloudFront Origin Access Control(OAC)\nOAC đang thay thế Origin Access Identity (OAI)\nCloudFront có thể được sử dụng như một nơi để truy cập để upload files vào S3\n\n\nCustom Origin (HTTP)\n\nApplication Load Balancer\nEC2 Instance\nS3 website (cần phải bật static web)\nBất kỳ HTTP backend nào bạn muốn.\n\n\n\n🌿 So sánh giữa CloudFront và S3 Replication §\n\nCloudFront\n\nGlobal Edge network\nFiles được cached trên các edge location(có thể là một ngày)\nPhù hợp cho các static content mà cần available ở mọi nơi.\n\n\nS3 Cross Region Replication\n\nCần setup cho từng region mà chúng ta muốn nhân bản.\nFiled được update gần như là real-time\nChỉ được đọc\nPhù hợp với những dynamic content cần available với độ trễ thấp ở một vài regions.\n\n\n\n🌿 CloudFront Geo Restriction §\n\nCó thể giới hạn người có thể truy cập vào bản phân phối của chúng ta.\n\nAllowlist: Cho phép người dùng của những khu vực được cho phép, truy cập vào content của bạn\nBlocklist: Ngăn ngừa người dùng của những khu vực chỉ định, không được truy cập vào content của bạn.\n\n\nKhu vực sẽ sử dụng một bên thứ 3 - Geo-IP database để giúp chúng ta xác định.\nUse case: Luật bản quyền để kiểm soát truy cập vào dữ liệu.\n\n🌿 CloudFront - Pricing §\n\n\nCloudFront Edge locations ở khắp nơi trên thế giới. Và mỗi khu vực lại có những chi phí khác nhau.\n\n\n\nChúng ta có thể giảm số lượng các edge locations để giảm chi phí.\n\n\nCó 3 price classes:\n\nPrice Class All: có trên tất cả các regions - hiệu suất tốt nhất\nPrice Class 200: hầu hết các regions, trừ những regions có giá thành cao nhất.\nPrice Class 100: chỉ những regions có chi phí thấp nhất.\n\n\n\n\n\n🌿 Cache Invalidations §\n\nChức năng cho phép xóa dữ liệu trong cache trước khi hết thời gian hết hạn. Tránh tình trạng dữ liệu được cập nhật mới ở S3 những trên các Edge locations vẫn sử dụng phiên bản cũ -&gt; ảnh hưởng đến trải nghiệm của người dùng.\nChức năng sẽ giúp các edge locations xóa cache để truy cập lại vào orgin để lấy dữ liệu mới nhất.\nChúng ta có thể refresh toàn bộ(all files - dấu hoa thị) hoặc một phần(/images/hoa thị) cache.\n"},"40123345-posts/42-Code/42.03-AWS/AWS-DataSync":{"title":"🌱 AWS DataSync","links":["40123345-posts/42-Code/42.03-AWS/Amazon-FSx"],"tags":["aws"],"content":"🌿 What? §\n\n\nDùng để move một số lượng lớn dữ liệu\n\nTừ mặt đất lên could\nTừ service này -&gt; service khác\n\n\n\nCó thể đồng bộ dữ liệu:\n\nAmazon S3(với bất kỳ storage classes nào - bảo gồm cả Glacier)\nAmazon EFS\nAmazon FSx\n\n\n\nCác tasks nhân bản sẽ được đặt lịch hàng giờ/hàng ngày/hang tuần.\n\n\nFile permissions và metadata được giữ nguyên khi đồng bộ.\n\n\nMột agent có thê sử dụng 10Gps, có thể setup giới hạn cho băng thông.\n\n\nĐồng bộ dữ liệu giữa on-premises và cloud:\n\n\n\nĐồng bộ giữa các services:\n\n\n"},"40123345-posts/42-Code/42.03-AWS/AWS-Global-Accelerator":{"title":"🌱 AWS Global Accelerator","links":[],"tags":["aws"],"content":"🌿 Vấn đề §\n\n\nChúng ta có một server app đặt tại một region, và người dùng của app là khắp nơi trên thế giới.\nHọ đến public internet và điều này sẽ gây ra độ trễ lớn từ nhiều bước truyền dữ liệu.\nChúng ta muốn dữ liệu được truyền nhanh nhất có thể thống AWS network với độ trễ tối thiểu.\n\n🌿 Unicast IP và Anycast IP §\n\nUnicast IP: mỗi server có một địa chỉ IP riêng\nAnycast IP: tất cả server đều có IP giống nhau và user sẽ được định tuyến đến server gần nhất.\n\n🌿 How §\n\n\nTận dụng mạng nội bộ của AWS để định tuyến tới app của bạn.\n\n\n2 Anycast IP được tạo cho app của chúng ta.\n\n\nAnycast IP gửi lượng truy cập trực tiếp tới các edge locations và edge locations sẽ gửi lượng truy cập về app của chúng ta.\n\n\nWorks với Elastic IP, EC2 Instance, ALB, NLB, public hoặc private\n\n\nHiệu suất nhất quán.\n\nĐịnh tuyến thông minh để có độ trễ thấp nhất và khả năng chuyển đổi dự phòng region nhanh nhất.\nKhông ảnh hưởng đến client cache(bởi vì IP không đổi)\nSử dụng mạng nội bộ của AWS\n\n\n\nHealth Checks\n\nCó thực hiện health check với app của chúng ta.\nGiúp app của chúng ta được global(có khả năng chuyển đổi dự phòng dưới một phút nếu app bị đánh giá unhealthy)\nPhù hợp cho TH phục hồi sau thảm họa.\n\n\n\nSecurity\n\nChỉ được cho phép 2 IP nội bộ truy cập.\nCó DDoS nhờ có thằng AWS Shield\n\n\n"},"40123345-posts/42-Code/42.03-AWS/AWS-Global-infrastructure":{"title":"🌱 AWS Global infrastructure","links":[],"tags":["aws"],"content":"AWS Cloud Use Cases §\n\n🌱 Enterprise IT(chuyển giao công nghệ), Backup &amp; Storage, Big Data analytics\n🌱 Website hosting, Mobile &amp; Social Apps\n🌱 Gaming, …\n\nGlobal infrastructure §\n\n🌱 Regions\n🌱 Availability Zones(AZs)\n🌱 Data Centers\n🌱 Edge Locations / Points of Presence\n\nRegions §\n\n🌱 Là khu vực vật lý, một cụm nhiều AZs, tối thiểu là 3, không quá 6.\n🌱 Tên: eu-west-3, eu-east-1, …\n\n\n\n                  \n                  How to choose an AWS region? \n                  \n                \nSome factors could be impact to your choice:\n\n\nCompliance with data governance and legal requirements: xem xét dự án có dữ liệu chỉ được lưu hành trong nước không(ví dụ như dự án phục vụ chính phủ) -&gt; chọn region phù hợp.\n\n\nProximity to customers: Xem xét tập khách hàng chủ yếu truy cập từ đâu -&gt; chọn region gần đó sẽ giảm thiểu được độ trễ.\n\n\nAvailable Services within a Region: Không phải tất cả các Regions đều có đầy đủ Services. Xác định rõ services sẽ được sử dụng để lựa chọn Region phù hợp. Xem các available services cho từng khu vực ở đây 👇.\n\n\nPricing: Mỗi region có một giá khác nhau, đây cũng là một yếu tố cần cân nhắc khi chọn AWS region.\n\n\n\nAvailability Zones(AZs) §\n\n🌱 Cách nhau tối thiểu 100km, độc lập, tránh các TH thiên tai.\n🌱 Là tập hợp của một hoặc nhiều trung tâm dữ liệu riêng biệt, bao gồm:\n\nNguồn điện dự phòng.\nNetworking.\nĐược liên kết với một AWS Region.\n\n\n🌱 Tất cả AZs trong một AWS Region đều được kết nối với nhau với điều kiện:\n\nBăng thông cao\nĐộ trễ cực thấp\nNetworking\n\n\n\nEdge Locations §\n\n🌱 Chứa CloudFront(Amazon’s content delivery network - CDN): truyền tải dữ liệu đến end-user với độ trễ thấp nhất có thể.\n\nAWS Service liên quan đến AWS Solution Architect Exam §\n\nAnd more …"},"40123345-posts/42-Code/42.03-AWS/AWS-Integartion":{"title":"🌱 AWS Integartion","links":["40123345-posts/42-Code/42.03-AWS/Amazon-SQS---Simple-Queue-Service"],"tags":["aws"],"content":"🌿 What? §\n\n\nTrong quá trình phát triển, dự án có thể sử dụng nhiều services lưu trữ và chúng ta cần thực hiện đồng bộ cả về trạng thái cũng như dữ liệu.\n\n\nCó 2 parterns để các services giao tiếp với nhau:\n\nĐồng bộ trực tiếp giữa 2 services\nBất đồng bộ, đặt ở giữa 2 services một Queue, dữ liệu sẽ đi qua queue rồi mới đến service kia.\n\n\n\n\nVới cách 1 sẽ có vấn đề là 2 services sẽ có liên kết và bị ảnh hưởng lẫn nhau, nếu một bên bị quá tải thì service còn lại cx sẽ bị ngáo ngơ.\n\n\nVì vậy mà chúng ta cần tách riêng(decouple) 2 services. Queue trong AWS có cung cấp 3 services:\n\nSQS: queue model\nSNS: pub/sub model\nKinesis: real-time streaming model\n\n\n\nNhững services này có thể được scale độc lập với app của chúng ta.\n\n"},"40123345-posts/42-Code/42.03-AWS/AWS-Lambda---ver2":{"title":"🌱 AWS Lambda - ver2","links":[],"tags":["aws"],"content":"🌿 Limits §\n\n\nGiới hạn của Lambda trên **từng region”\n\nExcution:\n\nBộ nhớ được cấp phát: 128MB - 10GB\nThời gian excution: 900 senconds(15 phút)\nCác biến môi trường: 4KB\nDung lượng lưu trữ trong “funtion container”(in/tmp): 512MB - 10GB\nThực thi đồng thời: 1000(có thể gia tăng)\n\n\nDeployment:\n\nLambda function deployment size(compresed .zip): 50MB\nSize of uncompressed deployment(code + dependencied): 250MB\nCó thể sử dụng thư mục /tmp để load các files khác để khởi động.\nCác biến môi trường: 4KB\n\n\n\n\n\nTrong bài thi nếu người ta hỏi cần 30GB of RAM hay 30 phút excution times hay cần load các files lớn mấy GB thì =&gt; không phải Lambda đâu.\n\n\n🌿 Networking §\n\n\nMặc định Lambda function được launch bên ngoài VPC của chúng ta, nó chạy trong một VPC của AWS. Vì vậy mà nó không thể truy cập được tới các tài nguyên trong VPC của chúng ta(RDS, ElastiCache, internal ELB, …)\n\n\n\nĐể giải quyết vấn đề này, chúng ta cần launch Lambda Funtion trong VPC.\n\nĐầu tiên cần xác định VPC ID, Subnets và Security Groups.\nLambda sẽ tạo ra một ENI trong subnets, thông qua đó để giao tiếp với các resources nằm trong VPC.\n\n\n\n\nTrường hợp sử dụng phổ biến nhất mà cần Lambda nằm trong VPC đó là connect với RDS Proxy.\n\n\nThật ra để Lambda connect trực tiếp với RDS thì cũng được, chỉ cần public access là được. Nhưng vấn đề là không được để Lambda connect trực tiếp với RDS vì rất có thể nó sẽ mở thêm quá nhiều các kết nối, vượt quá khả năng chịu tải của RDS.\n\n\nGiải pháp là sử dụng thằng RDS Proxy ở giữa để nó điều hoà nội tiết các kết nối. Lý do phải cho thằng Lambda này vào VPC bởi vì RDS Proxy không thể set truy cập public được.\n\n\n"},"40123345-posts/42-Code/42.03-AWS/AWS-Lambda":{"title":"🌱 AWS Lambda","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà một dịch vụ tính toán không máy chủ được cung cấp bởi AWS.\nCho phép run code mà không cần chúng ta phải cung cấp hay quản lý servers.\n\n🌿 Why? §\n\nVirtual Functions - không cần quản lý server.\nGiới hạn thời gian excute\nRun on-demand(chạy theo yêu cầu), có yêu cầu gửi đến thì mới chạy. Còn như EC2 là chạy bất kể ngày đêm, chỉ trừ khi chúng tắt\nTự động mở rộng một cách mượt mà, không giống EC2 phải xóa add/remove servers\n\n🌿 Benefits of AWS Lambda §\n\nDễ dàng thanh toán:\n\nTrả theo từng request và thời gian compute\nFree tier cung cấp 1,000,000 AWS Lambda requests và 400,000 GBs thời gian compute\n\n\nTích hợp được với toàn bộ các services của AWS.\nTích hợp được với nhiều ngôn ngữ lập trình.\nDễ dàng giám sát chỉ số thông qua AWS CloudWatch\nDễ dàng lấy thêm tài nguyên cho từng funtions(up to 10GB RAM)\nKhi tăng RAM tự động cũng sẽ phát triển cả CPU và network!\n\n🌿 Language support §\n\nNode\nPython\nJava(tương thích Java 8)\nC#(.NET Core)\nGolang\nC# / Powershell\nRuby\nCustom Runtime API\nLambda Container Image\n\n🌿 Pricing §\n\nPay per calls:\n\n1,000,000 requests đầu tiên sẽ được miễn phí.\n0.2$ cho mỗi 1,000,000 requests tiếp theo.\n\n\nPay per duration:\n\n400,000 GB-seconds thời gian tính toán trong một tháng - free\n= 400,000 seconds ứng với function là 1GB RAM.\n= 3,200,000 seconds ứng với 1288 MB RAM\n\n\nRất rẻ để chạy AWS Lambda nên nó rất rất phổ biến!\n\n🌿 Invoking from RDS &amp; Aurora §\n\n\nTrong thực tế, có những trường hợp chúng ta cần gọi Lambda Funtions từ trong DB instance để thực hiện một tác vụ gì đó (ví dụ như khi người dùng insert một bản ghi vào RDS -&gt; RDS gọi Lambda để Lambda gửi email xác nhận tới người dùng)\n\n\nCho phép chúng ta thực hiện các data events từ trong một databases.\n\n\nHỗ trợ với RDS for PostgreSQL và Aurora MySQL.\n\n\nPhải cho phép outbound traffic của DB instance tới Lambda function.\n\n\nDB instance cần phải yêu cầu quyền để gọi Lambda funtion.(Lambda Resource-based Policy &amp; IAM Policy)\n\n\n\nRDS Event Notifications\n\nChỉ gửi event về trạng thái hoạt động của database(created, stopped, start,…), sẽ không gửi thông tin về dữ liệu.\nĐăng ký để theo dõi các event của: DB Instance, DB snapshot, DB Parameter Group, DB Security Group, RDS Proxy, Custom Engine Version.\nGần với thời gian thực(chậm nhất là 5p có thông báo)\n\n\n"},"40123345-posts/42-Code/42.03-AWS/AWS-Snow-Family":{"title":"🌱 AWS Snow Family","links":[],"tags":["aws"],"content":"🌿 What? §\n\n\nLà dịch vụ có tính bảo mật cao, cung cấp các thiết bị di chuyển được dùng cho mục đích:\n\nThu thập và xử lý dữ liệu trên các edge\nMigrate data trong hoặc ngoài AWS\n\n\n\nData migration:\n\nSnowcone\nSnowball Edge\nSnowmobile\n\n\n\n\nEdge computing:\n\nSnowcone\nSnowball Edge\n\n\n\n\n🌿 Why? §\n\n\nLý do phải sử dụng Snow Family để chuyển dữ liệu vì thời gian truyền tải dữ liệu trên mạng là rất lâu.\n\n\n\nThử thách đưa ra cần giải quyết các vấn đề sau:\n\nKết nối bị giới hạn.\nBăng thông cũng bị giới hạn.\nChi phí di chuyển cao.\nBăng thông bị chia năm sẻ bảy(dùng chung -&gt; không thể sử dụng tối đa được)\nKết nối ổn định(mạng public thì hay chập chờn)\n\n\n\nSnow Family sẽ giải quyết các vấn đề trên bằng cách gửi thiết bị offline đến cho bn(qua bưu điện chẳng hạn), mất tầm khoảng một tuần, bạn nhận được và chỉ việc tải dữ liệu từ thiết bị offline lên AWS thôi.\n\n\n\n🌿 Types §\n🍃 Snowball Edge §\n\n\nGiải pháp vật lý vận chuyển dữ liệu: move TBs hoặc PBs dữ liệu vào hoặc ra từ AWS, thay thế cho việc truyền tải dữ liệu qua mạng(và việc trả phí cho mạng)\nTrả tiền theo từng job\nCung cấp block storage và Amazon S3-compatible object storage\nSnowball Edge Storage Optimized\n\nDung lượng HDD là 80TB\n\n\nSnowball Edge Compute Optimized\n\nDung lượng HDD là 42TB\n\n\nUse Cases: migrate cho dữ liệu lớn trên cloud, phục hồi sau thảm họa, …\n\n🍃 AWS Snowcone &amp; Snowcone SSD §\n\n\nNhỏ gọn, có thể thực hiện tính toán ở bất cứ đâu, bền bỉ và bảo mật, phù hợp với những môi trường cần dữ liệu không lớn.\nNặng khoảng 2.1kg\nSnowcone - 8 TB HDD\nSnowcone SSD - 14 TB SSD\nSử dụng khi Snowball không phù hợp(ví dụ như cần tối ưu cân nặng để mang lên máy bay chẳng hạn)\nPhải cung cấp sạc hoặc pin để nó hoạt động\nCó thể gửi về AWS offline hoặc connect nó với internet và sử dụng AWS DataSync để gửi dữ liệu.\n\n🍃 AWS Snowmobile §\n\n\nLà một cái xe tải chở các thiết bị lưu trữ\nDùng để vận chuyển dữ liệu lên đến exabyte(1EB = 1000PB = 1000000TBs)\nMỗi một Snowmobile(1 xe tải) có dung lượng là 100PB\nBảo mật cao, nhiệt được điều kiểm soát, GPS, video giáo sát 24/7\nTối hơn Snowball nếu chúng ta muốn vận chuyển nhiều hơn 10PB dữ liệu.\n\n🌿 AWS OpsHub §\n\nTrước đây để sử dụng các thiết bị Snow Familly, bạn cần phải có 1 CLI tool\nGiờ chúng ta có thể sử dụng AWS OpsHub(một phần mềm có thể cài vào máy tính) để quản lý các thiết bị Snow Family.\n\n🌿 Snowball into Glacier §\n\nKhông thể chuyển dữ liệu trực tiếp từ Snowball vào Glacier được.\nChúng ta phải sử dụng Amazon S3 để nhận dữ liệu từ Snowball, sau đó kết hợp với S3 lifecycle police để chuyển dữ liệu vào Amazon Glacier.\n\n"},"40123345-posts/42-Code/42.03-AWS/AWS-Step-Function":{"title":"🌱 AWS Step Function","links":["40123345-posts/42-Code/42.03-AWS/AWS-Lambda","40123345-posts/42-Code/42.03-AWS/Amazon-ECS---Elastic-Container-Service","40123345-posts/42-Code/42.03-AWS/AWS-API-Gateway","40123345-posts/42-Code/42.03-AWS/Amazon-SQS---Simple-Queue-Service"],"tags":["aws"],"content":"🌿 What? §\n\nBuild trực quan workflow cho Lambda funtions.\nTính năng: sequence, parallel, conditions, timeouts, error handling, …\nCó thể tích hợp với các AWS services khác như: EC2, ECS, On-premises server, API Gateway, SQS queue, …\nUse cases: order fullfillment, data processing, web applications, any workflow.\n\n"},"40123345-posts/42-Code/42.03-AWS/AWS-Storage-Compare":{"title":"🌱 AWS Storage Compare","links":[],"tags":["aws"],"content":""},"40123345-posts/42-Code/42.03-AWS/AWS-System-Manger":{"title":"🌱 AWS System Manger","links":["40123345-posts/42-Code/42.03-AWS/Networking---VPC/Bastion-Host","40123345-posts/42-Code/42.03-AWS/S3","40123345-posts/42-Code/42.03-AWS/Monitoring/Amazon-CloudWatch","40123345-posts/42-Code/42.03-AWS/Amazon-SNS---Simple-Notification-Service","40123345-posts/42-Code/42.03-AWS/Monitoring/Amazon-EventBridge","40123345-posts/42-Code/42.03-AWS/EBS-Volume---Elastic-Block-Store","40123345-posts/42-Code/42.03-AWS/Monitoring/AWS-Config"],"tags":["aws"],"content":"🌿 SSM Session Manager §\n\nCho phép start một secure shell trên EC2 Instance hoặc on-premise server thông qua IAM Permissions, không cần thông qua bastion host, ssh.\nKhông cần tạo cổng 22 luôn.\nHỗ trợ cho Windows, Linux và MacOS.\nDùng để send session log data đến S3 hoặc CloudWatch Logs\n\n\n🌿 SSM Run Command §\n\n\nThực thi script hoặc chạy một câu lệnh tới các EC2 Instances thông qua SSM Agent.\nOutput sẽ có thể gửi tới CloudWatch Logs, S3, SNS.\nCó thể được gọi từ EventBridge.\n\n🌿 SSM Patch Manager §\n\n\nTự động thực hiện các tiến trình update bản vá cho OS, hệ thống hoặc bảo mật.\nHỗ trợ cho các EC2 Instances và on-premise servers.\nHỗ trợ hệ điều hành Windows, Linux, MacOS.\nPatch on-demand hoặc lập lịch bằng Maintenance Windows.\nScan Instance và gen ra báo cáo về những bản vá cần thiết(phát hiện thiếu bản vá nào).\n\n🌿 Maintenance Windows §\n\n\nGiúp lập lịch để thực hiện các hành động theo maintain theo kế hoạch.\nNó bao gồm:\n\nLịch.\nDIễn ra trong bao lâu\nCác Instances được chỉ định maintain\nCác tasks được chỉ định thực thi\n\n\n\n🌿 Automation §\n\n\nGiúp thực hiện một số các actions đơn giản và thường được sử dụng trong maintain và deploy.\n\nvd như restart instance, create an AMI, EBS snapshot.\n\n\nAutomation Runbook - Là nơi define các actions sẽ thực thi với các EC2 Instances hoặc AWS resources.\nCó thể trigger tới SSM Automation bằng các cách sau:\n\nThủ công kích hoạt thông qua AWS Console, SDK, CLI.\nEventBridge\nMaintenance Windows\nAWS Config\n\n\n"},"40123345-posts/42-Code/42.03-AWS/AWS-Transfer-Family":{"title":"🌱 AWS Transfer Family","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà một dịch vụ toàn quyền quản lý, thực hiện chuyển dữ liệu vào hoặc ra khỏi S3 hoặc EFS bằng giao thức FTP.\nHỗ trợ các giao thức:\n\nAWS Transfer for FTP(File Transfer Protocol)\nAWS Transfer for FTPS(File Transfer Protocol over SSL\nAWS Transfer for SFTP(Secure File Transfer Protocol\n\n\nQuản lý hạ tầng, scalable, reliable, HA(multi-AZ)\nTrả tiền theo endpoint thuê theo giờ + số Gb chuyển dữ liệu.\nLưu trữ và quản lý credential của user trong service.\nTích hợp được với các hệ thống xác thực có sẵn(LDAP, Okta, …)\nUsage: chia sẻ files, public datasets, CRM, ERP, …\n\n"},"40123345-posts/42-Code/42.03-AWS/Amazon-Cognito":{"title":"🌱 Amazon Cognito","links":["40123345-posts/42-Code/42.03-AWS/AWS-API-Gateway","40123345-posts/42-Code/42.03-AWS/Amazon-DynamoDB"],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ cấp phát cho người dùng định danh để có thể giao tiếp với các web hoặc mobile apps.\nCognito User Pools:\n\nĐăng nhập cho người dùng app.\nTích hợp được với API Gateway &amp; Application Load Balancer.\n\n\nCognito Identity Pools:\n\nCung cấp AWS credentials để user có thể truy cập trực tiếp vào các AWS Services.\nTích hợp với Cognito User Pools như một nơi cung cấp định danh.\n\n\nCognito vs IAM:\n\nHàng trăm users.\nSử dụng cho cả mobile users.\nXác thực với SAML.\n\n\n\n🌿 Cognito User Pools(CUP) §\n\n\nTính năng:\n\nTạo ra một database không máy chủ lưu dữ liệu người dùng cho web hoặc mobile apps.\nSimple login\nPassword reset\nVerify email/phone number\nMFA\nLogin với bên thứ3 - Facebook, Github, SAML, …\n\n\n\nMô hình tích hợp với API Gateway và ALB:\n\n\n\n🌿 Cognito Identity Pools §\n\nDiagram:\n\n\n🌿 Row level Security in DynamoDB §\n\nCó thể thông qua Cognito để chỉ định user được đọc những row nào trong DynamoDB.\n\n"},"40123345-posts/42-Code/42.03-AWS/Amazon-ECR":{"title":"🌱 Amazon ECR - Elastic Container Registry","links":["50-til/51-Code/09-Docker/Docker","40123345-posts/42-Code/42.03-AWS/S3"],"tags":["aws"],"content":"🌿 What? §\n\nLà nơi lưu trữ và quản lý các Docker images trên AWS.\nCó thể lưu trữ private hoặc public(trên Amazon ECR Public Gallery).\nTương thích cao với ECS, được S3 hỗ trợ.\nQuản lý truy cập thông qua IAM\nHỗ trợ scanning lỗ hổng bảo mật (vulnerability scanning), quản lý phiên bản, tags, lifecycle, …\n"},"40123345-posts/42-Code/42.03-AWS/Amazon-EKS":{"title":"🌱 Amazon EKS - Elastic Kubernetes Service","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà một cách để launch containers được quản lý bởi các Kubernetes clusters trên AWS.\nKubernetes là một hệ thống open-source hỗ trợ việc tự động deployment, scaling và quản lý các app chạy trên containers.\nCái này là một lựa chọn khác, bên cạnh ECS, cùng chung mục đích những khác API.\nEKS hỗ trợ EC2 nếu chúng ta muốn triển khai các worker nodes hoặc Fargate nếu chúng ta muốn triển khai các serverless containers.\nUse Cases: Nếu công ty, tổ chức đã áp dụng Kubernetes vào hệ thống, thì sài cái này thôi.\nKubernetes là dịch vụ riêng, không thuộc bất kỳ cloud nào, vì vậy chúng ta có thể sử dụng Kubernetes ở các Cloud khác nữa. Có thể chọn EKS để phòng cho sau này muốn chuyển qua sử dụng một Cloud khác.\n\n🌿 Node Types §\n\nManaged Node Groups\n\nTạo và quản lý Nodes(EC2 Instances) cho chúng ta.\nNodes là một phần của ASG đươc quản lý bởi AWS.\nHỗ trợ On-demand và Spot Instances\n\n\nSelf-Managed Nodes\n\nChúng ta tự tạo các nodes và đăng ký chúng với EKS clusters và được quản lý bởi một ASG.\nHỗ trợ On-demand và Spot Instances\n\n\nAWS Fargate\n\nKhông yêu cầu bảo trì, không cần quản lý nodes.\n\n\n\n🌿 Data Volume §\n\nCần chỉ định một StorageClass rõ ràng cho EKS cluster.\nHỗ trợ với:\n\nAmazon EBS\nAmazon EFS(dùng được với Fargate)\nAmazon FSx for Lustre\nAmazon FSx for NetApp ONTAP\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Amazon-Elastic-Transcoder":{"title":"🌱 Amazon Elastic Transcoder","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ convert các media files trong S3 thành định dạng phù hợp với bên nhận files(phone, macbook, …)\nLợi ích:\n\nDễ dàng sử dụng\nCó khả năng mở rộng tốt - không sợ file to\nGiá cả hợp lý, dùng đến đâu trả tiền đến đấy\nChỉ việc dùng thôi các vấn đề còn lại AWS lo.\n\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Amazon-FSx":{"title":"🌱 Amazon FSx","links":[],"tags":["aws"],"content":"🌿 Overview §\n\nLaunch 3rd party - một file system có hiệu suất cao trên AWS.\nDịch vụ toàn quyền quản lý.\n4 loại phổ biến:\n\nFSx for Lustre\nFSx for NetApp ONTAP\nFSx Windows File Server\nFSx for OpenZFS\n\n\n\n🌿 FSx for Windows File Server §\n\nQuản lý hoàn toàn hệ thống file Windows.\nHỗ trợ giao thức SMB và Windows NTFS.\nTich hợp Microsoft Active Directory, ACLs, user quotas.\nCó thể mounted vào trong Linux EC2 Instances.\nHỗ trợ Microsoft’s Distributed File System (DFS) Namespaces(Nhóm các files trên nhiều FS).\nStorage options:\n\nSSD - độ trễ thấp, tính toán nhanh(databases, media processing, data analytics, …).\nHDD - phù hợp để lưu trữ dữ liệu lớn, ít được truy cập hơn.\n\n\nCó thể truy cập từ những hạ tầng có sẵn(VPN chẳng hạn).\nCó thể config multi-AZ.\nDữ liệu được backup hàng ngày vào S3.\n\n🌿 FSx for Lustre §\n\nLà một kiểu hệ thống files phân phối song song, dùng cho những trường hợp tính toán phức tạp\nCái tên Lustre có nguồn gốc từ ‘Linux’ và ‘cluster’\nDùng cho ML, High Performance Computing (HPC)\nStorage options:\n\nSSD\nHDD\n\n\nCó khả năng tích hợp liền mạch với S3\n\nCó thể đọc S3 như một file system(thông qua FSx)\nCó thể ghi ngược vào S3( thông qua FSx)\n\n\nCó thể sử dụng từ những hệ thống sẵn có của mình(VPN chẳng hạn)\n\n🍃 Deployment Options §\n\nScratch File System\n\nLưu trữ tạm thời\nDữ liệu không được nhân bản\nNhanh gấp 6 lần option kia\nUsage: sử dụng với những tiến trình ngắn hạn, tối ưu giá tiền\n\n\nPersistent File System\n\nLưu trữ lâu\nDữ liệu được nhân bản trong AZ\nThay thế file lỗi trong vài phút\nUsage: sử dụng với những tiến trình dài hạn, với những dữ liệu nhạy cảm\n\n\n\n🌿 FSx for NetApp ONTAP §\n\n\nQuản lý NetApp ONTAP trên AWS\nTương thích với các giao thức NFS, SMB, iSCSI.\nCó thể clone dữ liệu tại bất kỳ thời điểm nào.\n\n🌿 FSx for OpenZFS §\n\n\nQuản lý OpenZFS trên AWS\nCó thể clone dữ liệu tại bất kỳ thời điểm nào.\n"},"40123345-posts/42-Code/42.03-AWS/Amazon-Kinesis":{"title":"🌱 Amazon Kinesis","links":[],"tags":["aws"],"content":"🌿 What? §\n\n\nLà dịch vụ giúp chúng ta đơn giản hóa việc thu thập, xử lý cũng như là phân tích luồng dữ liệu một cách realtime.\n\n\nCó 4 loại:\n\nKinesis Data Streams: capture, xử lý và lưu trữ data streams.\nKinesis Data Firehose: load data streams vào các dịch vụ lưu trữ của AWS.\nKinesis Data Analytics: phân tích data streams cùng với SQL hoặc Apache Flick\nKinesis Video Streams: capture, xử lý và lưu trữ video streams.\n\n\n\n\n🌿  Kinesis Data Streams §\n\n\nGiữ lại dữ liệu từ 1 -&gt; 365 ngày.\nCó khả năng xử lý lại dữ liệu.\nMột khi dữ liệu được inserted vào Kinesis thì sẽ không thể xóa.\nData được chia sẻ chung một partition thì sẽ vào chung một shard.\nProducers: AWS SDK, Kinesis Producer(KPL)\nConsumers:\n\nKCL - Kinesis Client Library, AWS SDK\nAWS Lambda, Kinesis Data Firehose, Kinesis Data Analytics.\n\n\n\n🍃 Capacity modes §\n\n\nProvisioned mode\n\nChúng ta được chọn số lượng shards, scale thủ công hoặc sử dụng API\nMỗi shard là 1MB/s in (1000 records mỗi giây)\nMỗi shard là 2MB/s out.\nThanh toán cho từng shard theo giờ.\n\n\n\nOn-demand mode\n\nKhông cần khả năng cung cấp hoặc quản lý.\nMặc định 4MB/s\nTự động scale dựa vào thông lượng được quan sát trong 30 ngày gần nhất.\nTrả tiền theo giờ từng stream, dữ liệu in/out per GB\n\n\n\nNếu không có yêu cầu gì đặc biệt thì chọn on-demand mode dùng cho thuận tiện.\n\n\n🌿 Kinesis Data Firehose §\n\n\nDịch vụ toàn quyền sử lý, khong admin, tự động scale, serverless, giúp chuyển dữ liệu lớn vào storage tier.\nTrả tiền theo dữ liệu được truyền đến Firehose.\nGần real time.\nKhông lưu trữ dữ liệu.\nKhông hỗ trợ khả năng replay.\n\n🌿 Ordering data §\n\nGiả sử app của chúng ta cần thực hiện check vị trí của các xe tải. Số lượng xe tải ngày càng tăng nếu tất cả dữ liệu được đổ vào các shards khác nhau trên Kinesis -&gt; Mất dữ liệu hoặc mất thời gian để truy vấn dữ liệu.\nGiải pháp: Trong Kinesis, muốn dữ liệu được sắp xếp có thứ tự, sử dụng partition key. Vd keys là trunk_1, trunk_2, …\nCác dữ liệu cùng key sẽ được stream trong cùng shard -&gt; dễ dàng tìm kiếm hơn, tránh bị lack mất dữ liệu\n\n\n🌿 Kinesis vs SQS ordering §\n\nGiả sử chúng ta có 100 trucks, 5 shards và 1 SQS FIFO\nVới Kinesis Data Streams:\n\nTrung bình mỗi shard sẽ chứa dữ liệu của 20 trucks\nCác trucks sẽ được sắp xếp trong mỗi shard.\nTối đa có thể có 5 consumers chạy đồng thời.\nCó thể nhận được dữ liệu lên tới 5MB/s\n\n\nSQS FIFO:\n\nChỉ có một Queue\nCó 100 Group ID\nTối đa có thể có 100 consumers\nCó thể nhận được 300 messages mỗi giây(hoặc 3000 nếu kết hợp sử dụng batching)\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Amazon-OpenSearch-Service":{"title":"🌱 Amazon OpenSearch Service","links":[],"tags":["aws"],"content":"🌿 What? §\n\n\nĐược kế thừa từ Amazon ElasticSearch, cung cấp khả năng tìm kiếm dữ liệu mạnh mẽ và linh hoạt trên AWS.\n\n\nChúng ta có thể tìm kiếm bất kỳ field nào thậm chí là cả tìm kiếm theo partially.\n\n\nThường được sử dụng như một phần bổ sung cho các database khác.\n\n\nOpenSearch yêu cầu một cụm các instances(không phải serverless).\n\n\nKhông hỗ trợ sẵn SQL(có thể enabled thông qua plugin)\n\n\nCó thể tìm kiếm ở những services khác nhau như là Kinesis Data Firehose, AWS IoT và CloudWatch Logs.\n\n\nBảo mật thông qua Cognito &amp; IAM, mã hóa KMS, TLS.\n\n\nCó khả năng:\n\nXử lý ngôn ngữ tự nhiên\nTìm kiếm dữ liệu phân tán\n\n\n\n🌿 Cấu trúc §\n\n\nCấu trúc thường được sử dụng với DynamoDB:\n\n\n\nCấu trúc thường được sử dụng với CloudWatch:\n\n\n\nCấu trúc thường được sử dụng với Kinesis Data Streams &amp; Kinesis Data Firehose:\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Amazon-Pinpoint":{"title":"🌱 Amazon Pinpoint","links":["40123345-posts/42-Code/42.03-AWS/Amazon-SES---Simple-Email-Service"],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ cải tiến hơn của SES, nó có thể mở rộng ở cả 2 chiều(inbound và outbound), hỗ trợ cho dịch vụ marketing communication.\nHỗ trợ email, SMS, voice, push và in-app messaging.\nMở rộng tới hàng tỷ tin nhắn một ngày.\nUse case:\n\nChạy chiến dịch marketing, có lượng traffic lớn\nBulk transaction, kiểu như mấy hôm shopee sale\n\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Amazon-QuickSight":{"title":"🌱 Amazon QuickSight","links":[],"tags":["aws"],"content":"🌿 What? §\n\n\nServerless ML, dịch vụ cung cấp khả năng trực quan hóa dữ liệu từ nhiều nguồn cho người dùng.\n\n\nNhanh, có thể tự động scale, có thể nhúng, với per-session pricing.\n\n\nUse cases:\n\nPhân tích nghiệp vụ\nXây dựng trực quan\nGiúp trực quan, hiểu hơn về dữ liệu.\n\n\n\nCó thể kết hợp với nhiều services khác như RDS, Aurora, Athena, Redshift, S3, …\n\n\nIn-memory tính toán sử dụng SPICE engine nếu dữ liệu được import vào QuickSight.\n\n\nPhiên bản doanh nghiệp: Có thể setup bảo mật cho từng cột Column-level security(CLS).\n\n\nCó thể chia sẻ những phân tích hoặc dashboard với Users hoặc Groups.\n\n"},"40123345-posts/42-Code/42.03-AWS/Amazon-Route-53":{"title":"🌱 Amazon Route 53","links":[],"tags":["aws"],"content":"🌿 What? §\n\nDịch vụ cung cấp tính khả dụng cao, khả năng mở rộng cũng như quản lý DNS.\nRoute 53 là một Domain Registrar.\nCó khả năng check the health của các resources\nService duy nhất của AWS cung cấp 100% availability SLA.\nTại sao lại là số 53? 53 là cổng của DNS.\n\n🌿 Records §\n\nĐịnh nghĩa cách mà bạn muốn điều hướng traffic cho một domain\nMột record chứa:\n\nDomain/SubDomain name - vd: example.com\nRecord Type - vd: A or AAAA\nValue - 12.34.56.78\nRouting Policy - Route 53 responds như thế nào\nTTL - thời gian record được cached lại ở DNS Resolvers\n\n\nRoute 53 hỗ trợ những kiểu DNS records sau:\n\nmust know: A/ AAAA / CNAME / NS\nadvance: CAA / DS / MX / NAPTR / PTR / SOA / TXT / SPF / SRV\n\n\n\n🍃 Types §\n\nA - maps một hostname với IpV4\nAAAA - maps một hostname với IpV6\nCNAME - maps một hostname với một hostname khác.\n\nMục tiêu phải là một record A hoặc AAAA\nKhông thể tạo một CNAM record là node đầu tiên của DNS, vd không thể đặt là example.com mà phải đặt là www.example.com\n\n\nNS - Name Servers cho Hosted Zone\n\nKiểm soát lượng truy cập được định tuyến đến một domain.\n\n\n\n🌿 Hosted Zones §\n\nLà khu vực chứa thông tin định tuyến lượng truy cập tới một domain\nPublic Hosted Zones - chứa những records được chỉ định để định tuyến truy cập trên internet\nPrivate Hosted Zones - chứa những records được chỉ định để định tuyến truy cập trong một hoặc nhiều VPCs\nPhải trả 0.5 $ một tháng cho tính năng này.\n\n🌿 Records TTL(Time to Live) §\n\nThời gian chỉ định để clien cache lại thông tin IP của DNS. Nếu TTL chưa hết hạn, khi client gọi lại Domain, sẽ truy cập vào địa chỉ IP đã truy cập lần đầu, kể cả chúng ta có thực hiện thay đổi IP cho DNS. Chỉ đến khi hết hạn TTL, thông tin IP mới mới được refresh.\nHigh TTL, 24h\n\nÍt traffic tới Route 53\nCó thể hết hạn records.\n\n\nLow TTL, 60s\n\nNhiều traffic tới Route 53(thêm $)\nHết hạn records trong thời gian ngắn hơn.\nDễ dàng thay đổi records.\n\n\nNgoại trừ Alias records, TTL là thông tin bắt buộc của mỗi một DNS record.\n"},"40123345-posts/42-Code/42.03-AWS/Amazon-SES---Simple-Email-Service":{"title":"🌱 Amazon SES - Simple Email Service","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ do AWS quản lý, hỗ trợ gửi mail với số lượng lớn và an toàn.\nHỗ trợ thống kê:\n\nsố lượng mail chuyển đi\nkết quả của các feedback\nbao nhiêu email đã được xem, …\n\n\nFlexible IP deployment.\nUse case:\n\nmarketing\nbulk email communications\n\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Amazon-SNS---Simple-Notification-Service":{"title":"🌱 Amazon SNS - Simple Notification Service","links":["40123345-posts/42-Code/42.03-AWS/Amazon-SQS---Simple-Queue-Service"],"tags":["aws"],"content":"🌿 What? §\n\n\n\nGiống với SQS, nhưng cái này theo mô hình publish/subcriber.\n\n\nPhù hợp khi ứng dụng có mô hình một service gửi message tới một số services được chỉ định.\n\n\nMỗi topic có thể set được 12,5000,000 subs.\n\n\nGiới hạn 100,000 topics.\n\n\nCác subcribers có thể nhận notification từ SNS:\n\n\n\nNhiều AWS Services có thể gửi dữ liệu trực tiếp đến SNS:\n\n\n\n🌿 Security §\n\nSame SQS security\n\n🌿 SNS + SQS: Fan Out Pattern §\n\n\nÝ tưởng là muốn một message được gửi tới nhiều Queues.\nGửi noti vào SNS, setup các subcribers là các Queues.\nHoàn toàn tách biệt, không bị mất dữ liệu.\nCó thể thêm nhiêu Queues hơn về sau.\nPhải setup access policy cho phép SNS ghi vào SQS.\nCross-Region Delivery: họat động với cả những Queues khác region.\n\n🌿 FIFO Topic §\n\nGiống với bên SQS.\nNếu set Topic là FIFO thì chỉ có thể nhận SQS FIFO queues là subcribers.\n\n🌿 Message Filtering §\n\n\nNhư một lớp filter theo điều kiện để các Queue nhận message từ SNS.\nNếu không có filter, Queue sẽ nhận được tất cả các messages từ SNS.\n"},"40123345-posts/42-Code/42.03-AWS/Amazon-SQS---Simple-Queue-Service":{"title":"🌱 Amazon SQS - Simple Queue Service","links":["40123345-posts/42-Code/42.03-AWS/ASG---Auto-Scaling-Group"],"tags":["aws"],"content":"🌿 What? §\n\n\nLà dịch vụ lâu đời nhất của AWS - hơn 10 năm.\nDịch vụ lưu trữ messages, sử dụng để tách biệt các ứng dụng của chúng ta.\nAttrubutes:\n\nKhông giới hạn thông lượng, không giới hạn số lượng messages trong queue.\nMặc định tin nhắn sẽ được giữ lại trong 4 ngày, lâu nhất là 14 ngày.\nĐộ trễ thấp\nMỗi message chỉ được gửi tối đa 265Kb.\n\n\nCó thể sẽ nhận được tin nhắn bị duplicate\nCó thể có order messages.\n\n🌿 Producing Messages §\n\n\nGửi messages đến Queue(use SendMessage API)\nMessages tồn tại trong Queue đến khi Consumer xóa\nMặc định giữ lại 4 ngày, nhiều nhất là 14 ngày.\n\n🌿 Consuming Messages §\n\n\nNhận Messages từ Queue(nhận được 10 messages một lần)\nConsumers có thể là EC2 Instance, AWS Lambda, hay server on-premises, …\nKhi nhận message sẽ tiếp tục xử lý(ở code của chúng ta)\nSau khi nhận xong thì sẽ gọi API xóa message trong Queue(DeleteMessage API)\n\n🌿 Kiến trúc phổ biến §\n\n\nHiểu đơn giản SQS là một nơi lưu trữ các job để xử lý bất đồng bộ cho hệ thống của chúng ta.\nVí dụ, hệ thống cần chỉnh sửa video, nhưng tác vụ chỉnh sửa sẽ mất thời gian ở phía backend, để tăng trải nghiệm của người dùng, chúng ta chuyển tác vụ chỉnh sửa vào Queue để chạy bất đồng bộ, người dùng có thể tiếp tục thao tác mà không cần phải ngồi đợi chỉnh sửa video xong.\nHoàn toàn tách biệt các tầng của hệ thống\n\nTầng Front-End\nTầng Back-End\nTầng Database\n\n\nKết hợp với Auto-Scaling để tự động mở rộng đáp ứng với nhu cầu sử dụng của Queue.\n\n🌿 Security §\n\nEncryption:\n\nIn-flight encryption using - HTTPS API\nMã hóa phần còn lại với KMS Keys\nClient-side encryption nếu clients muốn tự thực hiện mã hóa/giải mã.\n\n\nAccess Controls: IAM policies\nSQS Access Policies:(giống cái S3 bucket polices)\n\nHữu ích khi muốn truy cập chéo account\nHữu ích khi cho phép những services khác(SNS, S3, …) được quyền ghi.\n\n\n\n🌿 Message visibility timeout §\n\n\nLà khoảng thời gian cooldown sau khi có một consumer nhận được message, các consumers khác không thể nhận được message. Cái này sẽ tránh việc 2 consumers nhận 1 message và thực hiện logic.\nMặc định, timeout là 30s\nHết thời gian timeout, các consumers khác sẽ có thể nhận được messages, nếu trong thời gian đó nó chưa được xóa.\nNhưng trên thực tế, có thể consumer sẽ cần nhiều hơn 30s để thực hiện logic với message. Để cần thêm thời gian timeout, consumer có thể call ChangeMessageVisibility API.\nLưu ý không nên set timeout quá dài hoặc ngắn vì:\n\nNếu thời gian timeout quá dài(hàng giờ liền), consumer nhận message bị crashes vì một lý do nào đó, hệ thống sẽ phải đợi hàng để message visible trở lại để một consumer khác có thể nhận và thực hiện logic với nó.\nNếu thời gian timeout quá ngắn, consumer chưa xử lý xong mà đã hiển thị để một consumer khác nhận được message, hệ thống có thể sẽ thực hiện logic 2 lần trên cùng một message.\n\n\n\n🌿 Long Polling §\n\nKhi một consumer requests message từ Queue, nó có thể lựa chọn là đợi (chứ không ngắt poll luôn) khi Queue đang trống.\nLongPolling giảm số lượng API gọi đến SQS, tăng hiệu quả và giảm độ trễ(nhận được message ngay khi nó được đẩy vào Queue).\nThời gian đợi có thể được set từ 1s -&gt; 20s.\nLong Polling sẽ được khuyến khích sử dụng hơn Short Polling\nLong polling có thể được enabled trong Queue hoặc có thể sử dụng API WatiTimeSeconds để set thời gian đợi.\n\n🌿 FIFO Queue §\n\n\nFIFO =  FIrst In First Out\nGiới hạn thông lượng: 300 message/s\nTránh việc gửi duplicate\nCác messages được thực thi theo đúng thứ tự.\nChỉ có nhận một consumer.\n\n🍃 Ordering data §\n\nVì chỉ nhận một consumer -&gt; hiệu suất kém -&gt; muốn scale lên nhiều consumers -&gt; sử dụng Group ID\nCác messages vẫn được gửi theo thứ tự FIFO, những mỗi message sẽ được gắn với một group. Từ đó có thể tạo ra nhiều consumers, mỗi consumer sẽ poll messages ứng với mỗi group.\n\n\n🌿 Integrate with Auto Scaling Group §\n\n\nSử dụng cái CloudWach Metric để theo dõi số lượng messages trong Queue\nNếu nhiều hơn 100 chẳng hạn(server không xử lý kịp), cái CloudWatch Alarm sẽ báo cho ASG để thực hiện mở rộng, đáp ứng khả năng xử lý messages trong Queue, tương tự khi scale down.\n\n🌿 Kiến trúc sử dụng Queue làm buffer khi ghi dữ liệu lớn vào database §\n\n\nVí dụ chúng ta có một trang thương mại điện tử và vào đợt sale, mọi người mua hàng rất rất nhiều. Nếu để server ghi trực tiếp dữ liệu vào databases, khả năng cao database sẽ bị quá tải và sẽ bị mất một số giao dịch của người dùng.\nGiải pháp cho vấn đề này là sử dụng SQS, như vậy thì tất cả giao dịch của người dùng sẽ nằm trong Queue, một server khác sẽ có trách nhiệm nhận lại messages và thực hiện ghi dữ liệu dần dần vào databases.\n"},"40123345-posts/42-Code/42.03-AWS/Big-Data-Ingestion-Pipeline":{"title":"🌱 Big Data Ingestion Pipeline","links":["40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Serverless","40123345-posts/42-Code/42.03-AWS/S3","40123345-posts/42-Code/42.03-AWS/Amazon-Kinesis","40123345-posts/42-Code/42.03-AWS/AWS-Lambda","40123345-posts/42-Code/42.03-AWS/Databases/Amazon-Athena","40123345-posts/42-Code/42.03-AWS/Redshift","40123345-posts/42-Code/42.03-AWS/Amazon-QuickSight"],"tags":["aws"],"content":"🌿 Requirements §\n\nServerless\nMuốn thu thập dữ liệu real-time\nMuốn chuyển đổi dữ liệu\nMuốn truy vấn dữ liệu đã qua chuyển đổi bằng SQL\nCác báo cáo được tạo ra từ truy vấn cho S3.\nMuốn load dữ liệu vào một warehouse và tạo dashboard.\n\n🌿 Architecture §\n\n\nServerless\n\nKinesis Data Streams: real-time\nKinesis Data Firehose: giúp delivery dữ liệu gần real-time(1 phút)\nS3: lưu trữ\nLambda: chuyển đổi dữ liệu\nAthena: truy vấn dữ liệu đã qua chuyển đổi\nRedshift -&gt; QuickSight: tạo báo cáo, load vào warehouse và tạo dashborad.\n\n\n"},"40123345-posts/42-Code/42.03-AWS/CNAME-and-Alias":{"title":"🌱 CNAME and Alias","links":[],"tags":["aws"],"content":"🌿 What? §\n\nCả 2 đều là loại bản ghi DNS của Route53.\nCNAME:\n\nÁnh xạ một tên miền cho một tên miền khác.\nChỉ dùng được cho NON-ROOT DOMAIN.\n\n\nAlias:\n\nÁnh xạ một tên miền tới các AWS Resource(ELB, CloudFront, …)\nDùng được cho cả ROOT DOMAIN và NON ROOT DOMAIN.\nKhông phải trả phí.\nCó sẵn health check.\n\n\n\n🌿 Alias Records §\n\nÁnh xạ domain tới một AWS resource.\nMột extension\nTự động nhận ra các thay đổi đối với địa chỉ IP của các resources.\nKhông như CNAME, có thể sử dụng với top node của DNS namespace(Zone Apex)\nLuôn luôn là kiểu A/ AAAA đối với các AWS Resources\nKhông thể thiết lập TTL, nó sẽ được Route53 tự động set.\n\n🌿 Targets §\n\n\nKhông thể set Alias Record cho một EC2 DNS\n"},"40123345-posts/42-Code/42.03-AWS/Cost-Explorer":{"title":"🌱 Cost Explorer","links":[],"tags":["aws"],"content":"🌿 What? §\n\n\nLà dịch vụ giúp chúng ta quản lý các vấn đề về chi phí cũng như mức độ sử dụng một cách trực quan hoá, dễ tiếp cận.\n\n\nNó giúp chúng ta tạo báo cáo tuỳ chỉnh theo chi phí và mức độ sử dụng đã qua phân tích(theo tháng hoặc theo giờ).\n\n\nNgoài ra nó còn giúp chúng ta phân tích dữ liệu ở high level: tổng chi phí cũng như mức độ sử dụng trên nhiều accounts.\n\n\nTừ đó giúp chúng ta chọn được Savings Plan để có chi phí sử dụng tốt hơn.\n- Dự đoán mức độ sử dụng cho 12 tháng tới theo những dữ liệu đã có từ trước.\n\n\nTheo tháng:\n\n\n\nTheo giờ:\n\n\n\nSavings Plan - từ mức độ sử dụng lựa chọn plan phù hợp:\n\n\n\nForecast:\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Customization-At-The-Edge":{"title":"🌱 Customization At The Edge","links":[],"tags":["aws"],"content":"🌿 What? §\n\n\nTrong thực tế, có những lúc app của chúng ta cần chạy một số form logic trên các edges. Để thực hiện việc này chúng ta có thể sử dụng Edge Function.\n\n\nEdge Function:\n\nThực thi một đoạn code của chúng ta trên các bản phân phối của CloudFront.\nCác đoạn code được chạy ở gần với users, đạt được độ trễ tối đa.\n\n\n\nCloudFront cung cấp 2 loại: CloudFront Functions &amp; Lambda@Edge\n\n\nChúng ta không cần tạo, quản lý hay triển khai bất kỳ server, serverless.\n\n\nUse Cases: khi muốn custom lại CDN content.\n\n\nChỉ phải trả tiền khi sử dụng, còn để đấy không động vào thì không mất phí.\n\n\n🌿 CloudFront Functions §\n\n\nLà các lightweight functions được viết bởi Javascript.\n\n\nCó khả năng mở rộng cao, độ trễ thấp\n\n\nThời gian khởi động cực nhanh, tốc độ xử lý requests là cả triệu requests/giây.\n\n\nSử dụng để thực hiện thay đổi requests/responses của user.\n\n\nĐây là tính năng có sẵn của CloudFront(code được quản lý toàn bộ trong CloudFront)\n\n\n\nUse cases:\n\nCache key\nThao tác với Header(thêm, xoá, sửa HTTP headers trong các requests hoặc responses)\nViết lại URL hoặc thực hiện redirects.\nRequest xác thực hoặc phân quyền.\n\n\n\n🌿 Lambda@Edge §\n\nLambda functions được viết bởi NodeJS hoặc Python.\nScales lên 1000 yêu cầu/giây\nSử dụng để thay đổi các requests/response của cả viewer và origin server.\nCấp quyền cho các funtions trong một AWS Region, sau đó CloudFront sẽ sao chép đến các locations của nó.\n\nUse cases:\n\nCác tác vụ cần thời gian lâu hơn để thực thi.\nĐiều chỉnh CPU hoặc memory\nCode của chúng ta phụ thuộc vào một thư viện bên thứ 3.\nNetwork access để sử dụng các services nội bộ.\nTruy cập vào hệ thống file hoặc body của các HTTP requests -&gt; tuỳ chỉnh được nhiều hơn.\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Databases/AWS-Lake-Formation":{"title":"🌱 AWS Lake Formation","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ quản lý dữ liệu trên AWS, giúp chúng ta dễ dàng xây dựng và quản lý các data lakes trên nền tảng AWS.\nData lake là một nơi lưu trữ dữ liệu phi cấu trúc và cấu trúc từ nhiều nguồn dữ liệu khác nhau đổ về. Phân tích được lake sẽ đưa ra cái nhìn toàn diện từ đó đưa ra được các quyết định chính xác hơn.\nCác nguồn dữ liệu có thể là: RDS, S3, Relational &amp; NoSQL DB, …\nAccess control cho từng row và col.\nBuilt trên AWS Glue.\n\n"},"40123345-posts/42-Code/42.03-AWS/Databases/Amazon-Athena":{"title":"🌱 Amazon Athena","links":["40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Serverless","40123345-posts/42-Code/42.03-AWS/S3","40123345-posts/42-Code/42.03-AWS/AWS-Lambda","40123345-posts/42-Code/42.03-AWS/Databases/Amazon-DynamoDB","40123345-posts/42-Code/42.03-AWS/Databases/Amazon-RDS---Relational-Database-Service"],"tags":["aws"],"content":"🌿 What? §\n\n\nLà dịch vụ query serverless, dùng để phân tích dữ liệu trong S3.\n\n\nSử dụng ngôn ngữ SQL tiêu chuẩn để query files(built trên Presto).\n\n\nHỗ trợ các định dạng CSV, JSON, ORC, Avro, và Parquet.\n\n\nGiá: 5$ trên một TB dữ liệu scan.\n\n\nThường được kết hợp với một dịch vụ khác là Amazon QuickSight để báo cáo hoặc làm dashboard.\n\n\nUse cases: Phân tích/ báo cáo, CloudTrail trails, …\n\n\nNói chung là muốn phân tích dữ liệu lưu trong S3 bằng serverless SQL thì sử dụng Athena.\n\n\n🌿  Performance Improvement §\n\nSử dụng columnar data khi chỉ muốn scan đúng cột chúng ta cần.(less scan)\n\nTiết kiệm chi phí\n\n\nCompress data cho những truy suất nhỏ hơn\nPartition datasets trong S3, giúp query dễ dàng hơn trên các cột ảo.\nUse larger files(&gt; 128MB) để tối thiểu overhead(truyền tải tốt hơn).\n\n🌿  Federated Query §\n\nAthena cho phép chúng ta chạy SQL queries cho cả những dự liệu được lưu trữ dưới dạng relational, non-relational, object và custom data sources(AWS hoặc on-premises)\nSử dụng Data Source Connectors(AWS Lambda) để chạy Federated Queries(queries tới CloudWatch Logs, DynamoDB, RDS, …)\nLưu trữ kết quả phân tích được vào lại S3.\n"},"40123345-posts/42-Code/42.03-AWS/Databases/Amazon-Aurora":{"title":"🌱 Amazon Aurora","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà công nghệ độc quyền của AWS(không phải open source)\nTương thích với Postgres và MySQL.\nAurora là AWS  cloud optimized, x5 performance so với MySQL trên RDS và x3 performance so với Postgres trên RDS.\nTự động tăng bộ nhớ, từ 10Gb(mặc định) có thể tăng lên 128TB\nAurora có 15 replicas trong khi MySQL có 5, và replication process cũng nhanh hơn(10ms)\nChuyển đổi dự phòng là tức thời. Đảm bảo High Available\nGía của Aurora đắt hơn 20% so với RDS, nhưng nó cũng hiểu quả hơn.\n\n🌿 High Availability và Read Scaling §\n\nLuôn tạo ra 6 bản sao ở trên 3 AZ mỗi khi ghi gì đó vào DB. Có khả năng nhân rộng, tự hồi phục cũng như tự động mở rộng.\n\n4 bản sao trong 6 dùng để viết.\n3 bản sao dùng để đọc\n\n\nCó một Aurora Instance để ghi (master)\nTự động chuyển đổi dự phòng nếu master có lỗi trong vòng chưa đến 30s.\nMaster + 15 read replicas\nHỗ trợ nhân rộng giữa các Region.\n\n🌿 Aurora DB Cluster §\n\n\nLuôn chia sẻ dữ liệu lưu trữ với tất cả các cụm(master + read replicas)\nClient connect thẳng tới master để ghi dữ liệu(writer endpoint)\nClient conenct tới một Connection Load Balancing(reader endpoint) để truy cập đến cụm read replicas.\n\n🌿 Feature of Aurora §\n\nTự động chuyển đổi dự phòng nếu có lỗi\nLiên tục backup và recovery\nBảo mật và luôn sẵn sàng sử dụng\nTự động scaling\nZero downtime\nCó thể restore data tại bất kỳ thời điểm nào.\n\n🌿 Custom EndPoint §\n\nCho phép xác định custom endpoint để thực hiện tác vụ riêng.\nVí dụ cta có một cụm instance to hơn và nó tính toán tốt hơn, tạo một custom endpoint trỏ đến cụm đó để thực hiẹn các query phân tích dữ liệu(hay các query cần tính toán nhiều) để xử lý nhanh hơn.\n\n\n🌿 Aurora không có máy chủ §\n\nTự động tạo khởi tạo cũng như scaling dựa theo tình trạng sử dụng thực tế.\nPhù hợp với những ứng dụng không dự đoán trước được lưu lượng sử dụng.\nKhông cần lên kế hoạch sử dụng.\nDùng đến đâu trả đến đấy.\n\n🌿 Aurora Multi-Master §\n\nTrong trường hợp muốn chuyển đổi dự phòng ngay lập tức(chứ không phải đợi tầm khoảng 30s - HA), lựa chọn option này.\nTất cả các nodes đều được dùng để R/W và liên kết trực tiếp với client.(thay vì chuyển node chỉ đọc lên làm master)\n\n\n🌿 Global Aurora §\n\nAurora Cross Region Read replicas\n\nĐề phòng thảm hoạ\nDễ dàng đặt ở mọi nơi\n\n\nAurora Global Database (khuyên dùng)\n\n1 Primary Region(đọc/ghi)\nTối đa 5 regions phụ(chỉ đọc), nhân bản có ping nhỏ hơn 1s\nMỗi region phụ có thể có tối đa 16 read replicas, giảm độ trễ khi đọc dữ liệu\nKhôi phục dữ liệu sau thảm hoạ trong vòng 1 phút.\nChưa đến một giây để sao chép toàn bộ dữ liệu trên tất cả regions.\n\n\n\n🌿 Aurora Machine Learning §\n\nSupport services:\n\nAmazon SageMaker(dùng với bất kỳ model ML nào)\nAmazon Comprehend (dùng để phân tích cảm tính, đề xuất sản phẩm, …)\n\n\n\n\n🌿 Aurora Backups §\n\nGiống với RDS backups\n\nBackup tự động\n\nLưu trữ trong 1-35 ngày\nBackup tại tất cả các thời điểm, vì vậy chúng ta có thể lấy lại dữ liệu tại bất kỳ thời điểm nào.\n\n\nBackup thủ công\n\nUser tự thực hiện\nLưu trữ vô thời hạn\n\n\n\n\n\n🌿 Restore Options §\n\nRestoring từ Aurora backup hoặc snapshot tạo một database mới.\nRestoring MySQL Aurora cluster từ S3\n\nTạo một backup sử dụng Percona XtraBackup\nLưu file backup vào S3\nRestore từ file backup đó\n\n\n\n🌿 Aurora Database Cloning §\n\nTạo một Database Cluster mới từ cái có sẵn.\nNhanh hơn snapshot&amp;restore\nMột DB mới được tạo ra, giống y hệt cái cũ nhưng không đồng bộ(ko liên quan gì đến nhau, vd một cái dùng cho staging, mọt cái dùng cho production)\nRất nhanh và giá cả phải chăng\nHữu ích khi muốn tạo một staging database từ production database và không ảnh hưởng đến môi trường production.\n"},"40123345-posts/42-Code/42.03-AWS/Databases/Amazon-DynamoDB":{"title":"🌱 Amazon DynamoDB","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ cung cấp cơ sở dữ liệu toàn quyền quản lý, HA(Highly available) với khả năng nhân bản trên nhiều AZs.\nKiểu NoSQL - không phải kiểu quan hệ. Hỗ trợ transaction.\nCó khả năng scale với những dự án lớn.\nChịu được hàng triệu requests mỗi giây, hàng triệu triệu hàng, và hàng trăm TB dung lượng.\nHiệu suất nhanh và nhất quán.\nTích hợp được với IAM để bảo mật, phân quyền và quản trị viên.\nChi phí thấp và có khả năng tự động scaling\nKhông bảo trì hay vá version, vì AWS luôn cung cấp sẵn infrastructure nên không cần lo.\nCó 2 loại bảng trong DynamoDB:\n\nStandard Table\nInfrequent Access(IA) Table\n\n\n\n🌿 Basics §\n\nDynamoDB được tạo thành từ các bảng.\nTừng bảng có mọt Primary Key được chỉ định từ lúc khởi tạo.\nTừng bảng có thể có vô hạn các item(các hàng).\nTừng item có các attributes(có thể thêm bất kỳ lúc nào - có thể null)\nMột item có size tối đa là 400KB\nCác kiểu dữ liệu được hỗ trợ:\n\nScalar Types: String, Number, Binary, Boolean, Null.\nDocument Types: List, Map.\nSet Types: String Set, Number Set, Binary Set.\n\n\nVì vậy, DynamoDB có thể giúp chúng ta phát triển nhanh chóng.\n\n🌿 Read/Write Capacity Modes §\n\nKiểm soát thông lượng. Có 2 mode:\nProvisioned Mode(default)\n\nCó thể chỉ định số lượng reads/writes trên mỗi giây\nBạn cần có một plan về khả năng sử dụng trước.\nTrả cho Read Capacity Units (RCU) &amp; Write Capacity Units (WCU)\nCó thể add auto-scaling cho RCU và WCU\n\n\nOn-Demand Mode\n\nRead/write tự động được scale theo khả năng sử dụng.\nKhông cần phải lên kế hoạch sử dụng trước.\nDùng đến đâu, trả đến đấy - đắt hơn cái trên\nPhù hợp với những app không dự đoán trước được khả năng sử dụng, hoặc các app thử nghiệm, có thời gian sử dụng không dài.\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Databases/Amazon-ECS---Elastic-Container-Service":{"title":"🌱 Amazon ECS - Elastic Container Service","links":["50-til/51-Code/09-Docker/Docker"],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ của AWS, giúp dễ dàng chạy và quản lý các Docker containers trên 1 cụm EC2 instances hoặc AWS Fargate - một công cụ tính toán không máy chủ cho các containers.\nLaunch Docker container on AWS = Launch EC2 Tasks trên ECS Cluster.\n\n🌿 EC2 Launch Type §\n\nEC2 Launch Type: bạn phải cung cấp và bảo trì cho cơ sở hạ tầng(là các EC2 instances)\nMỗi EC2 Instance phải chạy một ECS Agent để đăng ký trên ECS Cluster. Sau đó, AWS có thể takes care việc starting/stopping các containers.\n\n\n🌿 Fargate Type §\n\nLaunch Docker containers trên AWS mà không cần tạo bất kỳ một EC2 Instances nào - tất cả đều là serverless\nChỉ cần tạo task định nghĩa, AWS sẽ thực hiện chạy ECS Tasks cho chung ta dựa theo lượng CPU/RAM mà chúng ta cần.\nKhi mở rộng, chỉ cần tạo thêm các tasks, không cần tạo thêm EC2 Instances.\nTrong khi đi thi, Fargate Type được khuyến khích sử dụng hơn vì nó là serverless - dễ mở rộng và quản lý.\n\n\n🌿 IAM Roles §\n\nCó 2 dạng ứng với 2 type.\nEC2 Instance Profile (EC2 Launch Type only):\n\nChỉ được sử dụng bởi các ECS Agents\nTác dụng:\n\nSử dụng để gọi API tới ECS service.\nGửi container logs đến CloudWatch Logs\nPull Docker image từ ECR\nXem các dữ liệu nhạy cảm trong Secrets Manager hoặc SSM Parameter Store.\n\n\n\n\nECS Task Role:\n\nCho phép các task sử dụng(mỗi task sẽ có những roles được chỉ định)\nTác dụng:\n\nSử dụng role để truy cập tới các AWS services của bạn.\nTask Role được định nghĩa trong task definition.\n\n\n\n\n\n\n🌿Tích hợp với Load Balancer §\n\nALB - Application Load Balancer: có được hỗ trợ và chạy được với hầu hết các use cases.\nNetwork Load Balancer: nên sử dụng với các use cases cần thông lượng/hiệu suất cao hoặc là khi sử dụng với AWS Private Link.\n\n\n🌿 Data Volumes (EFS) §\n\nMount thẳng EFS vào ECS tasks.\nCó thể chạy được với cả 2 Type: EC2 Launch Type and Fargate Type.\nCác tasks chạy trên bất kỳ AZ nào cũng sẽ chia sẻ chung dữ liệu trên EFS(chung một mối)\nFargate + EFS =  Serverless.\nUse cases: cần chia sẻ và dùng chung dữ liệu cho các containers trên nhiều AZ.\nNote:\n\nS3 không thể mount được như một file system.\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Databases/Amazon-EMR---Elastic-MapReduce":{"title":"🌱 Amazon EMR - Elastic MapReduce","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ hỗ trợ quản lý các clusters Hadoop(Big Data) để phân tích và triển khai các ứng dụng big data.\nClusters có thể được tạo bởi hàng trăm EC2 instances.\nEMR nó take care hết toàn bộ các tài nguyên cung cấp cũng như thông số thiết lập.\nTự động scale và tích hợp với Spot instances.\nUse case: data processing, ML, web indexing, big data, …\n\n🌿 Node types §\n\nMaster Node: quản lý cluster, điều phối, quản lý sức khỏe - chạy dài hạn.\nCore Node: Chạy các tasks và lưu trữ dữ liệu - chạy dài hạn.\nTask Node(optional): chỉ để chạy task - thường là Spot.\n\n🌿 Purchasing §\n\nOn-demand: tin cậy, có thể dự tính, sẽ không bị terminated.\nReserved(min là1 năm): tiết kiệm chi phí(EMR sẽ tự động sử dụng option này nếu nó phù hợp)\nSpot instances: rẻ hơn nhưng có thể bị terminated nếu được giá =)) kém độ uy tín.\n"},"40123345-posts/42-Code/42.03-AWS/Databases/Amazon-ElastiCache":{"title":"🌱 Amazon ElastiCache","links":[],"tags":["aws"],"content":"🌿 What? §\n\nDịch vụ lưu cache của Amazon, hỗ trợ Redis hoặc Memcached.\nCache mang lại hiệu suất cao(dữ liệu cần đã có sẵn, chỉ việc lấy ra dùng), đỗ trễ thấp.\nGiảm thiểu số lượng queris đọc vào database.\nGiống RDS, Amazon sẽ takes care OS, patching, optimizations, setup configuration, monitoring, failure recovery and backups.\nSử dụng ElastiCache sẽ phải thêm code.\n\n🌿 Redis vs Memcached §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRedisMemcachedMulti-AZ và tự động chuyển đổi dự phòngMulti-node để phân vùng dữ liệuRead replicas để scale đọc và high availabilityKhông High AvailibilityDữ liệu bền - persistenceDữ liệu không bềnCó chức năng Backup và RestoreKhông cóHỗ trợ Sets và Sorted SetsKiến trúc đa luồng\n🌿 Security §\n\nIAM Authentication for Redis, chỉ được dùng với AWS API-level security\nRedis AUTH\n\nset một cặp “password/token” khi tạo một cụm Redis cluster mới\n\n\nMemcached\n\nhỗ trợ SASL.\n\n\n\n🌿 Patterns §\n\nLazy Loading\nWrite Through\nSession Store\n\n🌿 Use Case §\n\nXếp hạng Gaming, cần tính toán phức tạp. Redis Sorted đảm bảo tính uniq cũng như thứ hạng của elements.\n"},"40123345-posts/42-Code/42.03-AWS/Databases/Amazon-Glue":{"title":"🌱 Amazon Glue","links":["40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Serverless"],"tags":["aws"],"content":"🌿 What? §\n\n\nLà dịch vụ ETL(Extract, transform và load)\n\n\nHữu ích để chuẩn bị và chuyển đổi dữ liệu để phân tích.\n\n\nserverless\n\n\n\nGlue Job Bookmarks: ngăn ngừa việc xử lý lại dữ liệu cũ.\n\n\nGlue Elastic Views:\n\nKết hợp và sao chép dữ liệu trên nhiều dữ liệu lưu trữ bằng SQL.\nKhông custom code, Glue quan sát những thay đổi trong source data, serverless.\nTạn dụng một bảng ảo.\n\n\n\nGlue DataBrew: làm sạch và chuẩn hóa dữ liệu sử dụng pre-built transformation.\n\n\nGlue Studio: GUI mới để tạo, chạy và quan sát ETL jobs trong Glue.\n\n\nGlue Stream ETL: tương thích với Kinesis Data Streaming, Kafka, MSK.\n\n"},"40123345-posts/42-Code/42.03-AWS/Databases/Amazon-RDS---Relational-Database-Service":{"title":"🌱 Amazon RDS - Relational Database Service","links":["40123345-posts/42-Code/42.03-AWS/EBS-Volume---Elastic-Block-Store"],"tags":["aws"],"content":"🌿 What? §\n\nService quản lý DB sử dụng SQL là query language, cho phép cta có thể tạo databases trên cloud.\nCác types AWS quản lý:\n\nPostgres\nMySQL\nMariaDB\nOracle\nMicrosoft SQL Server\nAurora\n\n\n\n🌿 Advantage §\n\n\nTự động cập nhật cũng như vá OS.\n\n\nLiên tục backup và restore tại một thời diểm chỉ định\n\n\nCó thể quan sát được thông số hoạt động\n\n\nCó thể đọc bản sao để cải thiện hiệu suất đọc dữ liệu\n\n\nCó thể setup trên nhiều AZs bằng DR(Disaster Recovery)\n\n\nCó thể scaling(cả dọc và ngang)\n\n\nBackup dữ liệu trên EBS.\n\n\nNhưng không thể SSH vào instances.\n\n\n🌿 Storage Auto Scaling §\n\nLà tính năng giúp chúng ta có thể tự động tăng thêm bộ nhớ để lưu trữ trong TH free storage được sử dụng hết.\nTránh mở rộng bằng cách thủ công\nCó thể set Maximum Storage Threshold, không được scale quá ngưỡng này.\nTính năng sẽ được kích hoạt mở rộng bộ nhớ khi:\n\nFree space nhỏ hơn 10%\nDung lượng lưu trữ thấp quá 5p\n6h trôi qua kể từ lần modification cuối cùng.\n\n\nHữu ích với những app không dự đoán được trước lượng dữ liệu.\nHỗ trợ cho các engines: MariaDB, PostgreSQL, SQL Server, Oracle.\n\n🌿 Read Replicas §\n\nTăng khả năng đọc dữ liệu, có thể tạo nhiều nhất 5 Read Replicas, thuộc về một AZ, khác AZ hoặc khác Region.\nASYNC.\nReplicas có thể chuyển thành DB\n\n🍃 Network Cost §\n\nTrong AWS, khi dữ liệu đi từ AZ này sang AZ khác sẽ phải chịu phí, nhưng Với những RDS Read Replicas trong cùng một region, không phải trả phí.\n\n\n🌿 RDS Multi AZ (Disaster Recovery) §\n\nChủ yếu là để khôi phục sau thảm họa(sóng thần cuốn mất data center 😔)\nTăng availability\nSYNC replication\nKhông dùng với mục đich scale\nPhòng trường hợp AZ mất kết nối, mất mạng hoặc instance hay store bị lỗi.\n\n🌿 From Single-AZ to Multi-AZ §\n\nZero downtime, không cần dừng DB\nCơ chế hoạt động:\n\nMột snapshot được tạo từ DB chính.\nDB mới được restored ở region mới từ snapshot.\nQuá trinh đồng bộ được thành lập giữa 2 databases.\n\n\n\n\n🌿 RDS Custom §\n\nQuản lý Oracle và Microsoft SQL Server Database cùng với OS và tuỳ biến database.\n|RDS|RDS Custom|\n|----|-------------|\n|tự động setup, hoạt động và scaling| truy cập được vào OS, databasem, có thể setting config, install patches, bật native features, truy cập vào EC2 Instance bằng SSH hoặc SSM Session Manager|\nDe-active Automation Mode để thực hiện custiomization, tốt hơn là nên tạo một DB snapshot trước.\n\n🌿 RDS Backups §\n\nTính năng cho phép lưu lại dữ liệu để có thể restore khi dữ liệu bị mất hoặc nếu cần.\nCó hai loại:\n\nBackups tự động\n\nBackup hàng ngày\nTransaction logs ffoec backups 5p một lần\nCó thể set thời gian lưu trữ (1 -&gt; 35 ngày), sau thời gian này sẽ không restore lại được nữa. Hoặc có thể set = 0 để disable tính năng này.\n\n\nBackup thủ công (DB Snapshots)\n\nThực hiện thủ công\nGiữ lại backup vô thời hạn.\n\n\n\n\nTrick: Nếu stop RDS database, chúng ta vẫn sẽ phải trả một khoản tiền cho bộ nhớ. Nếu chúng ta có kế hoạch sẽ stop lâu lâu, thì có thể snapshot để lưu trữ, sau dùng thì restore lại.\n\n🌿 RDS Restore §\n\nRestoring từ RDS backup hoặc snapshot tạo một database mới.\nRestoring MySQL RDS database từ S3\n\nTạo một backup sử dụng Percona XtraBackup\nLưu file backup vào S3\nRestore từ file backup đó\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Databases/Database-in-AWS":{"title":"🌱 Database in AWS","links":["40123345-posts/42-Code/42.03-AWS/Databases/Amazon-RDS---Relational-Database-Service","40123345-posts/42-Code/42.03-AWS/Databases/Amazon-Aurora","~JSON","40123345-posts/42-Code/42.03-AWS/Databases/Amazon-ElastiCache","40123345-posts/42-Code/42.03-AWS/S3","40123345-posts/42-Code/42.03-AWS/EBS-Volume---Elastic-Block-Store","40123345-posts/42-Code/42.03-AWS/Databases/Amazon-DynamoDB"],"tags":["aws"],"content":"🌿 Types §\n\nRDBMS(=SQL/OLTP): RDS, Aurora.\nNoSQL: Amazon DynamoDB|DynamoDB], ElastiCache (key/value), Neptune(graphs),DocumentDB(MongoDB), Keyspaces(Apache Cassandra).\nObject Store: S3(cho những object lớn) / Glacier(backup/archives).\nData Warehouse: Redshift(OLAP), Athena, EMR.\nSearch: OpenSearch - free text, tìm kiếm phi cấu trúc.\nGraphs: Amazon Neptune - hiển thị quan hệ của dữ liệu.\nLedger: Amazon Quantum Ledger Database.\nTime series: Amazon Timestream.\n\n🌿 Amazon RDS - Summary §\n\nTóm tắt ý chính của RDS:\n\nHỗ trợ với PosgreSQL / MySQL / Oracle / SQL Server / MariaDB / Custom\nCung cấp RDS Instance Size và EBS Volume Type &amp; Size\nCó khả năng tự động scale cho Storage\nHỗ trợ Read Replicas và Mutil AZs\nBảo mật với IAM, SG, KMS, SSL in transit.\nTính năng Automated Backup với từng thời điểm(tối đa lưu trữ trong 35 ngày)\nTính năng Manual DB Snapshot giúp lưu trữ với thời gian dài.\nHỗ trợ Xác thực IAM, tích hợp với Secrets Manager\nRDS Custom có thể dùng để truy cập và customize các instance cơ bản(Oracle &amp; SQL Server)\nUse cases: dùng khi muốn lưu trữ cơ sở dữ liệu có quan hệ, thực hiện các câu lệnh SQL, các transactions.\n\n\n\n🌿 Amazon Aurora - Summary §\n\nTóm tắt ý chính của Aurora:\n\nTương thích với PostgreSQL / MySQL, tách biệt giữa lưu trữ và tính toán.\nStorage: Dữ liệu được lưu trữ trong 6 replicas trên 3 AZ - vì vậy nó luôn HA, tự động khôi phục nếu có lỗi, tự động scale.\nCompute: Các cụm DB instance nằm trên nhiều AZ, tự động scale với Read Replicas.\nCluster: Custom endpoint cho các DB instances đọc và ghi.\nVề bảo mật / monitoring / bảo trì / backup giống với RDS.\nAurora Serverless: dùng khi không dự đoán trước được nhu cầu sử dụng.\nAurora Multi-Master: liên tục ghi dữ liệu(luôn dự phòng, khả năng ghi luôn sẵn sàng).\nAurora Global: Lên đến 16 DB read instances trên từng region, &lt; 1 giây để nhân bản\nAurora Machine Learning: dùng với ML sử dụng module SageMaker &amp; Comprehend trên Aurora.\nAurora Database cloning: Một cụm mới được clone từ cụm đã tồn tại, nhanh hơn sử dụng snapshot để restoring.\nUse Cases: giống với nhu cầu sử dụng RDS, nhưng yêu cầu cần nhanh hơn, ít cần bảo trì hơn, linh hoạt hơn, hiệu suât tốt hơn và nhiều tính năng khác nữa.\n\n\n\n🌿 Amazon ElastiCache - Summary §\n\nTóm tắt ý chính của ElastiCache:\n\nĐược quản lý bởi Redis hoặc Memcached(giống như RDS nhưng dùng cho cache)\nLưu dữ liệu trong bộ nhớ tạm, độ trễ cực thấp\nPhải cung cấp một  EC2 instance.\nHỗ trợ Clustering(redis) và Multi AZ, Read Replicas\nBảo mật thông qua IAM, SG, KMS, Redis Auth\nBackup / Snapshot / Lưu trữ tại thời điểm chỉ định.\nQuản lý và lập lịch cho bảo trì.\nYêu cầu phải thay đổi code của app để sử dụng\nUse Cases: Lưu trữ dạng Key/Value, dữ liệu cần đọc thường xuyên, ít ghi, cache các kết quả của các câu SQL queries, lưu phiên hoạt động của websites, không thể sử dụng SQL.\n\n\n\n🌿 Amazon DynamoDB - Summary §\n\nTóm tắt ý chính của DynamoDB:\n\nCông nghệ độc quyền của AWS, là database NoSQL serverless, độ trễ milisecond.\nCapacity modes:\n\nOptional auto-scaling: chủ động setting các thông số khi có plan cũng như ước lượng được trước nhu cầu sử dụng.\nOn-demand: không ước lượng được trước, nó sẽ tự động scale theo mức độ sử dụng của mình, dùng đến đâu trả đến đấy.\n\n\nCó thể thay thế ElastiCache để lưu trữ dạng key/value\nDAX cluster cache kết quả đọc, giảm độ trễ cũng như giảm số lượng truy cập đến DB.\nBảo mật, xác thực, phân quyền thông qua IAM.\nEvent processcing: DynamoDB Streams để tích hợp với AWS Lambda hoặc Kinesis Data Streams.\nGlobal Table: thiết lập nhiều DB cùng active, dữ liệu được đồng bộ với nhau.\nTự động backup tối đa 35 ngày với PITR(để lưu trữ 1 bảng mới) hoặc on-demand backups.\nNhanh chóng phát triển\nUse case: Phát triển ứng dụng với kiến trúc serverless, phân phối cache không máy chủ.\n\n\n\n🌿 Amazon S3 - Summary §\n\nTóm tắt ý chính của S3:\n\nS3 là là một dạng lưu key/value cho các objects\nPhù hợp với những objects lớn, không phù hợp với nhiều objects nhỏ.\nServerless, scale vô hạn, size của object tối đa là 5TB, có khả năng quản lý version.\nTiers: S3 Standard, S3 Infrequent Access, S3 Intelligent, S3 Glacier + lifecycle policy.\nFeatures: Versioning, Encryption, Replication, MFA-Delte, Access Logs, ..\nSecurity: IAM, Bucket Policies, ACL, Access Points, Object Lambda, CORS, Object/Vault lock\nBatch operation: trên các objects sử dụng S3 Batch, liệt kê các files thì sử dụng S3 Inventory.\nPerformance: Multi-Part upload, S3 Transfer Acceleration, S3 Select.\nAutomation: S3 Event Notifications(SNS, SQS, Lambda, EventBridge)\nUse case: Static files, key/value objects lưu trữ với những objects lớn, website hosting.\n\n\n\n🌿 DocumentDB - Summary §\n\nTóm tắt ý chính của DocumentDB:\n\nLà Aurora nhưng tương thích với mongoDB\nSử dụng để lưu trữ, query và index dữ liệu JSON.\nToàn quyền quản lý, HA với các nhân bản trên cả 3 AZ.\nTự động phát triển 10Gb - 64Tb,\nTự động scale worloads lên đến hàng triệu requests.\n\n\n\n🌿 Amazon Neptune - Summary §\n\nGraph database\nMột ứng dụng phổ biến là social network.\nHA trên 3 AZ, tối đa mở rộng 15 read replicas.\nBuild và chạy các apps hoạt động với các bộ dữ liệu có kết nối phức tạp - Nó đã được tối ưu với những queries khó và phức tạp.\nCó thể lưu trữ lên đến hàng tỷ quan hệ và query với độ trễ cực thấp(milisecond)\n\n🌿 Amazon KeySpaces  - Summary §\nApache Cassandra là một database open-source NoSQL\n\nTương thích với Apache Cassandra.\nServerless, có thể scale, HA, toàn quyền quản lý bởi AWS.\nTự động scale các bảng dựa theo lượng sử dụng của app.\nCác bảng sẽ được nhân bản ba lần trên nhiều AZ.\nSử dụng Cassandra Query Language(CQL)\nMode: on-demand và provisioned mode.\nEncryption, backup, Point-In-Time Recovery(PITR) tối đa 35 ngày.\nUse case: lưu trữ thông tin thiết bị IoT, time-series data, …\n\n🌿 Amazon QLDB  - Summary §\n\nQuantum Ledger Database.\nLà một cái sổ cái để lưu lại các giao dịch tài chính.\nToàn quyền quản lý, serverless, HA, Nhân bản trên cả 3 AZ.\nSử dụng để review lại lịch sử của toàn bộ những thay đổi đối với dữ liệu của app từ trước đến nay,\nimmutable system: không tác nhân nào có thể xóa, sửa.\n\n🌿 Amazon Timestream  - Summary §\n\nNhanh, có thể scale, serveless database time series.\nTự động scale để điều chỉnh khả năng sử dụng.\nLưu trữ và phân tích hàng nghìn tỷ events mỗi ngày.\nRẻ nhất\nUse case: IoT apps, phân tích real-time, …\n"},"40123345-posts/42-Code/42.03-AWS/Disaster-Recovery/AWS-Application-Discovery-Service":{"title":"🌱 AWS Application Discovery Service","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ giúp chúng ta khám phá và phân tích cơ sở hạ tầng của hệ thống.\nHiểu đơn giản nó sẽ scan hệ thống, tìm kiếm thông tin về ứng dụng, dịch vụ, máy chủ, phần cứng, … sau đó tổng hợp lại thành một báo cáo.\nGiúp đánh giá hiệu suất, độ tin cậy, tính khả dụng của hệ thống.\nGiúp tìm ra những vấn đề tiềm ẩn, từ đó khắc phục cũng như tối ưu hệ thống.\nĐặc biệt là dịch vụ này thường được dùng để làm tài liệu tham khảo cho việc lên plan để migrate server từ on-premise lên cloud.\nAgentless Discovery - các thông tin liên quan đến phần cứng.\nAgent-based Discovery - các thông tin liên quan đến hiệu suất của ứng dụng, network, …\nKết quả có thể xem được trong AWS Migration Hub.\n\n\n🌿 Refer §"},"40123345-posts/42-Code/42.03-AWS/Disaster-Recovery/AWS-Backup":{"title":"🌱 AWS Backup","links":["40123345-posts/42-Code/42.03-AWS/EBS-Volume---Elastic-Block-Store","40123345-posts/42-Code/42.03-AWS/S3","40123345-posts/42-Code/42.03-AWS/Databases/Amazon-RDS---Relational-Database-Service","40123345-posts/42-Code/42.03-AWS/Databases/Amazon-Aurora","40123345-posts/42-Code/42.03-AWS/Databases/Amazon-DynamoDB"],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ được quản lý hoàn toàn bởi AWS.\nHỗ trợ chúng ta quản lý cũng như tự động backups cho nhiều AWS Services.\nKhông cần phải tạo custom script hay những tiến trình thủ công, AWS lo tất.\nCác services được hỗ trợ:\n\nEC2 / EBS\nS3\nRDS / Aurora / DynamoDB\nDocumentDB / Neptune\nEFS / FSx\nStorage Gateway\n\n\nHỗ trợ backup trên nhiều regions và accounts.\nBackup Plans - có thể hiểu là Backup policies:\n\nTần suất backup - 1h, daily, weekly, …\nBackup windows\nTransaction to Cold Storage(never, 1 day, month, …)\nChu kỳ giữ lại(always, day, weeek, …)\n\n\n\n\n🌿 Backup Vault Lock §\n\nChỉ có ghi vào và đọc chứ không có xóa được.\n"},"40123345-posts/42-Code/42.03-AWS/Disaster-Recovery/DMS---Database-Migration-Service":{"title":"🌱 DMS - Database Migration Service","links":["40123345-posts/42-Code/42.03-AWS/Databases/Amazon-Aurora"],"tags":["aws"],"content":"🌿 What? §\n\n\nLà dịch vụ hỗ trợ migrate database ở bất cứ đâu và đến bất kỳ chỗ nào bạn muốn một cách nhanh chóng và an toàn.\nCó khả năng tự phục hồi cũng như tự động chạy lại nếu có lỗi trong quá trình hoạt động.\nTrong quá trình migrate, main database luôn phải trong trạng thái available.\nHỗ trợ:\n\nMigrate đồng nhất: vd như từ Oracle -&gt; Oracle.\nMigrate không đồng nhất: vd như Microsoft SQL Server -&gt; Aurora.\n\n\nCó thể sử dụng CDC - Continuous Data Relication: thực hiện nhân bản dữ liệu liên tục.\nSử dụng dịch vụ này, về bản chất chúng ta sẽ phải launch một EC2 Instance, nó sẽ chịu trách nhiệm nhân bản dữ liệu cho chúng ta.\n\n\n🌿 Schema Conversation Tool(SCT) §\n\n\nTính năng hỗ trợ convert schema của database sang engine phù hợp, để bên target có thể migrate được.\n\n\n\nBest practice:\n\n\n\nĐặt một server ở on-premise để thực hiện convert schema.\n\n\nDMS đặt ở public subnet trên Cloud, thực hiện Migrate + CDC.\n\n"},"40123345-posts/42-Code/42.03-AWS/Disaster-Recovery/Disaster-Recovery-Overview":{"title":"🌱 Disaster Recovery Overview","links":["40123345-posts/42-Code/42.03-AWS/Databases/Amazon-RDS---Relational-Database-Service","40123345-posts/42-Code/42.03-AWS/EBS-Volume---Elastic-Block-Store","40123345-posts/42-Code/42.03-AWS/S3","40123345-posts/42-Code/42.03-AWS/Databases/Amazon-ElastiCache","40123345-posts/42-Code/42.03-AWS/Networking---VPC/AWS-Site-to-Site-VPC","40123345-posts/42-Code/42.03-AWS/Networking---VPC/Direct-Connect-(DX)","40123345-posts/42-Code/42.03-AWS/Databases/Amazon-Aurora","40123345-posts/42-Code/42.03-AWS/Elastic-Beanstalk","40123345-posts/42-Code/42.03-AWS/Monitoring/Amazon-CloudWatch","40123345-posts/42-Code/42.03-AWS/AWS-Lambda"],"tags":["aws"],"content":"🌿 What? §\n\n\nBất kỳ sự kiện nào gây ảnh hưởng tiêu cực tới quá trình nghiệp vụ liên tục hoặc vấn đề tài chính của một công ty thì đó được gọi là disaster(hay còn được gọi là incident)\n\n\nDisaster Recovery(DR) là các hoạt động được chuẩn bị để thực hiện quá trình hồi phục sau khi xuất hiện một disaster.\n\n\nCác loại DR:\n\nOn-premise =&gt; On-premise: thuê một datacenter đặt ở Hà Nội, một cái đặt ở Hải Phòng chẳng hạn.\nOn-premise =&gt; Cloud: Hybrid Recovery - có một máy chủ vật lý đặt ở cty, thuê thêm datacenter trên cloud, nếu on-premise có vấn đề thì switch qua cloud sài.\nCloud Region =&gt; Cloud Region\n\n\n\nPhân biệt 2 định nghĩa:\n\nRPO - Recovery Point Objective - bao nhiêu dữ liệu bị mất khi xảy ra disaster\nRTO - Recovery Time Objective - thời gian downtime là bao lâu kể từ thời điểm phát sinh disater.\n=&gt; Việc của chúng ta làm làm cách nào đó tối ưu Data loss và Downtime càng nhỏ càng tốt.\n\n\n\n\n🌿 Strategies §\n\n\n4 strategies sắp xếp theo thời gian Downtime, cũng như giá tiền, càng đắt thời gian Downtime càng nhỏ.\n\n🍃 Backup and Restore (High RPO) §\n\n\nĐặt lịch để datacenter tự động tạo snapshot, hoặc với on-premise thì gửi dữ liệu lên Cloud. Cách này thì không cần setup gì nhiều, giá còn rẻ.\nCơ mà cách này thì nó dễ High RPO và RTO khi có disaster.\n\nVd như dùng AWS Snowball để chuyển dữ liệu tầm 7 ngày, trong thời gian di chuyển, on-premise nó cháy phát, thế là mất toàn bộ data trong 1 tuần luôn.\nHoặc tạo snapshot 24h hoặc 1h một lần thì nếu có disaster, hệ thống cx sẽ mất toàn bộ dữ liệu trong thời gian countdown đó.\n\n\nNgoài ra còn một số hạn chế cần xem xét khi triển khai:\n\nMất thời gian và tài nguyên để thực hiện sao lưu.\nKhông thể khôi phục ngay lập tức, khi xảy ra disater, dữ liệu chưa thể sử dụng ngay được mà sẽ có một khoảng downtime để khôi phục lại dữ liệu.\nNói là rẻ nhưng chúng ta cũng phải mất thêm phí để trả cho việc lưu trữ, băng tần sao lưu, …\n\n\n\n🍃 Pilot Light §\n\n\nLà chiến lược duy trì một bản sao của hệ thống, bản sao này sẽ chỉ bao gồm các phần quan trọng của hệ thống(vd như RDS, EC2 thì lúc nào sử dụng tạo sau nên không cần), duy trì ở mức tối thiểu để tối ưu chi phí.\nNhư ví dụ trên, khi disaster xảy ra, hệ thống sẽ điều hướng để chạy trên bản sao, từ đó giúp giảm thiểu RTO, cũng như dữ liệu luôn được nhân bản liên tục, giảm thiểu RPO.\nHạn chế:\n\nChi phí để duy trì bản sao\nCần có một kế hoạch chi tiết để thực hiện hồi phục nhanh chóng và chính xác. Chiến lược này liên quan nhiều đến cấu hình, kích thước, tài nguyên, network, và nhiều yếu tố khác của hệ thống.\n\n\n\n🍃 Warm Standby §\n\n\nGiống Spot Light, cũng duy trì một bản sao dự phòng nhưng bản sao này sẽ chạy thêm cả các dịch vụ chính của hệ thống.\nBên trên không chạy EC2 Instances thì chiến lược này sẽ có chạy sẵn để tạch thì chạy luôn, chứ không có downtime để launch EC2 Instance nữa.\nHạn chế:\n\nChi phí tất nhiêu là nhiều hơn rồi, đắt luôn ấy chứ.\nCó thể bản sao sẽ không đáp ứng được đầy đủ lượng traffic của hệ thống cũ, lúc này thì vẫn cần thời gian để scale trước khi hoàn toàn ổn định.\n\n\n\n🍃 Multi Site §\n\n\nPhiên bản khô máu, chạy song song 2 phiên bản poroduction luôn, nó cái nào gặp lỗi, điều hướng qua cái còn lại để sử dụng.\nRất đắt.\nDowntime hầu như rất thấp mấy giây, cùng lắm là mấy phút thôi.\n\n🌿 Tips §\n\nBackup\n\nEBS snapshots, RDS auto snapshot, …\nThường xuyên push lên S3/S3 Glacier, … dùng lifecycle policies\nNếu chạy cả trên on-premise: sử dụng Snowball hoặc Storage Gateway\n\n\nHigh Availability\n\nDùng Route53 để migrate DNS trên nhiều Regions.\nRDS/ElastiCache Multi-AZs, EFS, S3, …\nSite-to-site để recovery cho Direct Connect\n\n\nReplication\n\nRDS Replication, Aurora + Global Database\nDatabase relication từ on-premise lên RDS.\nStorage Gateway\n\n\nAutomation\n\nCloudFormation/Elastic Beanstalk để tạo lại toàn bộ hệ thống trên môi trường mới.\nRecover/Reboost thông qua CloudWatch nếu nó có alarm lỗi.\nDùng AWS Lambda Function để thực hiện tự động các tác vụ chỉ định.\n\n\nChaos\n\nKiểm thử, như Netflix đặt toàn bộ tài nguyên trên AWS Cloud, có một thuật ngữ “simian-army”. Là kiểu kiểm thử khả năng DC của hệ thống - random terminate EC2 của production luôn chứ không phải của môi tường test luôn =)))\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Disaster-Recovery/On-Premise-strategies-with-AWS":{"title":"🌱 On-Premise strategies with AWS","links":["40123345-posts/42-Code/42.03-AWS/Disaster-Recovery/DMS---Database-Migration-Service"],"tags":["aws"],"content":"🌿 Các chiến lược sử dụng để liên kết on-premise với cloud §\n\nCó khả năng Download Amazon Linux 2 AMI như một VM.\nVM import/export\n\nCó thể migrate hệ thống đã có vào EC2\nTạo một nơi để thực hiện DC trên máy ảo.\nCó thể export ngược lại từ EC2 về on-premise.\n\n\nAWS Application Discovery Service\n\nTổng hợp các thông tin về on-premise servers để lên kế hoạch migrate.\nKiểm tra, giám sát với AWS Migration Hub.\n\n\nAWS Database Migration Service(DMS)\n\nNhân bản, sao chép cơ sở dữ liệu từ on-premise lên cloud\nHỗ trợ đa dạng các kiểu databases.\n\n\nAWS Server Migration Service(SMS)\n\nCung cấp một cái live server thực hiện nhân bản, sao chép database từ on-premise lên cloud.\n\n\n"},"40123345-posts/42-Code/42.03-AWS/EBS-Volume---Elastic-Block-Store":{"title":"🌱 EBS Volume - Elastic Block Store","links":[],"tags":["aws"],"content":"🌿 What? §\n\n\nLà một dịch vụ lưu trữ thông qua các virtual disks, giúp chúng ta có thể truy xuất dữ liệu từ các EC2 Instances (a network drive, not a physical drive).\n\nEBS sẽ sử dụng network để giao tiếp với các EC2 Instance, vì vậy có thể có chút độ trễ.\n\n\nCho phép lưu trữ dữ liệu cả khi đã terminate EC2 instance. Có thể mount lại dữ liệu nếu cần.\n1 EBS chỉ mounted được tới 1 instance tại cùng một thời điểm.\n\nCó thể detached khỏi một Instance và attached vào một Instance khác dễ dàng và nhanh chóng.\n\n\nBound trong 1 AZ chỉ định, không sử dụng được cho các EC2 instance ở khác AZ.\n\nĐể move một volume qua AZ khác, chúng ta cần snapshot nó.\n\n\nCó thể hiểu nó như một cái USB, có thể mang đi cắm vào các EC2 instances khác cần sử dụng dữ liệu.\nĐương nhiên chúng ta sẽ cần chỉ định cấu hình(bao nhiêu Gbs và IOPS - Input/output Operations Per Second - tốc độ đọc ghi thế nào)\n\nCó thể thêm tiền để upgrade cấu hình.\n\n\n\n🌿 EBS Snapshots §\n\n\nLà tính năng giúp cta sao chép EBS Volume, bao gồm dữ liệu, tệp tin và cấu hình của chúng.\nGiúp move volume giữa những AZs khác nhau.\n\n🍃 Features §\n\n\n🌱 EBS Snapshot Archive\n\nCó thể chuyển Snapshot vào một archive tier thay vì lưu trữ thông thường, cách này rẻ hơn 75%.\nMất 24-72h để restoring lại.\n\n\n\n🌱 Recycle Bin for EBS Snapshots\n\nGiữ lại những snapshots đã bị xóa, từ đó có thể lấy lại được nếu chẳng may chúng ta xóa nhầm.\nChỉ định thời gian giữ lại (1 ngày - 1 năm)\n\n\n\n🌱 Fast Snapshot Restore (FSR)\n\nCho phép khởi tạo không có độ trễ cho lần đầu tiên. Nếu cta có snapshot lớn và muốn khởi tạo EBS Volume nhanh.\nTính năng này cần trả thêm phí để sử dụng.\n\n\n\n🌿 EBS Volume Types §\n\nCó 6 loại:\n\ngp2/gp3(SSD): cho những nhu cầu sử dụng tiêu chuẩn, cân bằng giữa giá cả và hiệu suất sử dụng. Phù hợp với nhiều ứng dụng.\nio1/io2(SSD): hiệu suất tốt nhất, sử dụng cho những ứng dụng cần thực hiện tính toán tốc độ cao, I/O tốt.\nst1(HDD): Giá thấp hơn, sử dụng HDD phục vụ lưu trữ dữ liệu thường xuyên truy xuất và yêu cầu khả năng truyền tải dữ liệu lớn.\nsc1(HDD): Giá thấp nhất, để lưu trữ dữ liệu lớn và dữ liệu không được thường xuyên truy xuất.\n\n\nCác đặc điểm của EBS Volume là: Size, Throughput, IOPS(I/O Operating Per Second)\nChỉ gp2/gp3 và io I/io2 mới có thể sử dụng để làm boot volumes.\n\n🍃 General Purpose SSD §\n\nGiá cả hợp lý, độ trễ thấp.\nSử dụng làm boot volumes, virtual desktops, development and test environments.\n1Gb - 16Tb\n|gp3|gp2|\n|----|----|\n|Baseline là 3000 IOPS và throughput of 125 Mib/s|Chỉ lên được 3000 IOPS là max|\n|IOPS và Throughput có thể set độc lập|IOPS và Throughput luôn linked với nhau|\n\n🍃 Provisioned IOPS §\n\nDự án có nghiệp vụ quan trọng cần duy trì hiệu suất IOPS hoặc rõ hơn là cần nhiều hơn 16000 IOPS.\nLà lựa chọn tuyệt vời cho database workloads\n4Gb - 16Tb\n\nMax: 64000 IOPS với Nitro EC2 instance và 32000 với những EC2 instances thường.\nGiống gp3, có thể nâng IOPS độc lập.\nio2 có độ bền cao hơn và IOPS trên GiB cao hơn io1 với cùng mức giá.\n\n\nio2 Block Express (4GB - 64 TB)\n\nĐộ trễ cực thấp.\nMax: 256000 IOPS\n\n\nHỗ trợ Multi-attach\n\nCho phép một EBS Volume attach với nhiều EC2 Instances trong cùng một AZ.\nMỗi Instance đều có full quyền đọc ghi.\nMax có thể attach được 16 Instances một lúc.\n\n\n\n🍃 Hard Disk Drivers §\n\nKhông thể là một boot volume\n125GB - 16TB\nThroughput Optimized HDD - st1\n\nUse cases: Big Data, Data Warehouses\nMax Throughput: 500 MiB/s - max IOPS 500\n\n\nCold HDD - sc1\n\nDùng để lưu trữ data không thường xuyên truy xuất\nChi phí thấp nhất\nMax throughput 250MiB/s - max IOPS 250\n\n\n\n🌿 EBS Encryption §\n\nMã hóa dữ liệu trước khi được lưu trữ.\nSau khi tạo một EBS Volume được mã hóa:\n\nToàn bộ data trong volume đều được mã hóa\nToàn bộ dữ liệu chuyển đổi giữa instance và volume đều được mã hóa\nTất cả snapshots đều được mã hóa.\nTạo volume mới phải tạo từ snapshot.\n\n\nCơ chế mã hóa và giải mã được thực hiện tự động.\nQuá trình mã hóa không ảnh hưởng nhiều đến độ trễ.\nĐược mã hóa bởi thuật toán AES-256.\nNếu tạo một EBS volume không mã hóa, muốn chuyển qua một EBS volume mã hóa:\n\nTạo snapchat từ Volume đang sử dụng.\nTạo một Volume từ snapchat -&gt; chọn encrypt.\nAttach tới EC2 Instance.\n\n\n"},"40123345-posts/42-Code/42.03-AWS/EC2---Elastic-Compute-Cloud":{"title":"🌱 EC2 - Elastic Compute Cloud","links":["40123345-posts/42-Code/42.03-AWS/EBS-Volume---Elastic-Block-Store","40123345-posts/42-Code/42.03-AWS/ELB---Elastic-Load-Balancing","40123345-posts/42-Code/42.03-AWS/EFS---Elastic-File-System","40123345-posts/42-Code/42.03-AWS/EC2-Instance-Store","50-til/51-Code/06-Servers/Remote-Desktop-Protocol"],"tags":["aws"],"content":"🌿 What? §\n\n🌱 EC2 - Elastic Compute Cloud - Infrastructure as a Service.\n🌱 Là một trong những Services được thuê nhiều nhất của AWS.\n🌱 Service này chủ yếu được sử dụng để:\n\nThuê virtual machines(EC2)\nLưu dữ liệu trên virtual drives(EBS - Elastic Block Store)\nPhân phối tải tới các máy ảo(ELB - Elastic Load Balancing)\nAuto-scaling group (ASG)\n\n\n\n🌿 EC2 sizing &amp; Configuration options §\n\n🌱 OS: Linux, Windows hoặc Mac OS.\n🌱 CPU: Cần tốc độ xử lý thế nào?\n🌱 RAM: Cần bộ nhớ đệm bao nhiêu?\n🌱 Storage space:\n\nNetwork-attached (EBS &amp; EFS - Elastic File System)\nHardware (EC2 Instance Store)\n\n\n🌱 Network Card: tốc độ, Public IP address.\n🌱 Firewall rules: bảo mật\n🌱 Boootstap script(chạy 1 lần đầu tiên khi launch): EC2 User Data\n\n🌱 EC2 User Data §\n\nChạy một số câu lệnh khi một máy ảo khởi chạy.\nScript này chỉ chạy 1 lần duy nhất khi máy ảo khởi chạy lần đầu tiên.\nMục đích thường là để:\n\nInstalling updates\nInstalling software\nDownloading common files from the internet\nHay bất kỳ tác vụ nào mà chúng ta muốn chạy.\n\n\nRoot user sẽ chạy EC2 User Data Script.\n\n🌿 EC2 instance types §\n\n\n🌱 Choosing the kind of intance that fits best your application.\n🌱 Naming convention: ví dụ: m5.2xlarge\n\nm: instance class\n5: gen 5\n2xlarge: size của instance(size, memory, CPU)\n\n\n🌱 Có 7 types.\n\n🍃 General Purpose Type §\n\nSử dụng cho đa dạng workloads như web servers hoặc code repositories( hiểu là những tác vụ không có yêu cầu đặc biệt).\nCân bằng giữa:\n\nCompute\nMemory\nNetworking\n\n\n\n🍃 Compute Optimized Type §\n\nSử dụng cho những ứng dụng có yêu cầu cao về hiệu suất tính toán, xử lý(CPU). Ví dụ như:\n\nBatch processing workloads (tác vụ xử lý dữ liệu hàng loạt)\nMedia transcoding\nWeb servers hiệu năng cao\nHPC - High performance computing\nMachine Learning &amp; Modeling (mô hình hóa)\nGaming servers\n\n\nInstance class: C (CPU)\n\n🍃 Memory Optimized Type §\n\nSử dụng cho những ứng dụng có yêu cầu cao về tốc độ xử lý những bộ dữ liệu lớn trong bộ nhớ(RAM). Ví dụ như:\n\nCần high performance để xử lý dữ liệu.\nỨng dụng cần xử lý real-time với những bộ dữ liệu không cấu trúc lớn.\nDatabases optimized for BI(business intelligence)\n\n\nInstance class: thường là R (RAM)\n\n🍃 Storage Optimized Type §\n\nSử dụng với những ứng dụng thường xuyên phải tương tác với dữ liệu(đọc, ghi) ở local storage. Ví dụ như:\n\nHệ thống xử lý transaction online (OLTP).\nDatabases(Relational &amp; NoSQL)\nCache dữ liệu(Redis)\nData warehousing\nLưu files.\n\n\n\n🌿 Security Groups §\n🍃 Overview §\n\n🌱 Là nền tảng an ninh mạng của AWS.\n🌱 Kiểm soát cách traffic tương tác với các EC2 Instances của chúng ta.\n🌱 Security groups chỉ chứa allow rules.\n🌱 Rules có thể tham chiếu theo IP hoặc Security Group.\n\n🍃 Deeper dive §\n\n🌱 Hoạt động như một “firewall” bảo vệ cho EC2 Intances.\n🌱 Qui định:\n\nTruy cập vào các cổng\nTrao quyền IP ranges -  IPv4 và IPv6\nKiểm soát inbound connect (từ bên ngoài vào instance)\nKiểm soát outbound connect (từ instance ra bên ngoài)\n\n\n\n🍃 Good to know §\n\n🌱 Có thể attached tới nhiều instances.\n🌱 Locked down một khu vực\n🌱 Sẽ tốt hơn khi có một security group riêng để truy cập bằng SSH\n🌱 Nếu app của bạn ko truy cập được(time out), có thể security group có vấn đề.\n🌱 Nếu app nhận được “connection refused”, là do app có vấn đề hoặc EC2 intance chưa được launched.\n🌱 Mặc định tất cả inbound traffic sẽ bị blocked.\n🌱 Mặc định tất cả outbound traffic được thông qua.\n\n\n🍃 Classic Port §\n\n🌱 22 = SSH - log into a Linux instance\n🌱 21 = FTP (File Transfer Protocol) - upload files\n🌱 22 = SFTP (Secure File Transfer Protocol)\n🌱 80 = HTTP\n🌱 443 = HTTPS\n🌱 3389 = RDP (Remote Desktop Protocol) - log into a Windows intance.\n\n🌿 Purchasing Options §\n\nCần lựa chọn các phương án phù hợp với nhu cầu sử dụng và tối ưu chi phí.\n\n🍃 On-Demand Instances §\n\n🌱 Đoán trước được chi phí, dùng đến đâu trả đến đấy.\n\nNếu dùng Linux or Windows - trả tiền theo từng giây, sau phút đầu tiên\nTất cả OS còn lại - trả tiền theo giờ.\n\n\n🌱 Có giá cao nhất khi không thanh toán trước.\n🌱 Không cần phải cam kết thời gian sử dụng.\n🤔 Nên sử dụng cho short-term và un-interrupted workloads, những dự án chúng ta không thể dự đoán được triển vọng tương lai cũng như yêu cầu tài nguyên:\n\nDự án kiểm thử.\nDự án cần triển khai nhanh nhưng có thể đóng bất kì lúc nào.\n\n\n\n🍃 Reserved Instances (1 &amp; 3 years) §\n\n\n🤔 Sử dụng cho các dự án dài hạn, vì thuê thời gian dài nên AWS sẽ discount tùy theo thời gian chúng ta thuê là bao lâu. Các dự án ví dụ như:\n\nMột trang blog\nDuy trì một database\n\n\n\nRẻ hơn nhiều so với On-demand instances.\n\n\nCó thể chọn attributes(type, region, OS,tenancy)\n\n\nCàng thuê nhiều năm càng được discount nhiều.\n\n\nNo upfront(+), Partial Upfront(++), All Upfront(+++)\n\n\nLựa chọn đuọc phạm vi: region, zone.\n\n\nCó thể mua hoặc bán trên Reserved Instance Marketplace tùy theo nhu cầu.\n\n\nConvertible Reserved Instances - long workloads\n\nflexible instances(có thể thay đổi được type, OS, family, tenancy của instance)\n\n\n\n🍃  Savings Plans(1 &amp; 3 years) §\n\nLong workloads.\nDiscount dựa theo thời gian sử dụng(thuê càng lâu càng rẻ)\nCam kết về số lượng sử dụng(vd 10$/hour for 1 - 3 years)\nBất kì chi phí phát sinh nào sẽ tính theo giá của On-Demand instances.\nChỉ định được instance family và region(vd M5 in us-west-1)\nCó thể thay đổi:\n\nInstance size(m5.xlarge, m5.2xlarge)\nOS\nTenancy(Host, Dedicated, Default)\n\n\n\n🍃 Spot Instances §\n\nShort workloads.\nLựa chọn rẻ nhất.\nCó thể hiểu option này chúng ta sẽ thuê những EC2 Instances chưa có người sử dụng, cta sẽ đấu giá nó là 1$ để xài, nếu không có người trả giá cao hơn thì vấn có quyền sử dụng. Nếu ai trả cao hơn thì mất luôn 😗\nPhù hợp với những servers chạy các tác vụ sẽ chạy lại khi có lỗi.Hoặc dự án thử nghiệm, không quan trọng khi bị dừng đột ngột.\n\nJobs\nImage processing\n\n\nKhông phù hợp với những công việc quan trọng hoặc sử dụng cho database.\n\n🌱 Terminate Spot Instances §\n\nPhải cancel spot request trước(có thể launch instances), việc này sẽ không terminate các EC2 Instances. Sau khi cancel, chúng ta tiếp theo mới thực hiện terminate các Instances.\n\n🌱 Spot Fleets §\n\nSpot Fleets = Spot Instances + (optional) On-Demand Instances\nĐạt được target capacity với mức phí hạn chế.\nStop launching khi đạt ngưỡng tải hoặc hạn mức chi phí.\nChiến lược sắp xếp Spot Instances:\n\nlowestPrice\ndiversified\ncapacityOptimized\n\n\nCho phép chúng ta tự động request Spot Instances với chi phí thấp nhất.\n\n🍃 Dedicated Hosts §\n\nThuê hẳn một server vật lý.\nĐắt nhất.\nCông ty tổ chức nào có tiền thì xài, hoặc phần mềm có những yêu cầu đặc thù(ví dụ như các phần mềm của chính phủ)\n\n🍃 Dedicated Instances §\n\nThuê riêng hardware để chạy instances, chỉ mình mình dùng thôi, ko có thằng nào dùng chung hardware với mình cả.\n\n🍃 Capacity Reservations §\n\nCó thể đặt trước ở một AZ bất kỳ thời gian nào.\nTruy cập vào EC2 bất cứ khi nào.\nKhông cần cam kết thời gian. không có discount.\nTrả tiền theo tỉ lệ của On-Demand\n\n\n🌿 Some notes §\n\n🌱 Khi start lại một EC2 Instance, Private IPv4 giữ nguyên còn Public IPv4 có thể bị thay đổi.\n"},"40123345-posts/42-Code/42.03-AWS/EC2-Hibernate":{"title":"🌱 EC2 Hibernate","links":[],"tags":["aws"],"content":"🌿 What? §\n\n\nLà một service giúp giữ lại trạng thái, toàn bộ bộ nhớ của một instance vào ổ đĩa EBS trước khi nó stop hoặc bị terminate.\nGiúp Instance khởi động nhanh hơn.\nRoot EBS volume phải được mã hóa.\nGiúp tiết kiệm chi phí khi chúng ta có thể giải phóng tài nguyên khi không cần sử dụng và không sợ phải mất dữ liệu hoặc cấu hình của một instance.\nUse cases:\n\nNhững dự án có tiến trình khởi chạy lâu.\nMuốn lưu trữ trạng thái của RAM.\n\n\n\n🌿 Good to Know §\n\nHỗ trợ các Instance Families: C3, C4, C5, I3, M3, M4, R3, R4, R2, T3, …\nInstance RAM size: phải nhỏ hơn 150Gb\nRoot Volume: phải là EBS, được mã hóa. Không hỗ trợ với những Instances sử dụng instance store và volume lớn.\nCó sẵn với các purchasing options sau: On-Demand, Reserved và Spot Instances.\nMột instance không thể lưu trữ trạng thái quá 60 ngày(có thể thay đổi số này nhưng đây là thời gian tiêu chuẩn).\n"},"40123345-posts/42-Code/42.03-AWS/EC2-Instance-Store":{"title":"🌱 EC2 Instance Store","links":[],"tags":["aws"],"content":"🌿 What? §\n\nCho phép lưu trữ dữ liệu của 1 EC2 Instance ở trên một ổ đĩa vật lý, được đặt cùng với máy chủ chứa Instance.\nKhác với EBS Volume lưu trữ và truy xuất dữ liệu thông qua mạng, EC2 Instance Store có một đặc điểm sau:\n\nI/O performance tốt hơn EBS Volume\nGiảm thiểu khả năng xảy ra do sự cố mạng và hao tổn băng thông. Nhưng có khả năng bị mất dữ liệu do hardware xảy ra lỗi.\nMất dữ liệu khi EC2 Instance bị dừng hoặc xóa.\nNên sử dụng với những ứng dụng không cần lưu trữ dữ liệu dài hạn hoặc không thì cần phải thực hiện lưu trữ và backup bằng những dịch vụ khác.\n\n\nCân nhắc giữa EC2 Instance và EBS Volume để có lựa chọn phù hợp nhất với dự án.\n"},"40123345-posts/42-Code/42.03-AWS/ECS-Service-Auto-Scaling":{"title":"🌱 ECS Service Auto Scaling","links":[],"tags":["aws"],"content":"🌿 What? §\n\n\nTự động tăng hoặc giảm số lượng desired(mong muốn) của ECS tasks.\n\n\nSử dụng AWS Application Auto Scaling\n\nScale theo CPU\nTheo RAM\nTheo số lượng request đếm được ở ALB\n\n\n\nTarget Tracking - scale dựa theo giá trị của một thông số chỉ định CloudWatch.\n\n\nStep Scaling - scale dựa theo CloudWatch Alarm chỉ định.\n\n\nScheduled Scaling - scale dựa theo thời gian chỉ định(có thể dự đoán được thay đổi)\n\n\nECS Service Auto Scaling là ở tasks level != EC2 Auto Scaling là ở EC2 instance level.\n\n\nFargate Auto Scaling dễ dàng setup hơn vì nó là serverless.\n\n\n🌿 Auto Scaling EC2 Instances §\n\n\nLà Add thêm EC2 Instances.\n\n\nAuto Scaling Group Scaling\n\nScale ASG dựa theo CPU\nAdd thêm EC2 Instances để đáp ứng nhu cầu sử dụng thực tế.\n\n\n\nECS Cluster Capacity Provider\n\nTự động cung cấp cũng như mở rộng cơ sở hạ tầng cho các ECS Tasks của chúng ta.\nCapacity Provider được kết hợp với một Auto Scaling Group.\nAdd EC2 Instances khi thiếu capacity(CPU, RAM, …)\n\n\n\nLuôn ưu tiên sử dụng ECS Cluster Capacity Provider.\n\n"},"40123345-posts/42-Code/42.03-AWS/EFS---Elastic-File-System":{"title":"🌱 EFS - Elastic File System","links":[],"tags":["aws"],"content":"🌿 What? §\n\n\nHệ thống quản lý file, có thể mounted tới nhiều EC2 Instances, ở nhiều AZ khác nhau. Một giải pháp hiệu quả để chia sẻ các files trên môi trường cloud.\nHighly available, dễ dàng scale, chi phí(gấp 3 lần gp2), dùng đến đâu trả tiền đến đấy.\nUse case: content management, web serving, data sharing, wordpress\nSử dụng giao thức NFSv4.1\nSử dụng Security Group để kiểm soát truy cập tới EFS.\nTương thích với Linux based AMI(not Windows)\nMã hóa sử dụng KMS\nScale tự động, dùng đến đâu trả đến đấy, không có đặt trước hay gì cả.\n"},"40123345-posts/42-Code/42.03-AWS/ELB---Elastic-Load-Balancing":{"title":"🌱 ELB - Elastic Load Balancing","links":["50-til/51-Code/06-Servers/Layer-3---Network-Layer"],"tags":["aws"],"content":"🌿 What? §\n\n\nLà dịch vụ phân phối tải tới các instances của hệ thống.\n\n🌿 Why to use? §\n\nPhân phối tải đều cho những instances của hệ thống, tránh tình trạng quá tải.\nExpose một điểm truy cập(DNS) duy nhất cho ứng dụng\nVẫn hoạt động bình thường khi có lỗi ở một instance.\nCung cấp SSL cho web\nTách biệt được public traffic và private traffic.\nThực hiện heath check thường xuyên cho các instances.\n\n🌿 Types of load balancer on AWS §\n\nNên dùng mấy cái gen mới, nó sẽ cung cấp nhiều tính năng mới hơn.\nMột số load balancers có thể setup private hoặc public ELBs.\n\n🍃 Classic Load Balancer §\n\nv1 - 2009 - CLB (có warning deprecated nhưng vẫn available)\nHTTP, HTTPS, TCP, SSL\n\n🍃 Application Load Balancer §\n\n\nv2 - 2016 - ALB\n\n\nHoạt động ở layer-7(Application) - HTTP\n\n\nHỗ trợ redirect(vd như từ HTTP sang HTTPS)\n\n\nRouting\n\nDựa theo path trên URL\nDựa theo hostname trên URL\nDựa vào query string, hearders\n\n\n\nALB phù hợp với micro services và app chạy trên container(Docker || Amazon ECS)\n\n\nCó tính năng ánh xạ cổng để điều hướng đến một cổng động trong ECS.\n\n\nTarget groups:\n\nEC2 Instances (có thể được quản lý bằng Auto Scaling Group) - HTTP\nECS tasks (quản lý bởi ECS) - HTTP\nLambda functions - in a future lecture\nIP Addresses - phải là private IPs\n\n\n\nCó thể định tuyến đến nhiều target groups\n\n\nHealth checks là một target group.\n\n\n\nEdit inbound rules Security Group của EC2 Instances để client phải truy cập qua ALB chứ không được truy cập trực tiếp qua publicIP của instance.\nđược truy cập trực tiếp từ public IP của Instance.\n\n\n🍃 Network Load Balancer §\n\nv2 - 2017 - NLB\nHoạt động ở layer-4(Transport)\n\nChuyển tiếp TCP &amp; UDP traffic tới các instances.\nMỗi giaay xử lý được hàng triệu requests.\nĐộ trễ thấp hơn so với ALB (~100ms vs 400ms)\n\n\nCó một static IP cho từng AZ, có thể sử dụng ElasticIP(hữu ích nếu dự án cần chỉ định IP)\nKhông được hỗ trợ trong free tier.\nTarget groups:\n\nEC2 Instances\nIP Addresses - must be private IPs\nApplication Load Balancer\n\n\nHealth check hỗ trợ qua các giao thức TCP, HTTP, HTTPS.\n\n🍃 Gateway Load Balancer §\n\nv3 - 2020 - GWLB\nHoạt động ở layer 3(Network layer) - IP Protocol\nĐể triển khai, scale và quản lý một cụm network virtual applicances trong AWS, vd như Firewalls, Intrusion Detection and Prevention Systems, …\nKết hợp của:\n\nTransparent Network Gateway - single entry/exit cho tất cả traffic\nLoad Balencer -  phân phối traffic tới các virtual appliances.\n\n\nSử dụng GENEVE protocol trên cổng 6081\n\n\n\n                  \n                  Note \n                  \n                \nKhác với ALB và NLB, GWLB mục đích phân tải cho cụm ứng dụng ảo thực hiện các công việc ngăn ngừa các traffic độc hại vd như Firewall\n\n🌿 Security Group §\n\n🌿 Sticky Session(Session Affinity) §\n\nLà tính năng điều hướng requests của cùng một người dùng đến cùng một instance. Đảm bảo tính nhất quán trong phiên làm việc cùa người dùng và tránh phân tán dữ liệu trên nhiều instances.\nTính năng hoạt động trên CLB &amp; ALB\nGửi Cookie tới client, với mỗi request sau sẽ được gắn cookie để xác định phiên của người dùng, ELB sẽ thực hiện điều hướng tới cùng một instance. Khi cookie hết hạn, người dùng có thể được điều hướng qua một instance khác.\nUse case: trong TH chúng ta không muốn thất lạc dữ liệu trong phiên hoạt động của người dùng.\nTuy nhiên, tính năng này cũng có khả năng gây nên mất cân bằng tải do nhiều user sticky trên một instance chẳng hạn.\nCookie name:\n\nApplication-based Cookies\n\nCustom cookie\nApplication cookie\n\n\nDuration-based Cookies\n\n\n\n🌿 Cross-Zone Load Balancing §\n\nCân bằng tải cho tất cả các instances ở trên nhiều AZs.\n\nALB\n\nMặc định được bật(có thể tắt ở phần edit attributes của target group)\nKhông phải trả phí\n\n\nNLB &amp; GWLB\n\nMặc định tắt\nBật lên thì phải trả tiền\n\n\nCLB\n\nMặc định tắt\nKhông phải trả nếu bật\n\n\n\n🌿 SSL Certificates §\n\n\nSử dụng X.509 certificate(SSL/TLS server certificate)\nCó thể quản lý các certificates bằng ACM - Amazon Certificate Manager\nCó thể tự tạo certificates.\nHTTP listener:\n\nBạn cần có một default certificate\nBạn có thể thêm một danh sách các certs để hỗ trợ cho multiple domains\nClients có thể sử dụng SNI - Server Name Indication để chỉ định hostname\nCó khả năng chỉ dịnh một chính sách bảo mật để hỗ trợ cho những phiên bản cũ SSL/TLS.\n\n\n\n🍃 Server Name Indication §\n\nGiải quyết vấn đề phải load nhiều chứng chỉ SSL trên cùng một web server.\nGiao thức mới, yêu cầu người dùng phải chỉ định hostname của tên máy chủ target trong lần đầu thực hiện khởi tạo SSL handshake.\nServer sẽ tìm ra đúng chứng chỉ hoặc trả về mặc định.\nChỉ work với ALB &amp; NLB, CloudFront\n\n🌿 Connection Draining §\n\nFeature naming:\n\nConnection Draining - for CLB\nDeregistration Delay - for ALB &amp; NLB\n\n\nLà tính năng giúp cho ELB dừng gửi traffic tới một instance đang có vấn đề(unhealthy, deploy lại) nhưng vẫn giữ kết nối tới instance đó.\nCó thể tắt tính năng này đi\n"},"40123345-posts/42-Code/42.03-AWS/ENI---Elastic-Network-Interfaces":{"title":"🌱 ENI - Elastic Network Interfaces","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà một phần logic của một VPC - Virtual Private Cloud, đại diện cho một virtual network card. Cho phép instances kết nối với mạng VPC.\nENI có thể có những attributes sau:\n\nPrimary private IP, một hoặc nhiều IPv4 phụ.\nMột Elastic IP trên tuengf private IPv4\nMột public IPv4\nMột hoặc nhiều Security Groups\nMột địa chỉ MAC\n\n\nKhi launch một instance sẽ tự động tạo ra một ENI.\nCó thể tạo một ENI độc lập và sử dụng cho những trường hợp thay thế dự phòng. Ví dụ như Instance1 đang dùng ENI2 mà nó tạch, có thể chuyển ENI2 cho Instance2 để thay thế.\nBao một AZ chỉ định.\n"},"40123345-posts/42-Code/42.03-AWS/Elastic-Beanstalk":{"title":"🌱 Elastic Beanstalk","links":[],"tags":["aws"],"content":"\nTrên thực tế, một kiến trúc có thể áp dụng được cho rất nhiều các dự án hoăc một dự án có nhiều môi trường(dev, test, stg, production, …). Mà mỗi dự án lại phải lọ mọ setup lại từng cái một (ELB, ASG, RDS, ElastiCache, …) thì rất là một mỏi. Những lúc thế này, hãy nghĩ ngay tới Elastic Beanstalk.\n\n🌿 What? §\n\nElastic Beanstalk sẽ tạo ra một môi trường giúp chúng ta thực hiện triển khai, mở rộng cho dự án. Chúng ta chỉ cần quan tâm đên source code phát triển tính năng của sản phẩm thôi.\nNó sử dụng toàn bộ các components mà chúng ta đã sử dụng: ELB, RDS, ASG, …\nQuan trọng là chúng ta vẫn có toàn quyền can thiệp vào quá trình config.\nBeanstalk thì miễn phí còn các dịch vụ nó quản lý bên trong(EC2 Instance, ELB, …) thì chúng ta phải trả tiền như bình thường.\n\n🌿 Components §\n\nApplication: Tổng hợp toàn bộ các component của một Beanstalk(enviroments, configuration, versions, …)\nApplication Version\nEnvironments\n\nTổng hợp toàn bộ AWS resourecs để chạy một website(chỉ chạy được mỗi ứng dụng một môi trường)\nTiers- quản lý từng tầng, vd như tầng server và tầng worker.\nCó thể tạo nhiều enviroments(test, dev, stg, production)\n\n\n\n\n🌿 Deployment modes §\n\n\nSingle Instance\n\n\n\nHigh Availability\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Hybrid-Cloud-for-Storage":{"title":"🌱 Hybrid Cloud for Storage","links":[],"tags":["aws"],"content":"🌿 What? §\n\nAWS thúc đẩy hybrid cloud\n\nMột phần thuộc về cơ sở hạ tầng trên cloud\nMột phần thuộc về cơ sở hạ tầng(mặt đất) của chúng ta.\n\n\nVậy làm thế nào để chúng ta có thể cho dữ liệu được giao tiếp mượt mà giữa hai hạ tầng đó? - AWS Storage Gateway\n\n🌿 AWS Storage Cloud Native Options §\n\n🌿 AWS Storage Gateway §\n\nLà cầu nối giữa dữ liệu ‘mặt đất’ và dữ liệu trên cloud\n\nUse cases:\n\nPhục hồi thảm họa\nBackup &amp; restore\nLàm tầng lưu trữ\ncache\n\n\nTypes:\n\nS3 File Gateway\nFSx File Gateway\nVolume Gateway\nTape Gateway\n\n\n\n🍃 S3 File Gateway §\n\n\nCó thể truy cập S3 File Gateway thông qua 2 giao thức là NFS và SMB.\nHầu hết các dữ liệu thường xuyên được truy cập sẽ năm ở file gateway.\nHỗ trợ S3 Standard, S3 Standard IA, S3 One Zone A, S3 Intelligent Tiering.\nChuyển dữ liệu tới S3 Glacier bằng Lifecrycle Policy.\nBucket sử dụng IAM roles để truy cập cho từng File Gateway.\nGiao thức SMB tích hợp với Active Directory (AD) để xác thực người dùng.\n\n🍃 FSx File Gateway §\n\n\nLocal cache những dữ liệu thường xuyên được truy cập\nTương thích với Window\nHữu ích cho việc nhóm các file và làm thư mục home.\n\n🍃 Volume Gateway §\n\n\nSử dụng giao thức iCSI để giao tiếp giữa local và Volume Gateway\nEBS snapshots có thể giúp restore dữ liệu ‘mặt đất’.\nCached volumes: độ trễ thấp khi truy cập dữ liệu thường xuyên.\nStored volumes: lưu trữ được toàn bộ dữ liệu ‘mặt đất’, sắp lịch để backups dữ liệu vào S3.\n\n🍃 Tape Gateway §\n\n\nVới một số công ty vẫn thực hiện việc sao chép dữ liệu trên đĩa từ, có thể sử dụng option này. Luồng thì vẫn như trên, dữ liệu vẫn sẽ được lưu trữ trên cloud.\nDữ liệu trên S3 sẽ được lưu trữ trong Amazon Glacier hoặc Glacier Deep Archive.\n\n🌿 Hardware appliance §\n\n\nVới 4 options trên, chúng ta đều sẽ cài các gateway trên máy ảo ở dưới local để sử dụng. Nhưng nếu chúng ta không có đủ tài nguyên để add thêm một gateway, chúng ta có thể thuê hardware của AWS, sau đó cài gateway lên đấy.\nHoạt động với 3 options trên trừ S3 File Gateway.\nHữu ích cho việc backup hàng ngày hệ thống NFS ở những data centers nhỏ.\n\n🌿 Summary §\n"},"40123345-posts/42-Code/42.03-AWS/IAM---Identify-and-Access-Management/Amazon-SSO":{"title":"🌱 Amazon SSO - Single Sign-On Service","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ cho phép đăng nhập một lần.\nQuan trọng, dịch vụ này còn cung cấp giải pháp quản lý quyền truy cập cho các accounts, roles, …\nCó 3 kiểu xác định chính:\n\nMulti-Account Permission:\n\nQuán lý truy cập của nhiều accounts trong Organization của bạn.\nPermission Sets - Là các bộ xác định quyền có thể sử dụng để assign cho các accounts.\n\n\nApplication Assignment:\n\nQuản lý thông qua một bên thứ 3 kiểu Okta, Saleforce, …\nBên thứ 3 sẽ cung cấp các thông tin như url, metadata, user info, …\n\n\nAttribute-Base Access Control:\n\nXác định quyền truy cập dựa vào attribute của account.\nVd quyền truy cập được xác định khác nhau với từng level account: junior, senior, expert,…\n\n\n\n\n"},"40123345-posts/42-Code/42.03-AWS/IAM---Identify-and-Access-Management/IAM---Identify-and-Access-Management":{"title":"🌱 IAM - Identify and Access Management","links":[],"tags":["aws"],"content":"🌿 What? §\n\n🌱 Một Global service - Region nào cũng có.\n🌱 Sử dụng để tạo users và groups.\n🌱 Mỗi user đại diện cho một người trong tổ chức.\n🌱 Mỗi group chỉ chứa users, không chứa group khác.\n🌱 Users có thể không thuộc một group nào(ko best practice) và 1 user có thể thuộc nhiều groups.\n\n\n🌿 Why? §\n\n🌱 Không bao giờ được cho tất cả users được sử dụng tất cả services.\n🌱 User cần làm gì -&gt; tạo quyền cho sử dụng cái đó. Tránh chi phí phát sinh(do user có thể launch được một đống services), vấn đề bảo mật.\n🌱 Users hoặc Groups có thể được assign JSON documents gọi là polices.\n\n\n\n\n                  \n                  Note \n                  \n                \nThe least privilege principle: Nguyên tắc đặc quyền tối thiểu.\n\n🌿 What is polices? §\n\n🌱 Xác định quyền của users hoặc groups.\n🌱 Bao gồm:\n\nVersion\nID (optional)\nStatement:\n\nSid: Statement id\nEffect: Allow | Deny\nPrincipal: account/user/role áp dụng policy\nAction: những acctions được cho phép || không cho phép\nResource: những resources áp dụng policy\nCondition(optional): điều kiện cho effect\n\n\n\n\n\n🌿 Protect mechanisms §\n\n🌱 Set Password\n🌱 MFA - Multi Factor Authentication\n\n📳 Virtual MFA device: GG Authencitator, Authy(nhiều tokens trên một device)\n🔑 Universal 2nd Factor(U2F) Security Key: YubiKey by Yubico(3rd party of AWS)(một security key dùng được cho nhiều root accounts and IAM users)\nHardware Key Fob MFA  Device.\nHardware Key Fob MFA Device for AWS GovCloud(US)\n\n\n\n🌿 What’s the AWS CLI? §\n\n🌱 Cho phép tương tác với các AWS Services thông qua terminal thay vì AWS Mangement Console.\n🌱 Truy cập trực tiếp đến các APIs của các AWS Services.\n🌱 Có thể sử dụng script để quản lý resources cũng như một số task tự động.\n\n🌿 What’s the AWS SDK? §\n\n🌱 Software Development Kit, một cách khác để tương tác với AWS Services.\n🌱 Được nhúng trong chương trình của chúng ta(kiểu như thư viện).\n🌱 Hỗ trợ nhiều program languages, mobile devices and IoT devices.\n\n🌿 IAM Roles §\n\n🌱 Một vài Intance Services sẽ cần thực hiện một số hành động và chúng ta cần thêm quyền cho chúng thông qua việc tạo IAM Roles.\n🌱 Common roles:\n\nEC2 Instance Roles\nLambda Function Roles\nRoles for CloudFormation\n\n\n\n🌿 IAM Security Tools §\n\n🌱 IAM Credentials Report (account-level)\n\nMột danh sách tất cả các users của account và trạng thái của các credentials.\n\n\n🌱 IAM Access Advisor (user-level)\n\nHiển thị những service permissions đã tạo cho một user và thời gian cuối cùng những services đó được truy cập.\n-&gt; theo dõi để nhận biết những permissions nào không được sử dụng -&gt; xóa nó đi, tuân thủ phương châm The principle least privilege.\n\n\n\n🌿 IAM Best Practice §\n\n🌱 Không sử dụng root account, nên tạo một IAM account và chỉ định quyền cho account.\n🌱 Mỗi một người(physical user) = một AWS user.\n🌱 Nên assign users vào groups và chỉ định quyền cho group.\n🌱 Tạo một password mạnh cho policy, nếu lộ người khác có thể thêm quyền tùm lum\n🌱 Sử dụng MFA, nâng cao tính bảo mật.\n🌱 Tạo và sử dụng IAM Roles để chỉ định permissions đến những AWS services.\n🌱 Sử dụng Access Keys khi Programatic Access(CLI/SDK).\n🌱 Audit lại permissions của account bằng IAM Access Advisor.\n🌱 Never share IAM users &amp; Access Keys.\n"},"40123345-posts/42-Code/42.03-AWS/IAM---Identify-and-Access-Management/Organizations":{"title":"🌱 Organizations","links":[],"tags":["aws"],"content":"🌿 What? §\n\nGlobal service\nLà dịch vụ cho phép quản lý phân cấp trên nhiều AWS accounts. Tăng khả năng quản lý cũng như nhất quán về quyền truy cập và sử dụng tài nguyên của các tài khoản.\nAccount chính sẽ là account quản lý, các accounts còn lại là account thành viên.\nCác accounts thành viên chỉ là một phần của organization.\nThanh toán cho toàn bộ các accounts - thanh toán một lần.\nNhận được lợi ích về giá từ nhu cầu sử dụng.\nChia sẻ reserved instances và saving plans giữa các accounts.\nCó API để tự động tạo mới một AWS account.\n\n🌿 Advantages §\n\nMulti Account vs One account Multi VPC\nDùng tag tiêu chuẩn để phục vụ mục đính thanh toán.\nEnable CloudTrail cho tất cả các accounts và gửi logs tới S3 của account trung tâm.\nGửi logs của CloudWatch cho account trung tâm.\nLập được các Cross Accout Rules với mục đích quản trị.\n\n🌿 Security: Service Control Policies(SCP) §\n\nIAM Policies cho phép apply cho OU(Organization Unit) hoặc các accounts để restrict User và Roless.\nKhông thể áp dụng đối với account quản lý(management account)\nCần phải xác định quyền hạn rõ ràng(không cho một account dùng hết các services được).\n"},"40123345-posts/42-Code/42.03-AWS/Instantiating-Applications-Quickly":{"title":"🌱 Instantiating Applications Quickly","links":[],"tags":["aws"],"content":"\nThông thường, khởi chạy một app chúng ta sẽ thường chạy stack sau: EC2 instance, EBS, RDS, làm thế nào để tăng tốc khởi chạy stack này?\nEC2 Instance:\n\nSử dụng Golden AMI - Là Image đã thực hiện install packages cũng như config từ trước rồi, giúp tăng tốc trong việc khởi chạy một instance mới.\nBootstrap User Data - Sử dụng User Data để thực hiện các tác vụ config động.\nHybrid Kết hợp giữa Golden AMI và User Data (Elastic Beanstalk)\n\n\nEBS vs RDS:\n\nLưu trữ snapshot để thực hiện restore nhanh chóng\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-Comprehend":{"title":"🌱 Amazon Comprehend","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ sử dụng trí tuệ nhân tạo để xử lý ngôn ngữ tự nhiên - Natural Language Procssing - NPL.  Nó cho phép phân tích và xử lý dữ liệu văn bản để trích xuất thông tin và đánh giá ý kiến.\nĐược quản lý hoàn toàn bởi AWS và là dịch vụ serverless.\nNó có thể:\n\nPhân tích được ngôn ngữ của text.\nTrích xuất ra các thông tin quan trọng.\nHiểu bối cảnh, cảm xúc của văn bản.\nPhân tích từ khoá.\nTự động tổ chức thu thập các files văn bản dựa theo chủ đề.\n\n\nUse cases:\n\nPhân tích email của khách hàng, xem khách hàng cảm thấy thế nào thông qua feedback.\nTạo và nhóm các bài báo, bài nghiên cứu theo các chủ đề.\n\n\n\n🌿 Amazon Comprehend Medical §\n\nLà dịch vụ xử lý ngôn ngữ tự nhiên với những văn bản y khoa.\n"},"40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-Forecast":{"title":"🌱 Amazon Forecast","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ được quản lý hoàn toàn bởi AWS, sử dụng trí tuệ nhân tạo để đưa ra các dự đoán về xu hướng hoặc giá trị tương lai của dữ liệu, từ đó tăng tính chính xác  đồng thời giảm thiểu rủi ro của các quyết định.\nNó có khả năng:\n\nXử lý các dữ liệu thời gian: cho phép dễ dàng nhập các loại dữ liệu thời gian khác nhau từ các nguồn khác nhau, bao gồm cả dữ liệu không đầy đủ(ngắt quãng hoặc bị thiếu).\nChuẩn bị dữ liệu.\nXây dựng và triển khai models.\nQuản lý models.\n\n\nUse cases: được sử dụng rộng rãi ở nhiều lĩnh vực như tài chính, bản lẻ hay dự báo tiêu thụ điện năng, …\n"},"40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-Kendra":{"title":"🌱 Amazon Kendra","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ được quản lý hoàn toàn của AWS, sử dụng trí tuệ nhân tạo để tìm kiếm và khai thác thông tin từ nhiều nguồn dữ liệu khác nhau một cách thông minh. Giống con ChatGPT.\nGiúp giảm thời gian tìm kiếm và nâng cao hiệu suất của người dùng.\nCó khả năng hiểu được ngôn ngữ tự nhiên để tìm kiếm câu trả lời.\nHọc tăng cường - Incremental Learning, học liên tục từ chính những tương tác hoặc phản hồi của người dùng.\nBảo mật: đảm bảo dữ liệu được bảo vệ và chỉ có thể tương tác khi có quyền.\nUse cases: Áp dụng cho các ngành bán lẻ, tài chính, lập trình, …\n"},"40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-Lex-&-Amazon-Connect":{"title":"🌱 Amazon Lex & Amazon Connect","links":[],"tags":["aws"],"content":"🌿 What? §\n\nAmazon Lex:\n\nLà dịch vụ chatbot dựa trên các cuộc đối thoại, cho phép người dùng xây dựng các ứng dụng đối thoại tự động với giọng nói và văn bản.\nCó thể hiểu được nhiều ngôn ngữ.\nỨng dụng tạo chatbot hoặc call center bots.\n\n\nAmazon Connect:\n\nLà dịch vụ tổng đài điện thoại trên cloud.\nNhận cuộc gọi, tạo contact flows, dựa trên virtual contact center\nRẻ hơn 80% các giải pháp cho contact center truyền thống khác.\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-Personalize":{"title":"🌱 Amazon Personalize","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ được quản lý hoàn toàn bởi AWS, sử dụng trí tuệ nhân tạo để đào tạo và triển khai các hệ thống đề xuất sản phẩm hoặc nội dung cá nhân(kiểu như thuật toán recommend video của tiktok)\nTăng trải nghiệm sử dụng ứng dụng cho người dùng.\nCác tính năng:\n\nTính cá nhân hoá.\nĐào tạo và triển khai mô hình.\nHỗ trợ sử dụng nhiều nguồn dữ liệu. Tích hợp được với các hệ thống khác(websites, apps, …).\nBảo mật.\n\n\nUse case: ứng dụng cho các lĩnh vực bán lẻ, giải trí hoặc truyền thông.\n"},"40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-Polly":{"title":"🌱 Amazon Polly","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ sử dụng trí tuệ nhân tạo để chuyển đổi văn bản thành giọng nói.\nCó thể custom từ vực cho Polly với Pronunciation lexicons.\n\nStylized words: St3ph4ne =&gt; ‘Stephane’\nAcronyms: AWS =&gt; ‘Amazon Web Services’\n\n\nUpload lexicons và sử dụng chúng trong SynthesizeSpeech.\nTạo giọng nói từ văn bản hoặc từ tài liệu với Speech Synthesis Markup Language(SSML)\n\nThêm ngắt nghỉ.\nSử dụng giọng điệu mà mình muốn ,…\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-Rekognition":{"title":"🌱 Amazon Rekognition","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ sử dụng Trí tuệ nhân tạo để xử lý thông tin từ hình ảnh và videos.\nNó có thể:\n\nPhát hiện và phân tích khuôn mặt\nNhận dạng đối tượng: ô tô, xe máy, …\nPhân tích hoạt động.\nPhát hiện và phân tích văn bản.\nTạo ra dữ liệu đào tạo và đối tượng chính xác.\n\n\nUse cases:\n\nTìm kiếm phân tích khuôn mặt(giới tính, độ tuổi, tâm trạng, …)\nGiám sát an ning.\nQuản lý nội dung.\nQuản lý tài sản.\n\n\n\n🌿 Content Moderation - Kiểm duyệt nội dung §\n\nTìm ra những nội dụng không cần thiết, phản cảm, … của videos và images.\nSử dụng cho mạng xã hội, e-commerce, quảng cáo, … để đem lại trải nghiệm tốt hơn cho người dùng.\nSet Minimum Confidnce Threshold cho items để đánh dấu, những items này sẽ được đánh giá thủ công trong Amazon Augmented AI(A21), giúp nội dung tuân thủ theo đúng những quy chuẩn.\n"},"40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-SageMaker":{"title":"🌱 Amazon SageMaker","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ được quản lý hoàn toàn bởi AWS, cung cấp một nền tảng đầyy đủ cho việc phát triển, đào tạo và triển khai các mô hình học máy cho các ứng dụng của nguời dùng.\nCác tính năng:\n\nThu thập và chuẩn bị dữ liệu.\nXây dựng và train models.\nTriển khai và quản lý models.\nGiúp triển khai được cả các models đã được train ở nền tảng khác.\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-Textract":{"title":"🌱 Amazon Textract","links":["40123345-posts/42-Code/42.03-AWS/S3","40123345-posts/42-Code/42.03-AWS/Amazon-DynamoDB","40123345-posts/42-Code/42.03-AWS/Amazon-Aurora","40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-Comprehend"],"tags":["aws"],"content":"🌿 What? §\n\n\nLà dịch vụ sử dụng trí tuệ nhân tạo để trích xuất các thông tin quan trọng từ những tài liệu truyền vào.\nTự động hoá việc trích xuất dữ liệu, sàng lọc thông tin từ các tài liệu phức tạp, từ đó nâng cao hiệu suất làm việc.\nCó thể đọc được nhiều định dạng tài liệu(PDFs, images, …)\nThường được dùng để phân tích nhiều loại tài liệu khác nhau như hoá đơn, báo cáo tài chính, biểu mẫu, bảng tính, …\nCó thể tích hợp với nhiều services khác như S3, DynamoDB, Aurora, Comprehend, …\nCác dữ liệu này sẽ được bảo mật.\n"},"40123345-posts/42-Code/42.03-AWS/Machine-Learning/Amazon-Transcript":{"title":"🌱 Amazon Transcript","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà một dịch vụ sử dụng trí tuệ nhân tạo để nhận dạng giọng nói của các file âm thanh hoặc videos và chuyển đổi thành văn bản.\nGọi ASR(automatic speech recognition) để chuyển đổi từ các cuộc hội thoại sang văn bản một cách nhanh chóng và chính xác.\nTự động bỏ những thông tin cá nhân của người(Personally Identifiable Information - PII) bằng Redaction.\nTự động detect được ngôn ngữ của các đoạn hội thoại.\nUse cases:\n\nDetect văn bản từ những cuộc gọi với KH.\nLàm phụ đề cho video.\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Monitoring/AWS-Config":{"title":"🌱 AWS Config","links":["40123345-posts/42-Code/42.03-AWS/Amazon-SNS---Simple-Notification-Service","40123345-posts/42-Code/42.03-AWS/S3","40123345-posts/42-Code/42.03-AWS/Databases/Amazon-Athena"],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ quản lý cầu hình, cung cấp khả năng theo dõi và kiểm soát cấu hình tài nguyên của các AWS services.\nGiúp kiểm tra cũng như tuân thủ các luật lệ cho mỗi account.\nGiúp lưu lại config và có thể thay đổi bất kỳ lúc nào.\nCác vấn đề có thể giải quyết với AWS Config:\n\nCó cái truy cập SSH không được unsretricted truy vập vào sg không?\nBuckets có bao nhiêu truy cập public?\n\n\nCó thể nhận được thông báo (SNS) khi có bất kỳ thay đổi nào.\nAWS Config là một dịch vụ riêng trên từng region.\nCó thể tổng hợp các dịch vụ từ nhiều regions và accounts.\nCó thể lưu config vào S3 và dùng athena để phân tích dữ liệu.\n\n🌿 Rules §\n\nRules có thể được sử dụng để đánh giá/ trigger:\n\nCho những config thay đổi.\nand/or tại một thời điểm bất kỳ\n- Nó không được dùng với mục đích ngăn ngừa các actions có thể xảy ra.\n\n\nGiá:\n\nkhông có free tier\n0.003$ cho từng config item lưu trên một region\n0.001$ cho từng rule đánh giá trên một region\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Monitoring/Amazon-CloudTrail":{"title":"🌱 Amazon CloudTrail","links":["40123345-posts/42-Code/42.03-AWS/Monitoring/Amazon-CloudWatch","40123345-posts/42-Code/42.03-AWS/S3"],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ cung cấp khả năng ghi lại toàn bộ logs từ các hoạt động của một AWS account.\nGiúp dễ dàng hơn trong việc kiểm tra, tuân thủ của các tài khoản AWS.\nDịch vụ này được bật mặc định.\nGhi lại logs từ:\n\nConsole\nSDK\nCLI\nAWS Services\n\n\nCó thể đặt logs của CloudTrail trong CloudWatch Logs hoặc S3.\nMột trail có thể áp dụng cho All Regions(mặc định) hoặc chúng ta cũng có thể set cho một region riêng biệt.\nNếu một resource bị xóa thì đầu tiên, nó sẽ được ghi vào CloudTrail.\n\n🌿 Events §\n\nManagement Events:\n\nLà các events thực hiện trên các resources với AWS account.\nVí dụ như:\n\nTạo Security Group\nConfig rules cho routing data(Amazon EC2 CreateSubnet)\n\n\nMặc định, Trail config là bật để log management events.\nCó thể tách biệt Read Event từ Write Event\n\n\nData Events:\n\nMặc định cái này không được bật.\n\n\n\n🌿 Insights §\n\nBật CloudTrail insight để có thể tìm ra được các hoạt động bất thường trong một AWS account.\nNó sẽ phân tích các management events bình thường để tạo ra một đường cơ sở, đánh giá được mức độ sử dụng.\nCloudTrail Insight liên tục phân tích các write events phát hiện sớm các patterns bất thường trong quá trình hoạt động.\n\n\n🌿 Retension §\n\nLưu trong CloudTrail: tối đa 90 ngày\nTrong S3: 4ever.\n"},"40123345-posts/42-Code/42.03-AWS/Monitoring/Amazon-CloudWatch":{"title":"🌱 Amazon CloudWatch","links":["40123345-posts/42-Code/42.03-AWS/S3","40123345-posts/42-Code/42.03-AWS/Amazon-Kinesis","40123345-posts/42-Code/42.03-AWS/AWS-Lambda","40123345-posts/42-Code/42.03-AWS/Amazon-OpenSearch-Service","40123345-posts/42-Code/42.03-AWS/Amazon-SNS---Simple-Notification-Service"],"tags":["aws"],"content":"🌿 What? §\n\nLà một dịch vụ giám sát, ghi log và cảnh báo trên môi trường cloud của AWS. Nó giúp chúng ta giám sát tài nguyên và ứng dụng trên AWS, thu thập và phân tích các dữ liệu khác nhau, cung cấp các thông tin về hoạt động và hiệu suất của các tài nguyên và ứng dụng của chúng ta.\n\n🌿 CloudWatch Metrics §\n\nLà tính năng của CloudWatch cung cấp các thông số hiệu suất hoạt động của tất cả các services của AWS.\nMetric là một biến để giám sát(CPUUtilization, network, …)\nCác Metrics thuộc về các namespaces.\nDimension là một thuộc tính của một metric(instance id, environment, …)\nTối đa là 30 dimensions cho từng metric.\nCác metrics đều có timestamps.\nCó thể tạo CloudWatcch dashboards từ các metrics.\nCó thể tạo CloudWatch Custom Metrics để trích xuất dữ liệu cần thiết(ví dụ như trích xuất metric của RAM của EC2 instance, …)\n\n🌱 Streams §\n\nCó thể liên tục stream các thông số hiệu suất của app tới các destinations khác để thực hiện các tác vụ như lưu trữ, phân tích … với tần suất near-real-time và độ trễ thấp.\nCó thể lựa chọn filters metrics để chỉ định stream tới destinations.\n\n\n🌿 CloudWatch Logs §\n\nLà tính năng của CloudWatch giúp chúng ta lưu trữ Logs của hệ thống.\nLog groups: thường là đại diện cho một app.\nLog stream: instances bên trong app / log files / containers.\nCó thể xác định thời gian hết hạn của log(nerver, 30 days, …), sau thời gian hết hạn, log sẽ tự động được xóa. Chúng ta sẽ phải trả tiền để được lưu log trên AWS.\nCloudWatch Logs có thể gửi logs tới:\n\nAmazon S3\nKinesis Data Streams\nKinesis Data Firehose\nAWS Lambda\nOpenSearch\n\n\n\n🌱 Filter &amp; Insights §\n\nCó thể filter để xem log dễ dàng hơn.\nMetric filters có thể được sử dụng để trigger CloudWatch alarms.\nCloudWatch Logs Insight có thể được sử dụng để query logs và thêm các câu queries để làm Dashboards.\n\n🌱 Log Subcriptions §\n\n\nDùng Subcription Filter để điều hướng đến các dịch vụ tùy theo nhu cầu sử dụng của dự án.\n\n\n\nKiến trúc để thu thập logs từ nhiều accounts, regions về một chỗ:\n\n\n\n🌿 Agent &amp; Logs Agent §\n\nMặc định sẽ không có logs từ EC2 machine tới CloudWatch. Để thu thập logs của EC2, chúng ta cần tạo một CloudWatch Agent đặt trong EC2 và nó sẽ thu thập + push log lên CloudWatch.\nLưu ý về IAM permissions.\nCloudWatch log agent có thể setup được cả ở những server on-premises\n\n\n🌿 Alarms §\n\nLà dịch vụ dùng để trigger các thông báo của các metrics.\nCó nhiều options(sampling, % max, min, …) để thực hiện trigger\nAlarm States:\n\nOK\nINSUFFICIENT_DATA\nALARM\n\n\nPeriod - thời gian tính theo giây, để đánh giá metric.\n\ncó thể custom: 10s, 30s hoặc nhiều lần 60s.\n\n\nTargets - đối tượng trigger của alarms:\n\nStop, Terminate, Reboot hoặc Recover EC2 Instance.\nTrigger đến Auto Scaling Action.\nGửi thông báo đến SNS.\n\n\n\n🌱 Composite Alarms §\n\n\nCloudWatch Alarms là một metric đơn lẻ.\n\n\nComposite alarms sẽ giúp chúng ta giám sát được trạng thái của nhiều alarms khác nhau.\n\n\nCó thể kết hợp điều kiện AND hoặc OR để kết hợp các alarms, tránh gặp những alarm noise không cần thiết.\n\nVí dụ high CPU và high Network là bình thường, mình chỉ cần nó alarm lúc bất thường như high CPU những low Network. Đó chính là tác dụng của Composite Alarms.\n\n\n\nAlarms có thể được tạo dự trên CloudWatch Logs Metrics Filters.\n\n\n🌿 Insight §\n\nContainer insight:\n\nTrích xuất, tổng hợp logs và metrics của các container trong AWS, sử dụng CloudWatch Agent.\n\n\nLambda insight:\n\nTrích xuất, tổng hợp logs và metrics cho các ứng dụng có kiến trúc serverless.\n\n\nContributes insight:\n\nCung cấp các thông tin chi tiết, dễ dàng tìm kiếm các thông số có giá trị bất thường.\n\n\nApplication insight:\n\nTự động tạo bảng thống kê, phản ánh các vấn đề của hệ thống hoặc của các AWS services.\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Monitoring/Amazon-EventBridge":{"title":"🌱 Amazon EventBridge","links":["40123345-posts/42-Code/42.03-AWS/AWS-Lambda","40123345-posts/42-Code/42.03-AWS/Amazon-SNS---Simple-Notification-Service"],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ hỗ trợ quản lý các sự kiện trigger đến các serivecs của AWS.\nSchedule: Cron jobs\n\nvd như mỗi giờ trigger đến Lambda Function để thực hiện tác vụ gì đó.\n\n\nEvent Pattern: Event rules xác định tới một service sẽ thực hiện một tác vụ\n\nvd: Khi có sự kiện IAM Root User đăng nhập, SNS sẽ gửi email.\n\n\n\n\n🌿 Rules §\n\n🌿 Schema Registry §\n\nEventBridge có thể phân tích các events trong bus và suy luận được ra schema.\nSchema Registry cho phép bạn gen code ra cho app, nó sẽ giúp chúng ta biết trước dữ liệu được cấu trúc như thế nào trong bus.\n"},"40123345-posts/42-Code/42.03-AWS/Networking---VPC/AWS-Network-Firewall":{"title":"🌱 AWS Network Firewall","links":["40123345-posts/42-Code/42.03-AWS/Networking---VPC/VPC---Virtual-Private-Cloud","40123345-posts/42-Code/42.03-AWS/Security-&-Encryption/AWS-Firewall-Manager"],"tags":["aws"],"content":"🌿 What? §\n\n\nBảo vệ cho toàn bộ VPC.\n\n\nBảo vệ từ Layer 3 và 7.\n\n\nNó sử dụng AWS Network Load Balancer\n\n\nCác rules được define được quản lý toàn bộ trên AWS Firewall Manager, để có thể áp dụng cho nhiều VPCs của nhiều accounts.\n\n\n\nHỗ trợ có thể define tới 1000 rules.\n\n\nTraffic Filtering: Allow, drop hoặc aleart nếu bắt gặp traffic match với các rules đã define.\n\n\nActive Flow Inspection: một biện pháp bảo vệ. Ngăn chặn các truy cập bất thường(giống như Network Load Balancerr)\n\n\nCó thể send log tới S3, Athena, … kết hợp với các dịch vụ khác để lưu trữ hoặc phân tích tùy theo nhu cầu của hệ thống.\n\n"},"40123345-posts/42-Code/42.03-AWS/Networking---VPC/AWS-Site-to-Site-VPC":{"title":"🌱 AWS Site-to-Site VPC","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà kiến trúc giúp kết nối các resources trong Private Subnet tới các server on-premise.\n\nGồm 3 thành phần:\n\nVirtual Private Gateway đặt ở VPC trên AWS, có tránh nhiệm là cổng kết nối bên Cloud.\nCổng kết nối bên on-premise là Custimer Gateway(public IP) hoặc là NAT Device.\n\n\nLưu ý:  Phải nhớ bật Route Propagation để kết nối Virtual Private Gateway với VPC.\nVPN CloudHub: Sử dụng khi cần kết nối đến nhiều servers on-premise.\n"},"40123345-posts/42-Code/42.03-AWS/Networking---VPC/Bastion-Host":{"title":"🌱 Bastion Host","links":["40123345-posts/42-Code/42.03-AWS/Networking---VPC/VPC---Virtual-Private-Cloud"],"tags":["aws"],"content":"🌿 What? §\n\nVì tất cả các EC2 Instances của chúng ta đều nằm trong VPC, chính vì vậy không thể để người dùng trực tiếp từ bên ngoài truy cập vào được, sẽ có nhiều rủi ro về bảo mật.\nĐể giảm thiểu rủi ro, chúng ta sẽ tạo một Bastion Host trong một EC2 Instance, nó sẽ là một pháo đài dựng trước các EC2 server của chúng ta.\nCon Bastion đặt public để người dùng SSH vào, sau SSH vào xong, người dùng sẽ tiếp tục từ đây SSH tiếp vào các EC2 Server.\nĐể tăng thêm tính bảo mật, có thể restrict subnet IP từ con Bastion luôn.\nLưu ý là cần setup Security Group để các phần có thể giao tiếp được với nhau.\n\n"},"40123345-posts/42-Code/42.03-AWS/Networking---VPC/CIDR,-Private-and-Public-IP":{"title":"🌱 CIDR, Private and Public IP","links":[],"tags":["aws"],"content":"🌿 CIDR - Classless Inter-Domain Routing §\n\nLà một method thực hiện viêc phân bổ các địa chỉ IP.\nĐược sử dụng trong Security Groups và networking của AWS nói chung.\n\nGiúp chúng ta define một dải địa chỉ IP:\n\nWWW.XX.YY.ZZ/34 =&gt; một IP\nWWW.XX.YY.ZZ/0 =&gt; tất cả IPs trong dải đó.\nNhưng chúng ta có thể define: 192.168.0.0/26 =&gt; đại diện cho một dải 64 IPs 192.168.0.0 -&gt; 192.168.0.63\n\n\n\n🌿 Ingredients §\n\n\nGồm 2 phần:\n\nBase IP\n\nĐại diện cho một dải IP.\n10.0.0.0, 192.168.0.0, …\n\n\nSubnet Mask\n\nXác định số lượng bits có thể thay đổi được trên IP\nCác dạng hay gặp:\n\n8 &lt;=&gt; 255.0.0.0\n16 &lt;=&gt; 255.255.0.0\n24 &lt;=&gt; 255.255.255.0\n32 &lt;=&gt; 255.255.255.255\n\n\n\n\n\n\n\nCách xác định dải IP từ Subnet Mask:\n\n\n\n192.168.0.0/24 2^(32-24) IP &lt;=&gt; 192.168.0.0 -&gt; 192.168.0.255\n🌿 Private &amp; Public IP §\n\nPrivate IP là các dải sau:\n\n10.0.0.0 -&gt; 10.255.255.255 (10.0.0.0/8)\n172.16.0.0 -&gt; 172.31.255.255 (172.16.0.0/12) -&gt; dải địa chỉ IP của AWS VPC\n192.168.0.0 -&gt; 192.168.255.225 (192.168.0.0/16)\n\n\nTất cả các IPs còn lại thì là Public IP.\n"},"40123345-posts/42-Code/42.03-AWS/Networking---VPC/Direct-Connect-(DX)":{"title":"🌱 Direct Connect (DX)","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ cung cấp kết nối mạng riêng tư để kết nối giữa Data Center của chúng ta tới AWS.\nĐể sử dụng chúng ta cần setup một Virtual Private Gateway trên VPC.\nDX giúp chúng ta vừa có thể kết nối public(như resources của S3) và private(EC2 Instances) trong cùng một kết nối.\nMạng riêng tư này nó băng thông rộng, độ trễ thấp và độ tin cậy cao. Giúp nâng cao hiệu suất của hệ thống, trải nghiệm của người dùng.\nUse Cases:\n\nKhi ứng dụng có dataset lớn và muốn sử dụng với giá thành thấp.\nTrải nghiệm mạng đồng nhất, như là các ứng dụng realtime.\nHybrid Environments - có kết hợp giữa on-premise và cloud.\n\n\nDữ liệu được truyền tải không mã hóa, nhưng nó private.\n\n🌿 Diagram §\n\n🌿 Direct Connection Gateway §\n\nNếu chúng ta muốn kết nối giữa nhiều VPC ở khác regions(same accounts), chúng ta cần setup thêm Direct Connection Gateway.\n\n\n🌿 Connection Types §\n\nDedicated Connection - 1Gbs, 10Gbs, 100Gbs\n\nCho một cái etherner vật lý luôn.\nOrder thông qua AWS, AWS sẽ liên hệ đến Partner để hỗ trợ lắp đặt\n\n\nHosted Connection - 50Mbps, 500 Mbps, 10Gps\n\nKết nối được cung cấp do bên Partner của AWS.\nOption này chúng ta có thể add hoặc remove dựa theo nhu cầu sử dụng.\nCó thể tăng lên 1Gbs, 2, 5, 10.\n\n\nThời gian để lắp đặt cái này khá lâu, thường mất tầm 1 tháng để có thể sử dụng được Direct Connection.\n"},"40123345-posts/42-Code/42.03-AWS/Networking---VPC/IGW---Internet-Gateway-&-Route-Tables":{"title":"🌱 IGW - Internet Gateway & Route Tables","links":["40123345-posts/42-Code/42.03-AWS/Networking---VPC/VPC---Virtual-Private-Cloud"],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ cho phép các resources(vd như EC2) trong một VPC có thể kết nối được với internet.\nHA, mở rộng chiều ngang theo nhu cầu sử dụng.\nPhải được tạo riêng biệt với một VPC.\nMột VPC chỉ có thể connect với một IGW và ngược lại.\nVà route tables cũng phải được chỉnh sửa.\n\nKịch bản là EC2 Instance sẽ dựa vào Route Table để connect tới Router, Router sẽ điều hướng requests qua Internet Gateway, từ đây sẽ thực hiện kết nối với internet.\n"},"40123345-posts/42-Code/42.03-AWS/Networking---VPC/IPv6-for-VPC":{"title":"🌱 IPv6 for VPC","links":["40123345-posts/42-Code/42.03-AWS/Networking---VPC/VPC---Virtual-Private-Cloud","40123345-posts/42-Code/42.03-AWS/Networking---VPC/CIDR,-Private-and-Public-IP","40123345-posts/42-Code/42.03-AWS/Networking---VPC/IGW---Internet-Gateway-&-Route-Tables","40123345-posts/42-Code/42.03-AWS/Networking---VPC/NAT-Gateway"],"tags":["aws"],"content":"🌿 What is IPv6? §\n\nVì IP v4 chỉ được thiết kế để cung cấp 4.3 tỉ địa chỉ IP, và nó sẽ sớm bị sử dụng hết, chính vì vậy mà IPv6 được ra đời với nhiệm vụ chính để thay thế cho IPv4.\nIPv6 cung cấp 3.4 x 10^38 địa chỉ IP riêng biệt.\nTất cả các địa chỉ IPv6 đều là public và được định tuyến với internet(không có private range).\nRange được xác định từ 0000 -&gt; ffff, format là x.x.x.x.x.x.x.x.x(x là hexadecimal)\nVí dụ:\n\n2001:db6:3333:4444:5555:6666:7777:8888\n:: -&gt; tất cả 8 phần đều là số 0\n2001:db5:: -&gt; 6 phần cuối đều có số 0\n::1234:2345 -&gt; 6 phần đầu đều là số 0\n2001:db6::1234:2356 -&gt; 4 phần ở giữa đều là số 0\n\n\n\n🌿 IPv6 in VPC §\n\nLưu ý: Không thể tắt được IPv4 đối với VPC và subnets\nChúng ta có thể bật thêm IPv6 để làm public IP và sử dụng chung với IPv4.\nCác EC2 Instances sẽ ít nhất phải có 1 public IPv6 và 1 private IPv4.\nInternet Gateway có thể tương thích với cả 2 kiểu IP này.\n\n\n🌿 IPv6 trong Private Subnet §\n\n\nTheo luồng của IPv4, cũng có thể áp dụng cho IPv6 khi muốn kết nối internet, chúng ta sẽ tạo một NATGW ở Public Subnet để điều hướng requests tới Internet Gateway, từ đây sẽ gửi requests lên internet.\nNhưng với IPv6, có thể trực tiếp tạo một Egress-only Internet Gateway, không cần đi vòng qua 2 thằng trên kia nữa.\nLưu ý là phải config trên route table để kiểm soát traffic đúng yêu cầu sử dụng.\n"},"40123345-posts/42-Code/42.03-AWS/Networking---VPC/NACL---Network-Access-Control-List":{"title":"🌱 Network Access Control List","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà tường lửa có nhiệm vụ kiểm soát traffic vào và ra của một subnet.\nMỗi một subnet sẽ có một NACL riêng, khi tạo mới một subnet sẽ được gán với một NACL mặc định.\nBạn cần phải xác định các rules cho NACL:\n\nMỗi rule sẽ được gắn với một số (từ 1-32766), số càng lớn càng có độ ưu tiên giảm dần.\nRule xuất hiện trước sẽ được ưu tiên áp dụng.\n\nvd nếu define rule 100 Allow và rule 200 Deny, thì vẫn được Allow.\n\n\nQui tắc cuối cùng được đánh dấu hoa thị, nếu đến cái rule này thì reject hết, không nói nhiều.\nAWS khuyến nghị chúng ta nên đặt rule tăng dần với step là 100.\n\n\nNhững NACLs tạo mới tinh là nó sẽ reject tất cả. Còn với NACL mặc định. sẽ allow tất cả các traffic in/out.\nNACL là một lựa chọn phù hợp khi chúng ta muốn chặn địa chỉ IP tại tầng subnet.\n\n🌿 Ephemeral Ports §\n\nCung cấp các cổng giao thức TCP hoặc UDP ngẫu nhiên để hình thành một kết nối mạng tạm thời giữa các ứng dụng hoặc các thiết bị trên internet.\nClients sẽ connect tới một defined port và mong đợi rằng sẽ được nhận response từ một ephemeral port.\n\n"},"40123345-posts/42-Code/42.03-AWS/Networking---VPC/NAT-Gateway":{"title":"🌱 NAT Gateway","links":["40123345-posts/42-Code/42.03-AWS/Networking---VPC/NAT-Instance","40123345-posts/42-Code/42.03-AWS/Networking---VPC/IGW---Internet-Gateway-&-Route-Tables"],"tags":["aws"],"content":"🌿 What? §\n\nGiống như  NAT Instance, cũng có tác dụng để định tuyến traffic từ các EC2 Instances trong private subnet để kết nối internet, nhưng NAT Gateway sẽ được AWS hỗ trợ hết, mình chỉ cần dùng thôi.\nVì do AWS bảo kê nên nó HA, có khả năng mở rộng theo nhu cầu sử dụng của các instances trong subnet, có thể tự động khởi động lại khi có lỗi.\nKhông cần phải quản lý Security Group\nNATGW được tạo trên một AZ chỉ định, và được gán một ElasticIP.\nBắt buộc phải kết hợp cùng với IGW.\n\nNhư đã biết thì trong Private Subnet không thể kết nối được với mạng internet, vì vậy cần phải sử dụng route table để định tuyến traffic tới resource(ở đây là NATGW) bên public subnet để nó trigger tới Router,  Router như cái phễu đổ hết traffic vào IGW để gửi lên internet.\n"},"40123345-posts/42-Code/42.03-AWS/Networking---VPC/NAT-Instance":{"title":"🌱 NAT Instance","links":["40123345-posts/42-Code/42.03-AWS/Networking---VPC/IGW---Internet-Gateway-&-Route-Tables","40123345-posts/42-Code/42.03-AWS/ASG---Auto-Scaling-Group","40123345-posts/42-Code/42.03-AWS/Networking---VPC/NAT-Gateway"],"tags":["aws"],"content":"🌿 What? §\n\n\nNAT - Network Address Translation\n\n\nLà một EC2 Instance trung gian giúp các EC2 Instances trong private subnets có thể kết nối được với internet.\n\n\nNAT Instance phải được launch public\n\n\nPhải tắt setting trong EC2: Source / destination check\n\n\nPhải attach ElasticIP cho NAT Instance.\n\n\nPhải config thêm Route Table để định tuyến traffic của các EC2 Instance trong Private Submet sang NAT Instance.\n\n\n\nKiến trúc tương tự như sử dụng IGW, những sẽ thay thế bằng NAT Instance.\n\n\n\n🌿 Notes §\n\nKhông được hỗ trợ kể từ 31/12/2020\nKhông HA/ không tự động thiết lập lại nếu có lỗi.\n\nCần phải config thêm như sử dụng ASG + script để resilient setup.\n\n\nBăng thông kết nối internet phụ thuộc vào EC2 Instance Type\nNgoài ra chúng ta còn cần phải quản lý thêm Security Groups và Roles của Instance.\nNên lựa chọn sử dụng NAT Gateway thay vì NAT Instance, nó outdate rồi.\n"},"40123345-posts/42-Code/42.03-AWS/Networking---VPC/Networking-Costs-in-AWS":{"title":"🌱 Networking Cost in AWS","links":[],"tags":["aws"],"content":"🌿 Những điều cần lưu ý §\n\n- Khi thực hiện tạo network trên AWS cần lưu ý:\n- Sử dụng private network của AWS sẽ rẻ hơn 0.01&lt;0.02 so với public. Vì private là chúng ta sẽ sử dụng mạng riêng của AWS, còn public thì AWS sẽ phải trả cho chúng ta phần chúng ta sử dụng trên mạng public.\n- Để tối ưu chi phí và trong trường hợp chúng ta muốn các EC2 Instances có thể giao tiếp tính toán với nhau ở tốc độ cao, hãy đặt chúng ở cùng AZ.\n\n\nEgress Traffic: outbound traffics(từ AWS ra ngoài - phải trả tiền)\nIngress Traffic: inbound traffics(từ ngoài vào AWS - miễn phí)\nNhư trên hình, nếu chúng ta lựa chọn đặt App ở local, outbound từ query DB sẽ rất là nhiều, và chúng ta phải trả với chi phí cao.\nThay vì đó, chúng ta hãy tạo tất cả các tài nguyên ở trên cloud, khi các dịch vụ giao tiếp với nhau trên môi trường cloud chúng sẽ không mất phí.\nNgoài ra trong trường hợp này chúng ta có thể sử dụng Direct Connection để kết nối từ cloud tới on-premise với chi phí rẻ hơn(cơ mà cái DC này lắp đặt cũng phải hơn tháng mới xong, nên cân nhắc nếu dự án cần sử dụng gấp thì bỏ nha).\n"},"40123345-posts/42-Code/42.03-AWS/Networking---VPC/Transit-Gateway":{"title":"🌱 Transit Gateway","links":["40123345-posts/42-Code/42.03-AWS/Networking---VPC/IGW---Internet-Gateway-&-Route-Tables"],"tags":["aws"],"content":"🌿 What? §\n\n\nVới rất nhiều các dịch vụ sử dụng để kết nối giữa các VPCs, từ VPCs kết nối tới on-premise, các VPCs ở khác regions, … Chính vì thế sẽ rất dễ làm cho cấu trúc liên kết mạng của hệ thống bị phức tạp, lâu dần sẽ khó mở rộng hoặc bảo trì, chưa kế đến vấn đề chi phí.\nGiải pháp là sử dụng Transit Gateway, như kiểu cafe 3in1, có sữa có đường có cafe, chỉ cần đổ nước nóng vào là uống thôi.\n\nCó thể kết nối giữa các region.\nChia sẻ trên nhiều accounts, sử dụng Resource Access Manager(RAM)\nCó thể sử dụng peer Transit Gateway trên nhiều region.\nKhi kết nối nhiều VPCs về một mối, cần chú ý setup route table để kiểm soát traffic giữa các VPCs, tránh không cho giao tiếp lung tung.\nHỗ trợ IP Multicast\n\n🌿 ECMP - Equal-Cost Multi-Part routing §\n\n\nSử dụng ECMP để giải quyết khi gặp bài toán cần kết nối với nhiều VPCs.\n\n🌿 Share Direct Connection between multiple accounts §\n\n\nTạo cái Direct Connection Gateway(ko share cho nhiều accounts được) ở ngoài, trỏ tới Transit Gateway để nó share cho các VPCs ở những accounts khác.\n"},"40123345-posts/42-Code/42.03-AWS/Networking---VPC/VPC---Virtual-Private-Cloud":{"title":"🌱 VPC - Virtual Private Cloud","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ cho phép tạo một môi trường mạng ảo trên AWS.\nGiúp chúng ta có thể tạo và quản lý các tài nguyên mạng của mình như route table, subnets, hay tường lửa, …\nCó thể có nhiều VPCs trong một region.\nMax CIDR trên một VPC là 5 đối với từng CIDR:\n\nMin size là /28 - 16 IPs\nMax size là /16 - 65,536 IPs\n\n\nBởi vì VPC là private IP, nên các giải IP nó nằm trong là:\n\n10.0.0.0/8\n172.16.0.0/12\n192.168.0.0/16\n\n\nVPC CIDR không nên trùng với các mạng khác.\n\n🌿 Default VPC §\n\nTất cả các accounts AWS mới đều có một VPC mặc định.\nMột EC2 Instance sẽ được launch trong VPC mặc định nếu không được chỉ định subnet.\nVPC mặc định có kết nối mạng và tất cả EC2 Instances trong đó sẽ có thể địa chỉ IPv4 public.\nChúng ta cũng có thể lấy một public và một private IPv4 DNS names.\n\n🌿 Subnet VPC §\n\nAWS sẽ giữ lại 5 địa chỉ IP(4 cái đầu tiên và 1 cái cuối cùng) cho từng subnet.\nChúng ta sẽ không thể assign 5 địa chỉ IP này cho các EC2 Instances được.\n5 địa chỉ này được giữ lại với mục đích:\n\n10.0.0.0: Network address\n10.0.0.1: AWS giữ lại cho VPC router\n10.0.0.2: AWS giữ lại để mapping tới DNS\n10.0.0.3: AWS giữ lại với mục đích dự phòng, sau này cần thì lôi ra sài.\n10.0.0.255: địa chỉ dành cho broadcast, AWS không hỗ trợ cái này nên địa chỉ này vứt xó.\n\n\nNếu trong bài thi có hỏi là cần 29 địa chỉ IP thì có thể suy ra là subnet mask phải cung cấp số địa chỉ IP &gt; 29 + 5 = 34 -&gt; /26\n"},"40123345-posts/42-Code/42.03-AWS/Networking---VPC/VPC-Endpoint":{"title":"🌱 VPC Endpoint","links":["40123345-posts/42-Code/42.03-AWS/Networking---VPC/IGW---Internet-Gateway-&-Route-Tables","40123345-posts/42-Code/42.03-AWS/Networking---VPC/NAT-Gateway","40123345-posts/42-Code/42.03-AWS/Networking---VPC/VPC---Virtual-Private-Cloud"],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ giúp chúng ta có thể kết nối trực tiếp từ trong private subnet tới các services khác của AWS, thông qua một private network của AWS được gọi là privatelink, thay vì thông qua internet.\nCó thể đáp ứng tốt theo nhu cầu sử dụng, nó scale theo chiều ngang.\nKhông cần phải setup thêm IGW, NATGW, … để kết nối. Giảm thiểu chi phí sử dụng.\nKhi có vấn đề, lưu ý các thông tin sau:\n\nKiểm tra lại DNS Setting Solution trong VPC.\nKiểm tra lại Route Table xem đã định tuyến đúng chưa.\n\n\n\n\n🌿 Types §\n\n\nInterface Endpoints (sử dụng privatelink)\n\nCung cấp một ENI như một entrypoint, và nó phải được gán security group để kiểm soát traffic.\nHỗ trợ cho hầu hết các services của AWS.\nThanh toán theo giờ + GB dữ liệu xử lý.\n\n\n\nGateway Endpoints\n\nCung cấp một gateway và sử dụng route table để kiểm soát traffic, không dùng security group như thằng bên trên.\nHỗ trợ cho S3 và DynamoDB.\nMiễn phí\n\n\n\n\nVới S3 nên sử dụng Gateway hay Interface endpoints?\n\nThông thường trong hầu hết các trường hợp, gateway luôn được ưu tiên sử dụng do nó miễn phí.\nChỉ khi chúng ta cần kết nối S3 với server on-premise, từ một VPC hoặc region khác, thì cần phải sử dụng với Interface Endpoints.\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Networking---VPC/VPC-Flow-Logs":{"title":"🌱 VPC Flow Logs","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà tích năng ghi lại các thông tin về IP traffic truy cập vào tài nguyên của VPC.\n\nVPC Flow Logs.\nSubnet Flow Logs.\nElastic Interface Network(EIN) Flow Logs.\n\n\nGiúp giám sát và xử lý kịp thời các hoạt động bất thường trong hoạt động.\nLogs có thể được lưu trong S3, kết hợp với một số các services khác thực hiện phân tích log để có cái nhìn tổng quan cũng như chi tiết hoạt động truy cập của VPC, ví dụ như kết hợp với CloudWatch.\n\n"},"40123345-posts/42-Code/42.03-AWS/Networking---VPC/VPC-Peering":{"title":"🌱 VPC Peering","links":["40123345-posts/42-Code/42.03-AWS/Networking---VPC/VPC---Virtual-Private-Cloud","40123345-posts/42-Code/42.03-AWS/Networking---VPC/IGW---Internet-Gateway-&-Route-Tables"],"tags":["aws"],"content":"🌿 What? §\n\n\nLà dịch vụ để tạo một kết nối riêng tư giữa 2 VPC sử dụng network của AWS.\n\n\nNó giúp cho các resources của 2 VPC như cùng chung một network.\n\n\nĐể sử dụng dịch vụ này, phải chắc chắn rằng không được overlap CIDRs.\n\n\nKhông có tính chất bắc cầu.\n\n\n\nNhớ là phải update route table để chúng có thể giao tiếp được với nhau.\n\n\nCó thể tạo VPC Peering giữa các VPCs ở khác accounts hoặc regions.\n\n\nCó thể reference security group trong một peered VPC.\n\n"},"40123345-posts/42-Code/42.03-AWS/Networking---VPC/VPC-Traffic-Miroring":{"title":"🌱 VPC Traffic Miroring","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà tính năng cho phép ghi lại và kiểm tra các traffic trong VPC.\nSao chép các traffic từ nhiều EC2 Instances hoặc ELB, sau đó chuyển tiếp đống traffic đấy tới một EC2 Instance khác để giám sát và phân tích.\nLà tính năng nâng cao bảo mật.\n\n"},"40123345-posts/42-Code/42.03-AWS/Placement-Groups":{"title":"🌱 Placement Groups","links":[],"tags":["aws"],"content":"🌿 What? §\n\n🌱 Về cơ bản, placement group cho phép chúng ta quản lý vị trí - nơi khởi chạy các EC2 Instances, từ đó nâng cao hiệu suất, giảm độ trễ , …\n🌱 Có 3 strategies: Cluster, Spread, Partition\n\n🌿 Cluster §\n\n\nCác EC2 Instances cùng nằm trong một hardware - same rack, same AZ.\nƯu:\n\nGreat network - độ trễ rất thấp, 10Gbps network.\n\n\nNhược:\n\nChết là chết tất. Rủi ro cao.\n\n\nUse cases:\n\nNhững dự án yêu cầu độ trễ cực thấp và khả năng truyền tải dữ liệu nhanh.\n\n\n\n🌿 Spread §\n\n\nCác EC2 Instances không cùng một một chỗ, thay vào đó sẽ được đặt riêng ở các hardwares khác nhau, ở nhiều AZ trên cùng một Region.\nƯu:\n\nGiảm rủi ro chết chùm.\n\n\nNhược:\n\nGiới hạn 7 instances cho mỗi placement group trên cùng một AZ(nhược với những dự án big size).\n\n\nUse cases:\n\nNhững dự án đề cao khả năng availability(app mạng xã hội, …)\nNhững dự án quan trọng, cần đảm bảo ít rủi ro.\n\n\n\n🌿 Partition §\n\n\nKết hợp giữa Cluster và Spread. Mỗi một AZ có thể chứa 7 partions, mỗi một partion chứa những EC2 Instances - same rack.\nƯu:\n\nĐảm bảo độ trễ cực thấp + truyền tải dữ liệu cao giữa các instances.\nGiảm thiểu rủi ro khi một partion chết, các partions khác vẫn hoạt động bình thường.\nCó thể setup hàng trăm EC2 Instances, xịn hơn spread nhiều.\n\n\nCó thể xem thông tin vị trí của instance thông qua metadata của instance.\nUse cases:\n\nKhi chúng ta có dự án có thể nhận biết phân vùng để truyền tải dữ liệu, các ứng dụng big data sử dụng: HDFS, HBase, Cassandra án Apache Kafka\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Private-vs-Public-IP":{"title":"🌱 Private vs Public IP","links":[],"tags":["aws"],"content":"🌿 Overview §\n\n🌱 Có 2 loại IP:\n\nIPv4: [0-255].[0-255].[0-255].[0-255], ex: 1.160.10.250\nIPv6\n\n\n🌱 IPv4 vẫn là format phổ biến nhất dùng cho web\n🌱 IPv6 mới hơn và được sử dụng cho IoT.\n🌱 IPv4 cho phép 3.7 tỷ địa chỉ khác nhau được public trên mạng/\n\n🌿 So sánh Private và Public IP §\n\n🌱 Public IP:\n\nĐể máy chủ có thể định danh trên internet.\nUniq, không trùng với bố con thằng nào trên internet.\nCó thể định vị vị trí thông qua public IP.\nThay đổi khi reboot lại instace.\n\n\n🌱 Private IP:\n\nĐể định danh máy trong một mạng nội bộ.\nPhải Uniq trong mạng nội bộ.\n2 Companies khác nhau có thể có cùng một IP.\nNhững máy trong mạng nội bộ sẽ kết nối với WWW thông qua một internet gateway(a proxy)\nChỉ một range của IP được chỉ định mới có thể sử dụng như private IP.\nKhông thay đổi khi reboot lại instace.\n\n\n\n🌿 Elastic IP §\n\n🌱 Như IP bình thường, khác cái là nó độc lập với instance, vì vậy chúng ta có thể dễ dàng thay đổi instance mà không cần gán lại địa chỉ IP.\n🌱 Chỉ có thể có 5 Elastic IP trong 1 tài khoản(có thể yêu cầu tăng thêm)\n🌱 Nên tránh dùng:\n\nChi phí\nQuản lý\nKhả năng mở rộng\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Redshift":{"title":"🌱 Redshift","links":["40123345-posts/42-Code/42.03-AWS/Databases/Amazon-Athena","40123345-posts/42-Code/42.03-AWS/EBS-Volume---Elastic-Block-Store","40123345-posts/42-Code/42.03-AWS/S3"],"tags":["aws"],"content":"🌿 What? §\n\nLà một data warehouse, cung cấp khả năng lưu trữ và phân tích lượng dữ liệu cực lớn.\nBase trên PostgreSQL nhưng không sử dụng OLTP mà là OLAP - online analytical processing.\nHiệu suât tốt hơn x10 só với các data warehouses khác.\nCó thể scale từ một node tới hàng trăm nodes để đáp ứng nhu cầu sử dụng.\nLưu trữ dữ liệu dạng cột thay vì hàng, có engine thực hiện query đồng thời.\nTrả phí dựa theo số lượng instances đã cung cấp.\nCó một giao diện SQL để thực hiện queries.\nCung cấp các BI(business Intelligence) tools như Amazon Quicksight hoặc Taubleau.\nvs Athena: truy vấn / joins / tổng hợp dữ liệu nhờ indexes nhanh hơn.\n\n🌿 Cluster §\n\nLeader node: để lên kế hoạch truy vấn, tổng hợp các dữ liệu.\nCompute node: để thực hiện truy vấn và gửi kết quả đến leader node.\nBạn cân cung cấp node size.\nCó thể sử dụng Reserved Instances để tiết kiệm chi phí.\n\n\n🌿 Snapshots &amp; DR §\n\nCó thể tạo snapshot và ứng dụng như của EBS.\n\n\n🌿 Readshift Spectrum §\n\n\nTăng khả năng xử lý phân tích dữ liệu cho S3.\n"},"40123345-posts/42-Code/42.03-AWS/Route-53---Routing-Policy":{"title":"🌱 Route 53 - Routing Policy","links":[],"tags":["aws"],"content":"🌿 What? §\n\nĐịnh nghĩa cách Route 53 phản hồi những câu truy vấn DNS.\nĐừng nhầm lẫn từ routing\n\nKhông giống routing của ALB, đấy là định tuyến lưu lượng truy vấn.\nRouting của Route 53 chỉ chịu trách nhiệm phản hồi những truy vấn DNS thôi.\n\n\n\n🌿 Types §\n\nCó những loại policies sau:\n\n🍃 Simple §\n\nTiêu biểu, định tuyến tới một resource đơn lẻ.\nCó thể chỉ định nhiều values cho một record.\nNếu có nhiều values trả về, client sẽ pick ngẫu nhiên một value để thực hiện truy cập.\nKhi bật Alias, phải chỉ định tới một resouce duy nhất.\nKhông liên quan tới Health Check.\n\n🍃 Weighted - tỉ trọng §\n\nKiểm soát phần trăm nhận requests được chỉ định cho từng resource.\nCác DNS records phải cùng tên và cùng kiểu.\nCó liên quan đến Health Check\nUse cases: Load balancing giữa các region, testing version mới của ứng dụng, …\nAssign 0% cho một record, tức là resource đó sẽ không được gửi traffic.\nNếu tất cả record được set = 0, thì sẽ trả về trọng số bằng nhau cho tất cả các records.\n\n🍃 Latency based §\n\nChuyển hướng tới resource có độ trễ thấp nhất đối với client. Phù hợp với những ứng dụng mà độ trễ được ưu tiên.\nVd client ở Việt Nam thì sẽ được điều hướng tới resouce đặt tại Singapore(Nếu ở đấy có độ trễ thấp nhất.)\nCó Health check(để thực hiện chuyển đổi dự phòng)\n\n\n🍃 Failover §\n\nTự động chuyển đổi dự phòng tới các instance healthy nếu primary instance được đánh giá là unhealthy.\n\n\n🍃 Geolocation §\n\nKhác với Latency(ở gần chưa chắc đã có độ trễ thấp nhất).\nDựa vào vị trí của user để định tuyến.\nNên tạo một default record(sẽ được sử dụng trong trường hợp không tìm được vị trí phù hợp)\nUsage: web định vị(kiểu baemin, ở đâu thì xác định vị trí gần để giao hàng cho nóng), giới hạn phân phối nội dung tới từng khu vực, load balancer, …\nCó thể kết hợp với Health Check\n\n🍃 Geoproximity Route §\n\n\nVẫn dựa vào vị trí của user và resouce, nhưng thằng này có khả năng điều chỉnh lượng traffic tới resouce bằng thông só bias. Set bias càng cao thì tỉ lệ traffic đổ về càng lớn.\n\n🍃 Multi-value §\n\nDùng khi muốn định tuyến traffic tới nhiều resources.\nCó thể kết hợp với Health Checks( sẽ chỉ trả về các values/resources healthy)\nTối đa trả về 8 values healthy cho từng query.\nMulti-Value không thay thế cho một ELB.\nNó khác với Simple, vì nó có health checks, Simple trả về nhiều values nhưng có thể trong đó có unhealthy value.\n\n🌿 Health Check §\n\nHTTP Health Check chỉ sử dụng để check cho các public resources.\nHealth Check =&gt; Tự động chuyển đổi dự phòng nếu phát hiện ra unhealth resource.\nHealth Check được kết hợp với CW(CloudWatch) metrics.\nCó 3 kiểu health check:\n\n🍃 Monitor on endpoint §\n\nCó khoảng 15 health checkers sẽ check health endpoint\n\nNgưỡng health/unhealthy mặc định = 3\n30s gọi check một lần ( có thể set xuống 10s nhưng phí đắt hơn)\nHỗ trợ giao thức: HTTP, HTTPS và TCP\nNếu &gt; 18% health checkers báo cáo là healthy thì Route 53 sẽ đánh giá nó là healthy và ngược lại.\n\n\nChỉ check pass với các responses có code là 2XX và 3XX\nCó thể đánh giá Health dựa trên 5120 bytes đầu tiên của response.\nPhải config route/firewall cho phép nhận requests từ Route 53 để Health Check.\n\n🍃 Calculated health checks §\n\nKết hợp kết quả của nhiều health check con cho một healthcheck cha, để đánh giá tình trạng sức khỏe của resource.\nCó thể sử dụng AND, OR, NOT\nCó thể set max 256 health check con.\nChỉ định số lượng health check con pass là bao nhiêu để health check cha pass.\nUsage: thực hiện bảo trì.\n\n🍃 Private Hosted Zones §\n\nRoute 53 thực hiện health check từ bên ngoài VPC.\nDo không thể truy cập trực tiếp tới các private endpoints, nên cần phải tạo CloudWatch và Route 53 đọc metrics của CW để đánh giá trình trạng sức khỏe của resources.\n\n\n🌿 Domain Registar &amp; DNS Service §\n\nBạn có thể mua hoặc đăng ký tên miền ở chỗ khác và sử dụng DNS Service ở chỗ khác để quản lý.\n\n\n\nTạo Hosted Zone trên Route 53\nUpdate NS record ở bên thứ 3(vd GoDaddy) sử dụng Route 53 Name Server.\n\n\nDomain Registar != DNS Service\n"},"40123345-posts/42-Code/42.03-AWS/S3-Advance":{"title":"🌱 S3 Advance","links":["40123345-posts/42-Code/42.03-AWS/S3"],"tags":["aws"],"content":"🌿 Lifecycle Rules §\n\nCó thể chuyển các objects giữa các storage classesclassescác.\nVí dụ với những object ít được truy cập thường xuyên, cho nó vào Standard IA\nVới những object cần lưu trữ, không cần tốc độ truy cập cao, chuyển nó vào Glacier or Glacier Deep Archive\nViệc chuyển các objects có thể thực hiện tự động bằng một LifeCycle Rules.\nCó 2 actions chính:\n\nTransition Actions: thiệt lập các điều kiện để chuyển object sang store class khác.\n\nvd move objects sang Standard IA class sau 60 ngày từ ngày khởi tạo.\nmove objects sang Glacier sau 6 tháng\n\n\nExpiration actions: thiết lập thời hạn cho objects.\n\nCó thể thiết lập xoá sau 365 ngày\nCó thể sử dụng để xoá old versions(nếu versioning được bật)\nCó thể dùng để xoá những object chưa hoàn thành khi thực hiện Multi-Part uploads.\n\n\n\n\nRules có thể tạo cho một certain prefix, ex: s3://mybucket/mp3/*\nRules cũng có thể tạo cho certain objects Tags, ex: Department Finance\n\n🌿 Requester Pays §\n\n\nMặc định, người dùng sở hữu buckets sẽ phải trả phí cho cả việc lưu trữ cũng như phí băng thông khi có người tải dữ liệu từ buckets.\n\n\n\nTuy nhiên, chúng ta có những tập dữ liệu lớn và có những người dùng muốn tải xuống để phục vụ nhu cầu cá nhân chẳng hạn, chúng ta không cần lo phần phí networking kia, chúng ta có thể lựa chọn option requester pays.\n\n\n\nKhi bật tính năng này, user muốn download resources thì cần phải authen với AWS, để AWS còn tính bill cho phí networking.\n\n\n🌿 Event Notifications §\n\n\n\nLà những thông báo được gửi đến các destinations(SNS, SQS, Lambda Function) khi có một sự kiện gì đó tác động đến bucket(created , removed, restore, replication, …)\n\n\nCó thể filter các event, ví dụ như chỉ cần nhận thông báo các sự kiện trigger đến object có đuôi là .jpg chẳng hạn.\n\n\nCó thể tạo số lượng S3 events tuỳ thích\n\n\nThường các thông báo sẽ được truyền đi trong vài giây, nhưng cũng có thể thỉnh thoảng sẽ mất vài phút hoặc lâu hơn.\n\n\nNgoài 3 destinations nhận event notifications, Amazon có thêm một tính năng mới, một destination cho event notifications, đó là Amazon EventBridge.\n\n\n🍃 Amazon EventBridge §\n\n\nGiờ là tất cả các các thông báo event đi qua cái cầu này trước, sau đó đi đâu thì sẽ được quyết định theo các rules.\nƯu điểm:\n\nAdvanced filtering - có thể filter theo điều kiện phức tạp hơn(metadata, object size, name, …)\nMultiple Destinations - có thể điều hướng event notifications tới nhiều điểm đến hơn.\nCapabilities - Cung cấp khả năng lưu trữ, lặp lại sự kiện, truyền tải uy tín hơn.\n\n\n\n🌿 Baseline Performance §\n\nAmazon S3 sẽ tự động scales để đáp ứng nhu cầu sử dụng tối thiểu(tỉ lệ requests cao, độ trễ thấp 100-200ms)\nApp của bạn có thể đạt được ít nhất 3,500 PUT/COPY/POST/DELETE hoặc 5,500 GET/HEAD requests / mỗi giây / mỗi prefix trong một bucket.\nĐiều đó có nghĩa nếu chúng ta đồng thời đọc 4 prefixs, sẽ có thể đạt được 22,000 GET/HEAD requests / mỗi giây / mỗi prefix trong một bucket.\n\n🌿 Performance §\n\n\nLàm sao để upload một cách tối ưu?\n\nMulti-Part upload:\n\nrecommended nên sử dụng cho những files &gt; 100MB, bắt buộc phải dùng cho những file &gt; 5GB\nTính năng này sẽ chia file lớn ra thành nhiều phần sau đó upload đồng thời các phần, lên S3 thì sẽ tự động ghép lại thành một files như ban đầu.\n\n\n\n\nLàm thế nào để tranfer một file một cách tối ưu?\n\nS3 Transfer Acceleration\n\nTăng tốc độ truyền file bằng một AWS edge location, nó giúp gia tốc quá trình truyền file đến một region chỉ định.\nGiảm thiểu dữ liệu truyền trên public network, sử dụng mạng private của AWS như kiểu đi xe ở làn ưu tiên, thoáng với nhanh hơn.\nCó tương thích với tính năng Multi-Part\n\n\n\n\nLàm thế nào để đọc file một cách tối ưu?\n\nS3 Byte-Range Fetches\n\nThực hiện đồng thời các câu GETS cho từ byte ranges.\nCó khả năng phục hồi tốt hơn khi request thất bại(bởi gì chia ra làm các phần nên đọc lại cũng nhanh hơn)\nCó thể sử dụng để download nhanh hơn\nCó thể sử dụng để hiển thị một phần thông tin cùa file, vd như phần đầu file để biết trước nội dung là gì chẳng hạn.\n\n\n\n\n\n\n🌿 Batch Operations §\n\nThao tác đồng thời với nhiều dữ liệu bằng một request.\n\nSửa metadata, properties\nMã hoá hoặc giải mã objects\n…\n\n\nChức năng cung cấp viêc quản lý progress, thông báo gửi thành công, tạo report, …\nBạn có thể sử dụng S3 Inventory để lấy danh sách object và sử dụng S3 Select để filter đống objects đó.\n"},"40123345-posts/42-Code/42.03-AWS/S3-Security":{"title":"🌱 S3 Security","links":[],"tags":["aws"],"content":"🌿 Object Encryption §\n\n\nBạn có thể mã hóa objects trong S3 buckets bằng4 phương thức sau:\n\nServer-Side Encryption (SSE)\n\nServer-Side Encryption with Amazon S3-Managed Keys (SSE-S3) - Enabled by Default\n\nMã hóa bằng key được xử lý, quản lý và sở hữu của AWS.\n\n\nServer-Side Encryption with KMS Keys stored in AWS KMS(SSE-KMS)\n\nTận dụng AWS Key Management Service (AWS KMS) để quản lý các keys mã hóa\n\n\nServer-Side Encryption with Customer-Provided Keys (SSE-C)\n\nKhi bạn muốn tự quản lý các keys của mình sở hữu.\n\n\n\n\nClient-Side Encryption\n\n\n\nCần hiểu để vận dụng cho những tình huống xuất hiện trong bài thi.\n\n\nNotes: Bucket Policies được đánh giá trước(ưu tiên hơn) Default Encryption\n\n\n\nChúng ta có thể chỉ định phương thức mã hóa ở trong Bucket Policicy\n\n\n🍃 SSE - S3 §\n\nMã hóa sử dụng keys được xử lý, quản lý cũng như sở hữu bởi AWS.\nObject được mã hóa ở Server Side\nLoại mã hóa là AES-256\nPhải set header là “x-amz-server-side-encryption”:“AES256”\nMặc định được bật cho những buckets mới hoặc objects mới\n\n\n🍃 SSE - KMS §\n\nMã hóa sử dụng các keys được xử lý và quản lý bởi AWS KMS(Key Management Service)\nLợi ích: người dùng control + audit key bằng CloudTrail\nObject mã hóa ở server-side\nPhải set header là “x-amz-server-side-encryption”:“aws:kms”\nỞ cách mã hóa này, không chỉ đòi hỏi người dùng có quyền truy cập vào object mà người dùng còn cần phải có key thì mới giải mã để xem được object.\n\n\n\nGiới hạn:\n\nCó thể bị ảnh hưởng bởi giới hạn của KMS\nKhi upload, nó sẽ gọi GenerateDataKey KMS API\nKhi download, nó sẽ gọi Decrypt KMS API\nTùy từng region, mỗi giây có thể gọi được từ 5000-30000 req/s\nBạn có thể yêu cầu để tăng số lượng request/s trên Service Quotas Console\n\n\n\n🍃 SSE - C §\n\nSử dụng các keys thuộc toàn quyền sở hữu của khách hàng ngoài AWS.\nS3 không lưu trữ các keys mã hóa này\nPhải sử dụng HTTPS\nKey mã hóa cần phải được cung cấp trong Header, với tất cả các request, áp dụng cho cả việc đọc và ghi dữ liệu.\n\n\n🍃 Client-Side Encryption §\n\nNgười dùng sử dụng các thư viện như Amazon S3 Clien-Side Encryption Library để lưu keys mã hóa.\nClient tự phải mã hóa dữ liệu trước khi gửi lên S3 lưu trữ.\nClient tự phải giải mã dữ liệu khi truy xuất từ S3\nClient toàn quyền quản lý các keys cung như encryption cycle.\n\n\n🌿 CORS - Cross Origin Resource Sharing §\n\nOrigin = scheme(protocol) +host(domain) + port\nDựa theo cơ chế này để quyết định xem có cho phép một origin khác truy cập vào tài nguyên của một origin không.\nMột request sẽ không được hoàn thành trừ khi origin kia cho phép, sử dụng CORS Hearder(ex: Access-Control-Allow-Origin)\n\n🌿 MFA Delete §\n\nMột phương thức giúp ngăn ngừa sai xót khi lựa chọn xoá hoàn toàn(permanent delete), yêu cầu người dùng nhập thêm bảo mật 2 lớp để xác nhận xoá.\nMFA sẽ được yêu cầu khi:\n\nXoá vĩnh viễn một object\nTắt versioning trên bucket\n\n\nMFA sẽ không được yêu cầu khi:\n\nBật versioning\nLiệt kê các object đã bị xoá\n\n\nĐể sử dụng MFA Delete, Phải bật versioning cho bucket\nChỉ bucket owner(root account) mới có thể bật/tắt MFA Delete\n\n🌿 Access Log §\n\nTự động lưu lại toàn bộ các requests của tất cả các accounts đến bucket.\nDùng cho mục đích audit\nBucket vs bucket set logging phải chung một region\n\nWarning\n\nKhông được set logging bucket và bucket tương tác với users là 1, vì nó sẽ dẫn đến tình trạng sinh requests vô hạn đến bucket -&gt; đốt tiền.\n\n\n\n\n🌿 Pre-Signed URLs §\n\n\n\nTạo ra pre-signed URLs sử dụng S3 Console, AWS CLI, SDK\n\n\nURL Expiration:\n\nS3 Console: 1 phút - 720 phút(12 giờ)\nAWS CLI: thiết lập thời gian hết hạn với tham số —expires-in, đơn vị là giây(mặc định là 3,600s, max là 604800s ~ 168 giờ)\n\n\n\nUser nhận pre-signed URL như sẽ kế thừa permission, trong thời gian quy định, cho phép thực hiện GET/PUT với bucket.\n\n\nEx: như Insta, cho phép xem ảnh một thời gian nhất định.\n\n\n🌿 Glacier Vault Lock §\n\nĐáp ứng cho những object có mô hình WORM(Write Once Read Many). Ý tưởng là object được ghi vào bucket sẽ không được modify hoặc delete, chỉ đọc được thôi.\n\n🌿 Object Lock §\n\nCũng dùng cho mô hình WORM\nChặn việc xoá một version object theo số lần chỉ định(set 2 lần, xoá đến lần thứ 3 mới được)\nRetention mode - Compliance\n\nObject version không thể bị overwrite hoặc delete bởi bất kỳ user nào, kể cả root user.\nRetension mode không thể bị thay đổi.\n\n\nRetention mode - Governance\n\nHầu hết user không thể orverwrite hoặc delete một object version hoặc sửa đổi lock settings của nó.\nMột số users có quyền đặc biệt có thể thay đổi retention hoặc xoá object.\n\n\nRetention Period\n\nBảo vệ object trong một khoảng thời gian cố định, có thể extend.\n\n\nLegal Hold\n\nBảo vệ object vô thời hạn, không phụ thuộc vào retention period.\nCó thể tự do thêm hoặc xoá bằng cách sử dụng quyền s3:PutObjectLegalHold của IAM\n\n\n\n🌿 Access Point §\n\nMột bucket sẽ có nhiều folders, access point sẽ xác định quyền truy cập của từng user đối với từng folder.\n\nMỗi một Access Point có:\n\nDNS name(Internet Origin hoặc VPC Origin)\nMột access point policy(giống bucket policy)\n\n\n\n\n🌿 S3 Object Lambda §\n\nSử dụng khi cần format lại dữ liệu trước khi trả về cho người dùng.\nVí dụ như cần sắp xếp lại theo thứ tự nhất định hay convert tử XML -&gt; JSON, …\n\nLambda hiểu đơn giản là service cho phép chạy code mà không cần có server, phù hợp cho những tác vụ kiểu xử lý dữ liệu trước khi trả về cho người dùng như trên hoặc chạy các tác vụ định kỳ kiểu cuối ngày tổng kết xem hôm nay có bao nhiêu objects mới, …\n"},"40123345-posts/42-Code/42.03-AWS/S3":{"title":"🌱 S3","links":[],"tags":["aws"],"content":"🌿 Introduction §\n\nS3 là một trong những khối xây dựng chính của AWS\nNó được quảng cáo là có khả năng lưu trữ vô hạn\nNhiều Web sử dụng S3 như Backbone\nNhiều services của AWS sử dụng S3 để integrate tốt hơn.\n\n🌿 Buckets §\n\nCho phép người dùng lưu trữ objects(files) trong “buckets”(directories)\nMột Bucket sẽ có một tên unique( trên tất cả regions của tất cả accounts)\nRegion level - S3 nhìn giống như một global service nhưng các buckets được tạo trên một region.\nNaming convention:\n\nKhông viết hoa, không gạch dưới\n3 - 63 ký tự\nKhông phải là một IP\nPhải bắt đầu bằng một chữ cái thường hoặc một ký tự số.\nKhông được đặt prefix là xn…\nKhông được đặt suffix là …s3alias\n\n\n\n🌿 Objects §\n\nObjects(file) có một một Key\nKey == full path:\n\ns3://my-bucket/my_file.txt\ns3://my-bucket/another_folder/my_file.txt\n\n\nKhông có khái niệm directories trong s3, tất cả là key hết.\nObject value:\n\nMax size là 5 TB(5000 Gb)\nNếu upload file nhiều hơn 5T, phải sử dụng multi-part upload\n\n\nCó metadata\nTags - hữu dụng cho bảo mật vào vòng đời.\nVersion ID(chỉ có khi bật versioning)\n\n🌿 Security §\n\nUser-Based\n\nIAM Policies\n\n\nResource-Based\n\nBucket Policies - áp dụng cho nhiều accounts\nObject Access Control List - ACL\nBucket Access Control List - ACL\n\n\nNote: Một IAM principle có thể truy cập được vào một S3 object phải thỏa mãn:\n\nIAM permission cho phép OR resource policy cho phép\nAND không có DENY\n\n\nEncryption: mã hóa objects trong S3 sử dụng encryption keys.\n\n🌿 S3 Bucket Policies §\n\n\nJSON policy chứa:\n\nResource: resource chỉ định để phân quyền(bucket or objects)\nAction: là APIs thao tác với resource\nEffect: Allow/Deny\nPrincipal: chỉ định account/user cho policy\n\n\nVí dụ như policy trên là: cho phép toàn bộ người dùng quyền get toàn bộ Objects trong bucket.\n\n🌿 Bucket settings for Block Public Access §\n\nNhững settings này để tránh company leak dữ liệu.\nCó thể set ở account level\nNếu chắc chắn các respurces sẽ không được public, chúng ta có thể giữ nguyên các thông số này.\n\n🌿 Static Website Hosting §\n\nS3 có thể host một static website và giúp chúng có thể truy cập được trên Internetmà không cần sử dụng máy chủ web riêng.\nURL có dạng:\n\nhttp://bucket-name.s3-website-aws-region.amazonaws.com\nhoặc http://bucket-name.s3-website.aws-region.amazonaws.com\n\n\nNếu mã trả về 403, hãy chắc rằng bạn đã setup policy để cho phép việc truy cập public.\nƯu điểm:\n\nChi phí thấp\nTính sẵn sàng cao\nKhả năng mở rộng vô hạn\n\n\nNhược điểm:\n\nGiới hạn khả năng phát triển tính năng, ví dụ như chạy script, không dùng cho web động,…\n\n\n\n🌿 Versioning §\n\nBạn có thể đánh phiên bản cho các files trên Amazon S3\nNó được bật ở bucket level\nCùng một key, nếu overwrite thì phiên bản sẽ được update.\nBest practice để quản lý version cho bucket:\n\nBảo vệ từng phiên bản một -&gt; dễ đang restore về một version trước đó\n\n\nNotes:\n\nCác files đã tồn tại trước khi bật tính năng versioning sẽ được đánh version = null.\nTạm dừng tính năng versioning sẽ không bị xóa các phiên bản trước đó.\n\n\n\n🌿 Replication §\n\nPhải bật Versioning cho cả 2 Buckets ở 2 regions.\nCross-Region Replication (CRR)\nSame-Region Replication (SRR)\nCác buckets có thể thuộc về những accounts khác nhau, không nhất thiết là phải chung account thì mới thực hiện replication được.\nQuá trình copying giữa 2 buckets là bất đồng bộ\nPhải cung cấp IAM permissions phù hợp cho S3.\nUse Cases:\n\nCRR - dùng khi cần truy cập từ nhiều region với độ trễ thấp.\nSSR - tổng hợp được log, live replication giữa các accounts production và test.\n\n\nNotes:\n\nSau khi bật tính năng replication, chỉ những objects mới về sau mới có bản sao.\nNếu muốn tạo bản sao cho những objects đã tồn tại, sử dụng tính năng S3 Batch Replication\n\nTính năng này sẽ tạo bản sao cho những objects đã tồn tại ngoài ra còn tạo cho những objects đã thất bại khi tạo bản sao ở những lần trước đó.\n\n\nVề cơ chế DELETE:\n\nCó thể tạo bản sao cho object xóa markers(xóa theo version) từ bucket source sang bucket target(optional setting)\nXóa với một version ID(xóa vĩnh viễn) sẽ không được tạo bản sao.\n\n\nKhông hỗ trợ sao chép chuỗi\n\nTức là có 3 bucket1,2,3. Nếu muốn sao chép bucket1 đến 2 và 3 thì sao chép trực tiếp 1 -&gt; 2 và 1 -&gt; 3. Chứ không được 1 -&gt; 2 -&gt; 3.\n\n\n\n\n\n🌿 Tính bền bỉ(durability) và tính khả dụng(availability) §\n\nDurability:\n\nRất bền bỉ, ứng với tất cả các objects trên tất cả các regions.\nNếu bạn lưu trữ 10,000 objects trên Amazon S3, trung bình 10,000 năm chúng ta sẽ bị mất một object.\nĐiều này đúng với tất cả các storage class.\n\n\nAvailability:\n\nLuôn khả dụng khi cần truy cập.\nCó sự khác nhau giữa các class.\nVí dụ S3 tiêu chuẩn có 99,99% khả dụng. Tức là một năm thì nó chỉ có khoảng 53 phút không khả dụng thôi.\n\n\n\n🌿 Storage Class §\n🍃 S3 Standard - General Purpose §\n\n99,99% khả dụng\nSử dụng cho những dữ liệu thường xuyên được truy cập\nĐộ trễ thấp, thông lượng cao.\nCó thể đồng thời duy trì 2 facility failures.\nUse cases: Phân tích BigData, mobile&amp;gaming applications, content distribution, …\n\n🍃 S3 Storage Classes - Infrequent Access §\n\nCho dữ liệu không thường xuyên được truy cập nhưng có thể yêu cầu truy cập nhanh khi cần.\nGiá thấp hơn S3 Standard\nAmazon S3 Standard-Infrequent Access (S3 Standard-IA)\n\n99,9% khả dụng.\nUse case: Disaster Recovery, backups\n\n\nAmazon S3 One Zone-Infrequent Access (S3 One Zone-IA\n\nĐộ bền(99,999999999%) trong một AZ, dữ liệu sẽ bị mất khi AZ bị phá hủy.\n99,5% khả dụng\nUse case: Lưu backups cho dữ liệu đang sử dụng hoặc dữ liệu muốn recreate.\n\n\n\n🍃 S3 Glacier Storage Classes §\n\n\nChi phí thấp, là lựa chọn khi chúng ta muốn lưu trữ dữ liệu lâu dài nhưng ít được truy cập.\n\n\nGiá  = Giá dung lượng + giá truy xuất object\n\n\nS3 Glacier Instant Retrieval\n\nPhù hợp với nhu cầu truy cập dữ liệu một quý một lần.\nTối thiểu lưu trữ 90 ngày\n\n\n\nS3 Glacier Flexible Retrieval\n\nExpected(1-5 phút), Standard(3-5 giờ), Bulk(5-12 giờ) - miễn phí\nTối thiểu lưu trữ 90 ngày\n\n\n\nS3 Glacier Deep Archive - lưu trữ dài hạn\n\nStandard(12 giờ), Bulk(48 giờ)\nTối thiểu lưu trữ trong 180 ngày\n\n\n\n🍃 S3 Intelligent-Tiering §\n\nGiúp chuyển đổi tự động các class dựa theo việc truy xuất dữ liệu của người dùng, từ đó tối ưu được chi phí cũng như khả năng lưu trữ và truy xuất dữ liệu phù hợp với nhu cầu sử dụng của người dùng.\nKhông phải trả phí truy xuất dữ liệu khi lựa chọn option này.\n\n\n🍃 Comparision §\n"},"40123345-posts/42-Code/42.03-AWS/Scalability-&-High-Availability":{"title":"🌱 Scalability & High Availability","links":[],"tags":["aws"],"content":"🌿 Scalability §\n\nKhả năng mở rộng linh hoạt dự theo yêu cầu của khách hàng. Hệ thống có khả năng thích nghi tốt với trạng thái của ứng dụng.\nScalability có liên quan đến High Availability.\nCó 2 loại scalability:\n\nVertical scalability\nHorizontal scalabilily\n\n\n\n🍃 Vertical scalability §\n\n\nMở rộng về phần cứng của instance để xử lý các yêu cầu nhanh và chính xác hơn.\nVd t2.micro -&gt; t2.large\nVertical scalability rất thường được sử dụng với những hệ thống không phân tán, ví dụ như database.\nRDS, ElasticCache là những services có thể sử dụng để thực hiện scale vertically.\nThường có giới hạn về khả năng scale vertically(hardware limit)\n\n🍃 Horizontal scalability §\n\n\nMở rộng về số lượng instances, số lượng hệ thống của ứng dụng để có thể đáp ứng được nhiều yêu cầu của người dùng hơn.\nDành cho những hệ thống phân tán.\nThường được xử dụng cho web applications / modern applications.\nDễ dàng để scale horizontally với EC2 service.\n\n🌿 High Availability §\n\nHigh Availability thường sẽ được hiểu như scale horizontally.\nHA là ứng dụng của chúng ta được chạy trên ít nhất 2 data centers(AZs) mục đích để hệ thống luôn sẵn sàng sử dụng ngay cả khi có sự cố ở một data center nào đó.\n"},"40123345-posts/42-Code/42.03-AWS/Security-&-Encryption/AWS-Certificates-Manager":{"title":"🌱 AWS Certificates Manager","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ tạo, lưu trữ và quản lý các chứng chỉ SSL/TLS được cung câp bởi AWS.\nGiúp dễ dàng sử dụng cũng như lưu trữ cho việc vận hành các services hoặc trang web của người dùng.\nCung cấp tính năng quản lý vòng đời của các chứng chỉ. Cho phép cập nhật, xoá hoặc tái phát hành các chứng chỉ theo nhu cầu sử dụng của hệ thống. Tự động hóa việc thực hiện các tác vụ trên có thể giúp chúng ta tránh được những lỗ hổng bảo mật tiềm ẩn.\nMiễn phí với các chứng chỉ TLS public.\nCó khả năng tích hợp với những services cần in-flight encryption như ELB, CloudFront, API Gateway, …\nKhông tích hợp được với EC2 Instances.\n"},"40123345-posts/42-Code/42.03-AWS/Security-&-Encryption/AWS-Firewall-Manager":{"title":"🌱 AWS Firewall Manager","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ cung cấp khả năng lưu trữ tường lửa của AWS.\nCho phép chúng ta tạo, chỉnh sửa và áp dụng các chính sách tường lửa trên nhiều accounts khác nhau ở một nơi duy nhất.\nThuận tiện hơn trong việc quản lý, áp dụng cũng như tracking các chính sách.\n**Các chính sách được áp dụng cho các resources mới được tạo ra của(tốt cho việc tuân thủ các quy tắc) tất cả các accounts hiện có hoặc tương lai được tạo trong một Organization **\n"},"40123345-posts/42-Code/42.03-AWS/Security-&-Encryption/AWS-KMS---Key-Management-Service":{"title":"🌱 AWS KMS - Key Management Service","links":["40123345-posts/42-Code/42.03-AWS/Monitoring/Amazon-CloudTrail","40123345-posts/42-Code/42.03-AWS/Databases/Amazon-RDS---Relational-Database-Service","40123345-posts/42-Code/42.03-AWS/S3","40123345-posts/42-Code/42.03-AWS/EBS-Volume---Elastic-Block-Store","40123345-posts/42-Code/42.03-AWS/Databases/Amazon-DynamoDB"],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ lưu trữ keys encrypt trên AWS.\nBất cứ khi nào nhắc về encrypt, hầu hết sẽ đề cập đến KMS.\nĐược tích hợp với IAM để thực hiện authorization.\nGiúp việc quản lý truy cập dữ liệu dễ dàng hơn.\nCó thể audit các KMS keys được sử dụng ntn thông qua CloudTrail.\nCó khả năng tích hợp với nhiều services của AWS như RDS, S3, EBS, …\nKhông bao giờ được lưu trữ các khóa bằng text thường, đặc biệt là ở trong code, lưu trong biến môi trường thôi.\n\n🌿 Types §\n\nKMS Key có tên mới là KSM Customer Master Key\nSymmetric(AES-256 keys)\n\nMột khóa duy nhất dùng cả cho encrypt và decrypt\nCác services AWS sẽ được tích hợp trực tiếp với KMS để sử dụng Symmetric key.\nChúng ta sẽ không thể truy cập được vào Symmetric Key để lấy dữ liệu unencrypt(bắt buộc phải thông qua API của KMS)\n\n\nAsymmetric(RSA &amp; ECC key pair)\n\nCó một cặp khóa public/private, khóa public để encrypt, khóa private để decrypt.\nPublic key chúng ta có thể download và lưu trữ được, còn private thì không.\nSử dụng với các trường hợp người dùng không thể call API của KMS.\n\n\n\n🌿 Policies §\n\nKiểm soát truy cập tới các KMS Keys.\nDefault KMS Key Policy\n\nĐược tạo nếu chúng ta không chỉ địng policy nào.\nCho phép toàn bộ AWS accounts truy cập\n\n\nCustom KMS Key Policy\n\nXác định users, roles nào được truy cập vào KMS Key.\nXác định quản trị viên cho KMS Key.\nPhù hợp để sử dụng với trường hợp xài chung cho nhiều accounts.\n\n\n\n🌿 Multi-Region Key §\n\nMột khóa chính và được nhân rộng(sao chép) khóa cho các regions còn lại.\nGiúp dễ dàng quản lý key, giảm thiểu thao tác tạo key trên nhiều region.\nSử dụng với các service trên nhiều region vd như Global DynamoDB, Global Aurora…\n"},"40123345-posts/42-Code/42.03-AWS/Security-&-Encryption/AWS-Secrets-Manager":{"title":"🌱 AWS Secrets Manager","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ lưu trữ và quản lý các thông tin bí mật của app(thông tin connect vào database, khóa mã hóa dữ liệu, …)\nDịch vụ này sẽ chịu trách nhiệm lưu trữ, bảo mật và cung cấp cho các dịch vụ tích hợp những thông tin bí mật này một cách an toàn.\nCác thông tin bảo mật được lưu trữ trong dịch vụ hoàn toàn được mã hóa bằng KMS.\nCó khả năng quản lý vòng đời của các thông tin bí mật này.\nThường sẽ được sử dụng để tích hợp với RDS.\n\n🌿 Multi-Region Secrets §\n\nTính năng cho phép sao chép, nhân rộng Secret Manager trên nhiều Region.\nBao gồm một Secret Manager chính, các Secret Manager trên region khác sẽ được đồng bộ.\nCó thể promote một Secret Manager trên region khác trở thành một phiên bản độc lập.\n\n"},"40123345-posts/42-Code/42.03-AWS/Security-&-Encryption/AWS-Shield":{"title":"🌱 AWS Shield","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ giúp bảo vệ hệ thống của chúng ta tránh khỏi những cuộc tấn công phân tán phân tán dữ liệu(DDoS).\nDDoS - Distributed Denial of Service: tấn công hệ thống bằng cách gửi thật nhiều requests lên hệ thống một lúc, mục đích làm hệ thống quá tải và bị treo.\nCó 2 loại chính:\n\nAWS Shield Standard:\n\nBản này miễn phí\nCung cấp một số giải pháp để bảo vệ một số kịch bản tấn công như Reflection attacks hoặc là layer3/4 attacks.\n\n\nAWS Shield Advance:\n\n3000$ một tháng cho từng organization.\nXịn xò hơn, cung cấp nhiều giải pháp bảo mật ngon hơn.\n\n\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Security-&-Encryption/AWS-WAF---Web-Application-Firewall":{"title":"🌱 AWS WAF - Web Application Firewall","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ cung cấp tường lừa của AWS.\nTường lửa có tác dụng ngăn ngừa các cuộc tấn công tới trang web của chúng ta thông qua việc lọc các requests HTTP/HTTPS.\nTriển khai trên:\n\nALB\nAPI GateWay\nCloudFront\nAppSync GraphQL API\nCognito User Pool\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Security-&-Encryption/Amazon-GuardDuty":{"title":"🌱 Amazon GuardDuty","links":["40123345-posts/42-Code/42.03-AWS/Monitoring/Amazon-EventBridge","40123345-posts/42-Code/42.03-AWS/Amazon-SNS---Simple-Notification-Service","40123345-posts/42-Code/42.03-AWS/AWS-Lambda"],"tags":["aws"],"content":"🌿 What? §\n\nLà một dịch vụ bảo mật, sử dụng trí tuệ nhân tạo để phát hiện ra khác hoạt động độc hại hoặc bất thường trên hệ thống của chúng ta.\nData input sẽ là các phần logs của hệ thống để AI có thể training.\nCó thể tích hợp với các services khác để tăng hiệu quả bảo mật\n\nvd như tích hợp với EventBridge để gửi thông báo tới SNS, từ SNS gửi thông báo tới Lambda để thực hiện các actions phù hợp.\n\n\nCó thể chống lại được cuộc tấn công CryptoCurrency\n"},"40123345-posts/42-Code/42.03-AWS/Security-&-Encryption/Amazon-Inspector":{"title":"🌱 Amazon Inspector","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ cung cấp khả năng tự động đánh giá các lỗ hổng bảo mật.\nInspector sẽ sử dụng các quy tắc được thiết lập trước đó để phân tích và đánh giá các vấn đề bảo mật của hệ thống.\nCó khả năng cung cấp các báo cáo phân tích về các lỗ hổng bảo mật, giúp người dùng đưa ra các quyết định đúng đắn khi hệ thống gặp vấn đề.\nNgoài ra có thể chỉ định dịch vụ để Inspector thực hiện phân tích và đánh giá.\nChỉ thực hiện phân tích và đánh giá được trên:\n\nEC2 Instances\nContainer Images\nLambda Functions\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Security-&-Encryption/Amazon-Macie":{"title":"🌱 Amazon Macie","links":[],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ dựa vào trí tuệ nhân tạo và các patterns cho trước để thực hiện phục hồi hoặc bảo vệ các thông tin nhạy cảm của hệ thống.\n\nCác thông tin như thông tin người dùng, thông tin ngân hàng, …\n\n\nDịch vụ sẽ tự động detect được đâu là thông tin nhạy cảm. Từ đó thực hiện giám sát các hoạt động thao tác với các dữ liệu này.\nCung cấp báo cáo chi tiết về các hoạt động trên những dữ liệu nhạy cảm.\nCung cấp khả năng giám sát cũng như thông báo khi có bất kỳ các hoạt động bất thường nào đối với các dữ liệu nhạy cảm của hệ thống.\nGiúp nâng cao khả năng bảo mật của hệ thống với các thông tin quan trọng này.\n"},"40123345-posts/42-Code/42.03-AWS/Security-&-Encryption/SSM-Parameter-Store":{"title":"🌱 SSM Parameter Store","links":["40123345-posts/42-Code/42.03-AWS/Security-&-Encryption/AWS-KMS---Key-Management-Service","40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Serverless","40123345-posts/42-Code/42.03-AWS/Monitoring/Amazon-EventBridge"],"tags":["aws"],"content":"🌿 What? §\n\nLà dịch vụ lưu trữ các thông tin câu hình, khóa bí mật. Bảo mật thông qua IAM.\nCó thể sử dụng KMS để mã hóa dữ liệu.\nServerless, có khả năng mở rộng, bền bỉ và sử dụng dễ dàng với SDK.\nQuản lý version của các thông tin như cấu hình hay khóa bí mật.\nGửi thông báo tới AWS EventBridge.\nTích hợp với CloudFormation.\n\n\n🌿 Hierarchy §\n\n🌿 Tier §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStandardAdvancetổng số param lưu trữ(cho 1 account/region)10,000100,000size tối đa của 1 param4Kb8Kbparam policy availableNoYesChi phíkhông cần cọcphải cọcChi phí lưu trữmiễn phí0.05$ cho mỗi param/ tháng\n🌿 Parameters Policy §\n\nCó thể assign TTL để thực hiện update hoặc xóa các thông tin nhạy cảm ví dụ như mật khẩu chẳng hạn.\nCó thể assign một lúc nhiều policies.\n\n"},"40123345-posts/42-Code/42.03-AWS/Serverless-Architectures---Myblog.com":{"title":"🌱 Serverless Architectures - Myblog.com","links":["40123345-posts/42-Code/42.03-AWS/AWS-API-Gateway","40123345-posts/42-Code/42.03-AWS/AWS-Lambda","40123345-posts/42-Code/42.03-AWS/Amazon-DynamoDB","40123345-posts/42-Code/42.03-AWS/S3"],"tags":["aws"],"content":"🌿 Requirements §\n\nMột web viết blog có khả năng mở rộng toàn cầu.\nCác bài blogs hiếm khi được viết nhưng thường hay được đọc.\nCaching\nKhi người dùng mới đăng ký phải gửi một email chào mừng người dùng.\nKhi có ảnh được upload sẽ tự động tạo thumbnail.\n\n🌿 Architecture §\n\n\nVẫn sử dụng kiến trúc API Gateway + Lambda + DAX + DynamoDB để đáp ứng yêu cầu như expose API HTTP, truy vấn các bài posts tăng hiệu suất đọc dữ liệu.\nĐể app global, sử dụng CloudFront để phân phối. Các edge location sẽ nhận request của người dùng, giảm độ trễ, nâng cao trải nghiệm của người dùng.\nS3 thiết lập OAC - Origin Access Control để các edge location có thể truy cập được vào S3.\nTiếp đến là vụ gửi mail. Bật DynamoDB Stream để nhận được sự kiện khi có người dùng được tạo mới trong db. Sau đó dùng Lambda để thực hiện gửi mail qua dịch vụ Simple Email Service(SES)\nVề vụ gen ra thumbnail, sau khi ảnh được upload vào S3, gửi sử kiện đến Lambda để tạo thumbnail và import vào S3.\n"},"40123345-posts/42-Code/42.03-AWS/Serverless-Architectures---todo-list-mobile-app":{"title":"🌱 Serverless Architectures - Todo list mobile app","links":["40123345-posts/42-Code/42.03-AWS/Serverless","40123345-posts/42-Code/42.03-AWS/S3","40123345-posts/42-Code/42.03-AWS/AWS-API-Gateway","40123345-posts/42-Code/42.03-AWS/AWS-Lambda","40123345-posts/42-Code/42.03-AWS/Amazon-DynamoDB","40123345-posts/42-Code/42.03-AWS/Amazon-Cognito"],"tags":["aws"],"content":"🌿 Requirements §\n\nTạo một mobile app:\n\nExpose REST API với HTTPS\nKiến trúc serverless.\nUser có thể tương tác trực tiếp với folder của họ trên S3\nUser cần xác thực thông qua một service quản lý không máy chủ.\nUser có thể đọc và ghi mới các to-do, nhưng thường chủ yếu là họ sẽ đọc.\nDatabase có thể scale và có thông lượng có khả năng đọc cao.\n\n\n\n🌿 Serverless Architecture §\n\n\nSử dụng API Gateway để expose các HTTP API và để gọi đến các Lambda function.\nLambda function dùng để xử lý logic và query vào database\nDatabase sử dụng DynamoDB để đáp ứng kiến trúc không máy chủ.\nVề vụ xác thực sử dụng Amazon Cognito để định danh cho người dùng. Sử dụng Cognito Indentity pool để cung cấp certificate cho người dùng. Người dùng có thể sử dụng nó để thực hiện các tác vụ với S3.\nĐể nâng cao khả năng đọc dữ liệu từ trong DB, sử dụng DAX làm lớp layer giữa Lambda và DynamoDB. Giúp cache lại các thông tin hay được sử dụng, từ đó nâng cao hiệu suất đọc cũng như giảm thiểu các câu queries tới DynamoDB.\n"},"40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Blocking-an-IP-Address-in-AWS":{"title":"🌱 Blocking an IP Address in AWS","links":["40123345-posts/42-Code/42.03-AWS/Networking---VPC/NACL---Network-Access-Control-List","40123345-posts/42-Code/42.03-AWS/Networking---VPC/VPC---Virtual-Private-Cloud","40123345-posts/42-Code/42.03-AWS/Security-&-Encryption/AWS-WAF---Web-Application-Firewall"],"tags":["aws"],"content":"\n\nTrong thực tế, các dự án không phải là public, việc phải restrict traffic truy cập là việc làm quan trọng, tránh cho hệ thống có tác nhân không được phép sử dụng truy cập ảnh hưởng đến vấn đề bảo mật của hệ thống.\nCó một số cách như:\n\nSử dụng NACL: chặn traffic ở tầng VPC bằng cách defind ra các deny rules.\nSecurity Group của EC2 Instance: defind những traffic nào được phép truy cập vào server.\nĐặt ALB, chặn trước một EC2 Instance. Nếu sử dụng Network Load Balancer thì phải sài thêm WAF, tường lửa chặn truy cập ở tầng network.\nHoặc khi có sử dụng Cloudfront thì cũng cần cài thêm WAF nếu muốn filter IP addresses mà chúng ta cho phép truy cập vào hệ thống.\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Caching-Strategies-in-AWS":{"title":"🌱 Caching Strategies in AWS","links":["40123345-posts/42-Code/42.03-AWS/AWS-API-Gateway","40123345-posts/42-Code/42.03-AWS/Databases/Amazon-ElastiCache"],"tags":["aws"],"content":"\n\nAWS cũng cấp nhiều dịch vụ hỗ trợ caching.\nViệc lựa chọn dịch vụ caching một cách hiệu quả sẽ liên quan rất nhiều đến cách thức hoạt động của hệ thống.\nVí dụ nếu app yêu cầu độ trễ thấp, không cần đồng bộ real-time dữ liệu hoặc những thay đổi từ bên BE, có thể lựa chọn CloudFront để caching\nCache trên từng khu vực thì có thể chọn API Gateway.\nVới app nào mà không quan tâm đến độ trễ lắm, nhưng cần dữ liệu phải có tính thống nhất cao thì có thể sử dụng cache ở ElastiCache, DAX.\nNói chung là có nhiều dịch vụ hỗ trợ caching, cần phải làm rõ được các yêu cầu như về độ trễ, thời gian lưu trữ, giá cả, … để chọn được cách hoạt động hiệu quả nhất cho dự án.\n"},"40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Event-Processing-in-AWS":{"title":"🌱 Event Processing in AWS","links":[],"tags":["aws","architecture"],"content":"\nBài viết tổng hợp lại các kiến trúc thường được áp dụng cho hệ thống xử lý sự kiện trên AWS.\n\n🌿 Lambda, SNS and SQS §\nCó 3 kiến trúc thường được sử dụng:\n\nSQS + Lambda\n\n\n\nEvents push vào SQS queue\nLambda pull mess từ SQS về để xử lý, nếu xử lý không thành công thì push ngược trở lại SQS.\nTránh trường hợp message có vấn đề, mãi không được xử lý thành công, gây ra vòng lặp vô hạn -&gt; Chuyển message vào DLQ(Dead Letter Queue) sau số lần retry nhất định, không xử lý nó nữa\n\n\nSQS FIFO + Lambda\n\n\n\nGiống cái bên trên, khác là các messages trong Queue có thứ tự FIFO - First In First Out.\n\n\nSNS + Lambda\n\n\n\nNotification đc gửi bất đồng bộ tới Lambda để xử lý.\nLuồng retry + đẩy vào DLQ giống 2 cái bên trên.\n\n🌿 Fan Out Pattern - delivery to multi SQS §\n\n\n\nFan Out Pattern: được sử dụng với mục đích phân phối thông điệp tới nhiều đối tượng cùng lúc.\n\n\nĐảm bảo tính đúng đắn và tin cậy của các thông điệp.\n\n\nTăng khả năng chịu lỗi.\n\n\nCó khả năng mở rộng linh hoạt.\n\n\nSử dụng SNS - SNS hỗ trợ nhiều định dạng như email, tin nhắn, văn bản, … Tùy nhu cầu chúng ta có thể lựa chọn 2 options trên.\n\n\nOption1:\n\nCơ chế sẽ là một message sẽ được put lần lượt tới các Queue\nNhưng có thể xảy ra trường hợp put Queue2, message bị lỗi, thế là nó ko put đến Queue3 nữa -&gt; Không đáng tin cậy\n\n\n\nOption2:\n\nTăng cường độ tin cậy bằng cách thông qua SNS, kiêu gì nó cũng gửi message lên cả 3 Queue.\n\n\n\n🌿 Events of S3 §\n🍃 With EventBridge §\n\n\nFilter Advance - có thể tạo JSON rules, hỗ trợ cho việc tìm kiếm các thông tin của objects(metadata, size, …)\nMultiple Destinations - Có thể gửi các event tới nhiều AWS services khác, dễ dàng xử lý nhiều tác vụ theo nhu cầu sử dụng của hệ thống.\nCapabilities - Ngoài ra EventBridge hỗ trợ lưu trữ, replay event, reliable delivery\n\n\n\nNgoài ra nó còn được sử dụng để nhận các events từ các API được call. Từ đó có thể gửi tới các service khác ví dụ như SNS trong trường hợp khi người dùng xoá một bảng sẽ gửi mail tới tất cả các AWS accounts trong organization.\n\n🍃 With API Gateway §\n\n\nMô hình thường được sử dụng để người dùng có thể lưu dữ liệu lên S3.\n"},"40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/High-Performance-Computing-in-AWS":{"title":"🌱 High Performance Computing in AWS","links":[],"tags":["aws"],"content":"🌿 What is HPC - High Perfomance Computing? §\n\nLà thuật ngữ để chỉ các hệ thống yêu cầu khả năng tính toán cao.\n\nvd như các hệ thống dự báo thời tiết, machine learning, deep learning, mô hình hoá rủi ro tài chính, …\n\n\nVà cloud là một môi trường vô cùng thuận lợi cho việc phát triển các hệ thống HPC.\n\nChúng ta có thể tạo rất nhiều resource trên cloud.\nNhanh chóng áp dụng, mở rộng theo nhu cầu của hệ thống.\nĐầy đủ services để hỗ trợ cho việc phát triển, mối lo duy nhất chỉ là tài chính thôi =))\n\n\n\nVậy, AWS cung cấp những dịch vụ nào để hỗ trợ phát triển dự án HPC?\n🌿 Data Management &amp; Transfer §\n\nAWS Direct Connect - Có thể chuyển GB/s data lên Cloud, thông qua một private secure network.\nSnowball &amp; Snowmobile - Có thể chuyển PB data lên cloud, sử dụng các thiết bị lưu trữ vật lý, dump dữ liệu và chuyển về datacenter để migrate.\nAWS DataSync - Đồng bộ dữ liệu lớn giữa on-premise và các dịch vụ lưu trữ trên cloud.\n\n🌿 Computing &amp; Networking §\n\nEC2 Instances\n\nTối ưu CPU, GPU.\nCó thể lựa chọn các options thuê dịch vụ là Spot Instances / Spot Fleets để tiết kiệm giá cũng như thực hiện tự động mở rộng hệ thống.\nEC2 Placemenet: lựa chọn chiến lược đặt vị trí của các EC2 Instances phù hợp với yêu cầu của hệ thống.\n\n\nEC2 Enhanced Networking(SR-IOV)\n\nBăng thông cao hơn, PPS(packet per second) cao hơn, độ trễ thấp hơn.\nOption1: sử dụng ENA - Elastic Network Adapter có thể hỗ trợ băng thông tối đa là 100Gbs\nOption2: Intel 82599 VF hỗ trợ tối đa là 10GBs\n\n\nElastic Fabric Adapter - EFA\n\nPhiên bản cải tiến của ENA để hỗ trợ cho hệ thống HPC, chỉ hỗ trợ với hệ điều hành Linux.\nHỗ trợ khả năng giao tiếp tuyệt vời giữa các node của hệ thống, phù hợp với các hệ thống yêu cầu khả năng tính toán kết hợp giữa nhiều Instances.\nTận dụng Message Passing Interface tiêu chuẩn.\n\n\n\n🌿 Storage §\n\nInstance Storage\n\nEBS\nInstance Storage\n\n\nNetwork Storage\n\nS3\nEFS\nAmazon FSx for Lustre\n\n\n\n🌿 Automation &amp; Orchetration §\n\nAWS Batch\n\nHỗ trợ đồng thời chạy các jobs.\nDễ dàng lập lịch\n\n\nAWS ParallelCluster\n\nMột tool quản lý dùng để delpoy HPC lên AWS.\nThiết lập sử dụng text files.\n\nTự động tạo VPC, Subnets, cluster type hoặc instance type.\nCó khả năng bật EFA trên các cluster.\n\n\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Highly-Available-EC2-Instance":{"title":"🌱 Highly Available EC2 Instance","links":["40123345-posts/42-Code/42.03-AWS/Monitoring/Amazon-CloudWatch","40123345-posts/42-Code/42.03-AWS/AWS-Lambda","40123345-posts/42-Code/42.03-AWS/ASG---Auto-Scaling-Group","40123345-posts/42-Code/42.03-AWS/EBS-Volume---Elastic-Block-Store"],"tags":["aws"],"content":"Một điều quan trọng cần lưu ý khi thiết kế hệ thống, đó là tính sẵn sàng cao, hệ thống luôn luôn sẵn sàng để truy cập, thời gian downtime hầu như là không có.\n\n\nSử dụng ElasticIP để gắn cho một EC2 Instance.\nTạo một Standby EC2 Instance.\nSử dụng CloudWatch Event để theo dõi các thông số của EC2 Instance chính, nếu có nó có vấn đề gì bất thường(vd CPU nhảy lên 100% -&gt; lỗi rồi) -&gt; Gửi cho Lambda Function để thực hiện attach ElasticIP qua EC2 Instance. Thế là hệ thống đỡ mất thời gian để launch lại EC2 vì có sẵn rồi.\n\n\n\nSử dụng ASG để tự động mở rộng hệ thống tuỳ theo lưu lượng. Giảm khả năng bị quá tải của hệ thống.\nCó thể bật Multi-AZs, tránh khả năng datacenter đang sử dụng gặp sự cố.\n\n\n\nCó một vấn đề là khi Terminate EC2 Instance, cả EBS Volume sẽ bị xoá theo, để có thể giữ lại nó, ASG sẽ sử dụng lifecycle hook, nó sẽ triggerd khi EBS Volume bị terminate -&gt; tạo ra một EBS Snapshot, khi ASG launch một EC2 Instance mới, EBS cũng sẽ được tạo từ EBS Snapshot. Dữ liệu vẫn sẽ được giữ nguyên.\n"},"40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Micro-Services-Architecture":{"title":"🌱 Micro Services Architecture","links":[],"tags":["aws","architecture"],"content":"🌿 What? §\n\n\nBạn có thể tự do thiết kế từng micro-service theo cách bạn muốn.\nPatterns đồng bộ: API Gateway, Load Balancers.\nPatterns bất đồng bộ: SQS, Kinesis, SNS, Lambda triggers (S3)\nThách thức với micro-services:\n\nChi phí\nTối ưu\nPhức tạp khi phải quản lý nhiều versions của nhiều services.\nYêu cầu code nhiều hơn để tích hợp với nhiều services.\n\n\nMột số thách thức được giải quyết với kiến trúc serverless.\n\nAPI Gateway, Lambda tự động scale và chúng ta phải trả theo nhu cầu sử dụng.\nCó thể dễ dàng clone API, Dùng lại được các môi trường.\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Serverless":{"title":"🌱 Serverless","links":["40123345-posts/42-Code/42.03-AWS/S3","40123345-posts/42-Code/42.03-AWS/Amazon-SNS---Simple-Notification-Service","40123345-posts/42-Code/42.03-AWS/Amazon-SQS---Simple-Queue-Service"],"tags":["aws","architecture"],"content":"🌿 What? §\n\nLà một mô hình mới, các developers không cần phải quản lý bất kỳ một cái server nào.\nChúng chỉ để deploy code, functions.\nFaaS = Function as a Service\nServerless được triển khai đầu tiên với AWS Lambda những hiện tại mô hình này đã có thể kết hợp với bất kể cái gì có thể quản lý được: databases, messaging, storage, …\nServerless không phải là hoàn toàn không có servers nào, nó chỉ có nghĩa là chúng ta không cần quản lý, cung cấp hay nhìn thấy các servers thôi.\n\n🌿Mô hình serverless trong AWS §\n\nTrong AWS, các services hỗ trợ chúng ta build một mô hình serverless bao gồm:\n\nAWS Lambda\nDynamoDB\nAWS Cognito\nAWS API Gateway\nAmazon S3\nAWS SNS &amp; SQS\nAWS Kinesis Data Firehose\nAurora Serverless\nStep Functions\nFargate\n\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Solution-Architect-Discussion---Whattimeisit.com":{"title":"🌱 Solution Architect Discussion - Whattimeisit.com","links":[],"tags":["aws","architecture"],"content":"\nĐề bài: Tôi cần build kiến trúc cho một web xem thời gian, có domain là whattimeisit.com\n\n\n\nĐây là một app hỏi giờ thôi nên không cần database để lưu dữ liệu. Đầu tiên tôi cần launch một EC2 Instance + ElasticIP để người dùng có thể truy cập để hỏi giờ.\n\n\n\nSau đó, app được người dùng trải nghiệm tốt, họ giới thiệu cho bạn bè, một vài người sử dụng thử và lượng truy cập tăng lên. Tôi cần phải năng cấp Instance để đáp ứng nhu cầu sử dụng, lúc đầu là T2 -&gt; M5.\n\nStop Instance đang chạy\nĐổi thủ công từ T2 -M5\nLauch lại Instance, vì sử dụng Elastic IP nên không ảnh hướng đến địa chỉ truy cập.\n\n\n\n\n\nTrong thời gian upgrade, người dùng không thể truy cập để hỏi giờ được, thời gian downtime sẽ ảnh hưởng đến trải nghiệm của người dùng. Nhưng vì giờ app nó vẫn còn nhỏ, nên thôi cứ dùng tạm vậy đã.\n\n\n\nSau đó app thật sự nổi tiếng, lượng truy cập ồ ạt, tiếp theo tôi sẽ thực hiện scaling horizontal.\n\n\n\nVấn đề là người dùng sẽ phải nhớ địa chỉ IP tương ứng với từng instance để truy cập, về sau càng scale lên càng nhiều instances, việc nhớ IPs là rất bất tiện. Để giải quyết vấn đề này, tôi sử dụng Route 53 để điều hướng địa chỉ IP cho người dùng.\n\n\n\nNhưng hiện tại, nhu cầu scale là thường xuyên, việc add instance thêm hoặc đặc biệt là remove sẽ gây bất tiện. Do TTL được set là 1 giờ, nếu instance bị xóa thì trong một giờ nhóm user có response DNS sẽ không thể sử dụng được app, ảnh hưởng đến trải nghiệm. Ở bước này, tôi đầu tư thêm tiền để thực hiện scale horizontal bằng ELS - Elastic Load Balancer.\n\nVì ELB sẽ có IP thay đổi nên tôi bật alias trong DNS record lên, trỏ về ELB.\n\n\n\nCơ mà thấy phải scale thủ công cũng hơi bất tiện, thế là tôi dùng thêm dịch vụ ASG - Auto Scaling Group để tự động scale.\n\n\nBật thêm Multi-AZ để phòng tránh trường hợp bất ngờ như động đất sóng thần gì đấy làm hỏng một AZ, các AZ còn lại sẽ vẫn hoạt động bình thường.\n\n\nOk, giờ thì optimize cost một chút, tôi biết rằng chắc chắn mỗi năm sẽ cần ít nhất 2 instances để chạy app, tôi sẽ lựa chọn option reserved instance để thuê 2 instances cho 2 AZs, còn lại phát sinh tôi sẽ dùng option spot instances để tiết kiệm chi phí.\n\n\n\n\n                  \n                  Summary \n                  \n                \nCác bước bên trên là các bước để tạo nên một kiến trúc tốt trên nền tảng AWS, nó bao gồm 5/6 trụ cột\n\noperation pillar - vận hành tốt, đáp ứng nhu cầu mở rộng tự động và hợp lý cho hệ thống\nreliability pillar - uy tín, luôn định tuyến tới các healthy instance cũng như có dự phòng ngay khi xảy ra lỗi.\nperformance pillar - đáp ứng khả năng xử lý, tính toán tốt cho hệ thống\nsecurity pillar - các rules được thiết lập chặt chẽ, các requests sẽ được đi qua đúng các điểm chỉ định để đảm bảo tính an toàn cho hệ thống.\noptimize cost pilllar - chi phí sử dụng được tối ưu với những options của các dịch vụ phù hợp với nhu cầu sử dụng của ứng dụng.\n\n"},"40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Solution-Architect-Discussion---mywordpress.com":{"title":"🌱 Solution Architect Discussion - mywordpress.com","links":[],"tags":["aws","architecture"],"content":"🌿Đề bài §\n\nMột website viết blog\nYêu cầu phải show được ảnh, content của các bài blog cho các users.\nCó khả năng scale\nToàn bộ thông tin về users hay các blogs sẽ đươc lưu trong MySQL.\n\n🌿 Kiến trúc áp dụng §\n\n\nVẫn kiến trúc cũ như theclothes.com, nhưng web không cần lưu thông tin trạng thái giỏ hàng nên không cần sử dụng ElastiCache.\nThay RDS -&gt; Aurora, scale tốt hơn, performance tốt hơn, khả năng read scale tốt gấp 3 lần.(option tham khảo, dùng RDS thì cũng không sao, chi phí thấp hơn, tương đương với hiệu suât cũng thấp hơn thôi)\n\n\n\nVề vụ lưu ảnh, nếu dự án chỉ có một EC2 Instance, không mở rộng thì lưu luôn vào EBS - Elastic Block Store thì cũng được. Cơ mà lúc scale thêm một instance thì kèm với đó là một EBS mới. Lúc gửi ảnh vào EBS cũ xong lúc sau ELB định tuyến qua EBS mới thế là mất ảnh.\nĐể tránh tình trạng trên, chúng ta sẽ xuống tiền để sử dụng EFS - Elastic File System để lưu ảnh. Tạo thêm ENI - Elastic Network Interface để giao tiếp giữa EC2 Instances và EFS. Lưu ảnh vào một mối nên không sợ tinh trạng thất lạc ảnh như bên trên.\n"},"40123345-posts/42-Code/42.03-AWS/Some-Solution-Architectures/Solution-Architect-Discussion---theclothes.com":{"title":"🌱 Solution Architect Discussion - theclothes.com","links":[],"tags":["aws","architecture"],"content":"🌿 Đề bài §\n\nMột web bán quần áo, cho phép người dùng mua bán quần áo online.\nWebsite có cả trăm người dùng truy cập một lúc.\nCần scale, và luôn giữ trạng thái sử dụng của toàn bộ người dùng.\nCần lưu thông tin cá nhân của người dùng vào database.\n\n🌿 Kiến trúc áp dụng §\n\n\nÁp dụng kiến trúc cũ của web whattimeisit.com.\nMuốn giữ trạng thái của người dùng, ý tưởng đầu tiên là cần định tuyến đến đúng instance đã truy cập trước đó -&gt; Có thể bật Stick Session cho con ELB. Tuy nhiên cách này sẽ làm mất độ cân bằng tài do có thể có quá nhiều users cùng stick trên một instance.\nĐổi qua dùng kiểu lưu trạng thái mua hàng của user vào cookie và lưu dưới trình duyệt của user. Tuy nhiên cookie dễ bị thay đổi, thêm nữa chỉ có thể lưu trong 4Kb, quá ít, chả lưu được gì.\nĐến tầm này thì thuê luôn một con ElastiCache dùng cho nó máu. Chúng ta sẽ lưu thông tin mua bán hàng của user tại đây. Ở bên phía user sẽ lưu một session_id, khi truy cập vào bất kì instance nào, chỉ cần mã session_id là hợp lệ, hệ thống sẽ tìm trong ElasticCache để trả về thông tin cho user.\nTrong trường hợp session_id không hợp lệ hoặc cache lâu quá hết hạn bị xóa đi, hệ thống sẽ tìm trong RDS - Relational Database System để lấy thông tin, lưu lại vào trong ElasticCache để dùng lại cho những lần sau.\nVề vấn đề, cùng một thời điểm có cả trăm người dùng truy cập vào trang web, chúng ta sẽ scale read cho RDS để thực hiện đọc dữ liệu nhanh hơn.\nPhòng tránh thiên tai, bật Multi-AZ cho ELB, ElastiCache, RDS, đặt EC2 Instance ở nhiều AZs.\nCuối cùng là cần tạo đầy đủ các rules cho Security Group của từng phần một.\n\nELB - Nhận HTTP/HTTPS từ 0.0.0.0(every requests)\nEC2 Instance - Chỉ nhận requests từ ELB\nElastiCache - Chỉ nhận requests từ EC2 Instances\nRDS - Chỉ nhận requests từ EC2 Instances\n\n\nElastiCache:\n\nLưu session\nLưu dữ liệu cần sử dụng lại từ RDS\nBật Multi-AZ\n\n\nRDS:\n\nLưu thông tin của người dùng\nScale read để cải thiện tốc độ đọc của website\nBật Multi-AZ để tránh thảm họa.\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Trusted-Advisor":{"title":"🌱 Trusted Advisor","links":[],"tags":["aws"],"content":"🌿 What? §\n\n\nLà dịch vụ đưa ra các khuyến nghị để hệ thống của chúng ta hoạt động tốt hơn theo 5 tiêu chí:\n\nCost Optimization\nPerformance\nSecurity\nFault tolerance\nService limits\n\n\n"},"40123345-posts/42-Code/42.03-AWS/Well-Architected-Framework-&-Tool":{"title":"🌱 Well-Architected Framework & Tools","links":["40123345-posts/42-Code/42.03-AWS/ASG---Auto-Scaling-Group","40123345-posts/42-Code/42.03-AWS/AWS-CloudFormation"],"tags":["aws"],"content":"🌿 Well-Architected Framework §\n\nLà tập hợp các nguyên tắc (best practice) để thực hiện việc build một kiến trúc trên AWS.\nKhông dự đoán trước traffic của hệ thống, thay vào đó hãy sử dụng các service linh động hơn như ASG.\nNên thực hiện test hệ thống cả trên môi trường production, trên môi trường cloud việc này được hỗ trợ thực hiện dễ dàng và đảm bảo.\nNên xây dựng để mọi người dễ tiếp cận với kiến trúc(phát triển, thay đổi, …) vd như sử dụng CloudFormation.\nCho phép cải tiến kiến trúc.\nKiến trúc đảm bảo cho dữ liệu(đồng bộ, lưu trữ, …)\nLuôn thử nghiệm để phát triển(vd như giả định tình huống flash sale cho app, xem kiến trúc có hoạt động tốt không)\nhttps://aws.amazon.com/architecture/well-architected\n\n🌿 Six Pillars §\n\n\nOperational Excellent\nReliability\nSecurity\nPerformance Efficiency\nCost Optimization\nSustainability\n\n-&gt; Chúng ta không cần phải đánh đổi hay lựa chọn mức độ ưu tiên, tất cả sẽ liên kết và phụ thuộc lại để tổng hoà thành một hệ thống tốt.\n🌿 Well-Architected Tool §\n\nLà một công cụ miễn phí được giúp chúng ta review hệ thống dựa trên 6 trụ cột của Well-Architected Framework bằng cách trả lời các câu hỏi. Từ đó, công cụ này sẽ đưa ra những gợi ý để cải thiện hệ thống theo đúng chuẩn.\n"},"40123345-posts/42-Code/CSS-Learning":{"title":"🌱 CSS Learning","links":["[https:/css-tricks.com/snippets/css/](https:/css-tricks.com/snippets/css/)"],"tags":["css"],"content":"🌿 Resources §\n\nCSS- Tricks\n\n🌿 Refer §"},"40123345-posts/44-Finance/44.01-Wealth/9-sai-lầm-tài-chính-của-ng-trẻ":{"title":"💵 9 sai lầm tài chính của ng trẻ","links":[],"tags":["finance"],"content":"🌱 9 sai lầm tài chính của người trẻ §\n\nNguồn §\n\nhttps://www.youtube.com/watch?v=2EyGqvZrbyc&amp;ab_channel=HieuNguyen\n"},"40123345-posts/44-Finance/44.01-Wealth/Các-thói-quen-giàu-có":{"title":"🌱 Các thói quen giàu có","links":[],"tags":["journey","habit"],"content":"🌿 What? §\n\n🌱 Thói quen là một chuỗi phản xạ có điều kiện do rèn luyện mà có. Chuỗi phản xạ này là những hành vi định hình trong cuộc sống và được coi là bản chất thứ hai của con người.\n🌱 Xây dựng và kỷ luật bản thân với những thói quen tốt sẽ cải thiện rất nhiều đến chất lượng cuộc sống cũng như xác suất thành công của bản thân.\n\n\n\n                  \n                  Thói quen tốt \n                  \n                \nThói quen tốt mang lại cho bản thân sự thịnh vượng cả về sức khỏe, các mối quan hệ, nghề nghiệp, tài chính, và nhiều khía cạch khác trong cuộc sống.\n\n\n🌱 Post này mình sẽ update những thói quen mình đã và đang áp dung với bản thân 💪 để lưu lại bản chất thứ hai của con người mà mình muốn hướng tới ✨ Let’s gooooo!!!\n\n1. Tập thể dục ít nhất 30p mỗi ngày §\n\n\n\n                  \n                  Sức khỏe \n                  \n                \nNằm ở tầng thấp nhất trong tháp tài sản. Củng cố vững chắc nền móng, về lâu về dài tòa tháp của chúng ta mới có thể xây thật cao và kiên cố.\n\n2. Tiết kiệm ít nhất 10% thu nhập hàng tháng §\n\n\n\n                  \n                  Tiết kiệm \n                  \n                \nHãy luôn trả lương cho mình đầu tiên!\n\n\n🌱 Mọi người thường chi tiêu sinh hoạt trước, sau đó còn dư bao nhiêu sẽ tiết kiệm. Vấn đề là ít khi có “dư” lắm 😄\n\n3. Kiểm soát cảm xúc §\n\n\n\n                  \n                  Cảm xúc \n                  \n                \nCảm xúc ảnh hưởng rất nhiều đến những quyết định và hành vi.\n\n4. Rèn luyện kỹ năng đọc mỗi ngày §\n\n\n\n                  \n                  Đọc sách \n                  \n                \nAi cũng biết đọc sách quan trọng nhưng quan trọng là ko phải ai cũng cố gắng đọc sách (mình đấy 🤣).\n\n5. Rèn luyện kỹ năng viết mỗi ngày §\n\n\n\n                  \n                  TIL - Today I Learn \n                  \n                \nNão bộ là nơi suy nghĩ và đưa ra quyết định, không phải là nơi lưu trữ những kiến thức. Việc viết TIL để đảm nhiệm công việc này là vô cùng cần thiết. Khi viết mình có thể hệ thống kiến thức lại một cách rõ ràng, dễ hiểu với bản thân hơn.\n\n6. Updating §\n🌿 Refer §"},"40123345-posts/44-Finance/44.01-Wealth/Căng-thẳng-&-Bất-an":{"title":"🥶 Giai đoạn căng thẳng & Bất an","links":["40123345-posts/44-Finance/Theo-dõi-&-Kiến-tạo","40123345-posts/44-Finance/44.04-Macroeconomics/Interest-rate---Lãi-suất"],"tags":["finance","freedom"],"content":"✍️ Các kiến thức trong bài viết này được tổng hợp từ những chia sẻ của chú Hiếu Nguyễn trong podcast.\n🌿 Nợ nần (level ⚠️) §\n🌱 Thường sẽ là giai đoạn xuất phát điểm của các bạn trẻ bên nước ngoài. Vì bên này họ phát triển tư duy tự lập từ rất sớm, nên khi học đại học, các sinh viên sẽ phải tự trả số tiền học của mình. Nhưng vì hầu như các bản trẻ lúc này chưa có bất kỳ khoản tích lũy nào nên chính phủ sẽ hỗ trợ cho vay , khoản vay này có tên là Student Loan\n\nKhoản nợ này ở Mỹ có thể lên đến vài chục nghìn đô.\nThường sẽ mất vài năm, có thể lâu hơn mới có thể trả được hết món nợ này.\n\n\nLà món nợ lớn.\n\n🌿 Ăn bám gia đình (level 0️⃣) §\n🌱 Tự bản thân chưa nuôi được mình, phụ thuộc hoàn toàn vào chu cấp của gia đình.\n🌱 Nên đi làm sớm để biết Quý trọng đồng tiền. Từ đó có thể dần dần hình thành cảm nhận về tài chính =&gt; Nền tảng để xây dựng về sau.\n\nĐến năm 18 tuổi, nên kiếm việc làm thêm(phù hợp, lương thấp xíu cũng được).\nCố gắng chuyển sang level 1️⃣ sớm nhất có thể.\n\n🌿 Tự nuôi bản thân (level 1️⃣) §\n🌱 Tự làm được tiền, nuôi bản thân, không phụ thuộc vào gia đình nữa.\n🌱 Sống theo kiểu có tháng nào tiêu hết tháng đó. Có rất nhiều người chỉ dừng lại ở bước này đến cuối đời.\n🌱 Tiềm ẩn rủi ro bị lùi về level 0️⃣ hoặc tệ hơn level ⚠️. Khi bản thân có tiền, nếu không có cách quản lý tài chính hợp lý + tâm lý có thể dùng lương để trả thì rất có thể sẽ bị vướng vào nợ nần - báo nhà :v\n\nRất bấp bênh, không thể xử lý được các biến cố bất ngờ xảy ra(mất việc, đau ốm, có việc đột xuất, …). Có thể tụt level bất cứ lúc nào.\nĐạt được level này, hay ngay lập tức chuyển qua giai đoạn tiếp theo đó là Theo dõi &amp; Kiến tạo\n\n⛔ Ảnh hưởng của nợ nần §\nCó 2 kiểu nợ phổ biến:\n🌱 Nợ không có lãi suất §\n\nThường sẽ là nợ người thân, bạn bè. Mà để từ level 1️⃣ về đến level ⚠️ thì chúng ta cũng đã phải nợ nhiều nguồn, nhiều tiền rồi.\nKhông trả được đúng hạn =&gt; Mất uy tín.\nNhiều quá không trả nổi =&gt; Mất tư cách.\n\n\nCái mất nhiều nhất chính là mất những mối quan hệ chất lượng.\n\n🌱 Nợ có lãi suất §\nLoại này thì lại có 2 kiểu =))\n\n\nNợ tử tế\n\nNợ kiểu vay ngân hàng, nợ tín dụng =&gt; lãi suất cao, thường sẽ là 2%-4%/tháng =&gt; ~24%-42%/năm 😱.\n\n\n\nNợ không tử tế\n\nVay nóng, nợ xã hội đen, … thì thôi 🥵\n\n\n"},"40123345-posts/44-Finance/44.01-Wealth/The-4-percent-Rule":{"title":"🗺️ The 4% Rule","links":["40123345-posts/44-Finance/What-is-the-Financial-Freedom","40123345-posts/44-Finance/44.04-Macroeconomics/Inflation---Lạm-phát"],"tags":["finance","freedom"],"content":"\n🌱 Quy tắc 4% trong lĩnh vực tài chính cá nhân được sử dụng để xác định tương đối 3 cột mốc quan trọng trong hành trình Tự do tài chính, đó là:\n\nAn toàn tài chính (Financial Security)\nĐộc lập tài chính (Financial Independent)\nTự do tài chính (Financial Freedom)\n\n🌿What? §\nQuy tắc 4% được hình thành trong quá trình nghiên cứu và phân tích thị trường trong suốt 75 năm của William P. Bengen. Ông nhận ra rằng trong chu kì 30 năm, 90% các nhà đầu tư có thể bảo toàn được tài sản của mình nếu mỗi năm rút ra 4% trong tổng số đó, cùng với với mức lạm phát trung bình là 3%.\n🌿 Issue §\nTuy nhiên, vẫn có điểm yếu đối với quy tắc này. Theo Bob Dockendorff - chuyên gia tư vấn tài chính cá nhân người Mỹ, Phó chủ tịch Công ty tư vấn tài chính Claro Advisors đã nêu ra khá nhiều điểm bất cập có thể bị ảnh hưởng như:\n\nMức lạm phát hiện nay biến động vô cùng khó đoán\nCác yếu tố vĩ mô như suy thoái kinh tế, biến động chính trị(Nga X Ucraina), bệnh tật(Covid 19), …\n\n\nChính vì vậy, chúng ta cần chuẩn bị những phương án quản lý số tiền của mình một cách hợp lý hơn.\n"},"40123345-posts/44-Finance/44.01-Wealth/Theo-dõi-&-Kiến-tạo":{"title":"✍️ Giai đoạn Theo dõi & Kiến tạo","links":["40123345-posts/44-Finance/44.04-Macroeconomics/Interest-rate---Lãi-suất"],"tags":["finance","freedom"],"content":"✍️ Các kiến thức trong bài viết này được tổng hợp từ những chia sẻ của chú Hiếu Nguyễn trong podcast.\n🌿 Theo dõi chi tiêu (level 2️⃣ ) §\n🌱 Là bước quan trọng nhất! Nếu trong toàn bộ hành trình, chỉ làm duy nhất một bước theo dõi chi tiêu thì nó chắc chắn vẫn sẽ ảnh hưởng rất lớn đến vấn đề tài chính cá nhân của chúng ta.\nBước 1 - Ghi lại chi tiêu §\n🌱 Sử dụng một app điện thoại(hay bất cứ tool gì tiện nhất) như tôi đang sử dụng Money Lover để ghi chú lại tất cả những chi tiêu hàng ngày của mình. Cấu trúc ghi chú:\n\nNgày.                     Vd: 2022-11-20\nMục đích chi tiêu. Vd: Đổ xăng\nSố tiền.                  Vd: 70,000\n\n\nQuan trọng nhất là ghi chép đầy đủ tất cả chi tiêu. Từ đó mới có đủ dữ liệu để chúng ta đánh giá cho những bước tiếp theo.\n\nBước 2 - Phân loại chi tiêu §\n🌱 Sử dụng Excel thống kê toàn bộ dữ liệu chi tiêu của chúng ta đã log lại theo từng tháng. Cấu trúc thống kê:\n\n\nMust have: Các khoản thiết yếu, bắt buộc phải chi tiêu.\nNice to have: Các khoản có thì tốt mà không có cũng chả làm sao.\nWasted: Chi tiêu lãng phí, không có mục đích(Ăn nhậu, mua sắm linh tinh, …).\n\n\nNên làm ít nhất 1 tháng, lí tưởng là vài tháng. Phân loại càng lâu sẽ cover được càng đầy đủ những chi tiêu của chúng ta\n\n🌱 Chi tiêu tối thiểu =  Must have\n🌱 Chi tiêu tiêu chuẩn = Must have + Nice to have\nNếu trong sheet phân loại của chúng ta không có dòng nào là trả nợ, thì chúng ta có thể skip qua bước tiếp theo.\n🌿 Trả nợ (level 3️⃣) §\nTháng trước do ăn cơm Thố nhiều quá nên tôi có dùng ví trả sau Momo, mà tôi trả xong rồi nên trộm vía giờ tôi đang không có khoản nợ nào cả 😆.\nNhưng kiến thức không thừa, xem trước để nếu sau này có ăn cơm Thố quá liều thì còn biết đường mà trả nợ. Let’s gooo 💪!!\n\nBước 1 - Tách nguồn tiền §\n🌱 Setup thành 2 nguồn tiền\n\nEveryday account: là số tiền phục vụ cho chi tiêu tối thiểu của bản thân(= Must have)\nEmergency Fund:  quỹ khẩn cấp, theo đúng tên gọi, trong giai đoạn này, khẩn cấp nhất chính là trả nợ.\n\n\nNên tách riêng ra 2 tài khoản ở hai ngân hàng, cho cái quỹ Emergency khuất mắt đi, không nghĩ gì đến nó nữa.\n\nBước 2 - Xác định các khoản nợ &amp; Đánh độ ưu tiên §\n\nLãi suất cao trả trước.\nCố gắng sống ở mức tối thiểu, chỉ tập trung trả nợ thôi.\n\n🌿 Setup dòng tiền (level 4️⃣) §\n🌱 Setup thành 4 tài khoản:\n\n💰 Everyday Account §\n\nMỗi tháng sẽ để ở đây mức sống tối thiểu.\nÉp bản thân chỉ được chi tiêu với số tiền trong tài khoản này thôi.\n\n💰 Emergency Fund §\n\nQuỹ khẩn cấp dùng khi có những việc bất khả kháng như mất việc, bệnh tật, …\nƯu tiên đổ đầy quỹ khẩn cấp trước tiên(nếu có những nguồn thu nhập khác sẽ đổ vào đây trước, khi đầy rồi mới đổ vào những quỹ tiếp theo).\nTarget = Chi tiêu tối thiểu x runway(số tháng quỹ cover)\n\n\nTối thiểu là 6 tháng, lý tưởng là 12 tháng.\n\n💰 RainyDay Fund §\n\nQuỹ dùng cho những việc có kế hoạch trước như mua điện thoại mới, sửa nhà, …\nCó 2 kiểu xác định target cho quỹ này:\n\nDựa theo kế hoạch, ví dụ như xác định trước cần mua điện thoại 30tr, sửa nhà 50tr, chúng ta sẽ set target cho RainyDay Fund là 80tr\nDựa theo runway. Nếu chúng ta chưa có kế hoạch gì thì có thể set target với runway từ 3-6 tháng x Chi tiêu tối thiểu.\n\n\n\n💰 Investment Account §\n\nKhông có target cho tài khoản này. Bỏ tiền vào càng nhiều càng tốt.\n\n\nỞ giai đoạn này, bất cứ khi nào chúng ta có thêm nguồn thu nhập, ngay lập tức phân phối tiền theo mô hình đã setup ở trên. Hạn chế tối đa việc để tiền rảnh ở Everyday Account nếu không muốn hối hận khi thấy tiền nó cứ bay đi mất 💸\nSau giai đoạn này chúng ta đã có thêm quyền lựa chọn. Vd nếu môi trường làm việc hay công việc hiện tại không còn chất lượng, chúng ta hoàn toàn có thể xin nghỉ 👋, bỏ ra vài tháng để tìm cho mình công việc tốt hơn.\n✨ Loại bỏ cảm giác bất an, có đủ khả năng đối ứng với những biến cố trong cuộc sống.\n"},"40123345-posts/44-Finance/44.01-Wealth/Tiếp-cận-tự-do-tài-chính":{"title":"🗺️ Each step to the Financial Freedom","links":["40123345-posts/44-Finance/44.01-Wealth/Căng-thẳng-&-Bất-an","40123345-posts/44-Finance/44.01-Wealth/Theo-dõi-&-Kiến-tạo","40123345-posts/44-Finance/What-is-the-Financial-Freedom"],"tags":["finance","freedom"],"content":"\n📂 Ảnh được lấy từ podcast của chú Hiếu Nguyễn và bài viết này là tổng hợp những kiến thức mà chú đã chia sẻ trong podcast đó.\nNhư đã thấy ở bức ảnh trên, có bốn cột mốc chính đánh dấu cho từng giai đoạn trong hành trình Tự do tài chính.\n🌿 Căng thẳng &amp; Bất an §\n🌱 Nợ nần: trạng thái thấp nhất (level ⚠️)\n\nĐây thường sẽ là xuất phát điểm của hầu hết các bạn trẻ bên nước ngoài. Khi ra trường họ sẽ phải gách 1 món nợ - Student Loan\nCòn ở VN thường sẽ có xuất phát điểm ở cột mốc thứ 2\n\n🌱 Ăn bám gia đình (level 0️⃣)\n\nChưa có gì trong tay, phụ thuộc hoàn toàn vào gia đình.\n\n🌱 Tự nuôi bản thân (level 1️⃣)\n\nBắt đầu có thu nhập và có thể tự nuôi bản thân nhưng vẫn theo kiểu lương tháng nào tiêu hết tháng đấy.\n\n\nĐiểm chung ở giai đoạn này là bản thân sẽ luôn ở trong trạng thái căng thằng và bất an. Nếu có những biến cố(mất việc, ốm đau, …) xảy ra sẽ hoàn toàn không có khả năng đối ứng được.\n\n🌿 Theo dõi &amp; Kiến tạo §\n🌱 Theo dõi chi tiêu (level 2️⃣ - trạng thái hiện tại của tôi)\n\nTheo dõi chi tiết từng chi tiêu hàng ngày của bản thân. Từ đó tính toán được mức Chi tiêu tối thiểu và Chi tiêu tiêu chuẩn.\nBước này cực kì quan trọng, 2 mức độ chi tiêu xác định được ở trên sẽ là tiền đề để chúng ta tính toán những cột mốc tiếp theo.\nHiện tại tôi đã và đang tập hình thành thói quen lưu lại chi tiêu hằng ngày bằng app Money Lover.\n\n\nTạo cho bản thân thói quen theo dõi chi tiêu. Các mức chi tiêu sẽ thay đổi theo thời gian nên thói quen này vô cùng quan trọng.\nXác định được mức Chi tiêu tối thiểu và Chi tiêu tiêu chuẩn.\n\nSau quá trình theo dõi 👀, tiếp đến sẽ là hành động 👷‍♂️.\n🌱 Xóa nợ (level 3️⃣)\n\nLà nền móng quan trọng để chúng ta có thể xây dựng vững chắc mô hình tài chính của bản thân sau này.\nỞ level này, chúng ta cần xác định những khoản nợ xấu, khoản nợ tốt, thứ tự ưu tiên của từng khoản nợ. Kết hợp với kết quả của việc theo dõi chi tiêu =&gt; Có một kế hoạch rõ ràng cho việc trả nợ dứt điểm.\nĐừng nóng vội khi vừa muốn trả nợ vừa muốn tích góp và vừa muốn đầu tư. Bạn sẽ phải hối hận vì phải xử lý nhiều những tasks khó cùng một lúc đấy.\n\n\nTâm lý thoải mái, không lo đến nợ nần nữa, tập trung hoàn toàn tâm trí cũng như nguồn tiền cho việc xây dựng tài chính cá nhân.\n\nTrả nợ đời xong rồi thì tập trung xây dựng mô hình tài chính của bản thân thôi 💪\n🌱 Setup dòng tiền (level 4️⃣)\n\nKhông nên để tiền ở một chỗ, dễ dẫn đến việc tiêu tiền lấn sang những quỹ có mục đích khác.\nỞ bước này chúng ta sẽ thiết lập Dòng chảy cho nguồn tiền của bản thân. Tiếp cận những định nghĩa mới như Quỹ Khẩn Cấp (Emergency Fund), Rainy Day Fund, Every Day Fund, Saving Account, … được sử dụng như thế nào? Cách xác định tỉ lệ cho từng quỹ là bao nhiêu?\nSau khi Setup xong, tôi có thể xác định được runway của mình là bao nhiêu. Khi có biến cố, chất lượng cuộc sống của tôi vẫn được đảm bảo trong thời gian bao lâu.\n\n\nTạo ra một hành lang an toàn về tài chính cho bản thân. Tránh bản thân gặp phải những bất an khi có biến cố xảy đến.\n\n🌿 Tích lũy &amp; Đầu tư (Well Building) §\nMượn cách ví von của Kevin O’Leary - một trong những Shark xuất hiện trong chương trình Shark Tank của Mỹ chia sẻ:\n\nTôi coi tiền của mình là những chiến binh 💂. Mỗi ngày tôi thả những chiến binh của mình ra trận và cuối ngày tôi muốn những chiến binh đó sẽ đem lại cho mình thật nhiều tù binh 💵💵💵.\n\nSau khi đạt được level 4️⃣, chúng ta đã xây dựng được một hậu phương vững chắc. Công việc bây giờ sẽ là tuyển mộ quân sĩ để bắt đầu ra trận chinh chiến ⚔️.\n🌱 Trương mục đầu tư (level 5️⃣)\n\nXây dựng trương mục đầu tư và có cho mình những phương châm để quản lý những trương mục này.\n\n🌱 Thu nhập thụ động (Passive Incomes - level 6️⃣)\n\nXây dựng và phát triển những nguồn thu nhập thụ động.\n\n\nLevel 5️⃣ &amp; 6️⃣ sẽ đi liền với nhau, giúp chúng ta chiêu mộ thêm nhiều binh lính 💂 (gia tăng nguồn vốn).\nNguyên tắc căn bản của giai đoạn này đó là tăng thu và giảm chi.\n\n\nSau 2 level trên, khi đã tích lũy được một nguồn vốn nhất định, bây giờ chúng ta có thể chuyển qua bước Đầu tư.\n🌱 Đầu tư (level 7️⃣)\n\nTìm cách chọn những mô hình đầu tư hiệu quả.\nHọc hỏi, trau dồi, nâng cao kiến thức, kinh nghiệm đầu tư.\n\n\nỞ gian đoạn này, chúng ta có thể xen kẽ thực hiện các bước với nhau, không cần tuần tự như giai đoạn 2.\nGiai đoạn này sẽ là giai đoạn dài hơi nhất trong hành trình.  Liên tục tích góp và đầu tư thì sẽ đến lúc chúng ta sẽ bước đến giai đoạn thứ 4(tôi không muốn dùng từ giai đoạn cuối cùng vì đây không phải là điểm kết thúc).\n\n🌿 Tự do tài chính §\nCó 3 cột mốc khi chúng ta đạt đến giai đoạn chính quả này, đó là:\n🌱 An toàn tài chính (Finacial Security - level 8️⃣)\n\nCó được số tiền có thể đảm bảo mức sống cơ bản của bản thân cho đến cuối đời, kể cả khi chúng ta vì một lý do nào đó mà không thể làm việc được nữa.\nCó quyền bỏ đi(ở mọi lĩnh vực)\n\n🌱 Độc lập tài chính (Financial Independence - level 9️⃣)\n\nKhái niệm FIRE - Financal Independence Retire Early - Ngưng làm việc nhưng vẫn đáp ứng được những nhu cầu liên quan đến tài chính theo mức chúng ta mong muốn.\n\n🌱  Tự do tài chính  (Financial Freedom - level 🔟)\n\nKhi đã ở level 9️⃣ đủ lâu chúng ta sẽ dần cảm nhận được sự tư do khi không phải lệ thuộc vào tiền bạc.\nLúc này tiền sẽ là công cụ để chúng ta thực hiện những mục tiêu khác.\nCó thể tự tin nói: Fuckyou Money!!!\n"},"40123345-posts/44-Finance/44.01-Wealth/Vai-trò-của-tiền":{"title":"🌱 Vai trò của tiền","links":[],"tags":["finance"],"content":"🌿 Câu chuyện §\n\n\n\n\nLoài người đã sử dụng mô hình trên trong hàng ngàn năm. Cách để chúng ta tồn tại và hạnh phúc đó là:\n\nHiểu rõ giá trị của mình là gì.\nBiết được nhu cầu thực sự của bản thân.\nTìm được thị trường phù hợp.\nĐạt được thỏa thuận tốt, win-win giữa hai bên.\n\n\n\n\n\n                  \n                  Note \n                  \n                \nBản chất, Tiền không tồn tại!\n\n🌿 Vấn đề về trao đổi §\n\n\nVấn đề:\n\nGiá trị của Mea không phù hợp với nhu cầu của Fru.\nKhi Mea có nhiều thịt nhưng chưa có nhu cầu, nếu cứ tích góp lâu dần thịt sẽ bị kém chất lượng.\n\n\n\n\n\n                  \n                  Tiền \n                  \n                \nLoài người đã phát mình ra tiền để làm vật trao đổi trung gian.\n\n\nNếu muốn hiểu thêm về khái niệm của tiền, mọi người có thể xem ở đây.\n\n\n\n\n                  \n                  Giá trị \n                  \n                \nTiền có thể là Giá trị, nhưng Giá trị chưa chắc đã là tiền!\n\n🌿 Tiền đã làm thay đổi mọi thứ §\n\n\n\n\n\n\n🌿Ngẫm §\n\nCâu chuyện trên không có ý nói Tiền là xấu nhưng Tiền có khả năng chi phối chúng ta nếu chúng ta không có đủ khả năng để kiểm soát nó.\nSuy cho cùng Tiền cũng chỉ là công cụ giúp cho quá trình vận hành trao đổi được thuận tiện hơn. Để không lệ thuộc vào Tiền hãy quay về mô hình nguyên thủy và phát huy những giá trị cốt lõi.\n\nXác định được đúng giá trị của bản thân.\nBiết được nhu cầu thật sự của mình là gì.\nTìm được đúng thị trường để trân trọng những giá trị và đáp ứng được những nhu cầu của chúng ta.\nTạo ra những thỏa thuận chất lượng, thể hiện giá trị bản thân một cách trung thực đáp ứng được nhu cầu của người khác trên thị trường. Từ đó thỏa mãn những nhu cầu thật sự của bản thân.\n\n\n\n\n\n                  \n                  Biết đủ \n                  \n                \n“Biết đủ” chính là cách nắm giữ hạnh phúc trong tay.\n"},"40123345-posts/44-Finance/44.01-Wealth/What-is-the-Financial-Freedom?":{"title":"🗺️ What is the Financial Freedom?","links":["40123345-posts/44-Finance/The-4-percent-Rule","40123345-posts/44-Finance/Each-step-to-the-Financial-Freedom"],"tags":["finance","freedom"],"content":"\n🚀 Khi bắt đầu muốn tìm hiểu bất kì lĩnh vực gì, chúng ta nên có thói quen chủ động đặt ra 2 câu hỏi What? và Why? trước khi thực sự theo đuổi. Trong suốt hành trình đó, liên tục làm rõ câu hỏi How?.\nCâu hỏi How? thường sẽ mất rất nhiều thời gian, chúng ta cần có nhiều trải nghiệm, kinh nghiệm để đúc kết. Quá trình này có thể là một vài năm, chục năm hay có khi là cả đời. Chính vì vậy làm rõ  What? và Why? thật sự quan trọng nếu không chúng ta sẽ lãng phí thời gian và công sức của mình.\n🌱 What? : làm rõ cái chúng ta muốn thực hiện, theo đuổi là gì?\n🌱 Why? : tại sao chúng ta nên thực hiện, theo đuổi nó, chúng ta sẽ\nnhận được gì?\n🌱 How? : tôi cần làm như thế nào để cải thiện kết quả?\n\n🌿 What? §\n\n🤔 Tự do tài chính là gì?\n\n\n🌱 Theo ý hiểu ở thời điểm hiện tại của tôi, tự do tài chính là trạng thái đạt được khi chúng ta đã thoát khỏi sự ràng buộc của đồng tiền.\n🌱 Tiền sẽ là công cụ để chúng ta thực hiện những mục tiêu khác.\n🌱 Là khi chúng ta có thể tự tin nói:\n\nFuckyou Money 😏😏😏\n\n🌿 Why? §\n\n🤔 Tại sao tôi phải bỏ ra rất nhiều thời gian và công sức để đạt được Tự do tài chính?\n\n\nĐồng tiền không có xấu. Chỉ có 2 sự lựa chọn: Mình quản lý Tiền hoặc Tiền quản lý Mình.\n\n🌱 Không phải Tự do tài chính là Sự giàu có. Gốc rễ thật sự của hành trình này chính là Tự Do. Đây là thứ xa xỉ nhất mà đến cả những người có rất nhiều tiền cũng chưa chắc đã có được.\n🌱 Lúc này đồng tiền chỉ là công cụ giúp chúng ta thoải mái hơn trong mọi quyết định mà thôi.\n🌱 Là hành trình giúp chúng ta thay đổi và trau dồi mindset.\n🌱 Mang lại chất lượng cho cuộc sống - một cuộc đời đáng sống.\n🌿 How? §\n\n🤔 Làm thế nào để đạt đuợc Tự do tài chính?\n\n🌱 Loại bỏ những lối suy nghĩ sai lệch về tài chính.\n\nĐánh đồng chi tiêu phóng khoáng và chi tiêu không có kiểm soát.\nKhông có quản lý chi tiêu, lương tháng nào tiêu hết tháng đấy.\nCẩn thận khi chưa kịp Giàu đã Già.\n\n🌱 Trang bị kiến thức:\n\nMindset “biết đủ”.\nEscape Velocity - Vận tốc thắng được trọng lực của Trái Đất để có thể đưa được vệ tinh ra ngoài vũ trụ. Trong lĩnh vực tài chính, là một con số (dựa trên The 4% Rule thắng được sức cản của đồng tiền giúp chúng ta mở rộng danh sách lựa chọn của bản thân(Tự do).\nXác định từng cột mốc nhỏ cho hành trình này.\n"},"40123345-posts/44-Finance/44.02-Cycle/Chu-kỳ-bong-bóng-tài-chính":{"title":"🌱 Chu kỳ bong bóng tài chính","links":[],"tags":["finance","cycle"],"content":"\n\nMô hình Bubble Cycle bên trên được nghiên cứu bởi Tiến sĩ Jean-Paul Rodrigue, Giáo Sư Địa Lý tại đại học Hofstra. Một chu kỳ sẽ gồm 4 giai đoạn chính:\n\n🌿 Giai đoạn bình lặng:\n\nGiai đoạn mọi thứ vẫn còn mơ hồ, chỉ những người hiểu các nguyên tắc cơ bản của thị trường mới có thể nhìn ra cơ hội ở giai đoạn này.\nĐối tượng tham gia:\n\nCá mập\nBig Boys\nCác nhà đầu tư thông minh\n\n\nDòng tiền thông minh được đầu tư trong giai đoạn này một cách lặng lẽ và thận trọng. Giai đoạn này thường diễn ra lâu vì các nhà đầu tư cần có thời gian để gom cổ phiếu. Cổ phiếu phải được mua trong nhiều phiên với khối lượng không quá cao để tránh làm tăng giá mạnh. Vì vậy giai đoạn cổ phiếu sẽ có xu hướng đi ngang hoặc tăng nhẹ.\n\n\n🤔 Giai đoạn nhận thức:\n\nThị trường bắt đầu định hình, các tín hiệu tốt bắt đầu xuất hiện(truyền thông)\nĐối tượng:\n\nCác tổ chức\nCác nhà đầu tư nhanh nhạy\n\n\nKhối lượng giao dịch bắt đầu tăng cao. Các tổ chức hay các nhà đầu tư nhanh nhạy trong giai đoạn này nhận thấy các cổ phiếu được tích luỹ thời gian đủ lâu, họ sẽ thu mua vào với một khối lượng lớn, giá cổ phiếu sẽ tăng trần vài phiên, sau đó điều chỉnh lại vì có một số đối tượng chốt lời sớm.\n\n\n🔥 Giai đoạn điên cuồng:\n\nThị trường cực kỳ sôi động, đâu đâu cũng toàn là các tín hiệu tốt(truyền thông, báo cáo tài chính của các tổ chức, thậm chí các CEO cũng có những buổi toạ đàm ‘lùa gà’,…)\nĐối tượng:\n\nF0\n\n\nGiai đoạn này không còn có tính logic nữa, mọi người đầu tư theo cảm tính, phím con nào là chơi con đấy. Giai đoạn này rất dễ ăn, đánh đâu thắng đấy vì dòng tiền đổ vào là cực nhiều. Cổ phiếu được đẩy giá lên cao ngất ngưởng. Càng lúc càng có nhiều người không hiểu biết về thị trường lao vào kiếm lời.\n\n\n🚒 Giai đoạn dập tắt:\n\nThị trường xuất hiện thông tin đánh vào niềm tin của các nhà đầu tư, khiến họ bắt đầu nghi ngờ về giá trị thực sự của đống tài sản họ đầu tư.\nDòng tiền tháo chạy khỏi thị trường. Lúc này các cá mập hay các nhà đầu tư ở giai đoạn 1 sẽ bắt đầu chốt lời. Khối lượng giao dịch trên thị trường tăng cao đột biến. Do đám đông vẫn còn đang FOMO nên sẽ bắt đáy chỗ tuồn hàng này. Giá tiếp tục giảm và tạo đấy khi thị trường không còn người bán tháo nữa.\n\n\n\n\n\nLink bài viết: https://www.memostockvn.com/p/chu-ky-hype-va-chu-ky-bong-bong-tai"},"40123345-posts/44-Finance/44.02-Cycle/Chu-kỳ-kinh-tế":{"title":"🌱 Chu kỳ kinh tế","links":[],"tags":["finance","cycle"],"content":"\n\nMột chu kỳ kinh tế bao gồm 4 giai đoạn:\n\n🍃 Suy thoái:\n\nLà giai đoạn nền kinh tế giảm từ đỉnh xuống đáy. Các hoạt động liên quan đến kinh tế sẽ bị đình trệ và ảm đạm. Nếu tình trạng suy giảm nghiêm trọng hơn, có thể coi đây là một cuộc khủng hoảng kinh tế(đại khủng hoảng)\nChỉ số vĩ mô:\n\nGDP giảm trong ít nhất là 2 hoặc nhiều quý liên tiếp\nCPI đi ngang và giảm. Lạm phát tạo đỉnh và tụt dần.\n\n\nVị thế các doanh nghiệp:\n\nSản suất nhiều ➡️ dư thừa ➡️ cung &gt; cầu ➡️ cắt giảm sản lượng ➡️ lợi nhuận không tăng trưởng thậm chí còn giảm ➡️ giá chứng khoán giảm.\n\n\nVị thế của người tiêu dùng:\n\nGiá hàng hoá cao ➡️ tiết kiệm ➡️ dư thừa hàng hoá ➡️ nhu cầu sản xuất thêm hàng hoá giảm ➡️ nhân công lao động giảm ➡️ thu nhập giảm.\n\n\n\n\n🌱 Phục hồi:\n\nNền kinh tế giảm dần sự suy thoái, bắt đầu đi ngang tạo nền, sau đó sẽ phục hồi dần dần.\nChỉ số vĩ mô:\n\nGDP ngừng giảm, đi ngang\nTỷ lệ thất nghiệp lớn\nThu nhập bình quân đầu người giảm mạnh\n\n\nVị thế doanh nghiệp:\n\nTình hình kinh doanh dần ổn định lại ➡️ có đơn hàng mới ➡️ tăng sản xuất ➡️ phục hội lại nhân công ➡️ hoạt động kinh doanh tốt lên ➡️ tạo nhiều cơ hội việc làm\n\n\nVị thế người tiêu dùng:\n\nDoanh nghiệp thuê thêm nhân công ➡️ thu nhập dần cải thiện ➡️ chi tiêu nhiều hơn ➡️ nhu cầu tăng dần &gt; cung ➡️ giá hàng hoá tăng dần\n\n\n\n\n🌿 Tăng trưởng:\n\nNền kinh tế bắt đầu tăng trưởng, có những tín hiệu tốt hơn. Hầu hết các hoạt động kinh tế được đẩy mạnh trong giai đoạn này.\nChỉ số vĩ mô:\n\nGDP tăng trường\nHầu hết các chỉ số kinh tế đều tăng\nChỉ số tín dụng vay tiền cũng tăng lên để các doanh nghiệp mở rộng sản xuất\nLạm phát tăng do tiền lưu thông nhiều trên thị trường\n\n\nGiá cả các loại hàng hoá tài chính tăng cao: Chứng khoán, Bất Động Sản, Vàng, …\nVị thế doanh nghiệp:\n\nCầu &gt; cung ➡️ giá hàng hoá tăng cao ➡️ doanh nghiệp vay tiền để mở rộng sản xuất ➡️ hàng hoá sản xuất ra để cân bằng nhu cầu\n\n\nVị thế người lao động:\n\nDoanh nghiệp thuê nhân công nhiều hơn + tăng lương ➡️ thu nhập tăng ➡️ tiêu dùng nhiều hơn ➡️ cầu và cung cùng tăng trưởng\n\n\n\n\n🌳 Tạo đỉnh:\n\nGiai đoạn bùng nổ mạnh mẽ của nền kinh tế. Tất cả đều được đẩy lên cao nhất và có xu hướng tạo đỉnh, mọi thứ vượt quá tầm kiểm soát, bắt đầu xuất hiện nguy cơ sụp đổ.\nChỉ số vĩ mô:\n\nGDP ngừng tăng và bắt đầu giảm\nChỉ số CPI đạt đỉnh\nGiống như đấy, có thể kéo dài vài tháng hoặc vài quý (thời kỳ thịnh vượng)\n\n\nVị thế doanh nghiệp:\n\nNgừng mở rộng sản xuất, doanh thu lợi nhuận đều đạt kết quả tốt nhất ➡️ doanh nghiệp phát hành thêm cổ phiếu để tăng vốn ➡️ giá cổ phiếu bắt đầu ngừng tăng và đi ngang.\n\n\nVị thế người tiêu dùng:\n\nBắt đầu nhận thấy giá hàng hoá cao hơn thu nhập ➡️ giảm mức chi tiêu ➡️ cầu giảm dần, cung nhiều lên ➡️ bắt đầu quay trở về giai đoạn suy thoái 🍃\n\n\n\n\n\n\n\nLink bài viết: https://www.memostockvn.com/p/chu-ky-kinh-te-the-economic-cycle"},"40123345-posts/44-Finance/44.02-Cycle/Chu-kỳ-nhóm-ngành":{"title":"🌱 Chu kỳ nhóm ngành","links":["40123345-posts/44-Finance/44.02-Cycle/Chu-kỳ-kinh-tế","40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-tiêu-dùng-thiết-yếu","40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-tiêu-dùng-không-thiết-yếu","40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-chăm-sóc-sức-khoẻ","40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-Công-nghệ","40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-Công-nghiệp","40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-Vật-liệu","40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-Viễn-thông","40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-Tài-chính","40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-Năng-lượng","40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-Tiện-ích"],"tags":["finance","cycle"],"content":"\n\nTrong một chu kỳ kinh tế, mỗi một giai đoạn sẽ có những nhóm ngành vượt trội và phù hợp với xu hướng phát triển chung. Việc xác định được các nhóm ngành này sẽ giúp dễ dàng hơn trong việc lựa chọn thời điểm cũng như cổ phiếu để đầu tư.\n\n\n\n1️⃣ Nhóm ngành tiêu dùng thiết yếu\n\n\n2️⃣ Nhóm ngành tiêu dùng không thiết yếu\n\n\n3️⃣ Nhóm ngành chăm sóc sức khoẻ\n\n\n4️⃣ Nhóm ngành Công nghệ\n\n\n5️⃣ Nhóm ngành Công nghiệp\n\n\n6️⃣ Nhóm ngành Vật liệu\n\n\n7️⃣ Nhóm ngành Viễn thông\n\n\n8️⃣ Nhóm ngành Tài chính\n\n\n9️⃣ Nhóm ngành Năng lượng\n\n\n🔟 Nhóm ngành Tiện ích\n\n"},"40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-Công-nghiệp":{"title":"🌱 Nhóm ngành Công nghiệp","links":["40123345-posts/44-Finance/44.02-Cycle/Chu-kỳ-kinh-tế"],"tags":["finance","career"],"content":"\n\nCó cái tên khác là ngành Tư liệu sản xuất. Nhóm ngành bao gồm các doanh nghiệp chế tạo ra các loại tài sản hữu hình như nhà cửa, máy móc, thiết bị hay phương tiện, công cụ sản xuất, … Các ngành khác sẽ sử dụng các công cụ, thiết bị này để tạo ra các sản phẩm khác.\nNgành tiêu biểu: Xây dựng, Vận tải, Cơ khí, Thiết bị , Công nghiệp đa dụng, …\nVị trí trong chu kỳ kinh tế: Giai đoạn phục hồi. Khi các doanh nghiệp muốn mở rộng quy mô sản xuất để đáp ứng nhu cầu lớn.\nVị trí trong chu kỳ chứng khoán: Từ đầu đến cuối thị trường Bull\n"},"40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-Công-nghệ":{"title":"🌱 Nhóm ngành Công nghệ","links":["40123345-posts/44-Finance/44.02-Cycle/Chu-kỳ-kinh-tế"],"tags":["finance","career"],"content":"\n\nLà nhóm ngành liên quan đến lĩnh vực nghiên cứu, phát triển, phân phối các sản phẩm dịch vụ liên quan đến công nghệ.\nNgành tiêu biểu: Phần mềm, Ứng dụng, Máy tính, Dịch vụ Công nghệ, …\nVị trí trong chu kỳ kinh tế: Đầu giai đoạn phục hồi. Đây đang là nhóm ngành được chú trọng phát triển bất chấp tình hình. Phát triển bùng nổ ở các giai đoạn khi DN phục hồi và cần nâng cao hệ thống, áp dụng công nghệ trong sản xuất.\nVị trí trong chu kỳ chứng khoán: Từ đầu đến giữa thị trường Bull.\n"},"40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-Năng-lượng":{"title":"🌱 Nhóm ngành Năng lượng","links":["40123345-posts/44-Finance/44.02-Cycle/Chu-kỳ-kinh-tế"],"tags":["finance","career"],"content":"\n\nNhóm ngành liên quan đến lĩnh vực khai thác, sản xuất và cung cấp năng lượng. Đây là nhóm ngành không thể thiếu đóng góp vào giá trị phát triển của các ngành công nghiệp khác. Có năng lượng thì mới có thể sản xuất được.\nNăng lượng chia làm 2 loại:\n\nKhông tái tạo: Xăng, Dầu, Khí đốt, Khí tự nhiên, …\nTái tạo: Thuỷ điện, Gió, Mặt trời, …\n\n\nNgành tiêu biểu: Xăng dầu, Khí đốt, Than đá, …\nVị trí trong chu kỳ kinh tế: Giữa và cuối giai đoạn phục hồi. Như các ngành như Vật liệu, Tư liệu sản xuất. Đến giai đoạn này các DN sẽ mở rộng quy mô sản xuất để đáp ứng nhu cầu của người tiêu dụng, dẫn theo giá nhiên liệu sẽ tăng.\nVị trí trong chu kỳ chứng khoán: Đỉnh của thị trường Bull. Đây là nhóm ngành có biên bộ dao động giá lớn. Ảnh hưởng nhiều bởi các vấn đề vĩ mô như xã hội, chính trị.\n"},"40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-Tiện-ích":{"title":"🌱 Nhóm ngành Tiện ích","links":["40123345-posts/44-Finance/44.02-Cycle/Chu-kỳ-kinh-tế"],"tags":["finance","career"],"content":"\n\nLà nhóm ngành liên quan đến hoạt động cung cấp các tiện nghi cơ bản để phục vụ cho đời sống hàng ngày.\nCác doanh nghiệp trong nhóm ngành này thường phát triển ổn định, biên độ dao động kinh doanh nhỏ, tăng trưởng cũng khá chậm.\nNgành tiêu biểu: Điện, Nước, Gas, Xử lý chất thải, …\nVị trí trong chu kỳ kinh tế: Đỉnh của chu kỳ, khi tất cả mọi thứ đều tăng giá thì tất nhiên giá của các mặt hàng này cũng sẽ được điều chỉnh lên.\nVị trí trong chu kỳ chứng khoán: Giữa thị trường Bear. Do các công ty có tăng trường thấp nên ít được lựa chọn trong giai đoạn phát triển. Nhưng có tính ổn định cao và hiệu quả để nhận cổ tức trong giai đoạn thị trường downtrend\n"},"40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-Tài-chính":{"title":"🌱 Nhóm ngành Tài chính","links":["40123345-posts/44-Finance/44.02-Cycle/Chu-kỳ-kinh-tế"],"tags":["finance","career"],"content":"\n\nNgành Tài chính bao gồm các tổ chứng kinh doanh trong lĩnh vực đặc biệt, cung cấp các dịch vụ kinh doanh dựa trên các tài sản tài chính như Tiền, Cổ phiếu, Trái phiếu, Chứng chỉ quỹ, Bất động sản, Vàng …\nDo các tài sản tài chính của nhóm ngành này có tính chu kỳ cao nên ngành này sẽ biến động theo tình hình kinh tế.\nNgành tiêu biểu: Chia ra làm 2 nhánh\n\nNhóm A: Ngân hàng, Chứng khoán, Quỹ đầu tư, …\nNhóm B: Bất động sản, Bảo hiểm, …\n\n\nVị trí trong chu kỳ kinh tế:\n\nNhóm A: Đáy chu kỳ, đầu giai đoạn phục hồi. Do lúc này lãi vay của ngân hàng giảm =&gt; Lợi nhuận của Doanh nghiệp tăng =&gt; Giá cổ phiếu tăng =&gt; Thanh khoản tăng =&gt; Chứng khoán + Quỹ đầu tư phát triển.\nNhóm B: Giai đoạn đỉnh, bắt đầu suy thoái. Vì giai đoạn trước nền kinh tế đang lưu chuyển quá nhiều “tiền rẻ”, dòng tiền lúc này sẽ ngấm vào các loại tài sản như BĐS, Vàng. Giai đoạn này vì lo sợ chính phủ sẽ có những động thái để ngăn bong bóng BĐS, mọi người sẽ đầu tư vào Bảo hiểm để bảo đảm tài sản.\n\n\nVị trí trong chu kỳ chứng khoán:\n\nNhóm A: Đầu thị trường Bull\nNhóm B: Đầu thị trường Bear\n\n\n"},"40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-Viễn-thông":{"title":"🌱 Nhóm ngành Viễn Thông","links":["40123345-posts/44-Finance/44.02-Cycle/Chu-kỳ-kinh-tế"],"tags":["finance","career"],"content":"\n\nNhóm ngành bao gồm các doanh nghiệp xây dựng cơ sở hạ tầng cung cấp dịch vụ truyền tải thông tin trong lãnh thổ và ngoài khu vực thông qua mạng.\nNgành tiêu biểu: Điện tử Viễn thông, Truyền hình cáp,  Mạng không dây, Dịch vụ di động, Công ty vệ tinh, …\nVị trí trong chu kỳ kinh tế: luôn phát triển bất kể đang ở giai đoạn nào. Nhưng cũng giống như y tế, ổn định trong thời gian dài.\nVị trí trong chu kỳ chứng khoán: Đầu đến giữa thị trường Bear\n"},"40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-Vật-liệu":{"title":"🌱 Nhóm ngành Vật liệu","links":["40123345-posts/44-Finance/44.02-Cycle/Chu-kỳ-kinh-tế"],"tags":["finance","career"],"content":"\n\nHay còn gọi là ngành Công nghiệp cơ bản. Nhóm ngành bao gồm các tổ chức thực hiện việc nghiên cứu, khám phá, phát triển và chế tạo nguyên liệu thô.\nNhững nguyên liệu thô này là hữu hạn nên theo thời gian, cung giảm giá sẽ tăng. Nhưng trong ngắn hạn, giá của các chúng sẽ bị ảnh hưởng bởi nhu cầu xây dựng, sản xuất của các cá nhân hoặc doanh nghiệp.\nNgành tiêu biểu: Kim loại, Vật liệu cơ bản, Hoá chất, Vật liệu xây dựng, …\nVị trí trong chu kỳ kinh tế: Giữa giai đoạn phục hồi. Khi cầu bắt đầu tăng, các doanh nghiệp sẽ gia tăng sản xuất, dẫn theo đó giá của các nguyên liệu sẽ được tăng lên.\nVị trí trong chu kỳ chứng khoán: Giữa và cuối thị trường Bull.\n"},"40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-chăm-sóc-sức-khoẻ":{"title":"🌱 Ngành chăm sóc sức khoẻ","links":["40123345-posts/44-Finance/44.02-Cycle/Chu-kỳ-kinh-tế"],"tags":["finance","career"],"content":"\n\nLà lĩnh vực thiết yếu trong cuộc sống. Các dịch vụ liên quan đến sức khoẻ luôn được duy trì ổn định dù ở bất kỳ giai đoạn nào. Đặc biệt tăng trưởng mạnh trong những giai đoạn phát sinh dịch bệnh.\nNgành tiêu biểu: Bệnh viện, Dược phẩm, Thiết bị y tế, Dich vụ y tế,…\nVị trí trong chu kỳ kinh tế: Cuối giai đoạn hồi phục.\nVị trí trong chu kỳ chứng khoán: Giai đoạn Bear Market. Trong chứng khoán, đây được coi là nhóm ngành phòng thủ, biến động ít và thanh khoản thấp nhưng an toàn để đầu tư.\n"},"40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-tiêu-dùng-không-thiết-yếu":{"title":"🌱 Ngành tiêu dùng không thiết yếu","links":["40123345-posts/44-Finance/44.02-Cycle/Chu-kỳ-kinh-tế"],"tags":["finance","career"],"content":"\n\nHay còn gọi là ngành tiêu thụ theo chu kỳ. Ngành này kinh doanh các hàng hoá không cần thiết, mua tuỳ ý theo sở thích. Nó được gọi là theo chu kỳ vì ngành này phát triển trong giai đoạn kinh tế phát triển, mọi người có tiền để chi tiêu cho các sở thích cá nhân. Ngược lại khi nền kinh tế khó khăn, hàng hoá ngành này sẽ có nhu cầu thấp.\nNgành tiêu biểu: Ô tô, Trang sức, Du lịch, Thời trang, Giải trí, Du lịch, …\nVị trí trong chu kỳ kinh tế: Khi thị trường ở giai đoạn tạo đỉnh.\nVị trí trong chu kỳ chứng khoán: Cuối thị trường Gấu(Late Bear) - Nhóm ngành có mức biên độ lợi nhuận lớn, khả năng tăng trưởng lợi nhuận cũng khá cao nhưng vì có tính chu kỳ nên cần thận trọng khi đầu tư ngành này.\n"},"40123345-posts/44-Finance/44.02-Cycle/Nhóm-ngành-tiêu-dùng-thiết-yếu":{"title":"🌱 Ngành tiêu dùng thiết yếu","links":["40123345-posts/44-Finance/44.02-Cycle/Chu-kỳ-kinh-tế"],"tags":["finance","career"],"content":"\n\nLà ngành kinh doanh các loại mặt hàng thiết yếu, không phụ thuộc theo chu kỳ kinh tế. Dù tình tình thế nào thì vẫn phải dùng.\nNgành tiêu biểu: Thực phẩm, Hàng tiêu dùng gia đình, Văn Phòng phẩm, Đồ dùng cá nhân, …\nVị trí trong chu kỳ kinh tế:\n\nCuối giai đoạn phục hồi - Khi tất cả các vật liệu cơ bản đã tăng giá bán hết thì để duy trì biên lợi nhuận ổn định, ngành tiêu dùng thiết yếu cũng sẽ tăng giá và duy trì mức lợi nhuận tăng trưởng chậm.\n\n\nVị trí trong chu kỳ chứng khoán:\n\nĐầu thị trường Gấu(Early Bear) - Khi nên kinh tế tụt dốc thì ngành này vẫn sẽ sản xuất kinh doanh và có mức tăng ổn định. Nhưng khi nền kinh tế tăng trưởng thì các cổ phiếu ngành này sẽ tụt lại phía sau.\n\n\n"},"40123345-posts/44-Finance/44.03-Stock-Market/Các-chủ-thể-trong-Thị-trường-Chứng-khoán":{"title":"🌱 Các chủ thể trong Thị trường Chứng khoán","links":[],"tags":["finance","stock"],"content":"Nhà phát hành §\n\nLà các tổ chức cần huy động vốn thông qua thị trường chứng khoán.\nThông thường bao gồm:\n\nChính phủ và chính quyền địa phương: phát hành trái phiếu\nDoanh nghiệp: phát hành cổ phiếu\n\n\n💥 Mục đích chính: Huy động vốn, giá CP không ảnh hưởng đến hoạt động kinh doanh\n\n\n\n                  \n                  Nên cẩn thận với các cổ phiếu mới IPO hoặc phát hành thêm, doanh nghiệp sẽ cố gắng để giá cổ phiếu được đẩy lên cao =&gt; Huy động được nhiều vốn hơn. \n                  \n                \n\nChủ thể đầu tư §\nChủ thể đầu tư cá nhân §\n\nCác cá nhân đơn lẻ tham gia TTCK.\n💥 Mục đích chính: Kiếm lợi cá nhân\n\nChủ thể đầu tư tổ chức §\n\nLà các tổ chức như công ty, các quỹ đầu tư, có quỹ lớn và nắm nhiều cổ phiếu.\n💥 Mục đích chính: Kiếm lợi cho tổ chức\n\n\nChủ thể đầu tư khối ngoại §\n\nCũng là tổ chức hoặc cá nhân nhưng là từ nước ngoài.\n\n\nChủ thể kinh doanh trên TTCK §\n\nLà bên trung gian đứng giữa, cung cấp các dịch vụ cơ bản như mua bán cổ phiếu hay cho vay, …\n💥 Mục đích chính: lợi nhuận kiếm từ việc cho vay margin hoặc phí giao dịch chứng khoán\n\nChủ thể vận hành quản lý thị trường §\n\nLà các chủ thể đảm bảo cho việc giao dịch chứng khoán trên thị trường đúng với pháp luật và các quy định đã được đề ra.\nBộ Tài chính, Uỷ ban Chứng khoán Nhà nước, Sở giao dịch Chứng khoán.\n"},"40123345-posts/44-Finance/44.03-Stock-Market/Cổ-phiếu-là-gì":{"title":"🌱 Stock and related stuff","links":[],"tags":["finance","stock"],"content":"🌿 Các khái niệm §\n\n🌱 Giả sử mình có một ý tưởng kinh doanh, ban đầu mình sẽ xoay vốn từ người thân trong gia đình, bạn bè để hiện thực hóa ý tưởng kinh doanh đó. Sau một thời gian phát triển, mô hình kinh doanh của mình có kết quả vô cùng khả quan và mình muốn mở rộng nó ra hơn nữa. Nhưng lúc này, số tiền mình cần lại quá lớn, không thể vay từ người thân, bạn bè như lúc đầu nữa nên mình đã vay vốn ngân hàng hoặc từ các quỹ đầu tư. Lúc này các bên cho vay sẽ cần mình thế chấp tài sản hoặc như Shark Tank, mình sẽ phải đổi 10% cổ phần để lấy 500.000$ để tiếp tục phát triển doanh nghiệp.\n\n\n\n\n                  \n                  Cổ phần (Share) \n                  \n                \nLà phần vốn nhỏ nhất của một công ty. Vốn điều lệ của một công ty cổ phần được chia thành nhiều phần bằng nhau được gọi là cổ phần.\n\n\n🌱 Cơ mà sau đấy công ty lại càng tiềm năng và mình tham vọng 😎 muốn mở rộng nó ra phạm vi cả nước, xa hơn là toàn cầu nên số tiền 500.000$ là không đủ. Lúc này mình cần phải tìm đến nơi có nguồn vốn dồi dào hơn - đó là sàn chứng khoán. Có hai cách tăng vốn đó là sử dụng:\n\n💰 Công cụ vốn (Cổ phiếu - Stock)\n💰 Công cụ nợ (Trái phiếu - Bond)\n\n\n\n\n\n                  \n                  Cổ phiếu (Stock) \n                  \n                \nCổ phiếu hay vốn cổ phần, là một loại chứng khoán đại diện cho việc sở hữu một phần của tổ chức phát hành.\n\n\n\n\n                  \n                  Chứng khoán (Security) \n                  \n                \nLà một bằng chứng tài sản hoặc phần vốn của tổ chức phát hành. Chứng khoán có thể là Cổ phiếu, Trái phiếu, Chứng chỉ quỹ và các hình thức khác.\n\n\n🌱 Lúc này, mình sẽ phải liên tục chia nhỏ ra thành nhiều cổ phần để các cổ đông có thể sở hữu, qua đó mình sẽ nhận được thêm tiền để đầu tư và phát triển các dự án mới.\n\n\n\n\n                  \n                  Cổ đông (Shareholder) \n                  \n                \nCổ đông là những người nắm giữ cổ phần của công ty. Cổ đông nắm giữ càng nhiều cổ phần thì sẽ càng có sức ảnh hưởng đến đường lối phát triển hoặc các quyết định của công ty.\n\n\n🌱 Sau đó, doanh nghiệp của mình làm ăn có lãi, mình sẽ trả cho những cổ đông của mình một số tiền thưởng - gọi là cổ tức.\n\n\n\n                  \n                  Cổ tức (Dividend) \n                  \n                \nLà một phần lợi nhuận sau thuế được chia cho các cổ đông. Có thể là tiền hoặc cổ phiếu.\n\n🌿 Phân loại cổ phiếu §\n\n🌱 Cổ phiếu thường(common) 💢 Cổ phiếu ưu đãi(preferred)\n\nPhân loại theo luật\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCổ phiếu thường(common)Cổ phiếu ưu đãi(preferred)Sở hữu cổ phần doanh nghiệpSở hữu cổ phần doanh nghiệpCó quyền biểu quyết tương đương với sổ cổ phần nắm giữKhông có quyền biểu quyết tương đương với sổ cổ phần nắm giữĐược nhận cổ tức thườngĐược nhận cổ tức thường + cổ tức ưu đãi\n\n🌱 Cổ phiếu tăng trưởng(growth stock) 💢 Cổ phiếu giá trị(value stock)\n\nPhân loại theo cổ tức\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCổ phiếu tăng trưởng(growth stock)Cổ phiếu giá trị(value stock)Là những cổ phiếu thuộc các tổ chức có khả năng tăng trưởng mạnh trong thời gian ngắn sắp tớiLà những cổ phiếu thuộc các tổ chức đã lớn tuổi, hướng đến sự ổn định bền vữngRủi ro caoỔn địnhLợi nhuận lớnLợi nhuận trung bìnhSử dụng lợi nhuận để tái đầu tưNhận được cổ tứcLà những công ty phát triển lĩnh vực mới(như sinh học, FinTech, AI,…)Là những tổ chức thâm niên trên thị trường như Hòa Phát, Vin, …\n\n🌱 Cổ phiếu Large Cap/Bluechip 💢 Cổ phiếu Mid Cap 💢 Cổ phiếu Small Cap/Penny 💢 Cổ phiếu Micro Cap\n\nPhân loại theo vốn hóa thị trường\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameVolumnLarge Cap/Bluechip10,000 &gt;= Vốn hóa &gt; 1,000 tỷMid Cap10,000 &gt;= Vốn hóa &gt; 1,000 tỷSmall Cap/Penny1,000 &gt;= Vốn hóa &gt; 100 tỷMicro Cap100 tỷ &gt;= Vốn hóa"},"40123345-posts/44-Finance/44.04-Macroeconomics/BOP---Balance-of-Payment":{"title":"🌱 BOP - Balance of Payment","links":["40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Exchange-rate---Tỷ-giá-hối-đoái","40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Inflation---Lạm-phát"],"tags":["finance","macroeconomics","seed"],"content":"🌿 What? §\n\nBOP là tổng hợp tất cả các giao dịch dưới hình thức tiền tệ của quốc gia này với quốc gia khác, trong đó:\n\nTất cả những giao dịch được thực hiện bởi các cá nhân, doanh nghiệp cưu trú trong nước hoặc chính phủ của quốc gia đó.\nĐối tượng giao dịch thương mại bao gồm các loại hàng hoá, dịch vụ, tài sản, vốn, …\n\n\n\n\n🌿 Ý nghĩa §\n\nBOP được sử dụng để xác định sự thay đổi trong các dòng vốn nước ngoài. Đồng thời, nó tác động trực tiếp đến tỷ giá hối đoái.\nĐối với vi mô: BOP thể hiện cung cầu ngoại tệ và dự đoán sự biến động tỷ giá hối đoái. Bên cạnh đó, nó còn ảnh hưởng đến hoạt động kinh doanh xuất nhập khẩu và kinh doanh ngoại tệ.\nĐối với vĩ mô: BOP thể hiện chính sách đối ngoại nói chung và chính sách thương mại quốc tế nói riêng. Nó kiểm soát sự di chuyển của các dòng vốn như đầu tư nước ngoài(FDI) và xuất khẩu vốn. Bên cạnh đó, BOP sẽ ảnh hưởng trực tiếp đến thị trường tiền tệ quốc gia và việc điều hành chính sách tỷ giá.\n\n🌿 Các thành tố của BOP §\n\n\n🌱 Cán cân vãng lai: ghi lại những giao dịch về hàng hoá và dịch vụ giữa người cư trú trong nước và những người cư trú ở nước ngoài.\n🌱 Cán cân vốn: ghi lại vốn chảy vào và ra của một quốc gia. Bao gồm vốn dài hạn, ngắn hạn và chuyển giao một chiều.\n🌱 Nhầm lẫn và sai sót: là các khoản mục bị gây ra bởi các nguyên nhân như các danh mục quá đa dạng, không thể thống kê đầy đủ. Ghi chép đến từ những thời điểm khác nhau, trốn thuế, không khai báo chính xác và đầy đủ.\n🌱 Cán cân bù đắp chính thức: là loại hình cân đối tài khoản kế toán nhằm mục đích đưa các khoản mục ở các bên Có và Nợ có tổng bằng không.\nXem chi tiết các thành tố tại đây.\n\n🌿 Phân tích BOP §\n\n\n                  \n                  Mối liên hệ \n                  \n                \nCán cân tổng thể = Cán cân vãng lai + Cán cân vốn + Sai sót\nCán cân bù đắp chính thức = -Cán cân tổng thể\nBOP = Cán cân tổng thể + Cán cân bù đắp chính thức = 0\n\n\nHai yếu tố dễ tác động đến BOP:\n\nLạm phát: Giả sử nếu nước A lạm phát cao hơn nước B, BOP sẽ có sự chênh lệch. Trên thị trường quốc tế, giá hàng hoá của A sẽ cao hơn B, do đó năng lực cạnh tranh sẽ thấp hơn B. Dẫn đến khối lượng hàng xuất khẩu của A kém hơn B.\nTỷ giá hối đoái: Trong điều kiện các yếu tố kinh tế không quá chênh lệch, nếu tỷ giá của A cao hơn của B, dễ dàng nhận thấy dòng tiền sẽ đổ qua B do tiền của B giá trị hơn cũng như thị trường của A giá cả cao hơn.\n\n\n"},"40123345-posts/44-Finance/44.04-Macroeconomics/Bond-Yield---Lợi-suất-trái-phiếu-Chính-phủ":{"title":"🌱 Bond Yield - Lợi suất trái phiếu Chính phủ","links":["40123345-posts/44-Finance/44.04-Macroeconomics/Interest-rate---Lãi-suất"],"tags":["finance","macroeconomics","seed"],"content":"🌿 What? §\nKhi chúng ta đầu tư vào kênh Trái phiếu Chính phủ, ngoài lãi suất định kỳ được nhận, người sở hữu trái phiếu còn có thể nhận được một khoản lợi nhuận nữa được gọi là Yield - Lợi suất.\nVề cơ bản, khi Lãi suất và kỳ hạn của Trái phiếu không thay đổi nhưng giá của Trái phiếu lại có sự điều chỉnh theo nhu cầu của Thị trường, thì sự điều chỉnh đó chính là Yield.\n\n🌿 Đặc điểm của bond yield §\nĐây là kênh đầu tư không có rủi ro vì người vay ở đây là Chính phủ. Kèm theo đó, nó sẽ có những đặc điểm sau:\n\nTính ổn định: Được hưởng trái tức đúng theo kỳ hạn.\nMiễn thuế thu nhập: Không tính thuế cho những khoản thu nhập đến từ bond yield.\nLợi suất thấp: Lợi suất của Chính phủ sẽ không cao như của các Doanh nghiệp, bù lại đó là sự uy tín.\n\nNgoài ra, bond yield còn phụ thuộc vào các yếu tố mang tính quốc gia như sự ổn định chính trị, kinh tế vĩ mô hoặc mức độ tín nhiệm của một quốc gia.\n🌿 Vai trò trong nền kinh tế §\nLợi suất trái phiếu Chính phủ là một trong những chỉ báo quan trọng báo hiệu về xu hướng thị trường tài chính sắp tới của một quốc gia.\n🤔 Tại sao là như vậy?\nKhi nền kinh tế có xu hướng đi xuống, các nhà đầu tư sẽ chạy ra khỏi các kênh đầu tư rủi ro cao như Chứng khoán, BĐS, tiền ảo, … để tìm đến các kênh đầu tư ít rủi ro hơn và ở đây chính là Chính phủ. Lúc này do cung tăng nên bond yield cũng sẽ tăng giá.\nNgược lại khi thị trường có xu hướng đi lên, các nhà đầu tư sẽ hướng dòng tiền của mình tới những kênh đầu tư có xu hướng tăng trường tốt hơn để kiếm lợi nhuận, dẫn theo đó là bond yield giảm giá.\n\n\n                  \n                  Lợi suất trái phiếu Chính phủ luôn ngược chiều với Thị trường Chứng khoán \n                  \n                \n\n\nBond Yield VN1Y x Bond Yield US1Y x VNI trong 5 năm- Wichart\nTừ đồ thị trên có thể thấy, theo dõi biến động của bond yield sẽ giúp các nhà đầu tư xác định được đâu là vùng tăng trường để mua và đâu sẽ là vùi rủi ro để đưa ra các phương án phòng thủ."},"40123345-posts/44-Finance/44.04-Macroeconomics/Bơm-tiền-và-Hút-tiền":{"title":"🌱 Bơm tiền và Hút tiền","links":["40123345-posts/44-Finance/44.04-Macroeconomics/Thanh-khoản","40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Interest-rate---Lãi-suất"],"tags":["finance","macroeconomics","seed"],"content":"🌿 What? §\n\nBơm tiền và hút tiền là những động thái của NHTW để điều chỉnh Thanh Khoản(số lượng tiền trong thị trường liên ngân hàng)\n\n🌿 Hút tiền §\n\n\nKhi tiền trong các NHTM nhiều và không được cho vay, NHTW sẽ phát hành Tín phiếu với lãi suất 1.7%-2% để hút tiền về. Hết kì hạn NHTW mua lại tín phiếu, NHTM nhận lại tiền.\n\n\n🌿 Bơm tiền §\n\n\nKhi tiền của các NHTM ít, NHTW sẽ bơm tiền bằng cách mua các giấy tờ có giá trị của NHTM như Trái phiếu.\nHết kì hạn, NHTW trả lại giấy tờ, NHTM trả lại tiền cho NHTW.\n\n\n🌿 NHTW điều hành qua lãi suất OMO và Tín phiếu §\n\n\nNhìn lãi suất OMO và Tín phiếu + Số lượng bơm hút tiền là có thể nhìn ra được Thanh Khoản của thị trường. Đây là chỉ số leading trong việc đánh giá thị trường.\n"},"40123345-posts/44-Finance/44.04-Macroeconomics/CPI---Consumer-Price-Index":{"title":"🌱 CPI - Consumer Price Index","links":["40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Deflation---Giảm-phát","40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Inflation---Lạm-phát"],"tags":["finance","macroeconomics","seed"],"content":"🌿 What? §\n\n\n\nChỉ số giá cả tiêu dùng là chỉ số mức giá tiêu thụ trung bình cho một giỏ hàng hoá hay dịch vụ của một người. Chỉ số biểu hiện sự thay đổi về giá cả của hàng hoá, dịch vụ theo thời gian có đơn vị tính là phần trăm.\n\n\nSử dụng để đo lường trong các lĩnh vực thực phẩm, đồ uống, nhà ở, phương tiện vận chuyển, dịch vụ y tế, giáo dục, truyền thông, hàng hoá, giải trí và các dịch vụ khác.\n\n\n🌱 CPI sử dụng để đánh giá Giảm phát hoặc Lạm phát. Là một trong những chỉ số để đánh giá sức khoẻ của nền kinh tế hiện tại.\n\n\n🚫 Các hạn chế của chỉ số CPI:\n\nKhông phản ánh được các sự xuất hiện của các mặt hàng mới.\nKhông phản ánh được sự thay đổi về chất lượng của hàng hoá.\nKhông áp dụng cho tất cả các nhóm dân cư(ví dụ ở quê tiêu sẽ ít hơn trên thành phố).\nCó sai lệch với thực tế(thường sẽ cao hơn)\n\n\n"},"40123345-posts/44-Finance/44.04-Macroeconomics/Chính-sách-Tiền-tệ":{"title":"🌱 Chính sách Tiền tệ","links":["40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Chính-sách-tài-khoá","40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Cung-tiền","40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Inflation---Lạm-phát","40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Interest-rate---Lãi-suất","40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Exchange-rate---Tỷ-giá-hối-đoái","40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Bơm-tiền-và-Hút-tiền","40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Thanh-khoản"],"tags":["finance","macroeconomics","seed"],"content":"🌿 What? §\n\nGiống như Chính sách Tài khoá, Chính sách Tiền tệ là một trong 2 công cụ Kinh tế vĩ mô được Chính phủ sử dụng để điều chỉnh Nền kinh tế.\nĐể làm được điều này, Chính phủ sẽ thực hiện thay đổi Cung tiền trong nền kinh tế.\n3 mục tiêu chính của Chính sách Tiền tệ:\n\nTăng trưởng kinh tế\nGiảm tỷ lệ thất nghiệp\nỔn định giá cả thị trường\nKiểm soát lạm phát\n\n🌿 Phân loại §\nCó 2 loại Chính sách Tiền tệ:\n\nChính sách Tiền tệ mở rộng hay còn gọi là nới lỏng tiền tệ.\n\nLà việc NHTW tăng mức cung tiền trong nền kinh tế nhiều hơn bình thường. Đề làm được việc này, NHTW sẽ thực hiện 1 hoặc kết hợp 3 cách sau:\n\nHạ lãi suất chiết khấu.\nGiảm tỷ lệ dự trữ bắt buộc.\nTăng mua vào trên thị trường chứng khoán.\n\n\nDễ nhận thấy chính sách sẽ giúp các doanh nghiệp, tổ chức có khả năng tiếp cận được với nguồn vốn với lãi suất thấp =&gt; năng cao sản xuất =&gt; tạo công ăn việc làm cho người dân =&gt; thu nhập tăng =&gt; cầu tăng. Từ đó nền kinh tế phát triển.\n\n\nChính sách Tiền tệ thu hẹp hay còn gọi là thắt chặt tiền tệ.\n\nLà việc NHTW giảm mức cung tiền trong nền kinh tế, thông qua những hoạt động như:\n\nTăng lãi suất chiết khấu.\nTăng tỷ lệ dự trữ bắt buộc.\nBán chứng khoán ra thị trường.\n\n\nTừ những động thái trên sẽ tác động tới các cá nhân, tổ chức, khiến mọi người dè dặt hơn trong việc chi tiêu và đầu tư =&gt; giảm cầu =&gt; giảm cung =&gt; kiểm soát lạm phát.\n\n\n\n🌿 Công cụ của Chính sách Tiền tệ §\nĐể đạt được mục tiêu ổn định nền kinh tế, Chính sách Tiền tệ sẽ sử dụng những công cụ sau đây:\n\nTỷ lệ dự trữ bắt buộc\n\nLà số tiền mà NHTM phải giữ lại so với lượng tiền gửi huy động theo quy định của NHTW. NHTM có thể mua Tín phiếu của NHTW để lấy lãi(còn hơn là để không).\nDo đó để tăng cung tiền =&gt; hạ tỷ lệ dự trữ bắt buộc.\nGiảm cung tiền =&gt; tăng tỷ lệ dự trữ bắt buộc.\n\n\nTỷ giá hối đoái\n\nĐiều chỉnh tỷ giá được thực hiện khi Chính phủ muốn điều chỉnh lượng cung tiền bằng ngoại tệ trong nền kinh tế.\nTăng cung tiền ngoại tệ =&gt; giảm tỷ giá bằng cách NHTW mua Giấy tờ có giá trị(Trái phiếu) của NHTM bằng tiền ngoại tệ =&gt; tăng lượng tiền ngoại ra ngoài lưu thông.\nGiảm cung tiền ngoại tệ =&gt; tăng tỷ giá bằng cách NHTW bán Giấy tờ có giá trị(Tín phiếu) của mình cho NHTM bằng tiền ngoại tệ =&gt; hút ngoại tệ ra khỏi lưu thông.\nNgoài ra khi tỷ giá tăng =&gt; giá cả trong nước tăng =&gt; thị trường cạnh tranh hơn =&gt; lượng vốn ngoại tệ cũng sẽ chảy ra nước ngoài và ngược lại.\n\n\nLãi suất chiết khấu\n\nKhi LSCK tăng, NHTM sẽ ít muốn vay tiền của NHTW, ngoài ra nếu có thì NHTM cũng sẽ nâng lãi suất cho vay, giảm khả năng vay của các cá nhân và tổ chức doanh nghiệp. Từ đó làm giảm lượng cung tiền trong nền kinh tế.\n\n\nHạn mức tín dụng(khả năng dư nợ)\n\nNHTW sẽ áp dụng hạn mức tín dụng cho các NHTM, mọi người sẽ chỉ được vay trong hạn mức cho phép.\nMuốn cung tiền tăng =&gt; tăng hạn mức tín dụng.\nMuốn giảm cung tiền =&gt; giảm hạn mức tín dụng.\n\n\nNghiệp vụ thị trường mở(OMO)\n\nLà hoạt động NHTW mua hoặc bán các giấy tờ có giá trị với các NHTM, từ đó điều chỉnh thanh khoản trong thị trường.\n\n\nTái cấp vốn\n\nLà hoạt động NHTW cấp tín dụng cho các NHTM thông qua việc mua bán giấy tờ có giá, từ đó cung cấp nguồn vốn ngắn hạn và phương tiện thanh toán cho NHTM =&gt; Tăng lượng tiền cung ứng cho nền kinh tế.\n\n\n"},"40123345-posts/44-Finance/44.04-Macroeconomics/Chính-sách-tài-khoá":{"title":"🌱 Chính sách tài khoá","links":["40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Chính-sách-Tiền-tệ","40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/GDP---Gross-Domestic-Product"],"tags":["finance","macroeconomics","seed"],"content":"🌿 What? §\n\nGiống như Chính sách Tiền tệ, Chính sách Tài khoá là một trong hai công cụ Kinh tế vĩ mô được Chính phủ sử dụng để điều chỉnh Nền kinh tế.\nTrong đó, Chính phủ sẽ can thiệp điều chỉnh tăng/giảm\n\nThuế\nChi tiêu chính phủ\nđể đạt được các mục đích kinh tế vĩ mô như tăng trường GDP, tạo công ăn việc làm, bình ổn giá,…\n\nChỉ có cấp Chính phủ mới thực hiện được Chính sách Tài khoá, các cấp dưới như chính quyền địa phương sẽ không thể thực hiện được.\n🌿 Phân loại chính sách Tài khoá §\n\nCó 2 loại chính sách Tài khoá:\n\nChính sách Tài khoá mở rộng(hay chính sách Tài khoá thâm hụt) là việc chính phủ thực hiện hỗ trợ nền kinh tế thông qua việc giảm Thuế và tăng Chi tiêu Chính phủ.\n\nGiảm thuế giúp khuyến khích người dân cũng như doanh nghiệp chi tiêu nhiều hơn =&gt; cầu tăng\nTăng Chi phí Chính phủ giúp các doanh nghiệp và từ đó là người dân có nhiều công ăn việc làm hơn =&gt; thu nhập tăng lên =&gt; chi tiêu nhiều hơn.\nChính sách Tài khoá mở rộng sẽ được Chính phủ thực hiện khi sức khoẻ của nền kinh tế đang suy yếu, kém phát triển, tăng trưởng chậm và tỷ lệ thất nghiệp tăng cao.\nChính sách này thường không được thực hiện một mình mà sẽ được kết hợp với các chính sách khác giúp ổn định, tăng trưởng và phát triển kinh tế hiệu quả nhất.\n\n\nChính sách Tài khoá thắt chặt là việc Chính phủ thực hiện thắt chặt sự phát triển quá nóng của nền kinh tế thông qua việc tăng Thuế và giảm Chi tiêu Chính phủ.\n\nTăng Thuế làm cho người dân cũng như các doanh nghiệp giảm thu nhập cũng như chi tiêu tốn kém hơn =&gt; cầu giảm\nGiảm Chi phí Chính phủ làm giảm đi các công trình công cộng, các chi tiêu cho các ngành =&gt; giảm cầu =&gt; giảm cung =&gt; điều hoà lại nền kinh tế đang phát triển quá nóng.\n\n\n\n🌿 Công cụ của chính sách Tài khoá §\nNhư đã nói ở trên, Chính sách Tài khoá sẽ được chính phủ tác động vào 2 yếu tố là Chi tiêu Chính phủ và Thuế.\n\nChi tiêu Chính phủ bao gồm chi phí mua hàng hoá dịch vụ và chi chuyển nhượng, trong đó:\n\nChi mua hàng hoá dịch vụ: Chính phủ sử dụng ngân sách để đầu tư cho Quốc phòng, xây dựng cơ sở hạ tầng, trả tiền lương cho cán bộ Nhà nước, …\nChi chuyển nhượng: Là các khoản trợ cấp những nhóm người dễ bị tổn thương trong xã hội như người nghèo, người khuyết tật, thương binh, bệnh binh, …\n\n\n\nThuế là khoản thu bắt buộc của Nhà nước đối với người dân và doanh nghiệp nhằm đáp ứng nhu cầu chi tiêu của Nhà nước vì lợi ích chung. Thuế gồm 2 loại:\n\nThuế trực thu: hiểu đơn giản là khoản thuế áp dụng trên thu nhập, tài sản của các cá nhân tổ chức. Ví dụ như thuế thu nhập cá nhân, thuế đất, thuế thu doanh nghiệp, …\nThuế gián thu: là thuế thu thông qua giá cả hàng hoá kiểu như thuế VAT\n\n\n\n"},"40123345-posts/44-Finance/44.04-Macroeconomics/Cung-tiền":{"title":"🌱 Cung tiền","links":["40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Interest-rate---Lãi-suất"],"tags":["finance","macroeconomics","seed"],"content":"🌿 What? §\n\nCung tiền là tổng lượng tiền trong lưu thông của nền kinh tế. Cung tiền bao gồm: tiền trong dân giữ, tiền trong hệ thống ngân hàng và tiền của cơ quan doanh nghiệp.\nCung tiền có các hình thức: tiền mặt, tiền xu, tiền gửi ngân hàng, séc được phép lưu thông trên thị trường theo quy định nhà nước.\n\n🌿 Yếu tố tác động đến Cung và Cầu tiền §\n\n\nNHTW kiểm soát lượng cung tiền. Lý do vì họ muốn xác định được lãi suất mục tiêu.\nChính phủ không tác động được vào nhu cầu vay tiền của người dân. Họ chỉ tác động vào mặt Cung tiền - chỉ quyết định số lượng tiền sẽ bơm vào nền kinh tế.\nCổ phiếu sẽ bị tác động thông qua việc Mở rộng/Thắt chặt Cung tiền\n\n🌿 Cơ chế cung tiền §\n\n\nCó 3 tác nhân tác động Tăng Cung tiền:\n\nNgân hàng Trung Ương\n\nTăng lượng tiền cơ sở (MB)\nGiảm tỷ lệ dự trữ bắt buộc\n\n\nNgân hàng Thương mại\n\nGiảm Dự trữ vượt mức\n\n\nNgười gửi tiền\n\nGiảm dùng tiền giấy\n\n\n\n\n"},"40123345-posts/44-Finance/44.04-Macroeconomics/Deflation---Giảm-phát":{"title":"🌱 Deflation - Giảm phát","links":["40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Inflation---Lạm-phát"],"tags":["finance","macroeconomics","seed"],"content":"🌿 What? §\n\nNgược lại với Lạm phát, Giảm phát là thuật ngữ chỉ việc giá cả hàng hoá giảm theo thời gian.\nVí dụ: Hôm nay mất 10k để mua 2 gói bimbim nhưng mai 10k có thể mua được 3 gói bimbim cơ.\n\n🌿 Nguyên nhân §\n\nGiảm phát xuất hiện khi Tổng cầu giảm hoặc Tổng cung tăng vọt. Khi đó giá của hàng hoá sẽ bị giảm xuống.\n\n🌿 Ý nghĩa §\n\nGiảm phát rất nguy hiểm, nó làm chúng ta nghèo đi một cách êm đềm.\nKhi giảm phát, mọi người sẽ có xu hướng tiết kiệm, để dành chi tiêu sau vì tin rằng tiền của mình đang có giá trị, càng đợi thì giá cả hàng hoá sẽ càng rẻ(càng lời). Khi đó, hàng hoá sẽ không bán được dẫn đến các doanh nghiệp không thể tiếp tục duy trì hoạt động sản xuất. Hiệu ứng domino kéo theo là doanh nghiệp cắt giảm nhân sự, tỉ lệ thất nghiệp tăng cao, người dân không có tiền để chi tiêu, … Vòng lặp trên sẽ kéo tụt nền kinh tế xuống, có nguy cơ phải đối mặt với suy thoái kinh tế nghiêm trọng.\n"},"40123345-posts/44-Finance/44.04-Macroeconomics/Exchange-rate---Tỷ-giá-hối-đoái":{"title":"🌱 Exchange rate - Tỷ giá hối đoái","links":["40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Interest-rate---Lãi-suất","40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/BOP---Balance-of-Payment","40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/GDP---Gross-Domestic-Product","40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Inflation---Lạm-phát","40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Cung-tiền"],"tags":["finance","macroeconomics","seed"],"content":"🌿 What? §\n\n\nLà tỷ lệ quy đổi tiền tệ giữa các nước.\n\n🌿 Ý nghĩa §\n\nLà một yếu tố quan trọng ảnh hưởng đến xuất nhập khẩu của một quốc gia.\nNếu đồng tiền mất giá, vậy khi xuất khẩu, giá cả của hàng hoá xuất khẩu sẽ rẻ hơn, có thể cạnh tranh tốt hơn trên thị trường nước ngoài.\nNgược lại nếu đồng tiền tăng giá, việc nhập khẩu sẽ rất có lợi. VD khi tiền tăng giá, doanh nghiệp có thể đổi được nhiều $ hơn, nhập khẩu được nhiều hơn.\nViệt Nam là một nước có nền kinh tế phụ thuộc, nên tỷ giá cần phải được chính phủ điều chỉnh tốt để phù hợp với nền kinh tế toàn cầu, giúp cho xuất nhập khẩu phát triển hiệu quả.\n\nNgoài ra tỷ giá còn ảnh hưởng tới nợ công.\n\n🌿 Cách điều hành tỷ giá §\n\n\nViệt Nam đang sử dụng phương pháp Neo trường biên độ để điều hành tỷ giá.\n\n\n\nHiện tại biện độ đang là +-5% so với tỷ giá trung tâm.\n\n*SBV - State Bank of Vietnam - Ngân hàng nhà nước Việt Nam *\n\n\n\n\nDựa trên 3 trụ cột chính:\n\nLãi suất liên ngân hàng - OverNight rate\nCán cân thanh toán quốc tế - BOP\nGDP và Lạm phát\n\n\n\n🌿 Tác động của cung tiền đến tỷ giá §\n\n\nCung tiền - Tỷ giá hối đoái\n\n\n\nKhi cung tiền tăng =&gt; nhiều VNĐ ngoài thị trường =&gt; tỷ giá tăng\n\n\nKhi tỷ giá tăng =&gt; NHNN bán $ để mọi người mua =&gt; giảm VNĐ ngoài thị trường =&gt; tỷ giá giảm\n\n\n🌿 SWAP §\n\nNếu Lãi suất VND &gt; Lãi suất USD =&gt; SWAP Dương Nếu Lãi suất VND &lt; Lãi suất USD =&gt; SWAP Âm\n"},"40123345-posts/44-Finance/44.04-Macroeconomics/GDP---Gross-Domestic-Product":{"title":"🌱 GDP - Gross Domestic Product","links":["40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Inflation---Lạm-phát","40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Deflation---Giảm-phát"],"tags":["finance","macroeconomics","seed"],"content":"🌿 What? §\n\n\nTổng sản phẩm trong nước(nội địa)\n\n\nLà giá trị sản phẩm vật chất và dịch vụ cuối cùng được tạo ra của nền kinh tế trong một khoảng thời gian nhất định.\n\n\n\n🌱 Ý nghĩa:\n\nLà giá trị quan trọng, chỉ ra mức độ tăng trưởng kinh tế và phát triển của một quốc gia.\nThể hiện rõ giá trị của những hàng hoá được sản xuất trên thị trường(ngoại trừ các hàng hoá lậu hoặc những sản phẩm tự cung tự cấp như kiểu tự trồng rau tự ăn)\n\n\n\n🌱 Công thức tính GDP:\n\n\n\n🌱 GDP đầu người = tổng GDP chia cho tổng dân số của một quốc gia tại một thời điểm.\n\n\n🌱 GDP danh nghĩa là GDP được tính theo phương pháp bình quân để tính ra mức giá trung bình của mỗi sản phẩm\n\n\n🌱 GDP thực tế là GDP được tính theo GDP danh nghĩa điều chỉnh với tốc độ lạm phát.\n\n\n\n\n                  \n                  GDP thực tế = GDP danh nghĩa / Hệ số giảm phát GDP\n                  \n                \nÝ nghĩa:\n\nGDP thực tế &lt; GDP danh nghĩa: Lạm phát dương(đang lạm phát)\nGDP thực tế &gt; GDP danh nghĩa: lạm phát âm(đang giảm lạm phát)\n\n\n🌿 Các yếu tố ảnh hưởng đến GDP §\n\n\nDân số: dựa theo công thức trên, dân số ảnh hưởng đến cung và cầu, tác động mạnh mẽ lên GDP.\nFDI - Foreign Direct Investment: khoản đầu tư từ nước ngoài, đây là một phần quan trọng đóng góp vào sự phát triển kinh tế của một quốc gia.\nLạm phát: song hành cùng GDP, lạm phát cao dẫn đến chi tiêu nhiều, lâu dần tiền nội địa sẽ bị mất giá dẫn đến khủng hoảng kinh tế. Chính phủ đã đề ra các chính sách kinh tế để kiểm soát lạm phát không vượt quá mức độ tăng trưởng GDP.\nMột số yếu tố khác như: tài nguyên thiên nhiên, cơ cấu ngành nghề, pháp luật, …\n\n🚫 Hạn chế §\n\nKhông kiểm soát, phản ánh được các hoạt động kinh tế ngoài luồng như: mua bán chợ đen, tình nguyện, làm tại gia, …\nGDP chỉ tính các hoạt động mua bán cuối cùng, các hoạt động trung gian cũng không được phản ánh.\nChỉ phản ánh vật chất, không khẳng định được mức độ hạnh phúc của người dân.\n"},"40123345-posts/44-Finance/44.04-Macroeconomics/Inflation---Lạm-phát":{"title":"🌱 Inflation - Lạm phát","links":["40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/GDP---Gross-Domestic-Product"],"tags":["finance","macroeconomics","seed"],"content":"🌿 What? §\n\nLạm phát là sự tăng giá chung một cách liên tục trong một khoảng thời gian, kéo theo sự mất giá trị của đồng tiền nội địa.\nVí dụ như năm ngoái mua 1 cân thịt lợn hết 20K, năm nay phải 30K mới mua được miếng thịt y như thế. Nếu đồng thời nhiều loại hàng hoá đều tăng giá sẽ dẫn tới lạm phát cũng tăng lên.\n\n🌿 Nguyên nhân §\n\nCó thể do cầu kéo, nhu cầu tăng đột biến dẫn đến giá cả tăng theo.\nCó thể do giá cả sản xuất(tiền lương, nguyên vật liệu, …) tăng kéo theo giá cả hàng hoá tăng.\nCó thể do nhập khẩu: giá cả hàng hoá nhập khẩu tăng do thuế hoặc thị trường thế giới tăng kéo theo giá trị của hàng hoá tăng.\n\n🌿 Ý nghĩa §\n\nNếu lạm phát tăng lên quá cao sẽ dẫn đến hệ quả đồng tiền nội địa bị mất giá trị. Ảnh hướng lớn đến tài sản của người dân trong nước.\nNhưng lạm phát cũng có mặt tốt đó là giúp nền kinh tế phát triển nếu duy trì mức tăng ở phạm vi phù hợp. Dễ thấy nhất là lạm phát giúp tăng trưởng GDP.\n"},"40123345-posts/44-Finance/44.04-Macroeconomics/Interest-rate---Lãi-suất":{"title":"🌱 Interest rate - Lãi suất","links":["40123345-posts/44-Finance/44.03-Stock-Market/Các-chỉ-số-Vĩ-mô/Inflation---Lạm-phát"],"tags":["finance","macroeconomics","seed"],"content":"🌿 What? §\n\nLà tỷ lệ phần trăm tính trên số tiền gốc(gửi hoặc cho vay) mà đơn vị vay tiền phải có trách nhiệm hoàn trả lại người cho vay trong khoản thời gian xác định.\n\n🌿 Các loại lãi suất §\n\nLãi suất được xác định dựa theo năm tiêu chí sau:\n\n🌱 1. Dựa vào tính chất khoản vay §\n\nLãi suất tiền gửi ngân hàng - Lãi suất huy động.\n\nBên vay là ngân hàng, bên cho vay là cá nhân, tổ chức gửi tiền vào ngân hàng.\n\n\nLãi suất tín dụng ngân hàng.\n\nBên vay là cá nhân, tổ chức. Bên cho vay là ngân hàng.\n\n\nLãi suất chiết khấu.\n\nBên vay là ngân hàng thương mại. Bên cho vay là ngân hàng nhà nước.\n\n\nLãi suất tái chiết khấu.\n\nĐược quy định bởi NHNN dựa trên giấy tờ có giá trị ngắn hạn hoặc số tiền ghi trên thương phiếu khi đến kỳ hạn thanh toán.\n\n\nLãi suất liên ngân hàng - Overnight rate.\n\nLãi suất giữa các NHTM sử dụng để vay tiền lẫn nhau.\n\n\nLãi suất cơ bản.\n\nLà lãi suất tối thiểu Ngân hàng Nhà nước áp dụng cho đồng tiền trong nước.\n\n\n\n🌱 2. Dựa theo giá trị thực của tiền lãi thu được §\n\nLãi suất danh nghĩa: lãi suất được thống nhất từ đầu dựa trên khoản vay, không tính đến ảnh hưởng của lạm phát.\nLãi suất thực: Lãi suất danh nghĩa - Lạm phát\n\n🌱 3. Dựa vào tính linh hoạt của lãi suất quy định §\n\nLãi suất cố định: Là lãi suất được thống nhất từ đầu, không bị ảnh hưởng bởi biến động thị trường.\nLãi suất thả nổi: Là lãi suất bị ảnh hưởng theo biến động của thị trường. Điều này mang lại cả rủi ro và lợi nhuận cho cả bên vay và bên cho vay.\n\n🌱 4. Dựa vào loại tiền cho vay §\n\nLãi suất nội tệ: áp dụng cho các khoản vay bằng đồng tiền trong nước.\nLãi suất ngoại tệ: áp dụng cho các khoản vay bằng đồng tiền nước ngoài.\n\n🌱 5. Dựa vào tín dụng trong nước và quốc tế §\n\nLãi suất trong nước.\nLãi suất quốc tế.\n\n🌿 Ý nghĩa §\n\nLãi suất có vai trò vô cùng quan trọng trong nền kinh tế.\nLãi suất thấp thường sẽ kích thích đầu tư, giảm chi phí sản xuất, khuyến khích người dân mang tiền đi đầu tư thay vì để tiền trong ngân hàng tiết kiệm.\nNgược lại, khi muốn giảm lượng tiền lưu trông trên thị trường, tăng lãi suất sẽ giảm khả năng sản xuất của các doanh nghiệp, người dân gửi tiền vào ngân hàng để tiết kiệm cho an toàn.\nLà công cụ chính để nhà nước điều chỉnh sức khoẻ của nền kinh tế.\n\n🌿 Các yếu tố ảnh hưởng đến lãi suất §\n\nYếu tố cung cầu tiền tệ.\nYếu tố lạm phát. Nếu lạm phát tăng, chính phủ sẽ phải tăng và duy trì lãi suất ở mức cao để giảm lượng tiền đang lưu thông.\nCó 2 yếu tố để chính phủ quyết định giảm lãi suất:\n\nMột là lạm phát được kiểm soát tốt.\nHai là suy thoái kinh tế xảy ra.\n\n\nChính sách của chính phủ cũng là một trong những yếu tố ảnh hưởng đến lãi suất.\n"},"40123345-posts/44-Finance/44.04-Macroeconomics/Thanh-khoản":{"title":"🌱 Thanh khoản","links":["40123345-posts/44-Finance/44.04-Macroeconomics/Inflation---Lạm-phát","40123345-posts/44-Finance/44.04-Macroeconomics/Cung-tiền"],"tags":["finance","macroeconomics","seed"],"content":"🌿 What? §\n\nTính thanh khoản là một khái niệm trong Tài chính, chỉ mức độ lưu động của một loại tài sản bất kỳ, có thể mua hoặc bán trên thị trường mà không ảnh hưởng nhiều đến giá cả của tài sản đó.\nMột tài sản có tính thanh khoản cao tức là nó có thể được mua hoặc bán nhanh chóng mà giá bán không giảm đáng kể.\nTiền là tài sản có tính thanh khoản cao nhất, tiền được giao dịch hàng ngày và hầu như không mất giá(lạm phát ở Việt Nam khoảng 4%/năm)\nKhi thị trường chứng khoán bùng nổ, số lượng người đầu tư trên thị trường đông đúc, hoạt động mua bán sôi nổi nên cổ phiếu sẽ thường có thanh khoản cao. Nhưng khi thị trường downtrend, nhu cầu mua sụt giảm dẫn tới việc giảm thanh khoản.\nVậy nên theo định nghĩa, nếu muốn điều chỉnh thanh khoản trong nền kinh tế, Chính phủ sẽ tăng Cung tiền trong thị trường lên, nhiều tiền thì khả năng chuyển đổi các tài sản sang tiền mặt sẽ tốt hơn."},"40123345-posts/44-Finance/44.04-Macroeconomics/Đối-tác-chiến-lược-toàn-diện-là-gì?-Tiềm-năng-phát-triển-trong-tương-lai":{"title":"🌱 Đối tác chiến lược là gì? Tiềm năng phát triển trong tương lai","links":[],"tags":["finance","macroeconomics","seed"],"content":"Ngày 10/09/2023, Việt Nam và Hoa Kỳ đã chính thức nâng mối quan hệ ngoại giao giữa hai quốc gia từ Đối tác toàn diện lên thành Đối tác chiến lược toàn diện(skip qua Đối tác chiến lược). Vậy đối tác chiến lược toàn diện là gì? và việc nâng mối quan hệ như vậy đem lại tiềm năng phát triển gì cho Việt Nam?\n🌿 What? §\nTheo Wiki, định nghĩa của Đối tác chiến lược toàn diện hay còn gọi là đối tác hợp tác chiến lược toàn diện là hai hay nhiều bên xác định gắn bó lợi ích lâu dài, hỗ trợ lẫn nhau và thúc đẩy sự hợp tác sâu rộng và toàn diện trên tất cả các lĩnh vực mà các bên cùng có lợi. Đồng thời hai bên còn xây dựng sự tin cậy lẫn nhau ở cấp chiến lược.\nHiện tại Việt Nam đã thiết lập đối tác chiến lược toàn diện với 5 quốc gia:\n\nCộng hoà Nhân dân Trung Quốc - 2008\nLiên bang Nga - 2012\nCộng hoà Ấn Độ - 2016\nĐại Hàn Dân Quốc - 2022\nHợp chủng quốc Hoa Kỳ - 2023\n\n🌿 Tiềm năng phát triển §\n\nChiến lược friend-shoring là chính sách kinh tế dưới thời của Biden. Theo chiến lược đó, Mỹ muốn mở rộng quan hệ thương mại, đa dạng hoá chuỗi cung ứng giữa nhiều đối tác tin cậy như Việt Nam.\n\n\n\n                  \n                  Điều này có nghĩa là chuỗi cung ứng của Việt Nam sắp tới sẽ được đảm bảo hơn. Mỹ sẽ từ bỏ những chuỗi cung ứng giá rẻ, ưu tiên những đối tác chiến lược Toàn diện. \n                  \n                \n\n\n\nTái cơ cấu nền kinh tế. Các ngành chiếm tỷ trọng lợi nhuận lớn trong nền Kinh tế Việt Nam hầu hết là các ngành khai thác tài nguyên hoặc ngành trung gian(ngân hàng, môi giới chứng khoán). Nâng tầm quan hệ ngoại giao với Hoa Kỳ là cơ hội để Việt Nam chuyển rời tù các ngành trung gian sang các ngành ưu tiên sự sáng tạo như công nghệ mới hay môi trường như công nghệ xanh.\n\n\nMỹ cũng chỉ rõ muốn Việt Nam tham gia vào chuỗi cung ứng Chất Bán Dẫn. Việt Nam có tiềm lực lớn trong ngành này do Việt Nam sở hữu trữ lượng đất hiếm lớn thứ 2 thế giới.\n\n\n🌿 Khó khăn và thách thức §\n\nCơ hội lớn đi kèm với thách thức lớn. Chúng ta cần phải chủ động để phát triển về mọi mặt(đặc biệt về mặt tư duy, kiến thức) đáp ứng được các yêu cầu đề ra, trở thành một mắt xích không thể thiếu trong chuỗi cung ứng toàn cầu.\n"},"40123345-posts/46-Book/01-Sách/Fiction/Người-phát-ngôn-của-thần-chết":{"title":"📖 Người phát ngôn của thần chết","links":[],"tags":["review","book"],"content":"\nNgười phát ngôn của thần chết được viết tiếp nối với khung thời gian của cuốn Mưu sát(nội dung thì không liên quan gì đến nhau).\nDồn dập, kịch tích và lôi cuốn. Vẫn mang các nét đặc trưng của Tử Kim Trần, hung thủ có khả năng phản trinh sát cao kết hợp với đó là lối điều tra mang tư tưởng toán học mới mẻ. Đặc biệt ở phần kết truyện để lại cho người đọc nhiều suy nghĩ.\n\n\n                  \n                  Quote \n                  \n                \nMuốn tìm kiếm ‘sự thật’ hay ‘sự thật mà mọi người mong muốn’?\n\nCác chủ đề xã hội cùng được Tử Kim Trần lồng ghép vào truyện như:\n\nChuyện đấu đá trong giới quan chức\nTình yêu mù quáng\nGiới tính thứ ba\n\nNhưng với mình khi đã đọc những cuốn như Mưu sát, Tội lỗi không chứng cứ, … thì cuốn này hơi đuối về thủ pháp gây án, tình tiết bị lặp lại nhiều và dễ đoán 😗\nRate: ⭐⭐⭐"},"40123345-posts/46-Book/01-Sách/Fiction/Số-đỏ":{"title":"📖 Số đỏ","links":[],"tags":["review","book"],"content":""},"40123345-posts/46-Book/01-Sách/Fiction/Tắt-đèn":{"title":"📖 Tắt đèn","links":[],"tags":["review","book"],"content":"\nTác phẩm Tắt đèn của nhà văn Ngô Tất Tố đã lột tả hiện thực bần cùng, khổ cực của tầng lớp nhân dân khi phải chịu sưu cao thuế nặng. Qua đó vạch trần bộ mặt tàn ác của tầng lớp thực dân nửa phong kiến ở đầu thế kỉ XX.\nTuy là truyện ngắn, thời lượng đọc không nhiều nhưng dưới ngòi bút tả thực của tác giả, mình đã thật sự hoà mình vào những khó khăn, vất vả, sự dồn ép đến bất lực, sự cùng cực đến đáng thương. Chồng bị đánh sắp chết, phải đứt ruột dẫn cái Tý(con gái đầu) đi bán với giá không bằng 1 đàn chó mới đẻ, vậy mà vẫn không đủ tiền để chuộc chồng. Về đến nhà lại phải chịu nỗi dằn vặt khi nghe thằng Dần hỏi những câu hỏi ngô nghê, những tràng la khóc ầm xóm để đòi chị Tý của nó về bằng được. Những khó khăn nối tiếp những khó khăn như đang bao trùm lên cả gia đình chị tưởng chừng như không còn chỗ để thở, chứ đừng nói đến một tia sáng nào đó có thể rọi vào tới nơi.\nDù ở thời kì nào, tình người vẫn luôn là một món đồ xa xỉ.\nRate: ⭐⭐⭐⭐⭐"},"40123345-posts/46-Book/01-Sách/Non-fiction/Tại-sao-chúng-ta-lại-ngủ":{"title":"📖 Tại sao chúng ta lại ngủ","links":[],"tags":["review","book"],"content":"\nGiấc ngủ là nhu cầu sống không thể thiếu đối với hầu hết các loài sinh vật tồn tại trên Trái Đất, trong đó đương nhiên có loài Người chúng ta. Thế nhưng mình thấy hiện nay mọi người thường xem nhẹ tầm quan trọng của giấc ngủ. Như mình trước cuối tuần là cũng hay cố thức để cày phim hay chơi game cùng bạn bè lắm 😝\n😴 Giấc ngủ quan trọng như thế nào? §\nTheo học thuyết Darwin :\n\n\n                  \n                  Những cá thể có những đặc điểm di truyền thích nghi với môi trường thì khả năng sống sót sẽ cao hơn. \n                  \n                \n\nTrải qua hàng triệu năm tiến hoá, loài Người hay chính xác hơn là bộ Gene của chúng ta đã định hình lên những phản xạ không điều kiện để thích nghi và tồn tại trên Trái Đất. Ví dụ như:\n\nNhìn một sự vật, sự việc nào đó sẽ ngay lập tức đánh giá xem nó có thể gây nguy hiểm cho mình hay không(trong thời tiền sử, việc nhận biết sớm các nguy cơ tiềm tàng giúp chúng ta có nhiều khả năng sinh tồn hơn).\nKhi gặp tình trạng nguy hiểm, bộ não tự động tiết ra adrenaline để ra quyết định nhanh hơn, làm tăng nhịp tim, cung cấp năng lượng cho cơ thể.\n\nThế nhưng mọi người đã bao giờ tự hỏi, tại sao tổ tiên của chúng ta lại để bản thân rơi vào trạng thái bất tỉnh suốt nhiều giờ đồng hồ 💤 bất kể cho môi trường xung quanh đang tồn tại những nguy hiểm đang trực chờ(thú dữ, thời tiết xấu, …) hay không?\nĐúng vậy, tầm quan trọng của giấc ngủ là không cần phải bàn cãi!\nCó 3 yếu tố chính ảnh hướng đến sức khoẻ của chúng ta, đó là:\n\nGiấc ngủ\nChế độ ăn uống\nTập thể dục\n\nNhưng theo tác giả, và mình cũng đồng ý rằng: “giấc ngủ là yếu tố quan trọng nhất, vì chỉ khi có một giấc ngủ tốt thì hai yếu tố còn lại mới đạt được hiệu quả cao”.\nTại sao chúng ta lại buồn ngủ? §\n\nMelatonin là một loại hormone tồn tại trong cơ thể được tiết ra bởi tuyến tùng. Vai trò chính của hormone này là điều chỉnh giấc ngủ và nhịp sinh học của cơ thể.\nTác giả có giới thiệu thêm về nhân trên chéo, có thể hiểu là đồng hồ sinh học riêng của mỗi người. Khi nhân trên chéo cho rằng sắp đêm rồi, nó sẽ ra phát tín hiệu là “tuyến tùng - mày tiết ra melatonin đi để còn chuẩn bị đi ngủ”.\n\n\n                  \n                  FYI \n                  \n                \nTheo nghiên cứu, nhân trên chéo có thể điều chỉnh tối đa là một giờ cho đồng hồ sinh học. Có nghĩa là nếu bạn bay sang một nước lệch 5 giờ, bạn sẽ cần tối thiểu năm ngày để thích nghi với nhịp sống mới.\n\nQuay trở lại với Melatonin, tác giả ví hormone này như một tín hiệu của một cuộc đua, báo hiệu cho bộ não hãy chạy về đích(giấc ngủ). Điều này có nghĩa là melatonin không phải là thuốc ngủ, nó chỉ có khả năng kích thích để não bộ có được giấc ngủ tự nhiên thôi.\nNgoài ra còn một yếu tố nữa liên quan đến giác ngủ đó là adenosine - thứ gây ra áp lực ngủ.\n\nTrái ngược với caffein như chúng ta đã biết để tránh buồn ngủ, adenosine sẽ tích tụ dần dần trong ngày và khi đủ nhiều nó sẽ gây ra giấc ngủ không thể cưỡng lại được. Ngược lại khi ngủ adenosine sẽ được giải phóng nên chúng ta sẽ thấy tỉnh táo khi thức dậy - áp lực ngủ = 0.\n\n\n                  \n                  FYI \n                  \n                \nNếu chất lượng giấc ngủ không tốt, không thể giải phóng hết adenosine sẽ gây ra tình trạng buồn ngủ khi vừa thức dậy hay còn gọi là thiếu ngủ.\n\n\n\n                  \n                  Warning \n                  \n                \nCon người hiện đại hay bị vướng phải vòng lặp đó là không ngủ đủ giấc -&gt; thức dậy cần dùng caffein để tỉnh táo -&gt; caffein gây ảnh hưởng đến chất lượng giấc ngủ -&gt; không thể detox hết adenosine -&gt; sáng hôm sau dậy lại thấy thiếu ngủ và cần sử dụng caffein 🥴.\n\nCác giai đoạn của giấc ngủ §\n\nCó 2 loại giấc ngủ:\n\nGiấc ngủ NREM - giấc ngủ mắt không chuyển động nhanh (non-rapid eyes movement)\nGiấc ngủ REM - giấc ngủ mắt chuyển động nhanh (rapid eyes movement)\n\nCông dụng §\nGiấc ngủ REM giúp bộ não gia tốc nhanh chóng tính phức tạp và tính liên kết, ngoài ra nó còn thúc đẩy tính sáng tạo.\nGiấc ngủ NREM giúp chuyển giao các thông tin đã được tiếp thu trong ngày tới bộ nhớ lưu trữ lâu dài của bộ não.\nNgoài ra trong quá trình ngủ, cơ thể cũng sẽ thực hiện những tác vụ phục hồi ví dụ như thải độc cho gan, phổi, … Thiếu ngủ sẽ gây ảnh hưởng rất xấu đến hệ miễn dịch của chủ thể.\nGiấc ngủ giúp kiểm soát cảm xúc tốt hơn 🤗, ngăn chủ thể khỏi những suy nghĩ tiêu cực, stress.\n\nCây cầu tốt nhất để bắc giữa tuyệt vọng và hy vọng là một đêm ngủ ngon giấc.\n— E. Joseph Cossman\n\nTác hại nếu thiếu ngủ §\nThiếu ngủ sẽ khiến chúng ta:\n\nSuy giảm hệ miễn dịch - dễ ốm hơn\nThèm đường hơn - dễ tăng cân\nGiảm năng suất lao động - hay mắc lỗi\nCảm xúc thất thường\n\nNguy hiểm hơn nếu chúng ta không ngủ hoàn toàn, theo như tác giả có trích dẫn kết quả thí nghiệm trên loài chuột, sau 15 ngày chúng sẽ bị chết do Nhiễm Trùng Máu. Lúc này toàn bộ hệ miễn dịch của những con chuột không ngủ đã bị tê liệt, vậy nên nó không thể loại bỏ các vi khuẩn xuất hiện trong máu (Nếu được ngủ đủ, hệ miễn dịch hoàn toàn có thể loại bỏ vi khuẩn trong máu)\n\n\n                  \n                  Vậy nên để có một sức khoẻ tốt cũng như một não bộ phát triển toàn diện hay ngủ đủ giấc nhé. \n                  \n                \n\nLàm sao để có một giấc ngủ chất lượng? §\nĐây là một số phương pháp tác giả chia sẻ trong bài viết:\n\n⭐⭐⭐ Đi ngủ và thức dậy tại cùng một thời điểm mỗi ngày(vd ngày nào bạn cũng bắt đầu đi ngủ lúc 11h đêm và 7h sáng thức dậy). Nếu chỉ được chọn một phương pháp thì đây chính là phương pháp tác giả highly recommend.\nKhông nên tập thể dục trước 2-3 tiếng khi đi ngủ.\nĐiều chỉnh ánh sáng dịu để dễ ngủ hơn. Tránh ánh sáng xanh từ điện thoại, ipad. Như mình thì mình hay đọc kindle trước khi đi ngủ.\nKhông nên uống cafe sau buổi chiều. Trung bình chúng ta mất khoảng 7-8 tiếng để đào thải hết caffein, uống cafe muộn gây ảnh hưởng đến chất lượng giấc ngủ.\nKhông nên uống rượu trước 2-3 tiếng khi đi ngủ. Rượu làm ức chế giấc ngủ REM. Cá nhân mình thì thấy đúng, hôm nào say rượu là mình hay tỉnh lúc 4h sáng lắm (để đi tè hay khát nước á 😅)\nKhông nên ăn uống nhiều trước khi ngủ.\nKhông nên ngủ trưa quá 20 phút. Và không nên ngủ trưa sau 3 giờ chiều.\n\nNhững điều thú vị trong cuốn sách §\n\nChúng ta thường hay nói về chuyện ngủ bù, nhưng theo tác giả thì hoàn toàn không có chuyện đó. Nếu mỗi ngày bạn ngủ thiếu một tiếng thì đến ngày thứ 7 coi như là bạn hoàn toàn không ngủ. Việc ngủ thêm vào cuối tuần chỉ khiến ảnh hưởng đến thói quen thức giấc và làm bạn thức dậy mệt hơn vào sáng thứ 2 thôi.\nTác giả giới thiệu 2 cách để bù đắp giấc ngủ nếu tối qua bạn ngủ thiếu. Đó là ngủ trưa(nhưng không được quá 20p, ngủ lâu sẽ ảnh hướng đến giấc ngủ buổi tối) hoặc tối hôm sau bạn ngủ sớm hơn một tiếng.\nNếu bạn thức dậy lúc 7h sáng sau đó không ngủ đến tận tối, bạn đi ăn liên hoan với đồng nghiệp và không uống bất kì chút đồ uống có cồn nào. Khi bạn lái xe về nhà lúc 2h đêm, tình trạng của bạn lúc đấy không khác gì một người đang say rượu có nồng độ cồn vượt mức kịch khung cả.\nThức dậy bằng chuông báo thức có thể dẫn đến nhồi máu cơ tìm 😱 Nên thức dậy một cách tự nhiên (hic để yên cho ngủ chắc mình ngủ được cả ngày mất).\nNgủ 2 pha(ngủ trưa) giúp tăng tuổi thọ 😍\nKhông phải cứ dậy sớm là người thành công 😇 Chúng ta có 2 kiểu người được gọi là Chiền chiện sớm - những người có hiệu suất lao động tốt vào buổi sáng và Cú đêm - những người có hiệu suất lao động cao vào ban đêm.\n\n\n\n                  \n                  FYI \n                  \n                \nTheo tác giả, máy chấm công cũng là một tác nhân gây ra giấc ngủ kém chất lượng. Xã hội có xu hướng thiên vị với Chiền chiện sớm nhưng điều này hoàn toàn thiển cận và sai lầm. Sau đại dịch Covid, nhiều công ty đã áp dụng lịch làm việc flexible, việc này phần nào cũng giúp những người lao động cải thiện được giấc ngủ.\n\n\n\n                  \n                  Mình là một Chiền chiện sớm, còn bạn? 😄 \n                  \n                \n\nCảm nhận §\nĐoạn đầu của cuốn sách tác giả giới thiệu nhiều những kiến thức chuyên ngành hơi khô khan nhưng tác giả lấy ví dụ minh hoạ dễ hiểu nên mình thấy vẫn theo được không bị chán. Đoạn sau nói về các mặt lợi, tác hại hay cách để có giấc ngủ chất lượng thì mình thấy rất hữu ích.\nMình là một người dễ ngủ và cũng đề cao tầm quan trọng của giấc ngủ. Trước đây mặt mình rất nhiều mụn uống thuốc thì cũng chỉ được một thời gian xong lại đâu vào đấy. Từ đợt covid mình ở nhà ăn no ngủ kỹ, mặt mình láng hắn 😁(trộm vía), tinh thần cũng sảng khoái vui tươi. Công nhận giấc ngủ thần kỳ thật.\nSau khi đọc xong cuốn sách này mình như kiểu tìm thấy người đồng đạo vậy, tôn thờ thần Ngủ 🤣 Thần ngủ muôn nămm 🥳\nRate: ⭐⭐⭐⭐⭐"},"40123345-posts/46-Book/02-Tác-giả/Vũ-Trọng-Phụng":{"title":"Vài nét về nhà văn Vũ Trọng Phụ","links":["40123345-posts/46-Book/01-Sách/Fiction/Số-đỏ"],"tags":["review","book","author"],"content":"\n✍️ Vài nét về tác giả §\nTheo Wiki, Nhà văn Vũ Trọng Phụng sinh năm 1912 mất năm 1939(27 tuổi). Ngoài là nhà văn ông là một nhà báo nổi tiếng của Việt Nam vào đầu thế kỷ XX. Tuy thời gian cầm bút không được lâu nhưng ông cũng để lại một kho tác phẩm lớn bao gồm: hơn 30 truyện ngắn, 9 tập tiểu thuyết, 9 tập phóng sự, 7 vở kịch, cùng một bản dịch vở kịch từ tiếng Pháp, một số bài viết phê bình, tranh luận văn học và hàng trăm bài báo viết về các vấn đề Chính trị, Xã hội.\nPhong cách viết: trào phúng, châm biếm những mặt xấu trong xã hội.\nTuy nhiên do cách viết chân thực cũng như có yếu tố tình dục trong các tác phẩm ông đã bị chính quyền bảo hộ Pháp tại Hà Nội gọi ra tòa vì “tội tổn thương phong hóa”. Sau đó các tác phẩm của ông bị cấm xuất bản do bị gắn mác là “tác phẩm suy đồi”. Mãi đến tận cuối năm 1980 các tác phẩm ấy mới được phép lưu hành.\n📖 Các tác phẩm tiêu biểu §\n\nSố đỏ\nGiông tố\nLàm đĩ\nTrúng số độc đắc\n\nNguồn §\nhttps://vi.wikipedia.org/wiki/V%C5%A9_Tr%E1%BB%8Dng_Ph%E1%BB%A5ng"},"40123345-posts/46-Book/Review-sách":{"title":"🌳 Review Sách","links":["40123345-posts/46-Book/01-Sách/Fiction/Tắt-đèn","40123345-posts/46-Book/01-Sách/Fiction/Số-đỏ","40123345-posts/46-Book/02-Tác-giả/Vũ-Trọng-Phụng","40123345-posts/46-Book/01-Sách/Fiction/Người-phát-ngôn-của-thần-chết","40123345-posts/46-Book/01-Sách/Non-fiction/Tại-sao-chúng-ta-lại-ngủ"],"tags":["review","book"],"content":"Kể ra thì cũng hơi buồn cười, ngày xưa lúc đi thi đại học, điểm Văn của mình được đúng 3 điểm 🥵 Mình nhớ là đề thi có hai câu, mình viết hết câu một xong lăn ra ngủ, cán bộ coi thi thấy ngủ sớm quá cứ đứng cạnh động viên em ơi cố dậy viết một tí đi để tốt nghiệp nữa chứ 😆\nCơ mà viết mỗi câu một mà cũng được full 3 điểm, chắc lúc đấy ngồi viết thêm câu 2 có khi 10 ấy chứ 🤣 Đùa thui!!!\nNói thật là hồi đấy mình thấy viết văn nó hơi “giả tạo”, vì các cảm nghĩ mà mình viết vào trong bài thi có phải là cảm nghĩ của mình đâu 😅 Ý ở đây của mình không phải là chê trách gì về cách dạy của giáo viên cả. Mình thấy lý do chính là do mình lười và không có hứng thú với các tác phẩm trong SGK. Nếu chưa từng ngồi đọc một cách nghiêm túc các văn bản, đoạn thơ thì sao mà có được những cảm nhận của riêng bản thân mình được chứ.\nChắc hẳn mọi người đều biết văn bản Tức nước vỡ bờ trong tác phẩm Tắt đèn của nhà văn Ngô Tất Tố được viết trong SGK Ngữ văn lớp 8. Với mình trước đây thì không có ấn tượng gì lắm, chỉ nhớ mang máng chị Dậu bị mấy thằng quan hoạch hoẹ xong tức quá đấm lại mấy thằng đấy luôn.\nNhưng gần đây khi mình đọc lại trọn vẹn tác phẩm Tắt đèn, hơi ngại cơ mà mình khóc tu tu luôn ấy 😅 Khóc vì cái Tí sao nó còn bé mà nó ngoan quá, hiểu chuyện quá 😭. Khóc vì những đòi hỏi chưa hiểu chuyện nhưng hồn nhiên của thằng Dần 😭. Khóc vì tình người sao lại là thứ xa xỉ đến vậy 😭.\nTính ra là mình cũng cảm xúc dạt dào phết ấy chứ 🤣\nThế nên dù không được tính vào điểm tổng kết Văn nhưng mình quyết định sẽ viết cảm nhận của bản thân về những cuốn sách đã đọc ở đây, một cách ngắn gọn thôi, lưu trữ những cảm xúc, suy nghĩ hay đơn giản chỉ là tổng hợp những ý chính để sau này còn xem lại nữa ✍️.\nÚ kì !! Mong là bạn sẽ tìm được thứ gì đó hay ho ở đây, have funnnn 🥳\nP/s: Nếu bạn có sài Goodreads, hãy kết bạn với mình nha.\n🗓️ 2023 §\nFiction §\n\nSố đỏ - Vũ Trọng Phụng\nTắt đèn - Ngô Tất Tố\nMưu sát - Tử Kim Trần\nNgười phát ngôn của thần chết - Tử Kim Trần\nĐừng nói chuyện với cô ấy - Ngộ Cẩn\n\nNon-fiction §\n\nTại sao chúng ta lại ngủ - Matthew Walker\n"},"40123345-posts/46-Journey/Digital-garden-là-gì":{"title":"🌳 Digital garden là gì","links":["40123345-posts/46-Journey/Một-số-trang-youtube-thú-vị"],"tags":["journey"],"content":"\n🌿 What? §\nThuật ngữ Digital Garden để chỉ một cách viết blog được tổng hợp dưới dạng wiki, nơi lưu trữ những bài viết, ghi chú, tiểu luận, ý tưởng, cảm nhận, … của một cá nhân và liên kết chúng lại với nhau.\n\nTất cả mọi thứ đều có sự liên kết - ảnh chụp graph view của Obsidian\n🌿 Why? §\n🤔 Digital Garden mang lại lợi ích gì? Tại sao phải tạo ra nó?\n🌐 Connecting the dots §\nConnecting the dots là tư tưởng chủ đạo để tạo lên một digital garden.\nThuật ngữ trên được biết đến rộng rãi sau bài phát biểu của Steve Jobs trong buổi khai giảng của Stanford năm 2005. Trong bài phát biểu, Steve Jobs coi các kinh nghiệm, trải nghiệm của bản thân trong quá khứ là một dấu chấm và ông đề cao việc liên kết những dấu chấm đó để tạo ra những ý tưởng sáng tạo, đột phá.\n\nSteve kể là lúc ông ấy nghỉ học, ông ấy chán quá không biết làm gì nên tham gia đăng ký lớp Thư Pháp. Thời điểm đấy Steve cũng không biết nó sẽ giúp ích được gì, đi học cho đỡ buồn thôi. Thế nhưng 10 năm sau, nếu không có buổi đến lớp Thư Pháp đó thì ông cũng không thể cho ra đời các phông chữ máy tính tuyệt đẹp như vậy.\n\n\n\n\n                  \n                  Digital Garden giúp liên kết các kiến thức đã biết giúp chúng ta có thể đưa ra được những ý tưởng sáng tạo. \n                  \n                \n\n🧠 Second Brain §\nĐây cũng là thuật ngữ khá nổi dạo gần đây chỉ việc tạo ra một bộ não thứ hai thông qua việc ghi lại toàn bộ những kiến thức, kinh nghiệm, trải nghiệm, suy nghĩ của bản thân sau đó lưu trữ trên internet, vậy là chúng ta cũng đã tiến gần hơn tới trạng thái bất tử rồi 😆\nMình có nghe được câu này ở đâu đấy nhưng quên mất nguồn rồi, nghĩ lại thấy nó rất đúng.\n\nCông cụ quan trọng nhất để loài người vươn lên đứng đầu cái server trái đất này chính là Ngôn Ngữ.\n\nNói đùa thế chứ việc viết và tổng hợp lại những kiến thức là một kỹ năng vô cùng quan trọng và hữu ích. Viết giúp chúng ta hệ thống lại cũng như nâng cao khả năng ghi nhớ, ngoài ra còn đem lại khả năng vận dụng ngôn từ hiệu quả.\n🌿 How? §\nHai keywords quan trọng nhất để xây dựng lên Digital Garden đó là: Thu thập và Kết nối\n🌱 Thu thập §\nĐọc - Đọc - Đọc\nNguồn đọc:\n\nSách - Thể loại sách mình hay đọc là Trinh thám, Tâm lý, … Mọi người có thể kết bạn với mình trên Goodreads, đây là một mạng xã hội đọc sách được phát triển bời Amazon.\nFeedly là một công cụ giúp chúng ta có thể xem tất cả các trang blogs đã lưu thay vì check từng trang một.\nMột số trang youtube thú vị\n\n🌱 Kết nối §\nHiện tại mình đang dùng Obsidian để ghi chú.\n\n\n                  \n                  Duy trì thói quen đọc và ghi chú lại những kiến thức, trải nghiệm của bản thân theo cách tự nhiên nhất, không cần quá chỉn chu, tránh tạo áp lực cho bản thân trong việc xây dựng Digital Garden. Hãy tận hưởng quá trình phát triển khu vườn của chính mình. \n                  \n                \n\n\n\n                  \n                  Quote \n                  \n                \nHạnh phúc là một cuộc hành trình, không phải là đích đến.\n\n📋 Reference §\nhttps://www.sahilbloom.com/newsletter/7-lessons-from-steve-jobs-commencement-speech"},"40123345-posts/46-Journey/Một-số-trang-youtube-thú-vị":{"title":"🌱 Một số trang youtube thú vị","links":[],"tags":["journey"],"content":"\nKhalid Dinh Kênh chia sẻ kiến thức liên quan đến DevOps\n Hieu-TV Kênh của chú Hiếu chia sẻ về các kiến thức cũng như tư duy về tài chính cá nhân rất hay. Nên xem 🤩\n Duy Thanh Nguyen Kênh chia sẻ về các kiến thức liên quan đến chủ đề Tài chính, Kỹ năng học tập dạo gần đây thấy có seri về Triết học nghe cuốn phết.\n ByteByteGo - Kênh tổng hợp các kiến thức về Software Engineer\n Tài chính &amp; Kinh doanh  Cập nhật các thông tin kinh tế vĩ mô cũng như tình hình thị trường Việt Nam.\n Cú thông thái - Phân tích về tài chính. Kiến thức rất hữu ích. Thêm nữa là bạn này nói chuyện kiểu “có tâm\nFireship Giới thiệu siêu vắn tắt về các công nghệ, tin tức giới lập trình\nAlexanderTheGuest Review các nhà hàng 3 sao Michelin\nTechAltar Phân tích thị trường công nghệ smartphone, laptop, v.v…\nBetter Version Kênh tóm tắt sách có tâm, giọng đọc cũng rất okela.\nKiến thức thú vị Cung cấp kiến thức tổng quát về một chủ đề theo phong cách mỳ ăn liền.\ne.money24Kênh cập nhật những tin vắn về tình hình kinh tế của Việt Nam.\n\n… updating"},"50-til/51-Code/01-Style/SOLID":{"title":"💪 What is SOLID?","links":[],"tags":["til","style"],"content":"🌱 SOLID là cụm từ  tạo thành từ những chữ cái viết tắt của 5 nguyên tắc được đúc kết từ ‘xương máu’ của rất nhiều lập trình viên đi trước =)) Nếu đã từng làm dự án thực tế, mọi người sẽ đều biết là gần 80% thời gian sẽ là bảo trì hệ thống(thêm tính năng, sửa lỗi, …). Áp dụng SOLID, công việc bảo trì  và mở rộng sẽ dễ dàng hơn rất nhiều. Cùng xem những nguyên tắc ‘thần thánh’ nhưng vô cùng ‘thân thuộc’ này là gì nha!\n🌿 Single Responsibility Principle §\nMỗi class chỉ nên thực hiện một nhiệm vụ đơn lẻ!\n\n🌿 Open/Closed Principle §\nKhi thêm tính năng cho class, nên viết những class mới kế thừa class cần mở rộng.\n\n🌿 Liskov Substitution Principle §\n\n🌿 Interface Segregation Principle §\n\n🌿 Dependency Inversion Principle §\n"},"50-til/51-Code/02-Git/--force-vs---force-with-lease":{"title":"🌱 --force vs --force-with-lease","links":[],"tags":["til","git"],"content":"🌿 —force §\n\npush --force: luôn ghi đè lên remote branch theo trạng thái commit của local branch.\n\nremote brach: --cm1--cm2--cm3\n\t\t                \\\n\t\t\t             -- cm4 -&gt; push --force\nremote branch: --cm1--cm2--cm4\n\n🌿 —force-with-lease §\n\npush --force-with-lease: chỉ ghi đè khi remote branch không có commit mới so với local branch.\n\nremote brach: --cm1--cm2--cm3\n\t\t                \\\n\t\t\t             -- cm4 -&gt; push --force-with-lease\n-&gt; Error, remote brach: --cm1--cm2--cm3\n\n-----------------------------------------------------\n\nremote brach: --cm1--cm2--cm3\n\t\t\t                \\\n\t\t\t\t             -- cm4 -&gt; push --force-with-lease\nremote brach: --cm1--cm2--cm3--cm4\n\n\n\n\nOption này tránh việc ghi đè commit của người khác(trong trường hợp một nhánh có nhiều người cùng contribute). Khi có commit mới trên remote branch, chúng ta cần phải pull về và rebase trước thì mới push đươc lên remote branch.\n\n\n🌱 Refer: https://stackoverflow.com/questions/59309402/is-git-push-force-with-lease-always-safe\n\n"},"50-til/51-Code/02-Git/Create-bio-on-my-github":{"title":"🌱 Create bio on my github","links":[],"tags":["til","git"],"content":"\n🌱 Github cho phép hiển thị README trên profile github cá nhân. Chúng ta chỉ cần tạo một repo có tên trùng với account github, sau đó thỏa sức sáng tạo thôi 🥳\n\n\n\n\n                  \n                  Info \n                  \n                \nFile README.md sử dụng chuẩn markdown của Git, mọi người có thể tham khảo ở đây\n\n\n🌱 Chức năng này đã được các lập trình viên hưởng ứng sôi nổi sau khi ra mắt. Có cả một repo tổng hợp lại những profiles ấn tượng, mọi người có thể tham khảo ở đây\n"},"50-til/51-Code/02-Git/Delete-git's-branchs-safely":{"title":"🌱 Delete git's branchs safely","links":[],"tags":["til","git"],"content":"🌿 What? §\n\n🌱 Sau một thời gian làm việc trên 1 repo git, chắc chắn chúng ta sẽ cần xóa đi những merged branchs hoặc những branchs không cần sử dụng tới nữa. Dưới đây là cách mình dùng để xóa đồng thời nhiều branchs có các partterns chung dưới local:\n\n&gt; git branch -D `git branch -a | grep merge`\n\n🌱 Nhưng khi xóa các nhánh remote, cần bảo đảm an toàn, cẩn thận hơn nên mình sẽ bó cẩn thêm phần confirmation.\n\n&gt; git branch -a | grep remotes/anhnh-3008/deleted_branch | xargs -I % -p git push origin :%\n \n&gt; git push origin :remotes/sun/fixbug/game_room_controller ?... # y- Yes, n- No"},"50-til/51-Code/02-Git/Git-config-for-multi-accounts":{"title":"⚙️ Git config for multi accounts","links":["50-til/51-Code/06-Servers/Config-SSH"],"tags":["til","git"],"content":"🌿 Vấn đề §\n\nBài viết này ra đời khi mình bị các anh ngồi cạnh ‘cười chê’ do dùng nhiều accounts git trên cùng một máy nhưng lại switch bằng cơm =))) Sau khi khóc xong thì mình có tìm hiểu cách config để thuận tiện hơn cho việc sử dụng.\n\n🌿 Giải pháp §\n\n🌱 Ý tưởng là mình sẽ chia ra làm 2 thư mục work và personal  để sử dụng cho các repo tương ứng.\n🌱 Ở file .gitconfig global set user mặc định và điều hướng config riêng cho từng folder.\n\n# .gitconfig\n\n[user]\n  name = anhnh-1028\n  email = nguyen.hoang.anh-c@sun-asterisk.com\n\n[includeIf &quot;gitdir:~/personal/&quot;]\n  path = ~/personal/.gitconfig-personal\n\n[includeIf &quot;gitdir:~/work/&quot;]\n  path = ~/work/.gitconfig-work\n\n🌱 Set user cho từng folder\n\n# ~/work/.gitconfig\n\n[user]\n  name = anhnh-1028\n  email = nguyen.hoang.anh-c@sun-asterisk.com\n\n# ~/personal/.gitconfig\n[user]\n  name = anhnh-3008\n  email = mail-personal@gmail.com\n\n🌱 Xong phần config thông tin, giờ đến phần ssh. Skip bước gen ssh-key + add key lên git, giờ mình set Config SSH thôi.\n\n# ~/.ssh/config\n\nHost git-work\n  HostName github.com\n  User git\n  IdentityFile ~/.ssh/ssh-key-work\n\nHost git-personal\n  HostName github.com\n  User git\n  IdentityFile ~/.ssh/ssh-key-personal\n\n🌱 Thế là xong rồi, giờ mình chỉ cần set-url remote theo tên Host đã config thôi là chạy phà phà rồi.\n\ngit@github.com:anhnh-3008/app.git -&gt; git@git-personal:anhnh-3008/app.git\n\n🌱 Ngoài ra trong file .gitconfig còn có thể setup được cả color branch, alias, editor, … Mình có chôm được mấy cái settings hay hay của một anh ở công ty, mọi người có thể tham khảo nhé =)) nếu thấy hay thì cho anh mình một ⭐ nha &lt;3\n"},"50-til/51-Code/02-Git/Git-hooks-with-pre-commit":{"title":"🌱 Git hooks with pre-commit","links":[],"tags":["til","git"],"content":"\n\n🌱 Để tránh tình trạng gặp phải stupid mistakes như push code lên mà có cả byebug, binding.pry, debugger, … Git cho phép chúng ta sử dụng hooks để kiểm tra tự động những vấn đề ntn 🥳\n\n\n🌱 Tất cả các hooks của 1 repo được lưu trong folder .git/hooks\n\n\n\n\n🌱 Tạo file .git/hooks/pre-commit. Có thể viết bằng bất kỳ script language(như Ruby, Python, JS, ...) nào chúng ta muốn.\n\n#!/bin/sh\n \nFILES_PATTERN=&#039;\\.?$&#039;\n \nFORBIDDEN=&#039;binding.pry\\|byebug\\|console.log&#039;\n \ngit diff --cached --name-only | \\\n    grep -E $FILES_PATTERN | \\\n    xargs grep --color --with-filename -n $FORBIDDEN &amp;&amp; \\\n    echo &#039;COMMIT REJECTED&#039; &amp;&amp; \\\n    exit 1\n \nexit 0\n\n🌱 Bạn có thể custom những từ khóa không muốn push lên repo thông qua biến FORBIDDEN.\n\n"},"50-til/51-Code/02-Git/Highlight-Note-and-Warning-with-Git-Markdown(Beta-feature)":{"title":"🌱 Highlight Note and Warning with Git Markdown(Beta)","links":[],"tags":["til","git"],"content":"\n🌱 Git cung cấp syntax markdown highlight Note và Warning. Giúp chúng ta viết tài liệu hay description cho PR long lanh hơn ✨\n\n&gt; **Note**\n&gt; This is a note\n \n&gt; **Warning**\n&gt; This is a warning\n\n✨ Kết quả:\n\n\n\n🌱 Topic thảo luận: https://github.com/orgs/community/discussions/16925\n"},"50-til/51-Code/02-Git/Shortcut-checkout-to-previous-branches":{"title":"🌱 Shortcut checkout previous branches","links":[],"tags":["git"],"content":"🌱 Với Git, chúng ta có thể checkout về các previous branches bằng cách sử dụng @{-N} với N là số thứ tự nhánh muốn quay lại\n\nVí dụ từ nhánh master, chúng ta checkout qua nhánh branch-1, sau đó đến branch-2\n\nCheckout về branch-1 : git checkout -\nHoặc checkout về master : git checkout @{-2}\n\n\n\n🌱 Reference: https://til.hashrocket.com/posts/xmki4qh2xg-git-checkout-to-previous-branches"},"50-til/51-Code/03-Operating-System/Exit-code-on-terminal":{"title":"🌱 Exit code on terminal","links":[],"tags":["til","os"],"content":"🌿 Run multi commands in on line on terminal §\n$&gt; command1; command2; command3\n\n\nSẽ luôn excute hết các câu lệnh, kể cả khi các câu lệnh ở trước nó bị lỗi.\n\n\n Nhưng nếu cần sự ràng buộc phải đúng ở các câu lệnh trước thì mới được chạy tiếp, vd như apt-get update  và apt-get install package , dùng dấu &amp;&amp;\n\n\n$&gt; apt-get update &amp;&amp; apt-get install package\n🌿 Exit code in shell §\n\nNhư bên trên có nói đến việc check đúng - các câu lệnh chạy thành công được xác định bởi Exit Code.\n\nExit code trả về 0 -&gt; success\nExit code trả về khác 0, có giá trị từ 1-255 -&gt; nghĩa là câu lệnh chạy có lỗi\n\n\nCheck Exit Code của câu lệnh gần nhất:\n\n$&gt; who\n=&gt; hoanganh8999 :1           2022-12-14 19:24 (:1)\n \n$&gt; echo $?\n=&gt; 0\n \n$&gt; wo\n=&gt; wo: command not found\n \n$&gt; echo $?\n=&gt; 127\n🌿 Refer §\n\nhttps://mazer.dev/en/linux/tips/how-to-determine-error-and-exit-main-shell-script/\n"},"50-til/51-Code/03-Operating-System/Permission-in-Linux":{"title":"🌱 Permission in Linux","links":[],"tags":["til","os"],"content":"🌿 What? §\n\nBình thường mình hay chạy lệnh chmod 777 khi thấy báo lỗi không có quyền tương tác, mà 777 là cái gì?\nLàm sao để biết File hay Folder mình muốn thao tác có những quyền gì? Tài khoản nào được quyền tương tác?\n\n\n🌿 Refer §\n\nhttps://blog.bytebytego.com/\n"},"50-til/51-Code/03-Operating-System/Pipe-Data-between-Programs":{"title":"🌱 Pipe Data between Programs","links":[],"tags":["til","os"],"content":"\n🌱 Trong Shell, The Pipe cho phép kết hợp giữa nhiều commands trên cùng một dòng. Được kí hiệu bằng ký tự ASCII 124 ( | ), dấu gạch dọc.\n\nVD1:\n🌱 kết hợp câu lệnh tìm kiếm theo pattern và đếm có bao nhiêu lines trả về từ grep\n \n&gt; grep /bin/bash$ [PATTERN] | wc -l\n\nNguồn §\n\nLPIC - 1 - trang 105\n"},"50-til/51-Code/03-Operating-System/Some-Tips-for-irb-rails-console":{"title":"🌱 Some Tips for irb/rails console","links":[],"tags":["til","console"],"content":"🌿 Lấy giá trị output cuối cùng §\n\n🌱 _ được gán giá trị là output mới nhất của irb/rails console.\n\n&gt; 1 + 1 \n=&gt; 2\n&gt; _\n=&gt; 2\n🌿 Sandbox §\n\n🌱 Khi dùng option --sandbox các thay đổi đối với atabase sẽ được rollback khi thoát rails console.\n\nrails c --sandbox\n \n&gt; Account.first.destroy\n=&gt; true\n&gt; Account.find(1)\n=&gt; ActiveRecord::RecordNotFound: Could not find Account with id=1\n&gt; exit\n \nrails c\n&gt; Account.find(1)\n=&gt; #&lt;Account id: 1, ...&gt;\nTham khảo §\n\nhttps://pragmaticstudio.com/tutorials/rails-console-shortcuts-tips-tricks\n"},"50-til/51-Code/03-Operating-System/Why-must-run-apt-update-before-install-any-lib-for-Linux?":{"title":"🌱 Why must run apt update before install any lib for Linux?","links":[],"tags":["til","os"],"content":"Câu trả lời\n\n🌱 Lệnh apt update sẽ cập nhật danh sách mới nhất các packages có trong kho Ubuntu.\n\n\n\n                  \n                  Info \n                  \n                \nDanh sách repo được lưu trong file /etc/apt/sources.list\n\n\n\n🌱 Lệnh apt install sẽ đọc trong danh sách packages được cập nhật ở lệnh apt update gần nhất.\n\n\n🌱 Nếu chắc chắn package chuẩn bị install đã nằm trong danh sách cập nhật, việc chạy apt update có vẻ là hơi thừa 😶 Cơ mà thay vì ngồi xác định như thế thì mình chọn chạy apt update cho đỡ mệt mọi 😆\n\n"},"50-til/51-Code/03-Operating-System/create-multi-folders-linux":{"title":"🌱 Create multi folders linux","links":[],"tags":["til","os"],"content":"\n🌱 Create multi foders in Linux with command below:\n\nmkdir /path/{folder1, folder2, folder3}\n \ntree /path/\n \n├── folder1\n├── folder2\n├── folder3"},"50-til/51-Code/03-Operating-System/visudo":{"title":"🌱 visudo","links":[],"tags":["til","visudo"],"content":"\n\n🌱 Cấp quyền(cho user root, lệnh sudo, group admin) được cấu hình trong file /etc/sudoers .\n\nKhông bao giờ sử dụng trình soạn thảo văn bản thông thường(nano, vim, …) để sửa /etc/sudoers , thay vào đó hãy dùng visudo .\nvisudo validate cú pháp trước khi save file còn nano, vim, … thì không, save mà sai syntax là oẳng luôn đó 🥵\n\n\n\n🌱 Xem thêm: https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file\n\n"},"50-til/51-Code/04-Rails/Add-custom-flash-keys":{"title":"🌱 Add custom flash keys","links":[],"tags":["til","rails"],"content":"\n🌱 ActionController::Base mặc định cung cấp key :notice cho #redirect_to\n\n  class flash_demo\n    if true\n      redirect_to root_path, notice: &quot;Notice&quot;\n    else\n      flash[:error] = &quot;Error&quot;\n      redirect_to root_path\n    end\n  end\n\n🌱 Nhưng nếu bạn muốn thêm :error như :notice thì có thể thử cách này nhé!\n\n  class flash_demo\n    add_flash_types :error\n    \n    if true\n      redirect_to root_path, notice: &quot;Notice&quot;\n    else\n      redirect_to root_path, error: &quot;Error&quot;\n    end\n  end\n\n🌱 Refer: add_flash_keys\n"},"50-til/51-Code/04-Rails/Config-warning-when-fetched-a-lot-of-records":{"title":"🌱 Config warning when fetched a lot of records","links":[],"tags":["til","rails"],"content":"\n🌱 Từ Rails 5 chúng ta đã có thể thêm config warn_on_records_fetched_greater_than:  hiển thị cảnh báo trong rails server hoặc rails console khi có số lượng câu queries lớn hơn số lượng chúng ta đã chỉ định.\n\n# config/environments/development.rb\n \n# Show warn if fetch greater than 50 records\nconfig.active_record.warn_on_records_fetched_greater_than = 50\n"},"50-til/51-Code/04-Rails/Credentials-file-in-Rails":{"title":"🌱 Credential file in Rails","links":[],"tags":["til","rails"],"content":"\n\n                  \n                  Question \n                  \n                \nKhi khởi tạo một project, Rails sẽ tự động tạo ra file credentials.yml.enc trong folder config. Khi click vào xem nội dung thì chỉ có mỗi một dòng hash dài ngoằng ngoẵng. Thế nó sinh ra để làm gì nhỉ 🤔\n\n\n\n🌱 Từ sau Rails 5.2, khi init project sẽ tự động tạo file config/credentials.yml.enc chứa hash được mã hóa bởi aes-128-gcm  để lưu những thông tin “nhạy cảm” của dự án.\n\n\n🌱 Rails sẽ dùng config/master.key hoặc ENV[&quot;RAILS_MASTER_KEY&quot;] để mã hóa nội dung. Vì đã được mã hóa nên file config/credentials.yml.enc vẫn có thể public, miễn là chúng ta không làm lộ master key là được.\n\n\n🌱 Mặc định file tạo ra sẽ chỉ lưu secret_key_base của Rails app. Tuy nhiên chúng ta có thể edit thêm thông tin bằng command:\n\n\n$ rails credentials:edit\n\n\n                  \n                  Info \n                  \n                \n📝 Câu lệnh trên sẽ tạo file config/credentials.yml.enc và   config/master.key nếu chưa tồn tại hoặc chưa được định nghĩa.\nTìm hiểu thêm: rails credentials:help\n\n\n🌱 Đọc thông tin mã hóa bằng câu lệnh:\n\n&gt; Rails.application.credentials\n\n\n\n                  \n                  Danger \n                  \n                \nTuyệt đối không được làm mất hay public master key!\n\n\n🌱 Source: https://guides.rubyonrails.org/security.html#custom-credentials\n"},"50-til/51-Code/04-Rails/Custom-condition-sign-in-for-devise":{"title":"🌱 Custom condition sign-in for devise gem","links":[],"tags":["til","rails"],"content":"Mặc định khi đăng nhập, Devise sẽ tìm User dựa theo scope đã được thiết lập trong config/initializers/devise.rb\nVd như đăng nhập theo email:\nDevise.setup do |config|\n  config.authentication_keys = [:v_code]\nend\n🌿  Vấn đề §\n\n🌱 Thế nhưng cuộc sống thường lắm gian truân và cuộc đời của mình cũng không ngoại lệ.\n🌱 Dự án của mình có đồng thời 2 cơ chế đăng nhập 1 là qua Devise, 2 là SSO thông qua bên thứ 3. Khi thực hiện SSO, hệ thống sẽ lưu user đó vào DB chung luôn và phân biệt bằng trường provider. Vấn đề là giờ phải xử lý sao cho khi đăng nhập với Devise, những thằng user do bên thứ 3 cung cấp không thể login vào được hệ thống.\n\n🌿 find_for_database_authentication(warden_conditions) §\n\n🌱 Chúng ta có thể overwrite lại method find_for_database_authentication của Devise.\n\nMethod nhận vào scope chứa authentication_keys.\nOutput trả về một record tồn tại trong DB hoặc nil.\n\n\n\ndef find_for_database_authentication(warden_conditions)\n  conditions = warden_conditions.dup\n  # trim space and downcase\n  email = conditions.delete(:email).strip.downcase\n  find_by(email: email, provider: :traditional)\nend"},"50-til/51-Code/04-Rails/Custom-direct-URL-by-Routes-in-Rails":{"title":"🌱 Custom direct URL by Routes in Rails","links":[],"tags":["til","rails"],"content":"🌿 What? §\n\n🌱 Rails cung cấp direct giúp chúng ta xác định một route redirect đến một URL bất kỳ.\n\n# config/routes.rb\nRails.application.routes.draw do\n\tdirect :get_to_my_blog do\n\t\t&quot;https://nhanh.netlify.app&quot;\n\tend\nend\n\n🌱 Trong Rails ta sẽ có route get_to_my_blog_url gọn gàng đẹp đẽ.\n🌱 Ngoài ra có thể thêm điều kiện để  get URL.\n\n# config/routes.rb\nRails.application.routes.draw do\n\tdirect :get_to_the_goog, search: nil do |options| \n\t\t&quot;https://google.com/search?q=#{options[:search]}&quot;\n\tend\nend\n \nget_to_the_goog_url(search: &quot;stackoverflow&quot;)\n\n🌱 Direct sẽ không hiển thị routes khi chúng ta gõ rails routes. Chúng ta sẽ vẫn có _path helper nhưng ko nên sử dụng vì nó cắt mất cái tên miền đấy 😂.\n🌱 Ngoài ra direct không dùng được trong namespace hoặc scope. Nếu đặt nhầm thì rails sẽ raise exception.\n\n🌿 Refer §\n\nhttps://guides.rubyonrails.org/v5.2/routing.html#direct-routes\n"},"50-til/51-Code/04-Rails/Custom-order-in-SQL-with-RoR":{"title":"🌱 Custom order in SQL with RoR","links":[],"tags":["til","rails"],"content":"\n🌱 in_order_of cho phép order theo thứ tự chỉ định trong SQL.\n\nUser.in_order_of(:id, [1, 5, 3])\n# SELECT &quot;users&quot;.* FROM &quot;users&quot;\n#   ORDER BY FIELD(&quot;users&quot;.&quot;id&quot;, 1, 5, 3)\n#   WHERE &quot;users&quot;.&quot;id&quot; IN (1, 5, 3)\n\n\n🌱 source code\n\n\n📑 FYI: Cách này trong SQL sẽ sort mà không sử dụng index.\n\n\n"},"50-til/51-Code/04-Rails/Delegate-in-Rails":{"title":"🌱 Delegate in Rails","links":[],"tags":["til","rails"],"content":"🌿 Issues §\n\nKhi code RoR, mình thường xuyên sử dụng delegate trong các dự án. Nhưng nay tự nhiên có anh hỏi mình mấy câu như delegate là cái gì? tại sao phải dùng? nên dùng thế nào cho hợp lý? thì mình lại có sự ngập ngừng nhẹ 😅. Tiện đây mình lược lại một lần sau đi khè cho trôi chảy 😆 Let’s gooo!!\n\n🌿 What? §\n\nTheo APIdock:\n\n\nProvides a delegate class method to easily expose contained objects’ public methods as your own.\n\n\nDelegate hỗ trợ một object truy xuất dễ dàng các public methods của một object khác như chính các methods của nó.\n\n🌿 Why? §\n\nThe Law of Demeter Principle – LoD, còn gọi khác là nguyên tắc Demeter hay nguyên tắc “càng biết ít càng tốt” hay nguyên tắc “Một dấu chấm”. Nó là một nguyên tắc thiết kế để phát triển phần mềm, đặc biệt là các chương trình hướng đối tượng\n\n\nDelegate giúp code của cta tuân thủ theo nguyên tắc trên.\n\n🌿 How? §\n\nCó 3 options:\n\n\n:to - chỉ định object cần truy xuất public methods(có thể nhận nhiều giá trị).\n\nclass A &lt; ActiveRecord::Base\n\thas_many :Bs\nend\n \nclass B &lt; ActiveRecord::Base\n\tbelongs_to :A\n \n\tdelegate :name, :description, to: :A\nend\n \npry(main)&gt; B.first.name\n=&gt; &quot;A&quot;\npry(main)&gt; B.first.description\n=&gt; &quot;Description of A&quot;\n\n:prefix - chỉ định tiền tố.\n\nclass A &lt; ActiveRecord::Base\n\thas_many :Bs\nend\n \nclass B &lt; ActiveRecord::Base\n\tbelongs_to :A\n \n\tdelegate :name, :description, to: :A, prefix: &#039;A&#039;\nend\n \npry(main)&gt; B.first.A_name\n=&gt; &quot;A&quot;\npry(main)&gt; B.first.A_description\n=&gt; &quot;Description of A&quot;\n\n:allow_nil - nếu flag=true, không raise DelegationError\n\nclass A &lt; ActiveRecord::Base\n\thas_many :Bs\nend\n \nclass B &lt; ActiveRecord::Base\n\tbelongs_to :A\n \n\tdelegate :name, :description, to: :A, prefix: &#039;A&#039;, allow_nil: true\nend\n \n# allow_nil: false - default\npry(main)&gt; B.first.A_name\n=&gt; Module::DelegationError: B#A_name ...\n \n# allow_nil: true\npry(main)&gt; B.first.A_name\n=&gt; &quot;A&quot;\n🌿 Refer §\n\nhttps://apidock.com/rails/Module/delegate\n"},"50-til/51-Code/04-Rails/Encrypt-attribute-in-Rails-7":{"title":"🌱 Encrypt attribute in Rails 7","links":["50-til/51-Code/04-Rails/Credentials-file-in-Rails"],"tags":["til","rails"],"content":"\n\n                  \n                  Question \n                  \n                \nRails 7 vừa ra mắt Active Record Encryption, cho phép encrypt data ở trên tầng Application. Nhưng nó đem lại tác dụng gì khi chúng ta đã encrypt data ở tầng Database rồi nhỉ 🤔.\n\n🌿 Why? §\n\n\n🌱 Khi có hacker chiếm được quyền hệ thống, snapshot database hoặc application logs sẽ chỉ hiển thị dữ liệu đã được mã hóa.\n\n\n🌱 Ngăn ngừa lập trình viên sơ xuất để lộ dữ liệu nhạy cảm thông qua application logs.\n\n\n🌱 Ngăn truy xuất dữ liệu trong Rails console nếu không có bộ keys để giải mã.\n\n\n🌿 How? §\nSetup §\n\nTạo keys:\n\n$ rails db:encryption:init\n\nThêm keys vào credentials file.\n\nDeclare attribute §\n\nĐịnh nghĩ trong modal trường encrypts.\n\nclass User &lt; ApplicationRecord\n  encrypts :email\nend\n\nKhi tạo user, giá trị của email đã được mã hóa.\n\n\n\n\n                  \n                  Info \n                  \n                \nKhông thể find_by theo thuộc tính được mã hóa.\nNếu vẫn muốn truy vấn theo thuộc tính, hãy thêm option\ndeterministic: true\n\nclass User &lt; ApplicationRecord\n  encrypts :email, deterministic: true\nend\n🌿 Refer §\n\n🌱 https://guides.rubyonrails.org/active_record_encryption.html\n"},"50-til/51-Code/04-Rails/How-to-safely-remove-a-column-in-Rails?":{"title":"🌱 How to safely remove a column in Rails? ","links":[],"tags":["til","rails"],"content":"🌿 What? §\n\n🌱 Rails cung cấp method ignored_columns để xóa tạm thời một cột trong DB, sau khi sửa logic xong xuôi chúng ta mới thực hiện migrate, tránh việc migrate đi migrate lại, deploy nhiều lần(nếu cột đã có trên môi trường STG/PROD).\n\n🌿 How? §\n\n🌱 Step 1️⃣: Set ignore cột cần xóa trong model.\n\nclass User &lt; ActiveRecord::Base\n  self.ignored_columns = [:username]\nend\n\n🌱 Step 2️⃣: Kiểm tra xem cột username đã được xóa tạm thời chưa.\n\nUser.first.username\n \n=&gt; raises exception NoMethodError\n\n\n🌱 Step 3️⃣: Thay đổi logic code liên quan đến trường username.\n\n\n🌱 Step 4️⃣: Deploy lên các môi trường, test/fix những “lỗi lầm” nếu có.\n\n\n🌱 Step 5️⃣: Thêm migrate xóa cột username .\n\n\n🌿 Refer §\n🌵 https://newsletter.shortruby.com/p/how-to-safely-remove-a-column-in"},"50-til/51-Code/04-Rails/Kill-rails-server-quickly":{"title":"🌱 Kill rails server quickly","links":[],"tags":["til","rails"],"content":"🌿 Vấn đề §\n\n🌱 Khi làm việc với rails, chắc hẳn đã có lần chạy server bạn đã gặp lỗi này.\n\n\n\n🌱 Sau khi chạy rails s, file tmp/pids/server.pid được tự động sinh ra, lưu Process ID(PID) của server đang chạy. Nguyên nhân xảy ra lỗi trên có thể là do chẳng may crash server(mất điên, máy lag) hay bất kì tình huống nào khác mà rails chưa kịp kill server cho chúng ta.\n\n🌿 Giải pháp §\n\n🌱 Để giải quyết, tôi hay xóa xừ cái file server.pid.\n\nrm -rf tmp/pids/server.pid\n\n🌱 Sau đó thêm alias trong .bashrc để đỡ phải gõ nhiều 😄\n\n# /.bashrc\n \nalias kars=&quot;rm -rf tmp/pids/server.pid&quot;"},"50-til/51-Code/04-Rails/Quick-delete-a-record-in-rails":{"title":"🌱 Quick delete a recond in rails","links":[],"tags":["til","rails"],"content":"🌿 What? §\n\nTrước đây khi muốn xóa một record, mình thường phải find trước xong mới xóa.\n\nuser = User.find(1)\n \nuser.destroy # xóa dependent và check callback\nuser.delete # xóa luôn, chả check chiếc gì hớt\n\nNhưng từ Rails 6, nếu chúng ta chỉ muốn xóa record, có thể viết gọn hơn như sau:\n\nUser.destroy_by(id: 1) # xóa dependent và check callback\nUser.delete_by(id: 1) # xóa luôn, chả check chiếc gì hớt\n\nCả hai không có khác nhau gì về hiệu suất. Đây chỉ là một phiên bản rút gọn cách viết thôi.\n\n🌿 Refer §\n\nMọi người có thể xem thêm code trong Pull này ạ.\n"},"50-til/51-Code/04-Rails/Quick-open-source-of-gem":{"title":"🌱 Quick open source of gem","links":[],"tags":["til","rails"],"content":"\n🌱 Nếu bạn muốn debug hoặc sửa gem, có thể truy cập đến thư mục gem một cách nhanh chóng bằng command:\n\nbundle open GEM_NAME\n\n🌱 Trình soạn thảo văn bản sẽ được mở theo $EDITOR hoặc $BUNDLER_EDITOR\n"},"50-til/51-Code/04-Rails/Run-Rspec-save-your-time":{"title":"🌱 Run Rspec save your time","links":[],"tags":["til","rails"],"content":"🌿 What? §\n\n🌱 If you want to run rspec for a specific example, context or describe without having to care about path file, line number, you can try it:\n\n# spec/rails_helper.rb\n \nRSpec.configure do |config|\n  config.filter_run_when_matching focus: true\nend\n\n🌱 Then you add f to example, context or describe, Rspec will only focus it.\n\n#example\nfit &#039;should tell height&#039; do\n  expect(@person.height).to eq(160)\nend\n \n# as well\n \nit &#039;should tell height&#039;, focus: true do\n  expect(@person.height).to eq(160)\nend\n\n🌱 You can add focus for multi examples\n\n🌿 Refer §\nhttps://manny.codes/7-ways-to-selectively-run-rspec-tests/"},"50-til/51-Code/04-Rails/Save-serialized-object-to-the-database":{"title":"🌱  Save serialized object to the database","links":[],"tags":["til","rails"],"content":"🌿 What? §\n\nNhư mọi người đã biết, chỉ trong Postgresql chúng ta mới có thể lưu Array vào db còn MySQL thì chịu chết. Trong Rails nếu muốn làm việc trên, tôi thường viết custom attribute trong model để xử lý dữ liệu.\n\n# models/user.rb\n \nclass User\n  def codes\n    codes.split(&#039;,&#039;) #phone_numbers in db = &quot;123,345,567&quot; \n  end \nend\n🌿 Serialization of ActiveRecord §\n\nRails cung cấp một  Instance Public methods là serialize để giúp chúng ta thực hiện việc lưu serialized object(như Array, Hash, YAML, JSON) và tự động convert về đúng kiểu dữ liệu khi truy xuất.\nParams của method:\n\nattr_name: Tên attribute cần lưu serialized object\nclass_name_or_coder: Optional, chỉ định kiểu dữ liệu\n\nMặc định là YAML, ngoài ra có thể chọn Array, Hash, và JSON\ncustom coder: Có thể tự define kiểu dữ liệu (xem them ở doc__)\n\n\n\n\n\n\n# models/user.rb\n \nclass User\n  serialize:codes\nend\n \n3.1.2 :001 &gt; Comment.create! user_id: 1, content: [1,2,3]\n#&lt;Comment:0x00007fdf8dd6dac0                                   \n id: 1,                                                        \n content: [1, 2, 3],\n ...\n🌿 Refer §\n\nSerialize Document\n"},"50-til/51-Code/04-Rails/Show-entire-length-of-output-in-Rspec":{"title":"🌱 Show entire length of output in Rspec","links":[],"tags":["til","rspec"],"content":"🌿 Issues §\n\nKhi chạy test case compare 2 objects, trong trường hợp không match + object dài, output lỗi sẽ hiển thị rút gọn như dưới đây(mặc định sẽ hiển thị 200 kí tự cho từng object).\n\n\n🌿 Solution §\n\nSet RSpec::Support::ObjectFormatter.default_instance.max_formatted_output_length = nil  để show đầy đủ thông tin của 2 objects.\nHoặc\n\nRSpec.configure do |rspec|\n  rspec.expect_with :rspec do |config|\n    config.max_formatted_output_length = nil\n  end\nend\n\n🌿 Refer §\n\nCode Rspec xử lý độ dài output\n"},"50-til/51-Code/04-Rails/Show-schema-and-relationships-of-Model":{"title":"🌱 Show schema and relationships of Model","links":[],"tags":["til","rails"],"content":"🌿 What? §\n\n🌱 Gem pry-rails cung cấp method show-models hiển thị schema và relationships của tất cả Model trong DB.\n\n&gt; pry(main)&gt; show-models\n&gt; WhitelistedJwt\n\t  id: integer\n\t  jti: string\n\t  aud: string\n\t  exp: datetime\n\t  refresh_token: string\n\t  account_id: integer\n\t  device_id: integer\n\t  created_at: datetime\n\t  updated_at: datetime\n\t  refresh_token_exp: datetime\n\t  active_flag: boolean\n\t  belongs_to :account\n\t  belongs_to :device\n&gt; Schedule\n\t  id: integer\n\t  jti: string\n\t  aud: string\n\t  exp: datetime\n\t  refresh_token: string\n...\n\n🌱 Nếu DB nhiều model, chúng ta có thể chỉ định riêng model cần xem.\n\npry(main)&gt; show-model Project\n\n🌱 Dùng --grep để tìm theo partial. Trả về Model chưa partial truyền vào.\n\npry(main)&gt; show-models --grep aud\n🌿 Refer §\nMình quên mất tiêu 😅"},"50-til/51-Code/04-Rails/Sidekiq-Beta-7.0-available":{"title":"🥋 Sidekiq Beta 7.0 available","links":[],"tags":["til","rails"],"content":"Hôm 2022-09-26 Author and Maintainer của Sidekiq Mike Perham đã cho ra mắt bản beta version 7.0 của Sidekiq. Đây được giới thiệu là một đợt big update với một vài tính năng siêu to và mới =)) một vài tính năng bị loại bỏ, một số API được cấu trúc lại và requirements được update.\n🌿 Version Support §\n\nRequired Redis 6.2+\nRequired Ruby 2.7+\nSupport for Rails 6.0+\n\n🌿 Upgrade §\nNếu bạn muốn upgrade lên ver 7.0 để trải nghiệm và có cơ hội trở thành contributer cho sidekiq thì đừng ngần ngại mà hãy thêm dòng này vào Gemfile của mình nhé =))\ngem &#039;sidekiq&#039;, &#039;&lt; 8&#039;\n🌿 What’s new? §\nJob Metrics §\nVersion 7.0 sẽ add một tab metrics trên Web UI với high-resolution data cho thời gian excute job cũng như là khả năng đánh dấu thời điểm deploy.\nMọi người có thể xem chi tiết tính năng này ở Metrics\nEmbedding §\n\nTrước đây mọi người chỉ có thể khởi động Sidekiq bằng câu lệnh\nbundle exec sidekiq\nTính năng này theo tác giả có nói là một cách thử nghiệm để chạy Sidekiq thông qua việc gọi trực tiếp bằng những dòng code Ruby. Nó được gán nhãn thử nghiệm là vì có khả năng xung đột với plugins bên thứ 3 hay với chính hệ thống của bạn.\nMọi người có thể xem chi tiết tính năng này ở Embedding\nCapsules §\n\n…\nredis-client §\n\n\nredis-client là một Rubygem mới sử dụng giao thức RESP3 có trong Redis 6.0+.\nSidekiq 6.5 đã giới thiệu về việc hỗ trợ cho gem redis-client  trong khi vẫn sử dụng gem redis là mặc định. Đến sidekiq 7.0 đã hoàn thiện việc chuyển đổi này và đã không còn sử dụng redis là mặc định nữa.\nApp của bạn vẫn có thể tiếp tục sử dụng redis.\nHiện tại nếu bạn sử dụng Sidekiq.redis để truy cập vào kết nối Redis, API đó sẽ expose một connection dựa trên redis-client.\n\nredis-namespace §\n\n7.0 đã bỏ phần support cho redis-namespace.\n"},"50-til/51-Code/04-Rails/Syntax-mới-cho-QueryMethods-select":{"title":"🌱 New syntax of ActiveRecord::QueryMethods#select","links":[],"tags":["til","rails"],"content":"🌿 Before:\nUser.joins(:posts)\n    .select(&quot;user.id as user_id, users.name as user_name,\n             posts.id as post_id, posts.title as post_title&quot;)\n🌿 After:\nUser.joins(:posts)\n    .select(\n      users: {id: :user_id, name: :user_name},\n      posts: {id: :post_id, title: :post_title}\n    )\n🌿 SQL Query:\nSELECT &quot;users&quot;.&quot;id&quot; AS user_id, &quot;users&quot;.&quot;name&quot; AS user_name, &quot;posts&quot;.&quot;id&quot; AS post_id, &quot;posts&quot;.&quot;title&quot; AS post_title\nFROM &quot;users&quot;\nINNER JOIN &quot;posts&quot; ON &quot;post&quot;.&quot;user_id&quot; = &quot;users&quot;.&quot;id&quot;\nLIMIT $1  [[&quot;LIMIT&quot;, 11]]\n\n🌱 Refer: https://blog.saeloun.com/2022/09/07/activerecord-select-adds-support-for-hash-values-in-rails-7/"},"50-til/51-Code/04-Rails/Truncate-by-amount-of-word-in-Rails":{"title":"🌱 Truncate by amount of word in Rails","links":[],"tags":["til","rails"],"content":"\n🌱 Rails cung cấp method truncate một chuỗi dựa theo số lượng từ. Ví dụ như chỉ muốn hiển thị 3 chữ đầu:\n\nmy_string = &quot;một hai ba bốn năm!&quot;\nmy_string.truncate_words(3)\n \n#=&gt; &quot;một hai ba...&quot;\n\n🌱 Dấu 3 chấm tự động được thêm vào sau chuỗi đã được truncate. Chúng ta có thể custom bằng arg omission .\n\nmy_string.truncate_words(3, omission: &quot; ... more&quot;)\n \n#=&gt; &quot;một hai ba ... more&quot;\n\n🌱 Đương nhiên là cũng có truncate theo ký tự nữa, mọi người có thể đọc thêm ở đây.\n"},"50-til/51-Code/04-Rails/Validate-number-of-association":{"title":"🌱 Validate number of association","links":[],"tags":["til","rails"],"content":"🌿 What? §\n\n🌱 If you have a People model and a Vehicle model, every people has_many vehicles but you want to set maximum for number of vehicles which a people can has. You can use following command below:\n\n# vehicle.rb\nclass Vehicle\n  belongs_to :people\nend\n \n# people.rb\nclass People\n  has_many :vehicles\n \n  validates :vehicles, length: { maximum: 2 }\nend\n🌿 Refer §\nhttps://til.hashrocket.com/posts/egegrgsdnj-limiting-object-counts-in-rails-associations-"},"50-til/51-Code/04-Rails/Validate-numeric-in-Rails":{"title":"🌱 Validate numeric in rails","links":[],"tags":["til","rails"],"content":"🌿 Issues §\n\nOption only_integer được dùng để validate chỉ nhận giá trị integer. Nhưng mình muốn nhận được cả giá trị float và integer cơ 😅\n\n🌿 Solutuion §\n\nTheo doc, option only_integer validate format theo regex /\\A[+-]?\\d+\\z.\nNếu muốn pass các giá trị float, có thể thay thế format regex /\\A-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)\\z/\n\nvalidates :number, format: { with: /\\A-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)\\z/ }\n\nHoặc Rails 7 đã thêm option only_numeric để giải quyết vấn đề trên.\n\nvalidates :number, numericality: { only_numeric: true }\n🌿 Refer §\n\nPull add opion to numericality validator\n"},"50-til/51-Code/04-Rails/Why-is-must-run-bundle-exec-before-any-command?":{"title":"🌱 why is must run bundle exec before any command?","links":[],"tags":["til","rails"],"content":"🌿 Issue §\n\n🌱 Trước làm dự án, lúc đầu mình chạy mỗi  rspec hay rubocop thì vẫn ô’s kê mà sau lại phải thêm bundle exec ở đầu thì mới chạy được 🥵\n\n🌿 Why? §\n\n🌱 Nếu chạy chay không dùng bundle exec hệ thống sẽ tìm trong PATH, nếu trong PATH có nhiều versions của 1 gem, nó có thể xảy ra việc sử dụng sai version.\n🌱 bundle exec  để đảm bảo rằng version gem được sử dụng đúng với version gem chỉ định trong Gemfile chứ không phải là một version khác đã được cài trong hệ thống của chúng ta.\n\n\nVí dụ như rspec trước đây mình chạy được là do máy của mình mới reset, chỉ có duy nhất 1 gem rspec được cài đặt cho dự án đang làm =&gt; chạy không bị lỗi. Vấn đề xảy ra khi mình cài thêm các versions rspec cho các projects khác =&gt; lệch version.\n\n\n🌱 Theo mục đích trên, các câu lệnh không liên quan đến version gem, mình ko cần phải thêm bundle exec nữa. Ví dụ như rails s hoặc rails db:create ,…\n\n🌿 Refer §\n\nhttps://bundler.io/v2.4/man/bundle-exec.1.html\n"},"50-til/51-Code/04-Rails/_in_-and-_out_-of-Pry":{"title":"🌱 _in_ and _out_ of Pry","links":[],"tags":["til","rails"],"content":"🌿 What? §\n\n🌱 Trong Pry, các giá trị input, output sẽ tự động được lưu trong 2 array có thể truy cập được đó là _in_ và _out_. Số lượng phần tử cache của 2 cu này được định nghĩa ở Pry.config.memory_size(mặc định là 100 phần tử). Nếu hết dung lượng, những giá trị mới sẽ được ghi đè.\n\npry(main)&gt; 1\n=&gt; 1\npry(main)&gt; 2\n=&gt; 2\npry(main)&gt; 3\n=&gt; 3\npry(main)&gt; _in_\n=&gt; #&lt;Pry::Ring:0x0000562f98b2ce88 @buffer=[nil, &quot;1\\n&quot;, &quot;2\\n&quot;, &quot;3\\n&quot;, &quot;_in_\\n&quot;], @count=5, @max_size=100, @mutex=#&lt;Thread::Mutex:0x0000562f98b2ce60&gt;&gt;\npry(main)&gt; _out_\n=&gt; #&lt;Pry::Ring:0x000055d4e3002b80 @buffer=[nil, 1, 2, 3, #&lt;Pry::Ring:0x000055d4e3002b80 ...&gt;], @count=5, @max_size=100, @mutex=#&lt;Thread::Mutex:0x000055d4e3002b58&gt;&gt;\npry(main)&gt; _out_.to_a[1] + _out_.to_a[2]\n=&gt; 3\n🌿 Refer §\n\n🌱 Mọi người có thể đọc thêm ở  document\n"},"50-til/51-Code/04-Rails/frozen_string_literal-in-rails":{"title":"🌱 frozen_string_literal in rails","links":[],"tags":["til","rails"],"content":"🌿 What? §\n\n\n🌱 Rubocop có rule check khai báo frozen_string_literal: true cho từng file, nhưng nó để làm gì?\n\n\n🌱 frozen_string_literal là một magic comments có từ Ruby 2.3, nó giúp tối ưu bộ nhớ cũng như cải thiện performance bằng việc cung cấp vùng nhớ dựa theo nội dung của string(nội dung giống nhau sẽ chung 1 vùng nhớ), tương tự như :symbol. Ngoài ra, sử dụng comment trên cũng sẽ ngăn chặn việc thay đổi string.\n\n\n# test.rb\n# frozen_string_literal: true \np &#039;name&#039;.object_id\np &#039;name&#039;.object_id\n \nstr  =  &#039;hello&#039;\nstr  &lt;&lt;  &#039; world&#039;\n \np str\n&gt; ruby test.rb\n60\n60\nTraceback (most recent call last):\ntest.rb:6:in `&lt;main&gt;&#039;: can&#039;t modify frozen String: &quot;hello&quot; (FrozenError)\n\n🌱 Nếu trong file frozen, chúng ta vẫn muốn một string động, có thể khai báo:\n\nstr = String.new(&#039;hello&#039;)\nstr &lt;&lt; &#039; world&#039;\n🌿 Refer §\n\n🌱 Tham khảo\n"},"50-til/51-Code/05-Ruby/-percentw-and--percentW-in-Ruby":{"title":"🌱 %w and %W in Ruby","links":[],"tags":["til","ruby"],"content":"🌿 What? §\n\n🌱 %w return an splited array from a input string by space.\n\nirb&gt; %w(I am from Vietnam)\n#=&gt; [&quot;i&quot;, &quot;am&quot;, &quot;from&quot;, &quot;Vietnam&quot;]\n\n🌱 %W is similar %w but allows receive interpolation value.\n\nirb&gt; country = &quot;Vietnam&quot; \nirb&gt; %w(I am from #{country})\n#=&gt; [&quot;i&quot;, &quot;am&quot;, &quot;from&quot;, &quot;\\#{country}&quot;]\n \nirb&gt; %W(I am from #{country})\n#=&gt; [&quot;i&quot;, &quot;am&quot;, &quot;from&quot;, &quot;Vietnam&quot;]\n\n🌱 Similar with %q, %Q, %i, %I, …\n\n🌿 Refer §\n\nhttps://til.hashrocket.com/posts/aqkz0yqdky-the-difference-between-w-and-w-in-ruby\n"},"50-til/51-Code/05-Ruby/Awesome-Ruby-Repository":{"title":"🌱 Awesome-Ruby Repository","links":[],"tags":["til","ruby"],"content":"🌿 What? §\n\n🌱 Được khởi xướng bởi Marc Anguera - Lead engineer &amp; CTO tại Crisalix(cung cấp dịch vụ xuất hình ảnh 3D, 4D cho những người muốn nhìn thấy trước những thay đổi như phẫu thuật thẩm mỹ chẳng hạn, em cảnh báo là không nên xem web này ở trên cty nha 😂), repo hiện tại đã nhận được 12.4k sao và nhiều phản hồi tích cực từ cộng đồng Ruby Dev.\n🌱 Awesome-ruby là repo phân loại tổng hợp những thư viện cho Ruby, những tools, frameworks, best practice và phần mềm có chất lượng awesome có thể sẽ cần thiết để chúng ta xây dựng những modern Apps hay Web Apps .\n\n🌿 Điều kiện tiêu chuẩn: §\n\n🌱 Để được thêm vào repo, cần đạt những chất lượng tiêu chuẩn sau:\n\nThường được sử dụng(tối thiểu là 20k lượt tải) và hữu ích với cộng đồng.\nChủ động bảo trì, cập nhật thường xuyên(chỉ cần là vẫn giải quyết các issues cho version hiện tại cũng là đạt yêu cầu rồi).\nỔn định.\nĐược tài liệu hóa.\nCó tests.\n\n\n\n\n\n                  \n                  Note \n                  \n                \nVới những điều kiện trên thì mọi người có thể yên tâm mấy thứ được suggests trên repo toàn là hàng chất lượng thôi nhé :v\n"},"50-til/51-Code/05-Ruby/Changes-in-Class-Variable-behavior-in-Ruby3":{"title":"🌱 Changes in Class Variable behavior in Ruby3","links":[],"tags":["til","ruby"],"content":"🌿 What? §\n\n\n🌱 Ở Ruby 2.7, class variable được sử dụng chung giữa class cha và các class con. Do có thể overwrite ở bất cứ đâu nên sẽ khó để tracking hoặc debug.\n\n\n🌱 Đến Ruby 3.0, class variable chỉ có thể overwrite ở các Class con kế thừa hoặc ở chính Class đó.\n\n\nclass Dog\n  @@color = [&#039;yellow&#039;]\n \n  # bad practice\n  def self.overwrite_legs!\n    @@legs = 4\n  end\n  \n  def self.overwrite_legs!\n    @@color\n  end\nend\n \nclass Husky &lt; Dog\n  @@legs = 2\n \n  def self.show_legs\n    @@legs\n  end\n \n  # good practice\n  def self.add_color\n    @@color.push &#039;green&#039;\n  end\nend\n \n#=&gt; Dog.overwrite_legs!\n#=&gt; 4\n#=&gt; Husky.show_legs\n#=&gt; in `show_legs&#039;: class variable @@legs of Husky is overtaken by Dog (RuntimeError)\n \n--------------------------\n \n#=&gt; Husky.add_color\n#=&gt; [&quot;yellow&quot;, &quot;green&quot;]\n#=&gt; Dog.show_color\n#=&gt; [&quot;yellow&quot;, &quot;green&quot;]\n🌿 Refer §\n\nDocument: https://rubyreferences.github.io/rubychanges/3.0.html#changes-in-class-variable-behavior\n"},"50-til/51-Code/05-Ruby/Check-prefix-of-string":{"title":"🌱 Check prefix of string","links":[],"tags":["til","ruby"],"content":"🌿 What? §\n\n🌱 Trong Ruby, class String cung cấp method start_with? nhận vào những tiền tố mà bạn muốn xác định, trả về true nếu chuỗi kiểm tra bắt đầu bằng một trong những tiền tố đó.\n\nstring = &quot;hello world&quot;\n \nstring.start_with?(&quot;abc&quot;, &quot;mentor&quot;) # =&gt; false\nstring.start_with?(&quot;zys&quot;, &quot;hell&quot;)   # =&gt; true\n\n🌱 Tham số:\n\nPhân biệt chữ Hoa và chữ thường\nNhận regex\n\n\n\nstring = &quot;hello world&quot;\n \nstring.start_with?(&quot;zys&quot;, &quot;Hell&quot;) # =&gt; false\nstring.start_with?(/[\\s\\S]*/)     # =&gt; true\n🌿 Refer §\nhttps://til.hashrocket.com/posts/rettwv4dgl-check-if-string-starts-with-prefixes"},"50-til/51-Code/05-Ruby/Combine-arrays-in-Ruby":{"title":"🌱 Combine arrays in Ruby","links":[],"tags":["til","ruby"],"content":"🌿 What? §\n\n🌱 Trong quá trình làm dự án, mình cần build dữ liệu cho f.select từ 2 mảng lấy được từ server, ruby cung cấp method .zip để kết hợp mảng.\n\nids = [1,2,3,4]\naddress = [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;]\n \nids.zip(address)\n=&gt; [[1,&#039;a&#039;],[2,&#039;b&#039;],[3,&#039;c&#039;], [4,&#039;d&#039;]]\n\n🌱 Trường hợp cần kết hợp đầy đủ tất cả các cases từ các phần tử của mảng, sử dụng Enumerator.product.\nVí dụ như web bán quần áo, cta có mảng Size và mảng Brand, vì mới bán nên các Brand vẫn còn đủ các size.\n\nsizes = [&#039;small&#039;, &#039;medium&#039;, &#039;large&#039;]\nbrands = [&#039;adidas&#039;, &#039;nike&#039;, &#039;puma&#039;, &#039;lv&#039;]\n \nEnumerator.product(sizes, brands)\n=&gt; [\n  [&#039;small&#039;, &#039;adidas&#039;],\n  [&#039;small&#039;, &#039;nike&#039;],\n  [&#039;small&#039;, &#039;puma&#039;],\n...\n  [&#039;large&#039;, &#039;puma&#039;],\n  [&#039;large&#039;, &#039;lv&#039;]\n]"},"50-til/51-Code/05-Ruby/Comment-multi-lines-in-ruby":{"title":"🌱 Comment multi lines in ruby","links":[],"tags":["til","ruby"],"content":"\n🌱 Comment nhiều dòng(thay vì dùng # ở mỗi dòng) trong Ruby như sau:\n\n=begin\n  this is first comment!\n  this is sencond comment!\n=end\n \ndef func; end"},"50-til/51-Code/05-Ruby/Endless-method-in-Ruby3":{"title":"🌱 Endless method in Ruby3","links":[],"tags":["til","ruby"],"content":"🌿 What? §\n\n🌱 Từ vesion 3.0, Ruby cho phép định nghĩa những method đơn giản trên cùng một dòng giống endless condition.\n\ndef isMan?(sex) = sex == &#039;man&#039;\n \n# isMan(&#039;man&#039;) =&gt; true\n# isMan(&#039;female&#039;) =&gt; false\n \n------------------------------------------------\n \n# Method Setter không áp dụng được syntax này.\nclass A\n  def attr=(val) = @attr = val\nend\n# =&gt; SyntaxError &quot;setter method cannot be defined in an endless method definition&quot;\n \n------------------------------------------------\n \n# Có thể  viết được nhiều dòng\ndef read(name) = File.read(name)\n                     .split(&quot;\\n&quot;)\n                     .map(&amp;:strip)\n                     .reject(&amp;:empty?)\n                     .uniq\n                     .sort\n\n🌱 Ruby 3.0, endless method cần phải viết đầy đủ dấu ngoặc (, ), {, }. Vấn đề này đã được cải thiện ở version 3.1\n\ndef log = puts &quot;logging&quot;\n# 3.0: syntax error, unexpected string literal, expecting `do&#039; or &#039;{&#039; or &#039;(&#039;\n# 3.1: successfully defined\n🌿 Refer §\n\nDoc 3.0: https://rubyreferences.github.io/rubychanges/3.0.html#endless-method-definition\nDoc 3.1: https://rubyreferences.github.io/rubychanges/3.1.html#inside-endless-method-definitions-method-calls-without-parenthesis-are-allowed\n"},"50-til/51-Code/05-Ruby/Floating-point-error":{"title":"🌱 Floating-point error","links":[],"tags":["til","ruby"],"content":"🌿 What? §\n\nTrong các ngôn ngữ lập trình, khi tính toán với float hoặc double thì sẽ gặp sai số. VD:\n\n1.9 + 1.2\n=&gt; 3.0999999999999996\n\nVới những ngành như tài chính, tiền bạc mà tính lệch một số sau dấu phẩy thôi là tới công chiện liền 🥵\n\n🌿 Solution §\n\nTrong DB chúng ta hay dùng decimal với 2 thông số precision(số lượng chữ số tính cả sau dấu ,) và scale(số lượng chữ số sau dấu ,) để tính toán.\nCòn khi chúng ta thao tác ở bên ngoài, ví dụ như trong code hoặc console thì có thể sử dụng BigDecimal.\n\nBigDecimal(&quot;1.2&quot;) + BigDecimal(&quot;1.9&quot;)\n=&gt; 0.31e1\n \n_.to_f\n=&gt; 3.1\n🌿 Refer §\n\nhttps://spin.atomicobject.com/2014/08/14/currency-rounding-errors/\nhttps://ttuan.xyz/til/computer/floating_point_math/\nhttps://www.youtube.com/watch?v=PZRI1IfStY0&amp;ab_channel=Computerphile\n"},"50-til/51-Code/05-Ruby/Get-last-occurrence-of-value-in-an-array":{"title":"🌱 Get last occurrence of value in an array","links":[],"tags":["til","ruby"],"content":"\n🌱 Trong Ruby, hàm rindex nhận vào một giá trị và trả về index cho lần cuối cùng giá trị đó xuất hiện trong array.\n\narr= [&#039;b&#039;, &#039;a&#039;, &#039;a&#039;, &#039;a&#039;]\narr.rindex(&#039;a&#039;)\n#=&gt; 3\n \narr.rindex(&#039;b&#039;)\n#=&gt; 0"},"50-til/51-Code/05-Ruby/Operator-+=-and-<<-with-string":{"title":"🌱 Operator += and << with string","links":[],"tags":["til","ruby"],"content":"\n🌱 Trong Ruby, hãy nối chuỗi bằng &lt;&lt; thay vì +=!\n\n+= sẽ tạo ra một object mới sau khi nối chuỗi.\n\n\n\nname = &quot;Hoang&quot;\n \nname.object_id\n=&gt; 71860\n \nname += &quot; Anh&quot;\n \nname.object_id\n=&gt; 71880\n\n🌱 &lt;&lt; sẽ nối chuỗi trực tiếp trên object cũ, không tạo ra object mới. Cải thiện performance khi thao tác với những chuỗi lớn.\n\nname = &quot;Hoang&quot;\n \nname.object_id\n=&gt; 71900\n \nname &lt;&lt; &quot; Anh&quot;\n \nname.object_id\n=&gt; 71900"},"50-til/51-Code/05-Ruby/Pattern-matching-in-Ruby":{"title":"🌱 Pattern matching in Ruby","links":[],"tags":["til","ruby"],"content":"🌿 What? §\n\n🌱 Pattern matching là feature được thử nghiệm từ Ruby2.7 và được áp dụng chính thức từ version 3.0, cho phép dễ dàng match giá trị với pattern.\n\nif &quot;123&quot; in /\\A\\d+\\z/\n  p &quot;It&#039;s a string of only digits&quot;\nend\n \n# =&gt; It&#039;s a string of only digits\nCác pattern được hỗ trợ: §\n\n🌱 Array pattern: [&lt;subpattern&gt;, &lt;subpattern&gt;, &lt;subpattern&gt;, ...].\n\n\nKiểm tra mảng chỉ chứa pattern 2 integers liền kề không:\n\ncase [1, 2, 3]\nin [Integer, Integer]\n  &quot;matched&quot;\nelse\n  &quot;not matched&quot;\nend\n#=&gt; &quot;not matched&quot;\n\nHoặc chỉ cần phần tử đầu tiên là integer:\n\ncase [1, 2, 3]\nin [Integer, *]\n  &quot;matched&quot;\nelse\n  &quot;not matched&quot;\nend\n#=&gt; &quot;matched&quot;\n\n🌱 Find pattern: [*variable, &lt;subpattern&gt;, &lt;subpattern&gt;, &lt;subpattern&gt;, ..., *variable]. (Find pattern is experimental)\n\n\nKiểm tra mảng có chứa 2 chuỗi liền kề không:\n\ncase [&quot;a&quot;, 1, &quot;b&quot;, &quot;c&quot;, 2]\nin [*, String, String, *]\n  &quot;matched&quot;\nelse\n  &quot;not matched&quot;\nend\n#=&gt; matched\n\n🌱 Hash pattern: {key: &lt;subpattern&gt;, key: &lt;subpattern&gt;, ...}.\n\ncase {a: 1, b: 2, c: 3}\nin {a: Integer}\n  &quot;matched&quot;\nelse\n  &quot;not matched&quot;\nend\n#=&gt; &quot;matched&quot;\n\n🌱 One-line pattern matching with =&gt;.\n\n\nGán giá trị cho một biến nếu phần tử match với pattern:\n\ncase [1, 2]\nin Integer =&gt; a, Integer\n  &quot;matched: #{a}&quot;\nelse\n  &quot;not matched&quot;\nend\n#=&gt; &quot;matched: 1&quot;\n \ncase {a: 1, b: 2, c: 3}\nin a: Integer =&gt; m\n  &quot;matched: #{m}&quot;\nelse\n  &quot;not matched&quot;\nend\n#=&gt; &quot;matched: 1&quot;\n🌿 Refer §\n\nDocument: https://docs.ruby-lang.org/en/3.0/syntax/pattern_matching_rdoc.html\n"},"50-til/51-Code/05-Ruby/Ruby-Module---Include,-Prepend-and-Extend":{"title":"🌱 Ruby Module: Include, Prepend and Extend","links":[],"tags":["til","ruby"],"content":"🌿 Ancestors chain §\n\nKhi khởi tạo một Class, mỗi Class sẽ có một ancestors chain - là danh sách các classes và modules mà nó được kế thừa hoặc imported.\nTrong Ruby có 3 cách để import Module cho 1 Class.\n\n🌱 Include §\n\nMethod trong module sẽ trở thành instance method của Class.\nThứ tự trong ancestors chain: Class &gt; Module/Class imported &gt; Superclass.\n\nmodule A\n\tdef say\n\t\tp &#039;hello&#039;\n\tend\t\nend\n \nclass B\n\tinclude A\nend\n&gt; B.new.say\n=&gt; &quot;hello&quot;\n&gt;\n&gt; B.ancestors\n=&gt; [B, A, ..., Object, ..., BasicObject]\n🌱 Prepend §\n\nGiống include, khác thứ tự được thêm vào trong list ancestors.\nThứ tự trong ancestors chain: Module/Class imported &gt; Class &gt; Superclass.\n\nmodule A\n\tdef say\n\t\tp &#039;hello&#039;\n\tend\t\nend\n \nclass B\n\tprepend A\nend\n&gt; B.new.say\n=&gt; &quot;hello&quot;\n&gt;\n&gt; B.ancestors\n=&gt; [A, B, ..., Object, ..., BasicObject]\n🌱 Extend §\n\nMethod trong module trở thành class method của Class.\nImport methods của module vào ancestors chain của singleton class của class extend.\n\nmodule C\n\tdef say\n\t\tp &#039;hello&#039;\n\tend\t\nend\n \nclass D\n\textend C\nend\n&gt; D.new.say\n=&gt; undefined method &#039;say&#039; ...\n&gt;\n&gt; D.say\n=&gt; &quot;hello&quot;\n&gt;\n&gt; D.ancestors\n=&gt; [D, ..., Object, ..., BasicObject]\n&gt;\n&gt; D.singleton_class.ancestors\n=&gt; [#&lt;Class:D&gt;, C, ...] \n🌿 Tham khảo §\n\nhttps://medium.com/@leo_hetsch/ruby-modules-include-vs-prepend-vs-extend-f09837a5b073\n"},"50-til/51-Code/05-Ruby/Some-Change-in-Ruby3":{"title":"🌱 Some Change in Ruby3","links":["50-til/51-Code/05-Ruby/Endless-method-in-Ruby3","50-til/51-Code/05-Ruby/Pattern-matching-in-Ruby","50-til/51-Code/05-Ruby/Changes-in-Class-Variable-behavior-in-Ruby3"],"tags":["til","ruby"],"content":"\n🌱 Do dự án đang được yêu cầu nâng ruby từ 2.7.6 -&gt; 3.0 nên mình đọc cần đọc lại những highlight changes của version 3.0, tiện mình sẽ note một vài cái hay ho ở bài này.  Lẹt Go 💪🏻\n\n🌿 Language changes §\n1. Tách biệt keyword arguments &amp; positional arguments §\n\nChưa hiểu mục đích thay đổi.\n\n2. Endless method §\n\nEndless method in Ruby3\n\n3. Pattern matching §\n\nPattern matching in Ruby\n\n4. Changes in Class Variable behavior §\n\nChanges in Class Variable behavior in Ruby3\n\n🌿 Refer §"},"50-til/51-Code/05-Ruby/Splat-in-ruby":{"title":"🌱 Splat in ruby","links":[],"tags":["til","ruby"],"content":"\n🌱 Splat array in ruby with syntax below:\n\narray = [1,2,3]\nsplat_array = [*array, 4, 5] # =&gt; [1,2,3,4,5]\n\n🌱 Splat hash in ruby with syntax below:\n\nhash = {a: 1, b: 2}\nsplat_hash = { **hash, c: 3} # =&gt; {:a=&gt;1, :b=&gt;2, :c=&gt;3}"},"50-til/51-Code/05-Ruby/Split-array-by-an-value":{"title":"🌱 Split array by an value","links":[],"tags":["til","ruby"],"content":"Trong ruby, khi muốn split một array ra 2 arrays theo value, có thể sử dụng method slice_after(method slice_before cũng tương tự, chỉ khác vị trí split)\narray = [\n  {activity: &quot;1&quot;, ticket: &quot;123&quot;},\n  {activity: &quot;2&quot;, ticket: &quot;123&quot;},\n  {activity: &quot;3&quot;, ticket: &quot;&quot;},\n  {activity: &quot;4&quot;, ticket: &quot;234&quot;},\n]\n \narray.slice_after { |i| i.activity == &quot;3&quot; }\n# Returns:\n[\n  [\n    {activity: &quot;1&quot;, ticket: &quot;123&quot;},\n    {activity: &quot;2&quot;, ticket: &quot;123&quot;},\n    {activity: &quot;3&quot;, ticket: &quot;&quot;}\n  ],\n  [\n    {activity: &quot;4&quot;, ticket: &quot;234&quot;}\n  ]\n]\n \narray.slice_before { |i| i.activity == &quot;3&quot; }\n# Returns:\n[\n  [\n    {activity: &quot;1&quot;, ticket: &quot;123&quot;},\n    {activity: &quot;2&quot;, ticket: &quot;123&quot;}\n  ],\n  [\n    {activity: &quot;3&quot;, ticket: &quot;&quot;},\n    {activity: &quot;4&quot;, ticket: &quot;234&quot;}\n  ]\n]\nhttps://til.hashrocket.com/posts/rm9tvmzf9p-using-sliceafter-to-split-arrays-by-a-value-"},"50-til/51-Code/05-Ruby/Split-array-by-condition-in-Ruby":{"title":"🌱 Split array by condition in Ruby","links":[],"tags":["til","ruby"],"content":"🌿 What? §\n\n🌱 Từ 2.5.1, Ruby cung cấp method partition, chia 1 mảng thành 2 mảng con dựa theo điều kiện truyền vào.\n\n(1..6).partition { |v| v.even? }\n#=&gt; [[2, 4, 6], [1, 3, 5]]\n \n[&#039;&#039;, &#039;1&#039;, &#039;12&#039;, &#039;123&#039;, &#039;1234&#039;].partition { |v| v.length &gt; 2 }\n#=&gt; [[&#039;123&#039;, &#039;1234&#039;], [&#039;&#039;, &#039;1&#039;, &#039;12&#039;]]\n🌿 Refer §\n\n🌱 Link doc: Enumerable#partition\n"},"50-til/51-Code/05-Ruby/each_with_object()-method-in-ruby":{"title":"🌱 each_with_object in ruby","links":["50-til/51-Code/05-Ruby/reduce()-method-in-Ruby"],"tags":["til","ruby"],"content":"🌿 What? §\n\n🌱 each_with_object là method viết gọn cho TH chúng ta cần khởi tạo biến để lưu giá trị sau từng lần lặp. Tương tự như reduce().\n\nnumbers = [1, 2, 3, 4, 5]\n \ndef specify_array(array)\n  array.each_with_object([]) { |n, arr| arr &lt;&lt; n if n &gt; 3 }\nend\n \nspecify_array(numbers)\n=&gt; [4, 5]\n🌿 Compare with reduce() §\n\n🌱 Khác nhau về thứ tự tham số.\n\nnumbers = [1, 2, 3, 4, 5]\n \n# initial object is first arg, second arg is array&#039;s element\nsum_by_reduce = numbers.reduce(0) { |sum, num| sum + num }\n \n# opposite to reduce() method\nsum_by_each_with_object = numbers.each_with_object(0) { |num, sum| sum += num }\n\n🌱 Thêm nữa là reduce sẽ trả về đối giá trị tích lũy còn each_with_object trả về object khởi tạo. Để ý syntax của 2 ví dụ trên, each_with_object phải sử dụng += còn reduce thì không.\n\n🌿 Refer §\n\nhttps://ruby-doc.org/core-3.0.1/Enumerable.html#method-i-each_with_object\n"},"50-til/51-Code/05-Ruby/instance_eval()-in-ruby":{"title":"🌱 instance_eval() in ruby","links":[],"tags":["til","ruby"],"content":"🌿 What? §\n\n🌱 Trong Ruby, class Object có public method là instance_eval(), method này cấp quyền truy cập tới các biến instance của object, nhận vào string chứa code Ruby hoặc block và excute theo context của object.\n\nclass Klass\n  def initialize\n    @secret = 99\n  end\nend\n \nirb(main):001:0&gt; k = Klass.new\nirb(main):002:0&gt; k.instance_eval { @secret }\n=&gt; 99\n# add method\nstring = &quot;String&quot;\nstring.instance_eval do\n  def new_method\n    self.reverse\n  end\nend\n \nirb(main):033:0&gt; string.new_method\n=&gt; &quot;gnirtS&quot;\n\n🌱 Tương tự với module và class sẽ có module_eval() và class_eval()\n\n🌿 Refer §\n\nhttps://apidock.com/ruby/Object/instance_eval\n"},"50-til/51-Code/05-Ruby/reduce()-method-in-Ruby":{"title":"🌱 reduce() method in Ruby","links":[],"tags":["til","ruby"],"content":"🌿 What? §\n\n🌱 reduce là method viết gọn cho TH chúng ta cần khởi tạo biến để lưu giá trị sau từng lần lặp.\n\nnumbers = [1, 2, 3, 4, 5]\n \ndef specify_array(arr)\n  array = 0\n  arr.each do |num|\n    arr &lt;&lt; num if num &gt; 3\n  end\n  array\nend\n \nspecify_array(numbers)\n=&gt; [4, 5]\n\nSử dụng reduce()\n\nnumbers = [1, 2, 3, 4, 5]\n \ndef specify_array(array)\n  array.reduce([]) { |arr, n| arr &lt;&lt; n if n &gt; 3 }\nend\n \nspecify_array(numbers)\n=&gt; [4, 5]\n🌿 Refer §\n\nhttps://apidock.com/ruby/Enumerable/reduce\n"},"50-til/51-Code/06-Servers/Bastion-Host-là-gì?":{"title":"🌱 Bastion Host là gì?","links":[],"tags":["til","server"],"content":"🌿 What? §\n\n🌱 Bastion Host(máy chủ pháo đài) đúng như tên gọi, là một server sinh ra với sứ mệnh phòng vệ trước những mối hiểm họa có thể tấn công vào mạng lưới nội bộ của chúng ta.\n🌱 Theo định nghĩa của AWS, Bastion Host là một server có mục đích cung cấp quyền truy cập vào mạng nội bộ từ mạng bên ngoài, chẳng hạn như Internet.\n🌱 Hoạt động như cầu nối, đứng giữa private instance và những truy cập từ bên ngoài. Vì vậy khi tắt Bastion, người ngoài cũng sẽ không có cách nào có thể truy cập vào private instance của chúng ta.\n🌿 Why? §\n🌱 Tăng khả năng bảo mật trong việc quản lý truy cập vào private instance.\n🌿 Architect §\n\n\nBastion Host đặt ở Public subnet, để bên ngoài truy cập vào được.\nLinux Instance đặt ở Private subnet, chỉ có thể truy cập thông qua Bastion.\n\n🌱 Về mặt lý thuyết, hành trình thật sự để từ ngoài có thể vào được Linux Instance đó là:\n\nInternet Gateway\nRoute Table\nNetwork ACL\nSecurity Group\nBastion Host\n\n🌿 Refer §\n📑 https://aws.amazon.com/blogs/security/how-to-record-ssh-sessions-established-through-a-bastion-host/"},"50-til/51-Code/06-Servers/Config-SSH":{"title":"⚙️ Config SSH","links":[],"tags":["til","ssh"],"content":"🌿 Issue §\n\n🌱Chắc hẳn là một dev BE, các bạn ít nhiều cũng từng có lần ssh lên server để check log, xem db, hay là config dự án, … Quy trình đểcó thể ssh được lên  server sẽ gồm có những bước cơ bản như sau:\n\nTạo một bộ khóa tại máy local.\nĐưa public key cho bên infra hoặc người có thể lên được server, để họ thêm key của chúng ta vào 1 file - file này sẽ chứa các keys có thể ssh.\n\n\n🌱 Sau đó mỗi lần ssh chúng ta sẽ cần phải gõ command:\n\nssh user_name@ip\n\n🌱 Vấn đề ở đây là, chúng ta khó có thể nhớ chính xác 2 thông tin trên cho mỗi lần ssh. Trước đây mình sẽ note những thông tin này vào một chỗ nào đấy bí mật, khi nào cần ssh thì bật lên và copy vào, rất là mất thời gian. Đã thế khi gen ra nhiều key ssh, mình còn phải set -i để chỉ định ssh-key nào sẽ được dùng để ssh nữa.\n\n🌿 Solution §\n\n🌱 Khi search vấn đề này, mình thấy mọi người thường sẽ không dùng cách stupid trên kia của mình mà sẽ sử dụng file  ~/.ssh/config. Và nó giải quyết hoàn toàn được 2 vấn đề mình gặp phải ở trên.\n\nKhông cần nhớ thông tin ssh: user_name, ip\nKhông cần chỉ định bằng cơm ssh-key khi ssh nữa\n\n\n🌱 Mọi người chỉ cần thêm vào file ~/.ssh/config như ở dưới:\n\nHost project-dev\n  Hostname 1.0.5.374\n  User deployer\n  IdentityFile ~/.ssh/project-dev-ecdsa\n \nHost project-prod\n  HostName 1.12.6.52\n  User deployer\n  IdentityFile ~/.ssh/project-pro-ecdsa\n\nHost: tên tắt dùng để ssh, có thể đặt tên theo project để dễ nhớ nhé.\nHostname: ip server\nUser: user trên server\nIndentityFile: chỉ định ssh-key sẽ dùng để ssh cho Host\n\n🌱 Việc đơn giản bây giờ là chúng ta ssh theo Host thôi 💪🏻 !!\nssh project-dev"},"50-til/51-Code/06-Servers/Layer-3---Network-Layer":{"title":"🌱 Layer-3: Network Layer","links":[],"tags":["network"],"content":"🌿 What? §\n\n\nLà lớp thứ 3  trong kiến trúc mạng OSI(Open Systems Interconnection)\n\n\n\nNetwork layer chịu trách nhiệm về định tuyến dữ liệu giữa các mạng khác nhau bằng cách sử dụng các giao thức định tuyến như IP, ICMP và các công nghệ liên quan khác. Hiểu đơn gian thì lớp này sẽ quyết định dữ liệu sẽ đi theo đường nào là chính xác và hiệu quả.\n\n\nCác thiết bị của lớp này là router, firewall, …\n\n\n🌿 Refer §\n\nhttps://www.cloudflare.com/learning/ddos/glossary/open-systems-interconnection-model-osi/\n"},"50-til/51-Code/06-Servers/Remote-Desktop-Protocol":{"title":"🌱 Remote Desktop Protocol","links":[],"tags":["til","server"],"content":"Bình thường các server mình được làm trước đây đều là Ubuntu Server, muốn truy cập lên thì dùng ssh-key là được. Nhưng do spec của dự án hiện tại mình làm có yêu cầu sử dụng Window Server. Khi gửi thông tin Server(IP, users, pass) anh PSM có gợi ý dùng RDP Client để truy cập vào. Cơ mà RDP Client là cái khỉ gì 😅\n🌿 What? §\n\n🌱RDP là một giao thức độc quyền được phát triển bởi Microsoft, cung cấp cho người dùng giao diện để truy cập đến một máy tính khác thông qua kết nối internet. Bạn có thể làm mọi thứ với PC remote như một PC vật lý bình thường. Ví dụ như:\n\nSử dụng các ứng dụng của PC remote.\nTruy cập file và các tài nguyên mạng của PC remote.\nTắt các ứng dụng khi bạn thoát khỏi RDP Client (giống shut down PC vật lý.)\n\n\n🌱 Remote Desktop Protocol severs được dùng để các clients kết nối, severs mặc định của RDP là TCP port 3389 và UDP port 3389.\n🌱 Remote Desktop Connection được tích hợp cho RDP Clients trong hệ điều hành Windows.\n\n🌿 Quick connect to a Windows Server from Ubuntu using RDP Client §\n\n1️⃣ Step 1: Đảm bảo PC hoặc server Windows mà bạn muốn truy cập đã được bật Remote Desktop Connections.\n🌱 Nếu chưa bạn có thể xem cách bật ở đây.\n2️⃣ Step 2: Mặc định Ubuntu cung cấp Remmina để hỗ trợ RDP. Turn on!\n\n\n\n3️⃣ Step 3: Tạo một connect mới.\n\n\n\n4️⃣ Step 4: Điền thông tin server.\n\nTiếp theo là setting độ phân giải và color depth của màn hình desktop remote. Mặc định sẽ chọn độ phân giải và color depth ở mức cao nhất. Tuy nhiên, setting 2 thông số này thấp hơn sẽ cải thiện khá nhiều perfomance đấy.\nNếu muốn chia sẻ folder với Windows Server, check folder box và chỉ định folder cần chia sẻ.\nNgoài ra ở mục Advanced, bạn có thể bật/tắt tiếng, chia sẻ máy in, tắt đồng bộ cho bộ nhớ tạm, …\n\n\n\n\n\n5️⃣ Step 5: Lưu và chạy thôi!\n\n\n🌿 Góc so sánh §\n\n🌱 Theo định nghĩa, công dụng của thằng này nghe cũng khá giống TeamView nhỉ 😀 So sánh thôi 😗\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRemote Desktop ProtocolTeamViewLà giao thức được tích hợp sẵn trong hệ điều hành Windows và được phát triển độc quyền bởi công ty MicrosoftLà một phần mềm chia sẻ quyền điều hành máy tính được phát triển bởi TeamViewer GmbHKhông cho phép người dùng theo dõi tác vụ trên máy remoteCho phép người dùng dõi tác vụ trên máy remoteYêu cầu cấu hình port chuyển tiếp trên firewall hoặc route của máy remoteChỉ cần cài đặt là dùng bình thường\n\n🌱 Nhìn chung TeamView ngon và dễ sử dụng hơn RDP nhưng TeamView lại tiềm ẩn rủi ro bị lộ dữ liệu,  thông tin, như ở công ty mình TeamView được liệt vào danh sách đen không được cài đặt ấy.\n🌱 Tùy theo bối cảnh mọi người có thể cân nhắc sử dụng giữa 2 này nhé.\n\n🌿 Tham khảo §\n\nhttps://learn.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/remote-desktop-clients\nhttps://www.techrepublic.com/article/teamviewer-vs-remote-desktop/\n"},"50-til/51-Code/06-Servers/The-paradigms-that-generually-applied-when-release":{"title":"🌱 The paradigms that generually applied when release","links":[],"tags":["til","deployment"],"content":"Với những dự án đã có cộng đồng người dùng lớn, việc deploy những tính năng mới lên môi trường production cần phải có những phương pháp để giảm thiểu tối đa những rủi ro cũng như đạt được trải nghiệm tốt nhất dành cho người dùng.  Những mô hình thường được áp dụng thực tế: A/B Testing, Canary Deployments  và  Blue-Green Deployments.\n🌿 A/B Testing §\n\n🌱 Sử dụng để review độ hiệu quả và phản ứng của người dùng đối với những thay đổi mới.\n🌱 Những thay đổi mới sẽ chỉ được rolled out với một bộ phận người dùng nhất định. So sánh đánh giá của người dùng để đưa ra những chiến lược phát triển phù hợp hơn trong tương lai.\n🌱 Mô hình này được áp dụng cả cho phát triển web, bán hàng, quảng cáo, vv…\n\n\n🌿 Blue-Green Deployments §\n\n🌱 Là một chiến lược deploy dùng để kiểm thử những tính năng mới của dự án.\n🌱 Deploy without downtime.\n🌱 Mô hình này gồm 2 servers chạy đồng thời là Blue và Green, đều là môi trường production nhưng một server có status live - nhận reqs của users còn server kia là idle - không hoạt động.\n\n\n🌿 Canary Testing §\n\n🌱 Cũng giống 2 ý đầu của  Blue-Green Deployments.\n🌱 Thay vì switch toàn bộ users truy cập giữa Blue và Green, Canary Testing sử dụng cân bằng tải, cho phép một số users có thể sử dụng version code mới, sau khi chạy ngon lành thì dần dần áp dụng cho toàn bộ users của hệ thống.\n\n\n🌿 Tham khảo §\n\nhttps://www.oreilly.com/library/view/spring-50-microservices/9781787127685/6fab55ad-8897-42b7-b509-dd90850c861b.xhtml\nhttps://circleci.com/blog/canary-vs-blue-green-downtime/\n"},"50-til/51-Code/07-Utils/Cron-job-notify-drink-water":{"title":"🥂 Tạo background job nhắc nhở uống nước đều đặn","links":[],"tags":["til","script"],"content":"Không biết mọi người có giống mình không, mỗi khi làm việc mình cứ bị quên uống nước ấy, có khi cả buổi mình còn chả uống được 250ml nước =((. Tác hại của việc uống ít nước mọi người có thể gg nha, nhưng ncl uống nước đủ mỗi ngày là thói quen rất có lợi cho sức khỏe cũng như làn da của chúng ta =)).\nHôm trước mình có gặp anh mentor ở cty, anh ấy chia sẻ là vì hay ngồi gù lưng nên anh ấy viết một script để sau một khoảng thời gian, thông báo kiểu như ‘Thẳng lưng lên!’ được hiển thị trên Touch Bar. 🤩, hay thế!!! Sao mình ko áp dụng để improve khả năng uống nước của bản thân nhỉ 🤔 Thế nên tranh thủ cuối tuần, mình có tìm cách để setup cronjob cho Ubuntu.\n🌿 How? §\n\n🌱 Đầu tiên là setup cronjob, mình có xài cron, mn có thể dùng apt để install và enable nó lên nhé.\n\nsudo apt update\n# Check if cron package is installed\ndpkg -l cron\n \n# install cron\nsudo apt install cron\n \n# enable cron\nsystemctl start cron\n \n# check status cron\nsystemctl status cron\n \n# stop cron\nsystemctl stop cron\n\n🌱 Để thêm job, sử dụng command:\n\ncrontab -e\n\n🌱 Trong file đã có hướng dẫn cụ thể, về cơ bản cũng giống như setup cron-sidekiq, nếu chưa quen settings thời gian chạy job mọi người có thể sử dụng cron-time cho trực quan nhé!\n\nVí dụ mình set 20p là phải nhắc t uống nước đó nha Ubuntu =))\n20 * * * * cd ~/personal &amp;&amp; ./script-notify-myself.sh\n\n🌱 Tạo script:\n\n#!/bin/bash\n \nexport DBUS_SESSION_BUS_ADDRESS=&quot;${DBUS_SESSION_BUS_ADDRESS:-unix:path=/run/user/${UID}/bus}&quot;\nnotify-send &quot;Uống nước đii!!!&quot;\n\n🌱 Và kết quả là:\n\n🌿 Update §\n\n🌱 Sau một thời gian thêm cronjob, mình khá là khó chịu vì cái bảng thông báo của mình nó cứ hiển thị chất đống Uống nước đii!!!, rất là mất mỹ quan đô thị.\n\n\n\n🌱 Để khắc phục vấn đề này, mình có thêm một script chịu trách nhiệm để clear-all tất cả những thông báo hiện tại.\n\n# ./remove-all-notify-tray.sh\n \n#!/bin/bash\ngdbus call --session --dest org.gnome.Shell --object-path /org/gnome/Shell --method org.gnome.Shell.Eval &#039;Main.panel.statusArea.dateMenu._messageList._notificationSection._list.remove_all_children()&#039;\n\n🌱 Mình có viết scripts ở đây  để sau dùng lại cho tiện, nếu thấy hứng thú mọi người có thể pull về chạy thử nha ❤️\n"},"50-til/51-Code/07-Utils/DATE_SUB":{"title":"🌱 DATE_SUB - ngược về quá khứ","links":[],"tags":["til","mysql"],"content":"\n🌱 Trong SQL, hàm DATE_SUB() trả về ngày sau khi đã lùi một khoảng thời gian chỉ định.\n\nDATE_SUB(date, INTERVAL value unit)\n \n# date: Ngày làm mốc.\n# value: thời gian bị trừ(có thể chỉ định giá trị âm || dương)\n# unit: đơn vị thời gian(ngày, giờ, phút, ...)"},"50-til/51-Code/07-Utils/Find-by-Regex-in-VsCode":{"title":"🌱 Find by Regex in VsCode","links":[],"tags":["til","utils"],"content":"🌿 Vấn đề §\n🌱 Tôi có một file cần xóa nhiều dòng thừa có cấu trúc giống nhau (dòng trống, dòng comment ,…) trong VsCode.\n🌿 Giải pháp §\n\n🌱 Trong thanh tìm kiếm của VsCode, có option tìm kiếm theo regex. Nếu muốn xóa dòng trống,  Ctrl + H -&gt; thêm regex ^$\\n -&gt; Ctrl + Alt + Enter  là xong.\n\n\n\n🌱 Option rất tiện khi chúng ta muốn tìm những giá trị có format giống nhau(số điện thoại, email, etc …)\n"},"50-til/51-Code/07-Utils/Some-magical-function-of-ZSH":{"title":"🌱 Some magical function of ZSH","links":[],"tags":["zsh"],"content":"\n🌱 zsh_stats: Xem thống kê tần suất sử dụng của 20 câu lệnh thường dùng nhất với zsh\n🌱 mkcd: Tạo thư mục + truy cập vào thư mục\n🌱 alias: Liệt kê tất cả các aliases được defined\n🌱 take: Giống với mkcd,Nhưng nếu nhận một url để download =&gt; tự động giải nén(nếu cần), truy cập dô folder được giải nén\n"},"50-til/51-Code/07-Utils/Đánh-số-hiệu-phiên-bản-phần-mềm":{"title":"🌿 Đánh số hiệu phiên bản phần mềm","links":[],"tags":["til"],"content":"🌿 What? §\n\n🌱 Là quy tắc để xác định và phân biệt tên của phần mềm ở mỗi giai đoạn phát triển. \n🌱 Sematic Versioning\n\nLà quy tắc thường được sử dụng nhất. Do Tom Preston-Werner (ng sáng lập và là cựu CEO của Github) tạo ra.\nCó format là [major].[minor].[patch] , vd: 5.6.8\n\nmajor  - tăng lên khi có những thay đổi không tương thích với phiên bản cũ (vd thay đổi cấu trúcc response).\nminor  - tăng lên khi thêm tính năng mới nhưng vẫn tương thích với phiên bản cũ (vd thêm trường trả về trong response).\npatch  - tăng lên khi fix bug nhưng vẫn tương thích với phiên bản cũ.\n\n\n\n\n\n🌿 Refer §\nhttps://viblo.asia/p/semantic-versioning-OeVKBN2EKkW"},"50-til/51-Code/08-System-Design/CORS---Cross-origin-Resource-Sharing":{"title":"📑 CORS - Cross-origin Resource Sharing","links":["50-til/51-Code/08-System-Design/Same-origin-policy"],"tags":["til","sys-design"],"content":"🌿 What? §\n\n🌱 CORS  là một cơ chế cho phép chia sẻ nhiều tài nguyên(images, files, fonts, javascript,…) giữa nhiều trang web khác nhau.\n\n🌿 Why? §\n\n🌱 CORS ra đời do sự xuất hiện của Same-origin policy.\n\n🌿 How? §\n\n🌱 CORS sử dụng các HTTP Header để thông báo với trình duyệt nhận request là ‘Em là con ông A nhà bà B ở cuối làng, anh cho em vào lấy ít đồ cho bố em nhé ’ =))\n🌱 Access-Control-Allow-Origin  ở header mà trường này ko có giá trị hoặc giá trị ko hợp lệ thì sẽ bị báo lỗi.\n"},"50-til/51-Code/08-System-Design/Open-ID-Connect(OIDC)":{"title":"🔐 Open ID Connect(OIDC)","links":["50-til/51-Code/08-System-Design/Single-Sign-On(SSO)"],"tags":["til","sys-design"],"content":"Là một loại cơ chế xác thực kiểu Single Sign-On(SSO) dựa trên thuật toán mật mã hóa khóa bất đối xứng. Có 2 khóa đảm nhiệm riêng từng nhiệm vụ là mã hóa và giải mã.\n\n\nẢnh trên mô tả cơ chế hoạt động của Mật mã hóa khóa công khai, hiểu đơn giản thì 2 cái này sẽ giống nhau nhưng với 1 cái thì cả 2 khóa phải được giữ bí mật còn lại thì một khóa bí mật một khóa công khai.\nOIDC là phiên bản mở rộng của Oauth 2.0, thay vì là Access-Token chúng ta sẽ nhận được một Id Token từ Auth Server. Với access-token, mỗi lần qua một trang web khác chúng ta sẽ cần request lại access-token mới nhưng với id-token có thể dùng lại thoải mái, id-token có thể xác thực được user cũng như đảm bảo được các thông tin thuộc về User là ko thể bị giả mạo."},"50-til/51-Code/08-System-Design/Robustness-Diagram":{"title":"🌱 Robustness Diagram","links":[],"tags":["til","sys-design"],"content":"🌿 What? §\n\n🌱 Là một dạng UML diagram nằm trong ICONIX Process, xác định tất cả những objects và mối liên hệ của từng use case.\n\nGiảm sự mơ hồ của phần mô tả use case, dễ dàng hơn cho việc thiết kế, kiểm tra và estimate.\n\n\n\n\n\n\n                  \n                  ICONIX Process \n                  \n                \nICONIX Process là một phương pháp luận phát triển phần mềm, mục tiêu là để tránh analysis paralysis. Chỉ sử dụng 4 UML cơ bản ứng với 4 bước trong quá trình chuyển đổi từ Use Case text thành Code .\n\n\n🌱 Mỗi diagram sẽ trả lời cho từng câu hỏi:\n\nUse Cases - Users đang làm gì?\nDomain Models - Có những Objects nào?\nRobustness Diagrams - Những Object nào tham gia trong từng use case?\nSequence Diagrams - Những Object tương tác với nhau như thế nào?\n\n\n\n🌿 How? §\n\n\n🌱 Sử dụng khuôn mẫu boundary/control/entity class.\n\n\n🌱 4 nguyên tắc cơ bản:\n\nActors chỉ có thể giao tiếp với Boundary objects.\nBoundary objects chỉ có thể giao tiếp với Control objects hoặc Actors.\nEntity objects chỉ giao tiếp được với Control objects.\nControl objects có thể giao tiếp với Boundary objects, Entity objects và một số Control objects khác, nhưng cấm chơi với Actors.\n\n\n\n\nÝ nghĩ của các khuôn mẫu\n\n\n\n🌱 Ví dụ:\n\n\n🌿 Tham khảo §\n\nhttps://en.wikipedia.org/wiki/ICONIX\nhttps://docs.nomagic.com/display/MD190/Robustness+diagram\n"},"50-til/51-Code/08-System-Design/Same-origin-policy":{"title":"📑 Same-origin policy","links":[],"tags":["til","sys-design"],"content":"🌿 What? §\n\nLà một cơ chế bảo mật hạn chế việc documents hoặc script load thuộc một origin có thể tương tác với những resources thuộc một origin khác.\nĐược cài đặt vào toàn bộ  các trình duyệt hiện nay.\nChính sách này giúp trang web của chúng ta không bị truy cập bừa bãi từ những tác nhân lạ.\n\nVí dụ nếu bạn vào một trang web bất kỳ được cài sẵn một mã độc truy cập đến trang web VCB, nếu bạn đã đăng nhập vào VCB, vẫn còn hiệu lực đăng nhập và không có chính sách này, hacker sẽ chiếm được quyền sử dụng tài khoản ngân hàng của bạn.\nCòn bình thường mn sẽ nhận được message này ở console browser\n\n\n\nAccess to XMLHttpRequest at &#039;https://vietcombank.com/profile&#039; from origin &#039;xxx&#039; has been blocked by CORS policy: No &#039;Access-Control-Allow-Origin&#039; header is present on the requested resource.\n\n🌱 Nhưng thực hiện truy vấn giữa nhiều trang web với nhau là việc rất thường xuyên đối với một lập trình viên, đặc biệt là vụ call API. Và thế là Cross-origin Resource Sharing - CORS ra đời =))\n"},"50-til/51-Code/08-System-Design/Sequence-Diagram-là-gì?":{"title":"🌱 Sequence Diagram là gì?","links":[],"tags":["til","sys-design"],"content":"Sắp tới mình được giao tasks là vẽ lại sequence diagram cho toàn bộ tính năng của một con dự án ở cty, mà nghe đâu là gần 40 chục cái hay sao ấy 🤢 Thế nên tranh thủ cuối tuần mình ngồi ôn lại chút để tuần sau vào việc cho lẹ 💪 Let’s go!!!\n🌿  What? §\n\nSequence Diagram  -Biểu đồ tuần tự là một dạng biểu đồ UML - Unified Modeling Language dùng để xác định trình tự diễn ra của một nhóm đối tượng nào đó.\nBiểu đồ miêu tả chi tiết các thông điệp được gửi và nhận của từng đối tượng đồng thời cũng chú trọng cả việc xác định thứ tự của những thông điệp đó.\n\n🌿  Các thành phần §\nGồm 4 thành phần chính:\n\n\nĐối tượng (Object or Class)\n\n\n\nĐường đời đối tượng (Lifelines)\n\n\n\nThông điệp (messages)\n\n\n\nCác dạng thông điệp\n\n\n\n\n\n\n\n\n\n\nTiến trình xử lý (process)\n\n\n🌿 Ví dụ §\n\n🌿 Tham khảo §\n\nhttps://www.smartdraw.com/uml-diagram/\n"},"50-til/51-Code/08-System-Design/Single-Sign-On(SSO)":{"title":"🔐 Single Sign-On(SSO)","links":["50-til/51-Code/08-System-Design/System-Identification-Link"],"tags":["til","sys-design"],"content":"🌿  Issue §\nHiện nay hầu hết các dịch vụ web đều yêu cầu người dùng đăng nhập trước khi sử dụng. Nhu cầu sử dụng dịch vụ ngày càng nhiều đồng nghĩa chúng ta càng phải nhớ nhiều thông tin đăng nhập, giả sử nếu chúng ta dùng 10 webs khác nhau, việc nhớ thông tin đăng nhập cũng khá là ‘vất vả’ đúng ko nào =))\n\nChính vì vậy mà đã lòi ra cu SSO này =))\n\n🌿  What? §\n\n\nSingle Sign-On là cơ chế giúp người dùng đăng nhập một ID cho một vài trang webs hoặc hệ thống liên quan nhưng độc lập với nhau. Kiểu như Google dùng tài khoản Gmail đăng nhập cho các services độc lập(Driver, Clouds, …). Một khóa mở được nhiều chìa 🤞\n\n🌿  Why? §\nƯu điểm §\n\nGiảm thời gian nhập lại thông tin đăng nhập\nGiảm password fatigue cho hệ thống\nGiảm effort phát triển chức năng log-in\nGiảm thiểu rủi ro việc lộ thông tin của người dùng\nNâng cao hiệu suất cho người dùng. Người dùng ko phải nhớ nhiều thông tin đăng nhập.\nQuản lý dễ dàng hơn. Giả sử bạn có 3 trang webs và bạn muốn ban account A, nếu dùng SSO bn chỉ cần setting banned một lần cho cả 3 webs.\n\nNhược điểm: §\n\nPhụ thuộc vào bên thứ 3\n\n🌱 Lắm ưu ít nhược nên SSO khá là ngon, hiện tại cũng có khá nhiều service thứ 3 cung cấp dịch vụ SSO miễn phí(Facebook, Google, Github, …) mọi người có thể cân nhắc sử dụng theo nhu cầu phát triển của dự án nhé =))\n🌿  How? §\nSSO là một phần của System Identification Link, có liên quan chặt chẽ với việc xác thực thông tin người dùng. Nó sẽ định danh người dùng, và sau đó chia sẻ thông tin định danh được với các hệ thống con.\nCơ chế §\nTheo luồng bình thường user đăng nhập web A sẽ sinh ra cookie để xác thực cho những request sau, nếu mang cookie đó sang web B để xác thực thì sẽ tạch do các trình duyệt hiện nay chỉ có thể truy cập cookie do chính nó tạo ra.\n\nHiểu đơn giản giữa các web sẽ có một browser cookie storage chung và sử dụng cơ chế Cross-origin resource sharing. Khi Web nào đăng nhập thì sẽ truy cập vào browser cookie storage để lấy cookie lên server auth(của bên thứ 3) để xác thực."},"50-til/51-Code/08-System-Design/Store-passwords-safely-in-the-database?":{"title":"🛡️ Store passwords safely in the database","links":[],"tags":["til","sys-design"],"content":"🌿 Những điều không nên làm §\n\nKhông được lưu passwords dạng text trong db, vì bất cứ người nào có quyền connect vào db đều sẽ xem được nó.\nLưu password hashes trực tiếp cũng không an toàn vì nó có thể vị vô hiệu hóa bởi những cuộc tấn công tính toán trước(precomputation attacks), vd như là rainbow tables.\nĐể hạn chế precomputation attacks, chúng ta hãy salt the passwords.\n\nWhat is salt? §\n\nTheo như hướng dẫn của OWASP, salt là một chuỗi duy nhất, được sinh ra ngẫu nhiên và được thêm cho từng password như là một phần của quá trình mã hóa.\n\n🌿 How to store? §\n\nTheo hình trên, mọi người có thể hình dung các bước để lưu password vào DB như sau:\n1. User cung cấp password.\n2. Hệ thống sinh ra salt cho password.\n3. Trong DB sẽ lưu cả salt và hash được mã hóa từ password + salt.\n🌿 How to validate? §\n\nCác bước hệ thống thực hiện validate:\n1. User cung cấp validate.\n2. Lấy mã salt  của user được lưu trong DB.\n3. Thực hiện mã hóa từ password + salt =&gt; hash\n4. So sánh hash tạo từ bước 3 và hash lưu trong DB.\nP/s:  Ngoài ra mọi người có thêm cơ chế nào khác để có thể lưu trữ pasword an toàn trong DB không? Nếu có hãy cmt cho mình biết với nha &lt;3\n🌿 Tham khảo §\n\nFree System Design - ByteByteGo - Trang 13\n"},"50-til/51-Code/08-System-Design/System-Identification-Link":{"title":"📑 Hệ thống nhận diện liên kết","links":[],"tags":["til","sys-design"],"content":"Hệ thống nhận dạng liên kết( Federated Identity Glossary) là nơi tập trung và liên kết thông tin người dùng. Có 4 yếu tố nền tảng cấu thành nên hệ thống này:\n\nXác thực (Authentication): kiểm tra thông tin đăng nhập và tiến hàng định danh người dùng.\nPhân quyền (Authorization): dựa trên thông tin định danh để kiểm tra quyền truy cập của user.\nTrao đổi thông tin người dùng (User attributes exchange): Mỗi hệ thống con sẽ cần và lưu trữ các thông tin khác nhau của người dùng, tuy nhiên sẽ có các thông tin bị lặp lại, ví dụ như tên, họ… Do đó, cần có một nơi để tổng hợp lại các thông tin này, và trao đổi cho các hệ thống con.\nQuản lí người dùng (User management): admin có thể quản lí người dùng bằng các thao tác thêm, sửa, xóa… ở các hệ thống con.\n"},"50-til/51-Code/08-System-Design/Why-is-RAM-access-faster-than-hard-disk-drive?":{"title":"♻️ Why is RAM access faster than hard disk drive?","links":[],"tags":["til","sys-design"],"content":"Khi sử dụng Redis, mọi người thường hay nói Redis thực hiện thao tác dữ liệu trên Ram nên có tốc độ truy xuất nhanh hơn rất nhiều so với truy cập vào HDD. Vậy tại sao lại như thế?\n🌿 Why? §\n\n\nHDD nằm cách xa CPU, được kết nối với bảng điều khiển thông qua cổng SATA. 6Gb/s là tốc độ tiêu chuẩn của SATA III, HDD chỉ có thể đọc hoặc viết chứ không thể làm cả hai trong cùng một thời điểm.\nRAM nằm rất gần CPU và có kết nối băng thông rất cao. Thông lượng của DDR4 là khoản 40Gb/s, ngoài ra RAM còn có thể thực hiện đọc và viết cùng lúc. Khi sử dụng dual channel, RAM sẽ đọc/đọc, viết/đọc, viết/viết chính vì vậy mà nó có thể thao tác một lượng dữ liệu vô cùng lớn trong cùng một thời điểm.\n\n🌿 Câu hỏi §\nThế tại sao người ta lại không thiết kế để HDD lại gần CPU?\nVấn đề lớn nhất là chi phí. Tốc độ xử lý cao tương ứng với giá thành sản xuất cũng sẽ đắt. Và tùy theo mục đích nên mỗi phần sẽ có thiết kế phù hợp -&gt; đạt được cả hiệu năng và giá thành tốt nhất.\n\nĐối với những tác vụ lưu trữ file, đọc/ ghi đơn giản, không yêu cầu xử lý nhanh thì người ta dùng HDD cho rẻ. (ổ cứng lưu trữ)\nCác tác vụ cần xử lý nhanh hơn 1 chút, như load hệ điều hành, người ta ưu tiên dùng SSD (ổ cài win ý :v )\nThằng nào cần cache, xử lý tốc độ bàn thờ (làm bộ nhớ tạm cho các phần mềm đang chạy) thì người ta dùng tới RAM, CPU.\n\n"},"50-til/51-Code/08-System-Design/Why-is-Redis-so-Fast?":{"title":"♻️ Why is Redis so Fast?","links":["50-til/51-Code/08-System-Design/Why-is-RAM-access-faster-than-hard-disk-drive"],"tags":["til","redis"],"content":"🌱 Có 3 lý do chính giải thích điều này:\n\n\nRedis là một cơ sở dữ liệu lưu trữ trên RAM. Tốc độ truy cập RAM đểu nhất cx nhanh hơn 1000 lần so với tốc độ truy cập ổ cứng. Mọi người có thể xem thêm\nRedis sử dụng IO multiplexing và single-threaded. IO multiplexing là cơ chế đọc/ghi liên tục của RAM. RAM nhận tất cả các yêu cầu đọc/ghi dữ liệu, để vào một chỗ, sau đó dùng single-threaded lặp qua từng event để tiếp tục xử lý.\nRedis sử dụng một vài cấu trúc dữ liệu lower-level(String lưu thành SDS, …).\n\n🌿 Câu hỏi §\n\n🌱 Tại sao truy cập từ RAM lại nhanh hơn từ HDD?\nWhy is RAM access faster than hard disk drive?\n\nP/s: Memcached cũng là một giải pháp khá phổ biến để giải quyết vấn đề cached dữ liệu, mọi người có thể tìm hiểu thêm nhé.\n🌿  Tham khảo §\n\nFree System Design - ByteByteGo - Trang 76\n"},"50-til/51-Code/09-Docker/Best-practice-when-build-Dockerfile":{"title":"🌱 Best practice when build Dockerfile","links":["50-til/51-Code/09-Docker/What-is-mean-the-tag-suffix-of-an-image-on-docker-hub"],"tags":["til","docker"],"content":"🌿 I. Chỉ định rõ version của Base Image §\n\n🌱 Bad\n\nFROM ruby\n...\n\n🌱 Good\n\nFROM ruby:3.1.2\n...\n\nNên chỉ định rõ version để có thể tái sử dụng. Cũng tiện theo dõi khi chúng ta muốn upgrade &amp; maintain.\n\n🌿 II. Chỉ nên sử dụng trusted or official base images §\n\n🌱 Bad\n\nFROM random-dude-on-the-internet/ruby:3.1.2\n\n🌱 Good\n\nFROM ruby:3.1.2\n\n# hoặc \n\nFROM random-dude-on-the-internet/ruby:3.1.2\n\n# giả sử chúng ta biết chắc rằng random-dude-on-the-internet uy tín/tín.\n\nVì chúng ta không thể chắc rằng Base Image có được sửa đổi hay không. Với những nguồn không uy tín, nếu người viết không ghi change log rõ ràng có thể gây ảnh hưởng đến hệ thống.\n\n🌿 III. Chỉ định rõ version của dependencies §\n\n🌱 Bad\n\nFROM ruby:3.1.2\n\nRUN gem install sinatra\n\n🌱 Good\n\nFROM ruby:3.1.2\n\nRUN gem install sinatra -v 2.0.5\n\nTương tự như base image, chúng ta cũng nên chỉ định rõ version cho dependencies. Hầu hết các trình quản lý package như Gemfile.lock, package-lock.json, yarn.lock đều chỉ định rõ, dễ dàng quản lý, theo dõi cũng như thuận tiện tái sử dụng.\n\n🌿 IV. Đưa những commands ít thay đổi lên trước §\n\n🌱 Bad\n\nFROM ruby:3.1.2\n\n# Source code\nCOPY my-code/ /srv/\n\n# Application dependencies\nCOPY Gemfile Gemfile.lock ./\nRUN bundle install\n\n🌱 Good\n\nFROM ruby:3.1.2\n\n# Application dependencies\nCOPY Gemfile Gemfile.lock ./\nRUN bundle install\n\n# Source code\nCOPY my-code/ /srv/\n\nDocker sẽ build lại tuần tự từ trên xuống dưới, bắt đầu từ câu lệnh có ‘thay đổi’. Ví dụ như trên, source code sẽ được thay đổi thường xuyên hơn Gemfile, nếu đặt source code ở trên, Docker sẽ build lại cả phần COPY với RUN bundle install nữa.\n\n\n\n                  \n                  Note \n                  \n                \nĐặt các lệnh ít có khả năng thay đổi nhất ở trên cùng để tận dụng cache, giảm thời gian build Image.\n\n🌿 V. Tránh chạy container với quyền root §\n\n🌱 Bad\n\nFROM ruby:3.1.2\n\nRUN gem install sinatra -v 2.0.5\n\nRUN echo &#039;require &quot;sinatra&quot;; run Sinatra::Application.run!&#039; &gt; config.ru\n\n# By default this is run as root\nCMD rackup\n\n🌱 Good\n\nFROM ruby:3.1.2\n\nRUN gem install sinatra -v 2.0.5\n\n# Tạo user riêng để chạy container\nRUN adduser -D my-sinatra-user\n\n# Chỉ định User thực hiện các câu lệnh RUN, CMD hoặc ENTRYPOINT ở dưới\nUSER my-sinatra-user\n\n# Chỉ định thư mục riêng\nWORKDIR /home/my-sinatra-user\n\nRUN echo &#039;require &quot;sinatra&quot;; run Sinatra::Application.run!&#039; &gt; config.ru\n\n# Các câu lệnh sẽ chạy với quyền của user my-sinatra-user\nCMD rackup\n\nMặc định container run với quyền root.\nContainer của chúng ta sẽ tạo ra một process chạy với quyền root trong Linux kernel, điều này có thể gây ra lỗ hổng bảo mật, cho phép attackers thoát khỏi container và thực hiện quyền root trên thiết bị của chúng ta.\n\n🌿 VI. Sử dụng -chown khi run COPY hoặc ADD §\n\n🌱 Bad\n\nFROM ruby:3.1.2\n\n# Tạo user riêng để chạy container\nRUN adduser -D my-sinatra-user\n\n# Chỉ định User thực hiện các câu lệnh RUN, CMD hoặc ENTRYPOINT ở dưới\nUSER my-sinatra-user\n\n# Chỉ định thư mục riêng\nWORKDIR /home/my-sinatra-user\n\n# File copy sẽ thuộc sở hữu của root user\nCOPY Gemfile Gemfile.lock ./\n\nRUN bundle install\n\nCMD rackup\n\n🌱 Good\n\nFROM ruby:3.1.2\n\n# Tạo user riêng để chạy container\nRUN adduser -D my-sinatra-user\n\n# Chỉ định User thực hiện các câu lệnh RUN, CMD hoặc ENTRYPOINT ở dưới\nUSER my-sinatra-user\n\n# Chỉ định thư mục riêng\nWORKDIR /home/my-sinatra-user\n\n# File copy sẽ thuộc sở hữu của my-sinatra-user user\nCOPY --chown=my-sinatra-user Gemfile Gemfile.lock ./\n\nRUN bundle install\n\nCMD rackup\n\nUSER chỉ chỉ định user thực hiện RUN, CMD hoặc ENTRYPOINT. Còn với COPY và ADD chúng ta cần sử dụng --chown.\n\n🌿 VII. Tránh làm lộ thông tin nhạy cảm trong Dockerfile §\n\n🌱 Bad\n\nFROM ruby:3.1.2\n\nENV DB_PASSWORD &quot;real password&quot;\n\nCác thông tin như trên không bao giờ được hiện diện trong Dockerfile của chúng ta dưới dạng text thô. Thay vào đó, chúng ta có thể sử dụng thông qua những cách sau:\n\nLệnh ARG và truyền giá trị thông qua flag --build-arg khi run.\nBiến môi trường.\n\n\n\n\n\n                  \n                  Lưu ý \n                  \n                \nHai cách trên vẫn có rủi ro vì các giá trị thô sẽ vẫn được ghi lại trong lịch sử build.\n\n🌿 VIII. Xóa luôn những thông tin nhạy cảm sử dụng để build §\n\n🌱 Bad\n\nFROM ruby:3.1.2\n\nARG PRIVATE_SSH_KEY\n\n# Bước này sẽ lưu lại PRIVATE_SSH_KEY\nRUN echo &quot;${PRIVATE_SSH_KEY}&quot; &gt; /root/.ssh/id_rsa\n\n# Đến bước này vẫn sẽ còn giá trị của PRIVATE_SSH_KEY\nRUN bundle install\n\nRUN rm /root/.ssh/id_rsa\n\n🌱 Good\n\nFROM ruby:3.1.2\n\nARG PRIVATE_SSH_KEY\n\nRUN echo &quot;${PRIVATE_SSH_KEY}&quot; &gt; /root/.ssh/id_rsa &amp;&amp; \\\n  bundle install &amp;&amp; \\\n  rm /root/.ssh/id_rsa\n\nNếu có ai truy cập được vào lịch sử build thì có thể lấy được giá trị của PRIVATE_SSH_KEY. Chúng ta nên xóa luôn trong cùng một step để tránh trường hợp trên.\n\n🌿 IX. Tối ưu size của base image nếu có thể §\n\n🌱 Bad\n\nFROM ruby:3.1.2\n\nCMD ruby -e &quot;puts 1 + 2&quot;\n\n🌱 Good\n\nFROM ruby:3.1.2-alpine\n\nCMD ruby -e &quot;puts 1 + 2&quot;\n\nBase Image có nhiều version(chủ yếu khác nhau về base OS), chúng ta nên lựa chọn phù hợp với nhu cầu sử dụng. Mọi người có thể xem thêm ở đây\nKhi lựa chọn Image base từ OS thu gọn, cần để ý:\n\nPhải có package manager và các gói có sẵn.\nXem OS đó sử dụng Shell gì.\nTránh các môi trường thử nghiệm, dễ gây rủi ro về mặt bảo mật hoặc tính ổn định.\n\n\n"},"50-til/51-Code/09-Docker/Docker-Compose":{"title":"🦑 Docker Compose","links":["50-til/51-Code/09-Docker/Docker","50-til/51-Code/09-Docker/Dockerfile"],"tags":["til","docker"],"content":"\n🌿 I. What? §\n🌱 Chúng ta muốn ứng dụng Docker cho:\n- Dự án mới\n- Dự án đang phát triển\n🌱 Chúng ta có thể dùng Dockerfile cài chung tất cả vào một container duy nhất sau đó chạy project trên container đó.\n\n🌱 Tuy nhiên cách này không hợp lý cho việc mở rộng cũng như sử dụng lại cho nhiều projects.\n-&gt; docker-compose ra đời để kết nối những containers riêng lẻ với nhau.\n\n\n\nCó thể hiểu docker là con cá voi đang vận chuyển nhiều containers đến cảng Project A.\n\n\nCòn docker-compose sẽ là con bạch tuộc sử dụng các xúc tua của mình để lấy những containers cần thiết cho Project A.\n\n\n\nXem hướng dẫn cài docker-compose tại đây\n🌿 II. Xây dựng docker-compose §\n1. Cấu trúc thư mục §\n🌱 Mình sẽ chỉ làm một project demo nên cấu trúc đơn giản gồm:\n\n docker/entrypoint.sh\n Dockerfile\n docker-compose.yml\n\n🌱 Khi làm dự án thật, do phải build cho từng môi trường(development, staging, production) nên cấu trúc sẽ có khác hơn một chút, nhưng về cơ bản vẫn là vẫn có đủ thành phần cấu trúc như trên.\n2. Xác định những containers cần thiết §\n🌱 Mình làm demo trên Rails app và những công nghệ mình thấy hay được sử dụng nhất là:\n\n Web\n\nRuby\nRails(là Ruby framework nên chỉ cần pull image của ruby thôi)\n\n\n Mysql (hoặc postgret)\n Redis (lưu cache, backgournd job)\n Sidekiq (chạy background job)\n\nok triển thôi!!\n🌿 3. Viết docker-compose §\n\nversion: những version sẽ có vài điểm khác nhau như:\n\nvề cấu trúc và các keys config\nvề Docker Engine version thấp nhất mà bạn cần đáp ứng\nnetworking\nTại thời điểm viết bài này, trên trang chủ cập nhật version mới nhất là 3.8 hỗ trợ cho Docker Engine 19.03.0+\nChi tiết hơn về sự khác nhau của từng version hay các năng cấp từ 2.x lên 3.x thì mọi người có thể đọc thêm ở đây nhé.\n\n\nservices: những containers chúng ta định nghĩa sẽ nằm ở đây.\nnhững config trong từng container:\n\n image: chỉ định image được dùng để build container\n build: khi muốn build container bằng Dockerfile\n container_name: chỉ định tên tùy chỉnh của container nếu ko muốn dùng tên mặc định\n restart: mặc định là no, nếu set always container sẽ khởi động lại khi có lỗi\n environment: chỉ định biến mối trường, có thể chỉ định từng biến hoặc file chứa các biến môi trường\n volumes: chia sẻ dữ liệu từ máy ảo tới máy thật hoặc giữa nhiều containers với nhau\n\nVí dụ như container mysql, dữ liệu được tạo ra sẽ được lưu ở thư mục var/lib/mysql  trong container, nếu xóa container thì dữ liệu sẽ bị mất sạch.\nChính vì thế nên chúng ta dùng volumes để dữ liệu của container được mount ra ngoài host, nếu có xóa container thì dữ liệu vẫn còn, và khi khởi động lại, dữ liệu được mount ngược vào container và sử dụng bình thường.\n\n\n ports: Cấu hình cổng kết nối\n\ncó thể chỉ định cả 2 cổng host:container\nvd 123:345 cổng 123 của máy thật sẽ trỏ đến cổng 345 của container\n\n\n\n\n"},"50-til/51-Code/09-Docker/Docker-Network":{"title":"🐬 Docker Network","links":["50-til/51-Code/09-Docker/Docker"],"tags":["til","docker"],"content":"🌿 What? §\n🌱 Là mạng sử dụng cho các containers có thể kết nối và giao tiếp với nhau. Mỗi container có một vùng chứa riêng biệt nên cũng sẽ có mạng, port, IP riêng.\n🌱 Docker cung cấp sẵn một số mạng mặc định cho các container, chúng ta có thể gom một nhóm container vào một mạng chung. Điều này khá là tiện lợi trong trường hợp chúng ta muốn chỉ định một stack phù hợp cho dự án.\n🌿 What type of network? §\n\n\n🌱 Bridge network\n\nMạng Bridge cho phép kết nối giữa các container cùng mạng và sử dụng một dải ip được cấp ngẫu nhiên hoặc tự thiết lập.\nMạng Bridge đáp ứng hầu hết các usecase nếu triển khai các container trên cùng một host. Nhưng nếu chạy một môi trường đa host, Bridge sẽ không làm được điều này, đây sẽ là nhược điểm của mạng Bridge.\nDriver của mạng Bridge là bridge.\n\n\n\n🌱 Host network\n\nHost network cho phép mạng container kết nối với host. Và sử dụng IP có cùng dải mạng với host.\nDriver của mạng Host là host.\n\n\n\n🌱  None network\n\nTắt tất cả kết nối mạng.\nDriver của mạng None là null.\n\n\n\n🌱  Overlay network\n\nNhược điểm của mạng Bridge được Overlay network và Macvlan khắc phục.\nOverlay network thực hiện kết nối nhiều Docker daemon với nhau để tạo một mạng ảo trên các máy chủ. Nơi có thể thiết lập kêt nối giữa swarm service và container độc lặp hoặc hai container trên các host khác nhau.\nDriver của mạng Overlay là overlay.\n\n\n\n🌱  Macvlan netwrok\n\nMacvlan network cho phép bạn gán địa chỉ MAC cho một container, biến container như một thiết bị vật lý trên mạng.\nDriver của mạng Macvlan là macvlan.\n\n\n"},"50-til/51-Code/09-Docker/Docker":{"title":"🐬 Docker","links":["50-til/51-Code/03-Operating-System/Linux-Basic"],"tags":["til","docker"],"content":"🌿 I. Bối cảnh §\n\n🌱 Trước đây mô hình máy chủ được tạo thành bởi ba yếu tố:\n\nMáy chủ vật lý (Physical Server)\n\n\nHệ điều hành (Operating System)\nCác ứng dụng (Application)\n\nMô hình trên có những nhược điểm:\n\nMột máy chủ chỉ cài được 1 OS\nCho dù ổ cứng khủng, ram khủng thì cũng không thể tận dụng hết được\n\n🌱 Vì những nhược điểm đó, công nghệ ảo hóa Virtualization được ra đời, ưu điểm so với mô hình cũ là:\n\nTrên một máy chủ vật lý, có thể cài được nhiều hệ điều hành, tận dụng được tài nguyên tốt hơn do có thể phân chia tài nguyên cho từng máy ảo\n\nNhưng vẫn có những thứ chưa được tối ưu:\n\nVề tài nguyên:\n\nKhi thiết lập máy ảo chúng ta sẽ cần cấu hình để cung cấp tài nguyên từ ổ cứng và ram từ máy thật cho máy ảo. Những tài nguyên được phân ra sẽ là cố định. Dẫn đến việc, khi bật máy ảo, kể cả khi không làm gì thì máy thật cũng sẽ mất một lượng tài nguyên mà ban đầu chúng ta đã cung cấp.\n\n\nVề thời gian:\n\nThời gian bật/tắt máy ảo khá lâu(mấy phút lận)\n\n\n\n🌱 Để khắc phục những nhược điểm còn tồn đọng đó, công nghệ Containerization, ưu điểm của công nghệ này đó là:\n\n\nThừa hưởng khả năng tạo được nhiều máy ảo trên cùng một máy chủ vật lý như Virtualization , nhưng tốt hơn ở chỗ những máy ảo này sẽ dùng chung phần nhân và cùng chia sẻ với nhau tài nguyên của máy mẹ. Máy ảo dùng bao nhiêu tài nguyên sẽ được cấp bấy nhiêu, chứ ko có tình trạng tài nguyên bị rảnh rỗi nữa, như vậy thì việc tận dụng tài nguyên sẽ tối ưu hơn.\nĐặc trưng của công nghệ này là sử dụng các containers.\n\n\n🌱 Với công nghệ Virtualization, chúng ta có thể dùng các công cụ tiêu biểu như Virtualbox hay VMware, còn với Containerization đó chính Docker.\n\n🌿 II. What Docker? §\n\nLà mã nguồn mở\nMục đích develop, deploy and run applications bằng những containers\n\nXem hướng dẫn cài Docker tại đây\n🌿 III. Why Docker? §\n\nBuild một lần dùng được nhiều lần và nhiều chỗ\nBật/tắt nhanh chóng\n\n🌿 IV. Những khái niệm phổ biến §\n1. Container §\n\nLà một quá trình chạy trên Linux kernel.\nĐược cấp phát tài nguyên riêng: CPU, bộ nhớ và hệ thống tập tin. Chính vì vậy, Docker độc lập với những tiến trình đang chạy của máy tính và không ảnh hưởng đến các containers/processes khác đang chạy.\n\n2. Image §\nLà tệp chứa mọi thứ cần để thực thi: dependencies, binaries, source code, … Xây dựng bằng cách thực thi các câu lệnh trong Dockerfile. Một Image có thể được sử dụng để tạo nhiều containers giống nhau. Mỗi container là một instantiation của image.\n3. Dockerfile §\nLà một tệp chứa các câu lệnh cần thiết để xây dựng một Image.\n🌿 V. Một vài câu lệnh hay được sử dụng §\n\n\ndocker pull image_name: pull một image từ Docker Hub.\n\n\ndocker build: build một container từ Dockerfile và một context(bao gồm các folders|files được đặt ở PATH/URL).\n\n\ndocker run: chạy container từ một image.\n\n\ndocker ps: list ra những containers đang chạy. -a/—all để lấy tất cả containers hoặc -q/—quite nếu chỉ muốn lấy cấc ids của containers.\n\n\ndocker logs [container_id/container_name]: xem logs của 1 container, -f/—follow để xem log output.\n\n\ndocker volume ls: list ra các volumes được dùng để lưu trữ data được sinh ra và sử dụng bởi các containers.\n\n\ndocker rm [container_id/container_name]: xóa 1 hoặc nhiều containers.\n\n\ndocker rmi [image_id]: xóa 1 hoặc nhiều images.\n\n\ndocker stop: dừng 1 hoặc nhiều containers.\n\n\ndocker kill: kill 1 hoặc nhiều containers.\n\n\ndocker kill $(docker ps -q): kill tất cả containers đang chạy\n\n\n$(docker ps -q) #lấy ra id của các containers đang chạy.\n \n$(docker ps -a -q) #lấy id của toàn bộ các containers.\n\ndocker system prune: Dọn toàn bộ resources(images, containers, volumes, networks) đang bị treo(không liên kết với bất kì container nào).\n"},"50-til/51-Code/09-Docker/Dockerfile":{"title":"🐬 Dockerfile","links":["50-til/51-Code/09-Docker/Docker"],"tags":["til","docker"],"content":"🌿 I. Config §\n\n\nFROM: chỉ định image gốc. Docker Hub nơi lưu trữ và chia sẻ các images. Chúng ta có thể lấy các image gốc trên này và về xào nấu lại để phù hợp với nhu cầu sử dụng của mình.\n\n\nMAINTAINER: optional để đặt tên cho tác giả viết Dockerfile\n\n\nRUN: thực thi 1 câu lệnh trong quá trình build image.\n\n\nCMD: thực thi 1 câu lệnh trong quá trình bật container.\n\n\nMỗi Dockerfile chỉ chạy một câu lệnh CMD, nếu có nhiều hơn sẽ chỉ chạy câu lệnh CMD cuối cùng.\n\n\nNếu muốn khởi động nhiều ứng dụng khi start container, hay sử dụng ENTRYPOINT.\n\n\n\n\nENTRYPOINT: thực thi một số câu lệnh trong quá trình bật container, những câu lệnh này sẽ được viết trong file script có đuôi .sh.\n\n\nEXPOSE: chỉ định cổng mà container sẽ nghe khi chạy.\n\n\nADD: Copy file, thư mục, hoặc remote file thêm chúng vào filesystem của image.\n\n\nCOPY: Copy file, thư mục từ host machine vào image. Có thể sử dụng url cho tập tin cần copy(chưa dùng baoh =))).\n\n\nWORKDIR: chỉ định directory cho câu lệnh CMD\n\n\nVOLUME: mount thư mục từ máy host vào container.\n\n\nMình sẽ build những gì học được về docker ở repo này : app-demo-rails-docker, mọi người có thể theo dõi các steps theo pulls cho tiện nhé.\nPull mình build Dockerfile: pull build Dockerfile"},"50-til/51-Code/09-Docker/What-is-mean-the-tag-suffix-of-an-image-on-docker-hub?":{"title":"🌱 What is mean the tag suffix of an image on docker hub?","links":["[https:/wiki.debian.org/LTS](https:/wiki.debian.org/LTS)"],"tags":["til","docker"],"content":"🌿 Vấn đề §\n\nKhi chạy apt-get update , gặp lỗi KEYEXPIRED như dưới đây.\n\nStep 3/15 : RUN apt-get update -qq &amp;&amp; apt-get install -y build-essential libpq-dev nodejs vim cron\n ---&gt; Running in 8437242de6eb\nW: GPG error: http://deb.debian.org jessie-updates InRelease: The following signatures were invalid: KEYEXPIRED 1668891673\nW: GPG error: http://deb.debian.org jessie Release: The following signatures were invalid: KEYEXPIRED 1668891673\n🌿 Nguyên nhân §\n\nLỗi trên được xác định là do Dockerfile đang base theo Image ruby:2.4.2 , sử dụng debian:jessie , đã hết hạn LTS.\n\n\n\n                  \n                  LTS (Long Term Time) \n                  \n                \n🌱 LTS (Long Term Support) là một dự án hỗ trợ(cập nhật repo, vá lỗi, …) các versions Debian ổn định đã được release trong vòng ít nhất là 5 năm. LTS không phải do Team Security Debian phát triển mà do một bộ phận những lập trình viên + công ty “tình nguyện” triển khai.\n\n🌿 Giải pháp §\nCó 2 cách\n\n\n🌱 Sửa file /etc/apt/sources.list, replace repo jessie-updates bằng tay. Xem chi tiết hơn ở đây.\n\n\n🌱 Đổi Image ruby:2.4.2 -&gt; ruby:2.4.2-stretch\n\nKhi sử dụng Image, mọi người nên để ý phần tag xem nó đang được base theo version OS nào(nhất là các dự án thâm niên). Một số suffix thường gặp:\n\n-jessie - Mã phát triển của Debian 8. Có LTS từ ngày 26/04/2015, hết hạn 30/06/2020.\n-stretch - Mã phát triển của Debian 9. Team Security Debian ngừng update bảo mật từ 06/07/2020 và đổi qua LTS -&gt; đến khoảng 2025 là hết hạn LTS.\n-buster - Mã phát triển của Debian 10, released từ ngày 06/07/2019. Vẫn được Team Security Debian support.\n-bullseyes - Mã phát triển của Debian 11, released từ ngày 14/08/2021. Vẫn được Team Security Debian support.\n-slim - Tối ưu containers tốt hơn, nhỏ hơn, bảo mật hơn. Cân nhắc khi dùng, vì đây là phiên bản rút gọn, sẽ không đầy đủ bằng bản offical.\n-alpine - Image được base theo Alpine Linux, đây là một OS thiết kế đặc biệt để chạy trong container. Có size rất bé, vài Mb(&lt; slim). Highly recommended nếu bộ nhớ là tiêu chí ưu tiên. Xem thêm ở đây.\n\n\n\n\n\n🌿 Tham khảo §\n\nMọi người có thể đọc thêm những thông tin khác(bash, package management, …) của các versions tag ở đây:\n\nhttps://stackoverflow.com/questions/52083380/in-docker-image-names-what-is-the-difference-between-alpine-jessie-stretch-an\n\n\n"},"50-til/51-Code/10-React/Props-in-React":{"title":"🌱 Props in React","links":[],"tags":["til","react"],"content":"🌿 What? §\n\nLà dữ liệu được gửi từ component cha tới component con, để tiếp tục xử lý.\n\n"},"50-til/51-Code/10-React/State-in-React":{"title":"🌱 State in React","links":["50-til/51-Code/10-React/Props-in-React"],"tags":["til","react"],"content":"🌿 What? §\n\nLà nơi lưu trữ dữ liệu được sử dụng chung cho các components trong React.\n\nNó cũng giống như một Global Variable, có thể sửa đổi giá trị ở bất kỳ file nào.\n\n\n\n🌿 Why? §\n\nVí dụ chúng ta cần hiển thị tổng số lượng click vào các buttons.\n\n\n🌿 Identify §\n\nCác đặc điểm không phải là State:\n\nBiến không thay đổi theo thời gian.\nBiến được truyền từ một parent thông qua props.\nCó thể tính toán được giá trị của biến dựa trên state đã có hoặc props trong component.\n\n\n"},"50-til/51-Code/11-Golang/Generic":{"title":"🌱 Generic in Golang","links":[],"tags":["golang"],"content":"\nCác function có thể được viết để sử dụng chung cho nhiều Type\n\nfunc Index[T comparable](s []T, x T) int {\n\tfor i, v := range s {\n\t\tif v == x {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n \nfunc main() {\n\t// Index works on a slice of ints\n\tsi := []int{10, 20, 15, -10}\n\tfmt.Println(Index(si, 15))\n \n\t// Index also works on a slice of strings\n\tss := []string{&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;}\n\tfmt.Println(Index(ss, &quot;hello&quot;))\n}\n \n// =&gt; 2\n// =&gt; -1"},"50-til/51-Code/11-Golang/Goroutines":{"title":"🌱 Goroutines","links":[],"tags":["golang"],"content":"\n\n\nKhía cạnh mạnh mẽ nhất của Go so với các ngôn ngữ lập trình khác chính là khả năng xử lý các methods độc lập và đồng thời.\n\n\nTrước đó, cần làm rõ, một process và một thread là gì.\n\n\n🌱 Process: hiểu đơn giản là một chương trình đang chạy trong máy tính.\n\n\n🌱 Thread: Là các luồng chạy bên trong một tiến trình.\n\n\n🌿 What? §\n\nLà một lightweight thread được quản lý bởi Go runtime.\nTrong bất kỳ một chương trình Golang nào, đều tồn tại ít nhất một Goroutine, gọi là main Goroutine. Nếu main goroutine kết thúc, toàn bộ các goroutones khác trong tiến trình cũng sẽ kết thúc ngay.\nGoroutine sử dụng tối ưu hơn Thread truyền thống rất nhiều.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThreadGoroutineĐược quản lý bởi hệ điều hành và phụ thuộc vào số nhân CPUĐược quản lý bởi go runtime và không phụ thuộc vào nhân CPUSize vùng nhớ stack cố địnhSize vùng nhớ stack linh động cấp phát theo khả năng sử dụngGiao tiếp khó, có độ trễ lớn trong tương tácSử dụng channel để tương tác với nhau, độ trễ thấpCó định danhKhông có định danhKhởi tạo và giải phóng tốn nhiều thời gianKhởi tạo và giải phóng bởi go runtime nên rất nhanh\n\n\n                  \n                  Câu hỏi? \n                  \n                \ngo runtime là cái gì mà nó có thể khởi tạo và giải phóng các goroutines nhanh như thế?\n\n🌿 Channel §\n\nLà chỗ lưu trữ vùng nhớ stack\n\nch := make(chan int)\n \nch &lt;- v // send v to channel ch\nv := &lt;-ch // receive value from ch and assign value to v\n\nĐể tránh việc ghi bừa phứa dữ liệu vào vùng nhớ stack, Go chỉ cho phép gửi value vào channel khi có chỗ lấy ra value đó.\n\nch := make(chan int)\nch &lt;- v\n// nếu không có chỗ nhận v, hệ thống sẽ báo fatal error\n// fatal error: all goroutines are asleep - deadlock!\n\nĐể giải quyết vấn đề này, có thể sử dụng channel buffering, nó cho phép chúng ta giới hạn giá trị có thể đưa vào channel mà không nhất thiết phải sử dụng.\n\nch := make(chan int, 3)\nch &lt;- 1\nch &lt;- 2\nch &lt;- 3\n\nKhi hết buffer, sử dụng close() để channel không nhận thêm dữ liệu nữa.\n\nfunc fibonacci(n int, c chan int) {\n\tx, y := 0, 1\n\tfor i := 0; i &lt; n; i++ {\n\t\tc &lt;- x\n\t\tx, y = y, x+y\n\t}\n\tclose(c)\n}\n \nfunc main() {\n\tc := make(chan int, 10)\n\tgo fibonacci(cap(c), c)\n\tfor i := range c {\n\t\tfmt.Println(i)\n\t}\n\tv, ok := &lt;-c\n\tfmt.Println(v, ok)\n}\n\nselect statement sẽ thực thi những communication đã sẵn sàng(có đưa vào channel và lấy ra)\n\nfunc fibonacci(c, quit chan int) {\n\tx, y := 0, 1\n\tfor {\n\t\tselect {\n\t\tcase c &lt;- x:\n\t\t\tx, y = y, x+y\n\t\tcase &lt;-quit:\n\t\t\tfmt.Println(&quot;quit&quot;)\n\t\t\treturn\n\t\t}\n\t}\n}\n \nfunc main() {\n\tc := make(chan int)\n\tquit := make(chan int)\n\tgo func() {\n\t\tfor i := 0; i &lt; 10; i++ {\n\t\t\tfmt.Println(&lt;-c)\n\t\t}\n\t\tquit &lt;- 0\n\t}()\n\tfibonacci(c, quit)\n}\n// print 0 -&gt; 34\n// quit\n\ndefault case sẽ được thực hiện khi không có case nào phù hợp.\n\nselect {\n\tcase &lt;-ch:\n\t\t// code\n\tcase &lt;-ch:\n\t\t// code\n\tdefault:\n\t\t//code\n}\n\nsync.Mutex cung cấp 2 methods giúp Lock và Unlock một goroutine. Được cung cấp từ package sync.\n\nimport (\n\t&quot;sync&quot;\n)\n \n// SafeCounter is safe to use concurrently.\ntype SafeCounter struct {\n\tmu sync.Mutex\n\tv  map[string]int\n}\n \n// Inc increments the counter for the given key.\nfunc (c *SafeCounter) Inc(key string) {\n\tc.mu.Lock()\n\t// Lock so only one goroutine at a time can access the map c.v.\n\tc.v[key]++\n\tc.mu.Unlock()\n}"},"50-til/51-Code/11-Golang/Race-Condition":{"title":"🌱 Race Condition","links":["50-til/51-Code/11-Golang/Goroutines"],"tags":["til","golang"],"content":"🌿 What? §\n\nRace condition là trường hợp xảy ra khi thiết bị hoặc hệ thống của chúng ta cố gắng thực hiện hai hay nhiều tiến trình xử lý tại một thời điểm trên cùng một resource(một biến, một vùng nhớ, …) dẫn đến những kết quả không chính xác.\nRace condition thường xảy ra khi hệ thống xử lý các tác vụ đồng thời như Goroutines trong Golang.\n\n\n🌿 Detecting Race Condition §\n\nTrước tiên, để xử lý Race Condition, chúng ta cần phải xác định hệ thống có đang tồn tại Race Condition hay không. Go đã chu đáo chuẩn bị sẵn data race detector, để sử dụng chúng ta chỉ cần thêm flag -race như sau:\n\n$ go test -race mypkg    // to test the package\n$ go run -race mysrc.go  // to run the source file\n$ go build -race mycmd   // to build the command\n$ go install -race mypkg // to install the package\n🌿 Solving with Golang §\n\nCó hai cách thường được sử dụng:\n🌱 Sử dụng channel: chuẩn Go, Go cung cấp channel để giao tiếp dữ liệu giữa các tiến trình nên việc đọc ghi dữ liệu vào channel sẽ không xảy ra race condition.\n\nimport sync\n \nvar wg sync.WaitGroup()\nfor tagDate := currentDate; tagDate.Before(eDate); tagDate = tagDate.AddDate(0, 0, 7) {\n\tc := make(chan string) \n\twg.Add(1)\n\tgo func () {\n\t\tdefer func () {\n\t\t\tclose(c)\n\t\t\twg.Done()\n\t\t}\n\t\t// Get API and return data\n\t\tc &lt;- data\n\t}()\n}\nwg.Wait()\n\nNhưng thực tế trong quá trình phát triển, đôi khi chúng ta muôn lưu giá trị vào một biến có type phức tạp chứ không phải channel. Ví dụ như:\n\nimport sync\n \ntype Calendar struct {\n\tHolidays []time.Time\n\tTimeSlots []*TimeSlot\n}\n \ntype TimeSlot struct {\n\tStart time.Time\n\tEnd time.Time\n}\nvar wg sync.WaitGroup()\nvar calendar Calendar\nfor tagDate := currentDate; tagDate.Before(eDate); tagDate = tagDate.AddDate(0, 0, 7) {\n\twg.Add(1)\n\tgo func () {\n\t\tdefer wg.Done()\n\t\t// Get API and return data\n\t\tcalendar = data.Calendar\n\t}()\n}\nwg.Wait()\n\n🌱 Nếu viết như trên chắc chắn sẽ dính race condition và cách fix đó là sử dụng sync.Mutex. Chúng ta có thể Lock và Unlock quá trình ghi dữ liệu vào một ô nhớ, tránh việc nhiều tiến trình cùng xử lý tại một thời điểm.\n\nimport sync\n \ntype Calendar struct {\n\tHolidays []time.Time\n\tTimeSlots []*TimeSlot\n}\n \ntype TimeSlot struct {\n\tStart time.Time\n\tEnd time.Time\n}\nvar wg sync.WaitGroup()\nvar mu sync.Mutex()\nvar calendar Calendar\nfor tagDate := currentDate; tagDate.Before(eDate); tagDate = tagDate.AddDate(0, 0, 7) {\n\twg.Add(1)\n\tgo func () {\n\t\tdefer wg.Done()\n\t\t// Get API and return data\n\t\tmu.Lock()\n\t\tcalendar = data.Calendar\n\t\tmu.Unlock()\n\t}()\n}\nwg.Wait()\n🌿 Refer §\n\nRace Detector\nWhat are race conditions in Golang?\n"},"50-til/51-Code/11-Golang/Slice-in-Golang":{"title":"🌱 Slice in Golang","links":[],"tags":["golang"],"content":"🌿 Overview §\n\nTrong Golang, độ dài của một array sẽ được coi là một phần của kiểu dữ liệu, vậy nên không thể thay đổi được.\n\narr := [3]int{1,2,3} // arr có kiểu dữ liệu là [3]int\n\n\nVì vậy, Golang cung cấp một thằng khác để giúp chúng ta sử dụng mảng thuận tiện hơn, đó là slice.\n\n\nSyntax khởi tạo giống với 1 array, nhưng không cần truyền độ dài, độ dài của slice sẽ bằng với số lượng phần tử khởi tạo.\n\n\nslice := []int{1,2,3,4,5}\n\nCó thể khởi tạo một slice nil\n\nslice := []int{}\n🌿 Slice mechanism §\n\n\n🌱 Khởi tạo một slice , Go đồng thời sẽ tạo một array và trỏ con trỏ tới array đó.\nslice có 2 chỉ số cần quan tâm:\n\nlength: số lượng của các phần tử tồn tại trong slice\ncapacity: khả năng mở rộng của slice\n\n\n\n\n// có thể khởi tạo 1 slice bằng func make\n// 5 =&gt; capacity\n// 3 =&gt; length\n// length &lt;= capacity, unless =&gt; error\nslice := make([]int, 3, 5)\n \n// length là số lượng ô nhớ có thể sử dụng luôn \nslice[0] = 1\nslice[1] = 10\nslice[2] = 20\n \nslice[3] = 30 // =&gt; panic: runtime error: index out of range [3] with length 3\n\n2 ô nhớ còn lại đã được khởi tạo trước đó nhưng không sử dụng trực tiếp như ở trên được mà phải append\n\nslice = append(slice, 30)\n\nslice = append(slice, 40)\n\n\nKhi hết thêm hết capacity, từ đây, mỗi khi append Go sẽ tạo một array mới với capacity + 1 và length + 1, copy các giá trị cũ và append thêm giá trị mới.\n\nslice = append(slice, 50)\n\n\n\n                  \n                  Lưu ý \n                  \n                \nCần để ý capacity của 1 slice, tránh việc slice không đủ capacity, mỗi lần thêm một phần tử mới sẽ ảnh hưởng đến performance của hệ thống.\n"},"50-til/52-Journey/52.02-Other/Cách-phân-biệt-rượu-giả":{"title":"🌱 Cách phân biệt rượu giả(kém chất lượng)","links":[],"tags":["til","journey"],"content":"🌿 What? §\n\n🌱 Theo TS. Nguyễn Duy Thịnh - Viện Công nghệ sinh học và Công nghệ thực phẩm, Đại học Bách khoa Hà Nội, rượu giả không được kiểm soát trên thị trường Việt Nam đa phần là loại rượu có pha chế **methanol - một loại cồn công nghiệp**.\n🌱 Cách phân biệt:\n\nĐổ 1 ít rượu ra lòng bàn tay rồi xoa xoa hai bàn tay vào nhau. Nếu hai bàn tay còn dính dính thì là rượu không tốt vì **andehit dầu Fugien**  còn đọng lại trong rượu. Rượu tốt sẽ  bay hơi hết khi có tác động của ma sát (cách này hợp lý, dễ áp dụng, để tết em thử).\nNgửi - nếu mùi cồn thơm cay nồng thì là rượu tốt (cách này hơi khó áp dụng).\nNếm - rượu chứa **methanol** vị sẽ hơi ngọt (cái này cũng khó).\nThử với lửa - nếu mẫu đốt lên lửa màu vàng thì là rượu chưa **methanol** .\nDùng giấy quỳ đỏ - nhúng giấy vào rượu 2-3 phút nếu giấy đổi màu xanh nước biển -&gt; bỏ ngay không chơi.\n\n\n\n🌿 Refer §\n\nNguồn: VTV24\n"},"50-til/52-Journey/52.02-Other/Khám-phá-Văn-hóa-&-Nghệ-thuật":{"title":"🌱 Khám phá Văn hóa & Nghệ thuật","links":[],"tags":["til","journey"],"content":"🌿 What? §\n\n🌱 https://artsandculture.google.com/\n🌱 Một trang web rất thú vị cho những ai có hứng thú tới Văn hóa &amp; Nghệ thuật. Google Arts &amp; Culture là một sáng kiến phi thương mại. GG đã kết nối với rất nhiều tổ chức văn hóa và các nghệ sĩ trên toàn thế giới để có được tài nguyên phong phú cho chủ đề này.\n\n\n\n                  \n                  Thông điệp \n                  \n                \nSứ mệnh của chúng ta, đó là bảo tồn và đưa những giá trị văn hóa&amp;nghệ thuật Thế Giới lên Internet để có thể tiếp cận đến bất kỳ ai, ở bất cứ đâu.\n\n\n🌱 Mình lưu cái này zô, khi nào đi du lịch ở đâu thì lên đây tìm hiểu trước, khè mọi người trong đoàn cho zui :v\n🌱 Mọi người có thể xem thử Dấu ấn của một vương triều nao mà có dịp đi Huế thì đỡ bỡ ngỡ 😆\nObsidian\n"},"50-til/53-Psychology/Prisoner’s-Dilemma":{"title":"🌱 Prisoner’s Dilemma","links":[],"tags":["til","game_theory"],"content":"🌿 What? §\n\n\n🌱 Prisoner’s Dilemma - Thế lưỡng nan của tù nhân là một thuyết trò chơi(game theory) dùng để nghiên cứu hành vi hợp tác của con người.\n🌱 Luật chơi đơn giản như sau: Có 2 người A và B cùng bị bắt vì tình nghi là băng cướp ngân hàng(do cảnh sát phát hiện 2 người họ có súng). Có 3 TH có thể xảy ra:\n\nNếu cả 2 cùng thú tội thì mỗi người sẽ ngồi tù 5 năm.\nNếu cả 2 cùng im lặng thì mỗi người sẽ chỉ ngồi tù 1 năm do tàng trữ vũ khí trái phép.\nNếu B khai báo và A im lặng thì B sẽ được thả còn A sẽ ngồi tù 20 năm và ngược lại.\n\n\n🌱 Đứng từ góc nhìn của A, nếu A im lặng thì ít nhất sẽ ngồi tù 1 năm, có thể là 20 năm nếu B khai báo. Còn khi A khai báo có thể sẽ được thả hoặc nhiều nhất chỉ phải ngồi tù 5 năm. -&gt; Vậy chọn khai báo vẫn là có lợi hơn đúng không?\n🌱 Có thể thấy trong trò chơi này, nếu là A, bất kể B có chọn phương án nào, việc chọn khai báo sẽ mang lại kết quả có vẻ tốt hơn cho bản thân. Và đương nhiên B cũng sẽ nghĩ như vậy -&gt; Với sự lựa chọn ích kỉ, cuối cùng thì mỗi người nhận 5 năm tù và đây không phải là kết quả tốt nhất mà cả 2 bên có thể đạt được.\n\n\n\n                  \n                  Note \n                  \n                \nTrong một nhóm, hợp tác sẽ mang lại lợi ích tổng thể tốt nhất cho tất cả. Tuy nhiên nó chỉ có thể tồn tại dựa trên sự tin tưởng và cùng hướng về lợi ích chung.\n\n\n🌱 Thuyết trò chơi này được dùng để nghiên cứu những quyết định liên quan đến lợi ích của những cá nhân hoặc tổ chức với nhau. Được áp dụng cho nhiều lĩnh vực như kinh tế, khoa học chính trị, tâm lý, …\n🌱 Ví dụ như thực tế trong lĩnh vực kinh doanh, thuyết sẽ được sử dụng để phân tích khả năng cạnh tranh thị trường, chiến lượng định giá sản phẩm hoặc hành vi của những doanh nghiệp có thị trường độc quyền.\n🌱 Năm 1980, Robert Axerold, một giáo sư chính trị trường đại học Michigan mời 14 nhà toán học và kinh tế học để chơi Prisoner’s Dilemma, mục đích để tìm ra chiến lược tốt nhất.  Kết quả là chiến thuật đơn giản của giáo sư Anatol Rapoport từ Đại học Toronto, Canada, đã dành được số điểm cao nhất. Chiến thuật tên là ăn miếng trả miếng(Tit For Tat), bao gồm 2 nguyên tắc:\n\nLượt đầu chọn hợp tác.\nTừ lượt sau chọn giống như đối thủ đã chọn ở lượt trước.\n\n\n\n\n\n                  \n                  Kết luận rút ra từ chiến thuật trên \n                  \n                \n\nLuôn hợp tác đầu tiên.\nTự vệ nhưng biết tha thứ(phản công khi đối thủ không hợp tác, hợp tác khi đối thủ hợp tác lại)\nLuôn duy trì hợp tác(không đố kị hay để lợi ích cá nhân tác động).\nLuôn phải nhớ, đối tác(đối thủ) cũng nắm được luật chơi.\n\n\n\n🌱 Ngoài ra mọi người có thể chơi thử game The evolution of Trust để có cái nhìn trực quan hơn về vấn đề này nhé.\n\n🌿 Refer §\n\nhttps://vi.wikipedia.org/wiki/Song_%C4%91%E1%BB%81_t%C3%B9_nh%C3%A2n\n"},"50-til/53-Psychology/Sự-ngụy-biện-của-tay-thiện-xạ-Texas":{"title":"🧠 Sự ngụy biện của tay thiện xạ Texas","links":[],"tags":["til","psychology"],"content":"🌿 What? §\nTên của lỗi tư duy này bắt nguồn từ một anh chàng cao bồi tập bắn vào tường của một căn nhà gỗ. Sau nhiều lần bắn, các vết đạn chi chít trên tường nhưng có chỗ thưa, có chỗ dày đặc. Anh chàng cao bồi đã vẽ các vòng tròn đồng tâm lên chỗ có nhiều vết đạn nhất, sau đó khoe rằng mình là một tay thiện xạ.\n\nĐây là cơ chế tâm lý phổ biến ở con người. Giống như anh chàng cao bồi, chúng ta cũng hay mắc phải lỗi tư duy áp đặt một trật tự có chủ ý lên một tập hợp phân bổ ngẫu nhiên.\n\n\n                  \n                  Một nửa cái bánh mỳ vẫn là bánh mỳ, nhưng một nửa sự thật chưa chắc đã là sự thật. \n                  \n                \n__  sưu tầm \n\nLỗi tư duy này mình thấy bên truyền thông rất hay sử dụng để điều hướng dư luận. Kiểu như một doanh nghiệp trước khi phát hành thêm cổ phiếu sẽ sử dụng truyền thông để đưa ra các thông tin tốt đẩy giá tăng cao. Thế nhưng tìm hiểu kĩ hơn thì tổng tài sản của công ty toàn là nợ sắp đáo hạn, họ chỉ muốn gọi vốn về trả nợ chứ không phải để mở rộng quy mô sản xuất. Hoặc gần gũi hơn là mạng xã hội chúng ta thường dùng. Thứ được đưa lên mạng xã hội là những gì họ muốn cho chúng ta thấy, xe quay lên thì đẹp cơ mà là xe thuê thì cũng … 😁\n\n\n                  \n                  Note \n                  \n                \nTránh bias, chủ động tìm thêm thông tin để có góc nhìn đầy đủ hơn.\n\nRefer §\nTrong cuốn Bạn không thông minh lắm đâu - David McRaney"},"50-til/54-Mindset/Lùi-lại-một-bước":{"title":"🌱 Lùi lại một bước ...","links":[],"tags":["til","mindset"],"content":"🌿 What? §\n\n\n                  \n                  Question \n                  \n                \nTheo bạn, khi nào là thời điểm tốt nhất để bắt đầu một ngày mới?\n\n\nTheo mình, thời điểm bắt đầu tốt nhất chính là ngay từ tối hôm trước, khi chúng ta chủ động chuẩn bị cho mình một giấc ngủ đủ và chất lượng thì tự khắc ngày hôm sau sẽ rất là chè tươi ✨\nKhi đi làm mình cũng có gặp nhiều hoạt động ảnh hưởng bởi tư tưởng này, đơn cử như 5Whys meeting khi một dự án có incident. Mục tiêu của buổi họp là tìm ra lý do gốc rễ gây ra incident. Để làm được điều đó, tất cả các thành viên cần đưa ra các câu hỏi - câu trả lời để dẫn từ ngọn(incident) đến lý do gốc.\n\n                    incident\n                   /        \\\n            lý do 1(issue)  lý do 2(issue)\n                   |          |\n            lý do 3(issue)  lý do 4(root)\n              .....................\n\n\nÁp dụng tư duy này vào các vấn đề trong cuộc sống, mình cần suy nghĩ lùi lại một hoặc nhiều bước trước khi đánh giá mọi việc. Tư duy này giúp chúng ta xác định rõ những vấn đề cũng như các bước cần chuẩn bị để đạt được kết quả tốt.\n"},"50-til/55-Math/Hàm-số-đường-thẳng-y=ax+b":{"title":"🌱 Hàm số đường thẳng y=ax+b","links":[],"tags":["til","math"],"content":"\nHàm số đường thẳng(Linear Function) có công thức là y=ax+b. Trong đó:\n\na: hệ số góc, hay còn gọi là độ dốc, thể hiện độ dốc của đường thẳng. Độ dốc phản ánh khả năng tăng/giảm của một đại lượng y so với đại lượng x.\n\nHệ số a &gt; 0, càng lớn thì độ dốc càng hướng lên trên.\nHệ số a = 0, độ dốc = 0, đường thẳng trùng với trục tung.\nHệ số a &lt; 0, càng nhỏ thì độ dốc càng hướng xuống dưới.\n\n\nb: điểm tung độ, là điểm mà đường thẳng cắt trục tung.\n\n\n\n\n\n\nCách vẽ cũ: (cách mình được học ở trường) khi muốn biểu diễn đường thẳng trên trục toạ độ, mình thường gán x vào hàm số =&gt; y để tìm 2 điểm.\n\nVd với hàm số trên hình, gán x = 0 -&gt; y(x) = 1, x = 2 -&gt; y(x) = 1. Sau đấy nối 2 điểm lại với nhau.\n\n\n\n🌱 Cách vẽ nhanh:\n\nb = 1 -&gt; có một điểm (0, 1)\na = 1/2\n\n∆x = 2, ∆y = 1 -&gt; x tăng lên 2 đơn vị thì y tăng 1 đơn vị.\nXét điểm (0, 1) -&gt; xác định được điểm thứ 2 là (2, 2).\n\n\n\n\n"},"index":{"title":"Homepage","links":["40123345-posts/46-Journey/Digital-garden-là-gì","tags/til","tags/ruby","tags/rails","tags/golang","tags/aws","40123345-posts/46-Book/Review-sách","tags/finance","40123345-posts/42-Code/42.01-Ruby/Display-Hardcode-Value"],"tags":[],"content":"\nHế lôôô 👋 Welcome to my digital garden 🌳.\nNếu đây là lần đầu tiên nghe đến thuật ngữ này, bạn có thể đọc về Digital garden là gì ở đây nha.\nCòn nếu bạn skip bài viết trên, thì ngắn gọn đây là nơi lưu lại những kiến thức, trải nghiệm của bản thân về những chủ đề mình cảm thấy thú vị ✍️.\nVì là một lập trình viên nên sẽ có nhiều bài viết thiên về code, ngôn ngữ lập trình mình có kinh nghiệm nhiều nhất là Ruby và Golang. Mọi người có thể tìm đọc theo các chủ đề dưới đây:\n\nTIL - Today I Learned là những ghi chú nhỏ, ghi lại những kiến thức mà mình thấy thú vị trong quá trình làm việc.\nRuby notes tổng hợp các ghi chú về Ruby.\nRails notes tổng hợp các ghi chú về Rails.\nGolang note tổng hợp các ghi chú về Golang.\nAWS note tổng hợp các kiến thức khi mình ôn thi SAA.\n\nReview sách là nơi mình viết lại cảm nhận của bản thân hay tóm tắt lại các ý chính của những cuốn sách mình đã đọc 📖.\nNgoài ra, mình cũng có hứng thú với chủ đề về kinh tế nữa 💸\nÀ nếu bạn cũng là một dev Ruby, hãy xem thử extension VsCode này nha, có thể nó sẽ giúp quá trình code của bạn tiện lợi hơn đoá 🙇\nMong là bạn sẽ có những trải nghiệm thú vị trên khu vườn của mình 🥳. See yaaa 👋"}}