{"/":{"title":"Home","content":"\n\n\u003ch1\u003e Hi there, I'm a Ruby Developer 👋\n\u003ch2\u003e Welcome to my blog!!!\n\n🌱 \u003ca class=\"homepage-list-link\" href=\"50-til/\"\u003eTIL\u003c/a\u003e","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/40123345-posts/42-Code/42.01-Ruby/RubyCritic":{"title":"🌳 RubyCritic","content":"![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020164959.png]]\n\n🌱 `RubyCritic` cung cấp báo cáo trực quan về những vấn đề như code thối, cấu trúc code, tính dễ kiểm tra, và độ phủ của test case cho app Ruby. \n\n🌱 Đang liên tục phát triển và release tính năng mới. Có trong danh sách [Ruby Awesome](https://github.com/markets/awesome-ruby#:~:text=Rubycritic%20%2D%20A%20Ruby%20code%20quality%20reporter.).\n\n🌱 Bài viết này sẽ giới thiệu về một số những lợi ích mà `RubyCritic` đem lại, các `dependencies` của nó và cách để đọc `code reports`.\n\n## 🌿Why?\n\n🌱 Bạn có thể xem xét sử dụng `RubyCritic` nếu muốn có một nơi có thể theo dõi sự phát triển của code trong dự án. Áp dụng `RubyCritic` vào process dự án chắc chắn sẽ giảm được thời gian của team dev cho việc khắc phục `Technical debts`. Hầu hết các `technical debts` đều sẽ được phát hiện sớm và 'trả nợ' trong giai đoạn phát triển luôn.\n\n\u003e technical debts là gì?\n\u003e ...\n\u003e ...\n\u003e ...\n\n🌱 Một số những lợi ích của `RubyCritic` khi chúng ta áp dụng cho dự án hay process phát triển:\n- Thống nhất thông tin về một nơi duy nhất.\n- Báo cáo trực quan\n- Cài đặt dễ dàng\n- Không config\n- Cho phép tùy chỉnh theo nhu cầu sử dụng\n- Có thể mở rộng - Là open-source chúng ta có thể tích hợp thêm tính năng của mình.\n- Một trình tạo huy hiệu.\n\nĐể hiểu hơn về cách `RubyCritic` hoạt động, hãy xem những `internal dependencies` được sử dụng để tạo một report mặt mũi như thế nào nhé!  \n\n## 🌿 Internal dependencies trong Rubycritic\n\n- Khi bạn thêm `RubyCritic`, một số dependencies cũng được thêm kèm. \n- Điểm qua những dependencies chủ chốt: `The Reek`, `Flay`, và `Flog`. Đây đều là những gem cho phép `RubyCritic` hiển thị những thông tin hữu ích liên quan đến những code của bạn. Hiểu được cách hoạt động của bọn này sẽ thuận tiện hơn trong việc sử dụng `RubyCritic`.\n\n### 🌱 Reek: Tìm code Ruby bốc mùi 💩\n\n- [Reek](https://github.com/troessner/reek) là một gem dùng để tìm những dòng code 💩 trong Ruby. Code thối không phải là code sai, nó là những dòng code có thể được viết dễ đọc hơn, dễ bảo trì hoặc phát triển hơn nhưng vẫn đúng logic với ban đầu.\n- Reek sẽ phân tích xem có chỗ nào bốc mùi nhưng sẽ không gợi ý là sửa như thế nào vì hầu như code 'có mùi' đều liên quan đến business logic hoặc dựa theo kinh nghiệm của lập trình viên đối với một ngôn ngữ lập trình.\n\n\u003e Reek chỉ đánh giá được theo hướng chủ quan, nên chúng ta cũng nên cân nhắc thêm dựa theo logic của dự án cũng như kinh nghiệm của bản thân trước khi quyết định sửa code.\n\n- Reek cung cấp  [extensive list of smells](https://github.com/troessner/reek/blob/master/docs/Code-Smells.md). Kiểm tra và chỉ ra những chỗ bốc mùi trong:\n\t- Classes\n\t- Attributes\n\t- Methods\n\t- Parameters\n\t- Moduldes\n\t- Iterators\n\t- The implementation of polymorphism\n\n- Nhờ đó chúng ta sẽ chủ động trong việc làm cho code dễ đọc và dễ bảo trì hơn.\n\n- Cho phép config để:\n\t- Tắt kiểm tra những rule ko phù hợp với dự án.\n\t- Chỉ định các thư mục không cần kiểm tra.\n\t- Sử dụng filter để tắt tiếng cảnh báo.\n\n### 🌱 Flay: Kiểm tra code lặp\n- [Flay](https://ruby.sadi.st/Flay.html) xác định những điểm tương đồng trong cấu trúc code, bao gồm:\n\t- Tìm ra code bị lặp lại trong dự án.\n\t- Cho điểm để đánh giá mức độ tốt của code(điểm càng thấp, code càng ngon).\n\t- Checking the difference at any code level.\n\n- Nếu Flay báo cáo có sự trùng lặp trong code, khả năng cao chúng ta nên sửa nó. Đừng  bỏ qua vì nó rất có khả năng dẫn đến bugs. Khi bạn fix thêm gì đó ở một chỗ nhưng quên sửa những chỗ còn lại thì có khả năng bug sẽ xuất hiện đó.\n\n```rb\n# lib/flay.rb:80\nopts.on(\"-m\", \"--mass MASS\", Integer, \"Sets mass threshold (default = #{options[:mass]})\") do |m|\n  options[:mass] = m.to_i\nend\n \n# lib/flay.rb:105\nopts.on(\"-t\", \"--timeout TIME\", Integer, \"Set the timeout. (default = #{options[:timeout]})\") do |t|\n  options[:timeout] = t.to_i\nend\n```\n\nKiểm tra:\n```bash\n$ flay lib/flay.rb\nTotal score (lower is better) = 36\n \n1) Similar code found in :iter (mass = 36)\n  lib/flay.rb:80\n  lib/flay.rb:105\n```\n\nMặc dù nội dung bên trong không giống nhau hoàn toàn nhưng cấu trúc code có thể được cấu trúc lại để tránh trùng lặp. Đó là magic của Flay.\n\n\u003e Flay đánh giá trùng lặp dựa trên cấu trúc code, nếu điểm trùng lặp càng thấp có nghĩa code chúng ta càng ngon(dry). Tuy nhiên, chúng ta vẫn cần đánh giá thêm cả về logic của dự án trước khi sửa nhé.\n\n### 🌱 Flog: Kiểm tra độ phức tạp trong code\n[Flog](https://ruby.sadi.st/Flog.html) kiểm tra xem độ phức tạp của code(code khó đọc). Flog gán điểm phức tạp cho từng dòng sau đó tính tổng cho mỗi method hoặc class.\n\n``` rb\ndef validate_expiration\n  return if exp_month.blank? || exp_year.blank?\n \n  ...\nend\n```\n\nKiểm tra:\n```sh\n$ flog app/models/credit_card.rb\n \n5.2: CreditCard#validate_expiration   app/models/credit_card.rb:12-15\n```\n\n\n- Độ phức tạp đang là 5.2, giờ mình sẽ sửa để nó dễ đọc hơn một chút\n\n```rb\ndef validate_expiration\n  return if exp_month.blank?\n  return if exp_year.blank?\n \n  ...\nend\n```\n\nKiểm tra:\n```sh\n$ flog app/models/credit_card.rb\n \n4.8: CreditCard#validate_expiration app/models/credit_card.rb:12-15\n```\n\n\u003e Viết code là trò chơi đơn giản, nhưng để viết code đơn giản, dễ hiểu thì lại khó nhất trên đời 😆 Đừng cố viết cao siêu làm gì, hãy viết code thật dễ hiểu, hiệu quả để những người đồng nghiệp đọc code của bạn không phải chửi thầm nhé ❤️  \n\n### 🌱 Other Dependencies \n- Ngoài ra `RubyCritic` còn có nhiều dependencies khác, có cả những gem phổ biến mà chúng ta vẫn thường dùng như `buybug`, `simpleCov`, `rubocop`. Mọi người có thể xem đầy đủ các dependencies ở [đây](https://github.com/whitesmith/rubycritic/blob/main/rubycritic.gemspec).\n\n\n## 🌿Áp dụng cho dự án Ruby on Rails\n\n- `RubyCritic` cung cấp tài liệu chi tiết để bắt đầu mà không cần config nhiều. Trong khuôn khổ bài viết này, chúng ta sẽ tập trung cho việc phân tích những thông số có trong những báo cáo của `RubyCritic`.\n- Có 3 vấn đề được báo cáo là `Code`, `Smells` và `Coverage`. Cùng lược qua từng tính năng này nhé!\n\n### 🌱 Overview\nSau khi chạy `rubycritic` xong, tự động redirect tới một trang html chứa các reports của dự án.\n\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020153521.png]]\n\n- Màn `Overview` hiển thị tổng điểm của dự án trên một cái biểu đồ donut, xếp hạng theo A là tốt nhất và F là tệ nhất.\n- Phần `Summary` hiển thị chi tiết của từng rating (A -\u003e F) bao gồm số lượng files, số lượng commit(churns) và số lượng smell code được tìm thấy.\n- `Churn vs Complexity` hiển thị vị trí các Class/Module là một điểm, ứng với 2 chỉ số độ phức tạp và số lượng commit =\u003e phản ánh chính xác những điểm chưa tốt của dự án.\n\n### 🌱 Code Report\n\n- Hiển thị điểm của từng Class/Module bao gồm `churn`, `complexity`, `duplication` and `smells`.\n- Bạn có thể sort theo từng chỉ số để tiện đánh giá.\n- Có thể search tên của Class/Module.\n\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020154211.png]]\n\n- Click vào một Class/Module bất kỳ sẽ hiển thị chi tiết source code và các số liệu đi kèm như:\n\t- Code line\n\t- Chất lượng code\n\t- Churn\n\t- Độ phức tạp của method\n\t- Điểm phức tạp(tổng của class)\n\t- Số lượng code bị duplicates.\n\t- Số lượng smells tìm thấy.\n\n- Những dòng code có vấn đề sẽ được highlight(Dựa theo thông tin cả Reek gem cung cấp)\n\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020155314.png]]\n\n\n### 🌱 Smells Report\n- Hiển thị smell type, vị trí chính xác nơi bốc mùi và tình trạng khắc phục.\n- Như đã nói ở trên, Smells được cung cấp bởi gem Reek, và màn này chúng ta cũng có thể search và sort được như `Code Report`.\n- Bạn có thể nhìn thấy các class/module được nhóm theo smell type.\n\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020162956.png]]\n\n### 🌱 Coverage Report\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020164032.png]]\n\n- Chỉ hiển thị thông số độ bao phủ của kiếm thử đối với những class/module. \n- Không thể sắp xếp hoặc tìm kiếm như 2 trang bên trên.\n- Nếu tích hợp `SimpleCov` thì sẽ chi tiết và trực quan hơn, nhưng với hầu hết trường hợp chỉ cần một báo cáo đơn giản để đánh giá độ phủ của dự án, `Coverage Report` đã hoàn toàn đáp ứng được rồi.\n\n## ☘️Tham khảo\n- https://github.com/whitesmith/rubycritic\n- https://blog.appsignal.com/2022/10/19/improve-code-in-your-ruby-application-with-rubycritic.html\n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/40123345-posts/42-Code/42.02-Vuejs/Vue3-Essentials":{"title":"🥦 Vue3 - Essentials","content":"\n## 🌿 I. Creating the Vue App\n\n- Tạo Vue App(được khởi tạo một lần, tất cả đều config ở đây).\n\n```js\nconst app = Vue.createApp({ // Heart of the Vue App\n  data() { // data option\n    return {\n      product: 'Socks'\n    }\n  }\n})\n```\n\n- Mount App to DOM - như ví dụ ở dưới, mount tới div tag có id là app, tất cả DOM element bao trong div đó sẽ có thể truy cập tới Vue App.\n\n```html\n\u003cscript\u003e\n  const mountedApp = app.mount('#app')\n\u003c/script\u003e\n```\n\n- Sử dụng [Mustache Syntax](https://vuejs.org/guide/essentials/template-syntax.html) để call dữ liệu từ Vue App.\n\n```html\n\u003ch1\u003e{{ product }}\u003c/h1\u003e\n```\n\n- Multiple application instances\n\n```js\nconst app1 = createApp({\n  /* ... */\n})\napp1.mount('#container-1')\n\nconst app2 = createApp({\n  /* ... */\n})\napp2.mount('#container-2')\n```\n\n- doc: https://vuejs.org/guide/essentials/application.html\n- pull https://github.com/anhnh-3008/Vue3/pull/1\n\n## 🌿 II. Template syntax\n\n1. Muốn call dữ liệu cho các attribute của DOM element, sử dụng **v-bind**.\n\n```html\n\u003cimg v-bind:src=\"image\"\u003e\n\n\u003c!-- Shorthand: --\u003e\n\u003cimg :src=\"image\"\u003e\n\n\u003c!-- Use cases: --\u003e\n\u003cimg :alt=\"description\"\u003e\n\u003ca :href=\"link\"\u003e\n\u003cdiv :class=\"isActive\"\u003e\n\u003cspan :style=\"isActive\"\u003e\n```\n\n2. Dynamically Binding Multiple Attributes\n\n```js\ndata() {\n  return {\n    objectOfAttrs: {\n      id: 'container',\n      class: 'wrapper',\n      disabled: 'false'\n    }\n  }\n}\n```\n\n```html\n\u003cdiv v-bind=\"objectOfAttrs\"\u003e\u003c/div\u003e\n\u003c!-- \u003cdiv id=\"container\" class=\"wrapper\" disabled=\"false\"\u003e\u003c/div\u003e --\u003e\n```\n\n3. Calling functions\n\n- Có thể gọi function trong **v-bind**, function chỉ được một lần khi init component nên không sử dụng cho những case cần data động như changing data hoặc triggering asynchronous operations.\n\n```html\n\u003cspan :title=\"toTitleDate(date)\"\u003e\n  {{ formatDate(date) }}\n\u003c/span\u003e\n```\n\n4. Dynamic Arguments\n\n```html\n\u003ca :[someAttr]=\"value\"\u003e ... \u003c/a\u003e\n```\n\n- **someAttr** - giá trị thay đổi theo data mount từ Vue App, với những giá trị phức tạp, có thể sử dụng **computed properties**, xem thêm ở mục VIII.\n\n5. Modifiers\n- Khái niệm hiểu như trong JQuery. Vd **.prevent** có nghĩa là `v-on` sẽ call `event.preventDefault()` trong quá trình trigger sự kiện.\n\n```html\n\u003cform @submit.prevent=\"onSubmit\"\u003e...\u003c/form\u003e\n```\n\n![[00 Meta/01 Attachments/Pasted image 20221225223906.png]]\n\n- doc: https://vuejs.org/guide/essentials/template-syntax.html\n- pull https://github.com/anhnh-3008/Vue3/pull/2\n\n\n## 🌿 III. Condition rendering\n\n- **v-show**: luôn render DOM element, condition chỉ toggle `display` CSS property \n- **v-if** - **v-eles-if** - **v-else**: đúng condition thì mới render DOM, logic giống với các ngôn ngữ lập trình khác.\n\n```html\n\u003cp v-if=\"condition\"\u003eCondition is true\u003c/p\u003e\n\u003cp v-else\u003eCondition is false\u003c/p\u003e\n```\n\n- So sánh **v-if** và **v-show**:\n\n|**v-if**|**v-show**|\n|----|--------|\n|Là chuẩn conditional rendering vì nó đảm bảo sẽ xóa và render lại toàn bộ listener events or components nằm trong block khi toggles điều kiện|Toggle điều kiện thì chỉ thay đổi duy nhất `display: none` thôi|\n|Lazy - chỉ render DOM khi condition == true|Luôn render DOM|\n|higher toggle costs - dùng với những điều kiện ít thay đổi|higher initial render costs - dùng với những element cần toggle điều kiện thường xuyên|\n\n- Khi **v-if** và **v-for** được sử dụng trên cùng một object, **v-if** sẽ được gọi đầu tiên.\n\n- doc: https://vuejs.org/guide/essentials/conditional.html\n- pull https://github.com/anhnh-3008/Vue3/pull/3\n\n## 🌿 IV. List rendering\n\n1. **v-for**: lặp một mảng.\n\n```html\n\u003cul\u003e\n  \u003cli v-for=\"user in users\"\u003e\n    \u003cp\u003e{{user.id}}\u003c/p\u003e\n    \u003cp\u003e{{user.name}}\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n```\n\n2. Nested loop:\n\n```html\n\u003cli v-for=\"item in items\"\u003e\n  \u003cspan v-for=\"childItem in item.children\"\u003e\n    {{ item.message }} {{ childItem }}\n  \u003c/span\u003e\n\u003c/li\u003e\n```\n\n3. Có thể dùng **of** thay **in**.\n\n```html\n\u003cdiv v-for=\"item of items\"\u003e\u003c/div\u003e\n```\n\n4. Ngoài mảng, có thể lặp Object, cơ chế lặp qua các keys base theo **Object.keys()**.\n\n```js\ndata() {\n  return {\n    myObject: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n}\n```\n\n```html\n\u003cul\u003e\n  \u003cli v-for=\"value in myObject\"\u003e\n    {{ value }}\n  \u003c/li\u003e\n\u003c/ul\u003e\n```\n\n5. for with a range\n\n```html\n\u003cspan v-for=\"n in 10\"\u003e{{ n }}\u003c/span\u003e\n```\n\n\n- doc: https://vuejs.org/guide/essentials/list.html\n- pull https://github.com/anhnh-3008/Vue3/pull/4\n\n## 🌿 V. Event handling\n\n- **v-on:event**: bắt sự kiện\n\n```html\n\u003c!-- shorthand: @event --\u003e\n\u003cdiv v-for=\"variant in variants\" :key=\"variant.id\" @mouseover=\"updateImage(variant.image)\"\u003e{{ variant.color }}\u003c/div\u003e\n\n\u003cbutton class=\"button\" @click=\"addToCart\"\u003eAdd to Cart\u003c/button\u003e\n```\n\n1. Inline handlers\n- Với logic ngắn, đơn giản có thể truyền thẳng.\n```js\ndata() {\n  return {\n    count: 0\n  }\n}\n```\n\n```html\n\u003cbutton @click=\"count++\"\u003eIncrease\u003c/button\u003e\n\u003cp\u003eCount is: {{ count }}\u003c/p\u003e\n```\n\n2. Method handlers\n- Logic dài + phức tạp thì có thể xử lý thông qua method\n```js\ndata() {\n  return {\n    count: 0\n  }\n},\nmethods: {\n  alertCount() {\n    if (count \u003e 0) {\n      alert('Count is positive');\n    } else {\n      alert('Count is negative');\n    }\n  }\n}\n```\n\n```html\n\u003cbutton @click=\"alertCount\"\u003eAlert\u003c/button\u003e\n```\n\n3. Event Modifiers\n- Chúng ta thường xuyên phải sử dụng event modifiers(chỉ định những common event ví dụ như không reload khi submit form, ...). Có thể định nghĩa  Event Modifiers trong method nhưng theo quan điểm của Vue, method chỉ để xử lý logic thôi. Nên trong Vue, chúng ta có thể chỉ định trực tiếp như sau:\n\n```html\n\u003c!-- the click event's propagation will be stopped --\u003e\n\u003ca @click.stop=\"doThis\"\u003e\u003c/a\u003e\n\n\u003c!-- the submit event will no longer reload the page --\u003e\n\u003cform @submit.prevent=\"onSubmit\"\u003e\u003c/form\u003e\n\n\u003c!-- modifiers can be chained --\u003e\n\u003ca @click.stop.prevent=\"doThat\"\u003e\u003c/a\u003e\n\n\u003c!-- just the modifier --\u003e\n\u003cform @submit.prevent\u003e\u003c/form\u003e\n\n\u003c!-- only trigger handler if event.target is the element itself --\u003e\n\u003c!-- i.e. not from a child element --\u003e\n\u003cdiv @click.self=\"doThat\"\u003e...\u003c/div\u003e\n```\n\n4. Key Modifiers\n- Khi xử lý event theo các keys đặc biệt, Vue cho phép chỉ định nhanh như sau:\n\n``` js\n\u003c!-- only call `submit` when the `key` is `Enter` --\u003e\n\u003cinput @keyup.enter=\"submit\" /\u003e\n```\n\n- Với TH xử lý combo(vd: Ctrl + Enter), Vue cho phép thực hiện thông qua 4 keys bắt đầu :\n\t- `.ctrl`\n\t- `.alt`\n\t- `.shift`\n\t- `.meta`\n\n```html\n\u003c!-- Alt + Enter --\u003e\n\u003cinput @keyup.alt.enter=\"clear\" /\u003e\n\n\u003c!-- Ctrl + Click, mặc định sẽ + với click --\u003e\n\u003cdiv @click.ctrl=\"doSomething\"\u003eDo something\u003c/div\u003e\n```\n\n- `exact` - xem vd\n\n```html\n\u003c!-- chỉ cần có ấn ctrl (có thể là ctrl + shift) method sẽ được gọi --\u003e\n\u003cbutton @click.ctrl=\"onClick\"\u003eA\u003c/button\u003e\n\n\u003c!-- chỉ gọi method khi hệ thống nhận duy nhất key ctrl --\u003e\n\u003cbutton @click.ctrl.exact=\"onCtrlClick\"\u003eA\u003c/button\u003e\n\n\u003c!-- chỉ gọi method khi hệ thống không có event modifiers nào --\u003e\n\u003cbutton @click.exact=\"onClick\"\u003eA\u003c/button\u003e\n```\n\n- doc: https://vuejs.org/guide/essentials/event-handling.html\n- pull https://github.com/anhnh-3008/Vue3/pull/5\n\n## 🌿 VI. Class \u0026 Style binding\n\n### 🌱 Class binding\n\n- **:class**: xử lý tên class\n\n```html\n\u003cbutton class=\"button\"\n:class=\"{ disabledButton: inventories \u003c= 0 }\"\n:disable=\"inventories \u003c= 0\"\u003eAdd to Cart\u003c/button\u003e\n```\n\n1. Binding to Object\n-  Ngoài cách truyền điều kiện boolean như trên, có thể truyền object để dễ quản lý.\n```js\nconst classObject = reactive({\n  active: true,\n  'text-danger': false\n})\n```\n\n```html\n\u003cdiv :class=\"classObject\"\u003e\u003c/div\u003e\n\n\u003c!-- render --\u003e\n\n\u003cdiv class=\"active text-danger\"\u003e\u003c/div\u003e\n```\n\n2.  Binding to Array\n- Truyền một mảng, kết quả cũng giống bên trên.\n```js\nconst activeClass = ref('active')\nconst errorClass = ref('text-danger')\n```\n\n```html\n\u003cdiv :class=\"[activeClass, errorClass]\"\u003e\u003c/div\u003e\n```\n\n\u003e [!note] Note\n\u003e \n\u003e Trong doc có giới thiệu inline handle nhưng mình thấy không hợp lý lắm, có gì cần xử lý logic cứ nhét hết vào file Js, trong HTML để biến boolean thôi.\n\n3. With Components\n- Chỉ định `:class` cho component sẽ merge cho những class của child DOMs trong component(những DOM có define class)\n```html\n\u003c!-- child component template --\u003e\n\u003cp class=\"foo bar\"\u003eHi!\u003c/p\u003e\n\n\u003c!-- when using the component --\u003e\n\u003cMyComponent class=\"baz boo\" /\u003e\n\n\u003c!-- child rendered will be --\u003e\n\u003cp class=\"foo bar baz boo\"\u003eHi\u003c/p\u003e\n```\n\n- `class` của component được lưu trong biến `$attrs`, có thể chỉ định trực tiếp cho child DOM:\n\n```html\n\u003c!-- child component template --\u003e\n\u003cp :class=\"$attrs.class\"\u003eHi!\u003c/p\u003e\n\n\u003c!-- when using the component --\u003e\n\u003cMyComponent class=\"baz\" /\u003e\n\n\u003c!-- child rendered will be --\u003e\n\u003cp class=\"baz\"\u003eHi\u003c/p\u003e\n```\n\n### 🌱 Style binding\n\n- **:style**: xử lý style\n\n```html\n\u003cdiv\nclass=\"color-circle\"\n:style=\"{ backgroundColor: variant.color }\"\n\u003e\u003c/div\u003e\n```\n\n1. Giống với Class, cũng nhận Object và Array\n2. Support cả camelCase và kebab-cases(để trong nháy kép)\n\n```html\n\u003c!-- camelCase --\u003e\n\u003cdiv :style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"\u003e\u003c/div\u003e\n\n\u003c!-- kebab-cases --\u003e\n\u003cdiv :style=\"{ 'font-size': fontSize + 'px' }\"\u003e\u003c/div\u003e\n```\n\n- doc: https://vuejs.org/guide/essentials/class-and-style.html\n- pull: https://github.com/anhnh-3008/Vue3/pull/6\n\n## 🌿 VII. Computed Properties\n\n- Các thuộc tính cần dùng thêm logic để tính toán, khai báo trong **computed**.\n```js\nconst app = Vue.createApp({\n  data() {\n    return {\n      product: 'Socks'\n    }\n  },\n  computed: {\n    productWithBrandTilte() {\n      return 'Brand Vue - ' + this.product // Brand Vue - Socks\n    }\n  },\n})\n```\n\n- Tại sao không dùng function mà phải dùng computed làm gì?\n\n|Computed property|Function|\n|--------------------|---------|\n|cache dựa trên **reactive dependencies**, như vd trên nếu product không thay đổi khi gọi lại sẽ return ngay lập tức|không cache, luôn gọi lại getter|\n\n### 🌱 Best practice\n\n1. Chỉ nên tính toán, xử lý trả về giá trị, đừng có nhét cả logic thay đổi DOM hay gọi bất đồng bộ lấy dữ liêu, ... Trách nhiệm duy nhất của computed chính là tính toán và trả về giá trị - S(Single Responsibility Principle) in SOLID.\n2. Tránh trực tiếp thay đổi giá trị computed. Chỉ nên thay đổi những variables nằm trong logic xử lý của computed property.\n\n- doc: https://vuejs.org/guide/essentials/computed.html\n- pull: https://github.com/anhnh-3008/Vue3/pull/7\n\n## 🌿 VIII. Component basic\n\n### 🌱 Components\n\n-  Cho phép chia UI thành những phần nhỏ độc lập, có khả năng tái sử dụng, dễ quản lý hơn.\n- Không chỉ nhóm các DOM elments, Vue còn cho phép đóng gói dữ liệu, logic cho từng **component**.\n\n![[00 Meta/01 Attachments/Pasted image 20230103092932.png]]\n\n-  Defining a component:\n\n```js\napp.component('product-detail', {\n  // options\n  template:, // define DOM elements\n  data() {return {} }, // define data\n  methods {}, // define methods\n  computed {}, // define computed properties\n})\n```\n\n```html\n\u003cproduct-display\u003e\u003c/product-display\u003e\n\n\u003c!-- Import Component --\u003e\n\u003cscript src=\"./components/ProductDisplay.js\"\u003e\u003c/script\u003e\n```\n\n- Có thể sử dụng lại nhiều lần một **component**, mỗi khi một **component** được khởi tạo, toàn bộ data, computed properties sẽ được tạo mới, độc lập không liên quan gì đến nhau. Nếu muốn trigger đến một biến chung cho những **components** con, hãy define **variable** ở **component** cha và truyền vào **component** con thông qua **props**.\n\n### 🌱 Props\n\n- **Props** - Là option chỉ định những tham số nhận từ thằng cha vào **component**.\n- Ví dụ một trang web bán hàng có nhiều sản phẩm, nếu sản phẩm được gắn **premium** thì sẽ free ship ngược là phí ship sẽ là 2.99$. Biến **premium** sẽ dùng chung cho nhiều sản phẩm cùng category nên chúng ta sẽ define **premium** riêng và truyền vào **component** sản phẩm.\n\n```js\nconst app = Vue.createApp({\n  data() {\n    return {\n      premium: false\n    }\n  }\n})\n```\n\n```html\n\u003cproduct-display :premium=\"premium\"\u003e\u003c/product-display\u003e\n\n\u003c!-- Import Component --\u003e\n\u003cscript src=\"./components/ProductDisplay.js\"\u003e\u003c/script\u003e\n```\n\n```js\napp.component('product-detail', {\n  // define property recieve from parent component\n  props: {\n    premium: {\n      type: Boolean,\n      required: true\n    }\n  }\n  template:, // define DOM elements\n  data() {return {} }, // define data\n  methods {}, // define methods\n  computed {\n    shipping() {\n      if (this.premium) return 'free'\n      \n      return '2.99$'\n    }\n  }\n})\n```\n\n- doc: https://vuejs.org/guide/essentials/component-basics.html\n- pull: https://github.com/anhnh-3008/Vue3/pull/8\n\n### 🌱 Communicating events\n\n- Trong quá trình phát triển, TH chúng ta muốn method trong **component** con tương tác được với varibale define trong **component** cha, có thể giao tiếp thông qua `$emit`.\n\n```html\n\u003c!-- index.html --\u003e\n\u003cproduct-display @add-to-cart=\"updateCart\"\u003e\u003c/product-display\u003e\n\n\u003c!-- Import Component --\u003e\n\u003cscript src=\"./components/ProductDisplay.js\"\u003e\u003c/script\u003e\n```\n\n```js\n// main.js\nmethods: {\n  updateCart() {\n    this.cart += 1\n  }\n}\n```\n\n```js\n// ProductDisplay.js\ntemplate:\n  /*html*/\n  `\u003cbutton\n  class=\"button\"\n  @click=\"addToCart\"\u003e\n  Add to Cart\n  \u003c/button\u003e`,\nmethods: {\n  addToCart() {\n    this.$emit('add-to-cart')\n    // this.$emit('add-to-cart', params)\n  }\n}\n```\n\n- doc: https://vuejs.org/guide/essentials/component-basics.html#listening-to-events\n- pull: https://github.com/anhnh-3008/Vue3/pull/9\n\n## 🌿 X. Form Input Bindings \n\n- **v-model** - liên kết element trong form tới các biến trong data.\n\n```html\n\u003cp\u003eMessage is: {{ message }}\u003c/p\u003e\n\u003cinput v-model=\"message\" placeholder=\"edit me\" /\u003e\n```\n\n- doc: https://vuejs.org/guide/essentials/forms.html\n- pull: https://github.com/anhnh-3008/Vue3/pull/10","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/40123345-posts/42-Code/42.02-Vuejs/What-is-Vue":{"title":"🥦 What is Vue?","content":"\n## 🌿 What is Vue?\n\n![[00 Meta/01 Attachments/Pasted image 20221224114448.png]]\n- Vuejs là một open source Javascript framework hướng tới việc xây dựng giao diện người dùng(UI), được tạo ra bởi [Evan You](https://twitter.com/youyuxi?lang=en). Như trên [Landing page](https://vuejs.org/) có giới thiệu, Vuejs là một phiên bản cấp tiến của Javascript framework với những đặc điểm nổi bật như dễ tiếp cận, linh hoạt và hiệu quả. \n\n## 🌿 Why use it?\n\n### 🌱 Progressive - Cấp tiến\n\n- Vue được công nhận là **progressive** vì nó thường có thể scale down cũng như up. Với đa số những trường hợp sử dụng phổ thông, chúng ta có thể tích hợp Vue như jQuery - thêm một script tag như sau: \n\n```html\n\u003cscript src=\"https://cdn.jsdelivr.net/npm/vue\"\u003e\u003c/script\u003e\n```\n\n- Khi nhu cầu sử dụng của chúng ta phát triển, Vue cũng sẽ cung cấp thêm những công cụ có trong hệ sinh thái giúp nâng cao hiệu quả sử dụng. \n  \n### 🌱 Approachable - Dễ tiếp cận\n\n- Vue rất dễ tiếp cận miễn là chúng ta có hiểu biết HTML, CSS, và JS tiêu chuẩn. Vậy là bạn có thể bắt đầu làm việc với Vue được rồi. \n\n### 🌱 Versatile - Linh hoạt\n\n![[00 Meta/01 Attachments/Pasted image 20221224114549.png|80%]]\n\n- Vue linh hoạt vì xung quanh thư viện có đầy đủ các tools support, muốn dùng gì thì mình tích hợp thêm, chứ không cần phải cài hết một lượt. Các tools phổ biến:\n\t- [vue-cli](https://cli.vuejs.org/) (i.e. Vue Command Line Interface) - như cli của những framwork khác, cho phép giao tiếp nhanh cong với Vue app.\n\t- [vue-router](https://router.vuejs.org/) - chỉ định routes giao tiếp dễ dàng giữa client-side và server-side.\n\t- [vuex](https://vuex.vuejs.org/guide/) - hỗ trợ quản lý dữ liệu.\n\t- [vue-test-utils](https://vue-test-utils.vuejs.org/) - cung cấp đa dạng các helpers cũn như functions hỗ trợ chúng ta trong quá trình viết UT.\n\n- Các tools trên đều được created and maintained bởi chính đội Vue core nên việc tích hợp sẽ vẫn là trơn chu, mượt mà.\n  \n### 🌱 Performant - Hiệu quả\n\n![[00 Meta/01 Attachments/Pasted image 20221224120158.png]]\n\n- Cuối cùng, Vue hiệu quả vì nó tận dụng virtual DOM để có được thời gian re-render lại cực nhanh. Thư viện lõi của Vue cũng được phát triển với tiêu chí là tối ưu hiệu suất.\n\n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/40123345-posts/42-Code/CSS-Learning":{"title":"🥦 CSS Learning","content":"\n## 🌿 Resources\n1. [CSS- Tricks]([https://css-tricks.com/snippets/css/](https://css-tricks.com/snippets/css/))\n\n## 🌿 Refer \n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/40123345-posts/43-Psychology/T%C6%B0-duy-nhanh-v%C3%A0-ch%E1%BA%ADm":{"title":"📘 Tư duy nhanh và chậm","content":"\n---\n\nChào mọi người, thời tiết hôm nay nó cứ bị mưa mưa, mát mẻ làm mình lười viết về mấy bài công nghệ khô khan quá =)) Chắc để đổi gió nay mình sẽ viết về quyển sách mà dạo này mình đang đọc nha. Quyển sách này giúp chúng ta nhìn cách vận hành suy nghĩ một cách rất dễ hiểu thông qua những diễn đạt của tác giả - một người đã dành cả cuộc đời để nghiên cứu về Tâm lý học hành vi.\n\n![[00 Meta/01 Attachments/tu-duy-nhanh-va-cham.png]]\n\n## Tác giả\n---\n`Daniel Kahneman` sinh năm 1934, nhà Tâm lý học người Mỹ gốc Israel, giành giải Nobel kinh tế năm 2002. Ông dành cả đời để nghiên cứu về Tâm lý học hành vi. Cùng với người động sự đã qua đời là Amos Tversky, hai ông đã có những nghiên cứu sâu sắc về con đường tư duy và nhận thức của con người.\n\nCuốn sách đã dành được nhiều giải thưởng danh giá như: Sách khoa học hay nhất của Học viện Khoa học Quóc gia năm 2012, Sách hay nhất nhất năm 2011 do Thời Báo New York bình chọn, cuốn sách được quan tâm nhất năm 2021 của tạp chí Los Angeles. \n## Nội dung\n---\nXuyên suốt quyển sách hai khái niệm được nhắc đến nhiều nhất đó là `Hệ Thống 1` và `Hệ Thống 2`. Hai nhân vật chính này là xuất phát điểm cho tất cả những suy nghĩ, quan sát, hành vi, trải nghiệm, hay quyết định, ... của mỗi chúng ta.\n`Hệ Thống 1` hoạt động với cơ chế suy nghĩ nhanh, tự động, cảm tính, bản năng, rập khuôn và kiểu giác quan thứ 6 mà chị em phụ nữ hay được trải nghiệm =))\n`Hệ Thống 2` thì ngược lại, suy nghĩ chậm, sở hữu sự điềm tĩnh, logic, tính toán, ý thức và đòi hỏi một sự nỗ lực khi hoạt động.\n\nKhông phải tự nhiên mà ca sĩ Tóc Tiên đã hát:\n\t`Chọn con \u003c3 hay là nghe lý trí, chọn yêu anh hay chọn phút giây biệt ly.`\n\nPhần lớn chúng ta thường lười kích hoạt `Hệ Thống 2`, để mặc cho `Hệ Thống 1` 'tự do tác oai tác quái' :D. Bạn nhớ lại xem bạn đã từng đột nhiên nổi hứng lên mua một món đồ đắt tiền nhưng khi nhận về bạn lại bỏ xó. Nếu tại thời điểm nổi hứng đó `Hệ Thống 2` xuất hiện có phải đã tốt hơn rồi không =))) Nhưng nếu chúng ta kích hoạt liên tục `Hệ Thống 2` thì sao? Cẩn thận bộ não của bạn sẽ bị quá tải đấy =)) 'Hội trầm cảm sau sinh' sẽ ko quên mời bạn gia nhập đâu :D   \n\nChúng ta luôn luôn suy nghĩ, lựa chọn, quyết định với mọi vấn đề trong cuộc sống và những điều đó đôi khi sẽ thay đổi cả cuộc đời của chính chúng ta hay nhiều người khác nữa. Hiểu được các cơ chế hoạt động, tránh được `những lỗi sai hệ thống` là điều vô cùng cần thiết. Cuốn sách này sẽ giúp chúng ta hiểu được những 'dòng chảy' của não bộ, hai Hệ Thống giao tiếp với thế giới xung quanh ntn, ... từ đó giúp chúng ta sẽ phần nào hiểu được năng lực tư duy của chính mình và phát huy nó một cách hiệu quả \u003c3\n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/40123345-posts/44-Finance/9-sai-l%E1%BA%A7m-t%C3%A0i-ch%C3%ADnh-c%E1%BB%A7a-ng-tr%E1%BA%BB":{"title":"💵 9 sai lầm tài chính của ng trẻ","content":"\n## 🌱 9 sai lầm tài chính của người trẻ\n\n![[00 Meta/01 Attachments/Pasted image 20221021224059.png]]\n\n### Nguồn\n- https://www.youtube.com/watch?v=2EyGqvZrbyc\u0026ab_channel=HieuNguyen\n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/40123345-posts/44-Finance/C%C4%83ng-th%E1%BA%B3ng-B%E1%BA%A5t-an":{"title":"🥶 Giai đoạn căng thẳng \u0026 Bất an","content":"\n✍️ Các kiến thức trong bài viết này được tổng hợp từ những chia sẻ của chú Hiếu Nguyễn trong [podcast](https://www.youtube.com/watch?v=rqtDSOCUEj0\u0026list=PL1bLXQ3Ow2laRk3IFEqbDLM_l6YHNPp8W\u0026index=3\u0026ab_channel=HieuNguyen).\n\n## 🌿 Nợ nần (level ⚠️) \n\n🌱 Thường sẽ là giai đoạn xuất phát điểm của các bạn trẻ bên nước ngoài. Vì bên này họ phát triển tư duy tự lập từ rất sớm, nên khi học đại học, các sinh viên sẽ phải tự trả số tiền học của mình. Nhưng vì hầu như các bản trẻ lúc này chưa có bất kỳ khoản tích lũy nào nên chính phủ sẽ hỗ trợ cho vay , khoản vay này có tên là [Student Loan](https://en.wikipedia.org/wiki/Student_loan)\n- Khoản nợ này ở Mỹ có thể lên đến vài chục nghìn đô.\n- Thường sẽ mất vài năm, có thể lâu hơn mới có thể trả được hết món nợ này.\n\n\u003e Là món nợ lớn.\n\n## 🌿 Ăn bám gia đình (level 0️⃣)\n\n🌱 Tự bản thân chưa nuôi được mình, phụ thuộc hoàn toàn vào chu cấp của gia đình.\n\n🌱 Nên đi làm sớm để biết **Quý trọng đồng tiền**. Từ đó có thể dần dần hình thành cảm nhận về tài chính =\u003e Nền tảng để xây dựng về sau.\n\n\u003e Đến năm 18 tuổi, nên kiếm việc làm thêm(phù hợp, lương thấp xíu cũng được). \n\u003e Cố gắng chuyển sang level 1️⃣ sớm nhất có thể.\n\n## 🌿 Tự nuôi bản thân (level 1️⃣)\n\n🌱 Tự làm được tiền, nuôi bản thân, không phụ thuộc vào gia đình nữa.\n\n🌱 Sống theo kiểu có tháng nào tiêu hết tháng đó. Có rất nhiều người chỉ dừng lại ở bước này đến cuối đời.\n\n🌱 Tiềm ẩn rủi ro bị lùi về level 0️⃣ hoặc tệ hơn level ⚠️. Khi bản thân có tiền, nếu không có cách quản lý tài chính hợp lý + tâm lý có thể dùng lương để trả thì rất có thể sẽ bị vướng vào nợ nần - báo nhà :v\n\n\u003e Rất bấp bênh, không thể xử lý được các biến cố bất ngờ xảy ra(mất việc, đau ốm, có việc đột xuất, ...). Có thể tụt level bất cứ lúc nào.\n\u003e \n\u003e Đạt được level này, hay ngay lập tức chuyển qua giai đoạn tiếp theo đó là [[40123345 posts/44 Finance/Theo dõi \u0026 Kiến tạo| Theo dõi \u0026 Kiến tạo]]\n\n## ⛔ Ảnh hưởng của nợ nần\n\nCó 2 kiểu nợ phổ biến:\n\n### 🌱 Nợ không có lãi suất\n- Thường sẽ là nợ người thân, bạn bè. Mà để từ level 1️⃣ về đến level ⚠️ thì chúng ta cũng đã phải nợ nhiều nguồn, nhiều tiền rồi.\n- Không trả được đúng hạn =\u003e Mất uy tín.\n- Nhiều quá không trả nổi =\u003e Mất tư cách.\n\n\u003e Cái mất nhiều nhất chính là mất những mối quan hệ chất lượng.\n\n### 🌱 Nợ có lãi suất\n\nLoại này thì lại có 2 kiểu =))\n\n- Nợ tử tế\n\t- Nợ kiểu vay ngân hàng, nợ tín dụng =\u003e lãi suất cao, thường sẽ là 2%-4%/tháng =\u003e ~24%-42%/năm 😱.\n\n- Nợ không tử tế\n\t- Vay nóng, nợ xã hội đen, ... thì thôi 🥵 \n\n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/40123345-posts/44-Finance/Each-step-to-the-Financial-Freedom":{"title":"🗺️ Each step to the Financial Freedom","content":"\n![[00 Meta/01 Attachments/Pasted image 20221119163052.png]]\n\n📂 Ảnh được lấy từ [podcast](https://www.youtube.com/watch?v=GlUvl-MWn6E\u0026list=PL1bLXQ3Ow2laRk3IFEqbDLM_l6YHNPp8W\u0026index=2\u0026ab_channel=HieuNguyen) của chú Hiếu Nguyễn và bài viết này là tổng hợp những kiến thức mà chú đã chia sẻ trong podcast đó.\n\nNhư đã thấy ở bức ảnh trên, có bốn cột mốc chính đánh dấu cho từng giai đoạn trong hành trình ***Tự do tài chính***. \n\n## 🌿 [[Căng thẳng \u0026 Bất an]]\n\n🌱 Nợ nần: trạng thái thấp nhất (level ⚠️) \n- Đây thường sẽ là xuất phát điểm của hầu hết các bạn trẻ bên nước ngoài. Khi ra trường họ sẽ phải gách 1 món nợ - [Student Loan](https://en.wikipedia.org/wiki/Student_loan)\n- Còn ở VN thường sẽ có xuất phát điểm ở cột mốc thứ 2\n\n🌱 Ăn bám gia đình (level 0️⃣)\n- Chưa có gì trong tay, phụ thuộc hoàn toàn vào gia đình.\n\n🌱 Tự nuôi bản thân (level 1️⃣)\n- Bắt đầu có thu nhập và có thể tự nuôi bản thân nhưng vẫn theo kiểu lương tháng nào tiêu hết tháng đấy.\n\n\u003e Điểm chung ở giai đoạn này là bản thân sẽ luôn ở trong trạng thái căng thằng và bất an. Nếu có những biến cố(mất việc, ốm đau, ...) xảy ra sẽ hoàn toàn không có khả năng đối ứng được.\n\n## 🌿 [[Theo dõi \u0026 Kiến tạo]]\n\n🌱 Theo dõi chi tiêu (level 2️⃣ - trạng thái hiện tại của tôi)\n-  Theo dõi chi tiết từng chi tiêu hàng ngày của bản thân. Từ đó tính toán được mức ***Chi tiêu tối thiểu*** và ***Chi tiêu tiêu chuẩn***. \n- Bước này cực kì quan trọng, 2 mức độ chi tiêu xác định được ở trên sẽ là tiền đề để chúng ta tính toán những cột mốc tiếp theo.\n- Hiện tại tôi đã và đang tập hình thành thói quen lưu lại chi tiêu hằng ngày bằng app Money Lover.\n\n\u003e Tạo cho bản thân thói quen theo dõi chi tiêu. Các mức chi tiêu sẽ thay đổi theo thời gian nên thói quen này vô cùng quan trọng.\n\u003e \n\u003e Xác định được mức ***Chi tiêu tối thiểu*** và ***Chi tiêu tiêu chuẩn***. \n\nSau quá trình **theo dõi** 👀, tiếp đến sẽ là **hành động** 👷‍♂️.\n\n🌱 Xóa nợ (level 3️⃣)\n- Là nền móng quan trọng để chúng ta có thể xây dựng vững chắc mô hình tài chính của bản thân sau này. \n- Ở level này, chúng ta cần xác định những khoản nợ xấu, khoản nợ tốt, thứ tự ưu tiên của từng khoản nợ. Kết hợp với kết quả của việc theo dõi chi tiêu =\u003e Có một kế hoạch rõ ràng cho việc trả nợ dứt điểm.\n- Đừng nóng vội khi vừa muốn trả nợ vừa muốn tích góp và vừa muốn đầu tư. Bạn sẽ phải hối hận vì phải xử lý nhiều những tasks khó cùng một lúc đấy.\n\n\u003e Tâm lý thoải mái, không lo đến nợ nần nữa, tập trung hoàn toàn tâm trí cũng như nguồn tiền cho việc xây dựng tài chính cá nhân.\n\nTrả nợ đời xong rồi thì tập trung xây dựng mô hình tài chính của bản thân thôi 💪\n\n🌱 Setup dòng tiền (level 4️⃣)\n- Không nên để tiền ở một chỗ, dễ dẫn đến việc tiêu tiền lấn sang những quỹ có mục đích khác.\n- Ở bước này chúng ta sẽ thiết lập Dòng chảy cho nguồn tiền của bản thân. Tiếp cận những định nghĩa mới như Quỹ Khẩn Cấp (Emergency Fund), Rainy Day Fund, Every Day Fund, Saving Account, ... được sử dụng như thế nào? Cách xác định tỉ lệ cho từng quỹ là bao nhiêu?\n- Sau khi Setup xong, tôi có thể xác định được runway của mình là bao nhiêu. Khi có biến cố, chất lượng cuộc sống của tôi vẫn được đảm bảo trong thời gian bao lâu. \n\n\u003e Tạo ra một hành lang an toàn về tài chính cho bản thân. Tránh bản thân gặp phải những bất an khi có biến cố xảy đến.\n\u003e \n## 🌿 Tích lũy \u0026 Đầu tư (Well Building)\n\nMượn cách ví von của [Kevin O'Leary](https://en.wikipedia.org/wiki/Kevin_O%27Leary) - một trong những Shark xuất hiện trong chương trình Shark Tank của Mỹ chia sẻ:\n\u003e Tôi coi tiền của mình là những chiến binh 💂. Mỗi ngày tôi thả những chiến binh của mình ra trận và cuối ngày tôi muốn những chiến binh đó sẽ đem lại cho mình thật nhiều tù binh 💵💵💵.\n\nSau khi đạt được level 4️⃣, chúng ta đã xây dựng được một hậu phương vững chắc. Công việc bây giờ sẽ là tuyển mộ quân sĩ để bắt đầu ra trận chinh chiến ⚔️.  \n\n🌱 Trương mục đầu tư (level 5️⃣)\n- Xây dựng trương mục đầu tư và có cho mình những phương châm để quản lý những trương mục này.\n\n🌱 Thu nhập thụ động (Passive Incomes - level 6️⃣)\n- Xây dựng và phát triển những nguồn thu nhập thụ động.\n\n\u003e Level 5️⃣ \u0026 6️⃣ sẽ đi liền với nhau, giúp chúng ta chiêu mộ thêm nhiều binh lính 💂 (gia tăng nguồn vốn).\n\u003e Nguyên tắc căn bản của giai đoạn này đó là tăng thu và giảm chi.\n\n![[00 Meta/01 Attachments/Pasted image 20221119225431.png]]\n\nSau 2 level trên, khi đã tích lũy được một nguồn vốn nhất định, bây giờ chúng ta có thể chuyển qua bước **Đầu tư**.\n\n🌱 Đầu tư (level 7️⃣)\n- Tìm cách chọn những mô hình đầu tư hiệu quả.\n- Học hỏi, trau dồi, nâng cao kiến thức, kinh nghiệm đầu tư.\n\n\u003e Ở gian đoạn này, chúng ta có thể xen kẽ thực hiện các bước với nhau, không cần tuần tự như giai đoạn 2.\n\u003e Giai đoạn này sẽ là giai đoạn dài hơi nhất trong hành trình.  Liên tục tích góp và đầu tư thì sẽ đến lúc chúng ta sẽ bước đến giai đoạn thứ 4(tôi không muốn dùng từ giai đoạn cuối cùng vì đây không phải là điểm kết thúc).\n\n## 🌿 Tự do tài chính\n\nCó 3 cột mốc khi chúng ta đạt đến giai đoạn `chính quả` này, đó là:\n\n🌱 An toàn tài chính (Finacial Security - level 8️⃣)\n- Có được số tiền có thể đảm bảo mức sống cơ bản của bản thân cho đến cuối đời, kể cả khi chúng ta vì một lý do nào đó mà không thể làm việc được nữa.\n- Có quyền bỏ đi(ở mọi lĩnh vực)\n\n🌱 Độc lập tài chính (Financial Independence - level 9️⃣)\n- Khái niệm FIRE - Financal Independence Retire Early - Ngưng làm việc nhưng vẫn đáp ứng được những nhu cầu liên quan đến tài chính theo mức chúng ta mong muốn.\n\n🌱  [[40123345 posts/44 Finance/What is the Financial Freedom?|Tự do tài chính]]  (Financial Freedom - level 🔟)\n- Khi đã ở level 9️⃣ đủ lâu chúng ta sẽ dần cảm nhận được sự tư do khi không phải lệ thuộc vào tiền bạc.\n- Lúc này tiền sẽ là công cụ để chúng ta thực hiện những mục tiêu khác.\n-  Có thể tự tin nói: ***Fuckyou Money!!!***\n\n\n \n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/40123345-posts/44-Finance/Stock-and-related-stuff":{"title":"🥦 Stock and related stuff","content":"\n### 🌿 Các khái niệm\n- 🌱 Giả sử mình có một ý tưởng kinh doanh, ban đầu mình sẽ xoay vốn từ người thân trong gia đình, bạn bè để hiện thực hóa ý tưởng kinh doanh đó. Sau một thời gian phát triển, mô hình kinh doanh của mình có kết quả vô cùng khả quan và mình muốn mở rộng nó ra hơn nữa. Nhưng lúc này, số tiền mình cần lại quá lớn, không thể vay từ người thân, bạn bè như lúc đầu nữa nên mình đã vay vốn ngân hàng hoặc từ các quỹ đầu tư. Lúc này các bên cho vay sẽ cần mình thế chấp tài sản hoặc như Shark Tank, mình sẽ phải đổi 10% **cổ phần** để lấy 500.000$ để tiếp tục phát triển doanh nghiệp.\n\n![[00 Meta/01 Attachments/Pasted image 20221203213542.png]]\n\n\u003e [!info] Cổ phần (Share)\n\u003e \n\u003e  Là phần vốn nhỏ nhất của một công ty. Vốn điều lệ của một công ty cổ phần được chia thành nhiều phần bằng nhau được gọi là cổ phần.\n\n\n- 🌱 Cơ mà sau đấy công ty lại càng tiềm năng và mình tham vọng 😎 muốn mở rộng nó ra phạm vi cả nước, xa hơn là toàn cầu nên số tiền 500.000$ là không đủ. Lúc này mình cần phải tìm đến nơi có nguồn vốn dồi dào hơn - đó là sàn chứng khoán. Có hai cách tăng vốn đó là sử dụng:\n\t- 💰 Công cụ vốn (**Cổ phiếu - Stock**)\n\t- 💰 Công cụ nợ (Trái phiếu - Bond)\n\n\u003e [!info] Cổ phiếu (Stock)\n\u003e \n\u003e  Cổ phiếu hay vốn cổ phần, là một loại **chứng khoán** đại diện cho việc sở hữu một phần của tổ chức phát hành.\n\n![[00 Meta/01 Attachments/Pasted image 20221203205809.png]]\n\n\u003e [!info] Chứng khoán (Security)\n\u003e\n\u003e Là một bằng chứng tài sản hoặc phần vốn của tổ chức phát hành. Chứng khoán có thể là Cổ phiếu, Trái phiếu, Chứng chỉ quỹ và các hình thức khác.\n\n- 🌱 Lúc này, mình sẽ phải liên tục chia nhỏ ra thành nhiều **cổ phần** để các **cổ đông** có thể sở hữu, qua đó mình sẽ nhận được thêm tiền để đầu tư và phát triển các dự án mới. \n\n![[00 Meta/01 Attachments/Pasted image 20221203220524.png]]\n\n\u003e [!info] Cổ đông (Shareholder)\n\u003e \n\u003e  Cổ đông là những người nắm giữ cổ phần của công ty. Cổ đông nắm giữ càng nhiều cổ phần thì sẽ càng có sức ảnh hưởng đến đường lối phát triển hoặc các quyết định của công ty.\n\n- 🌱 Sau đó, doanh nghiệp của mình làm ăn có lãi, mình sẽ trả cho những **cổ đông** của mình một số tiền thưởng - gọi là **cổ tức**.\n\n\u003e [!info] Cổ tức (Dividend)\n\u003e \n\u003e  Là một phần lợi nhuận sau thuế được chia cho các cổ đông. Có thể là tiền hoặc cổ phiếu.\n\n\n### 🌿 Phân loại cổ phiếu\n\n- 🌱 **Cổ phiếu thường(common) 💢 Cổ phiếu ưu đãi(preferred)**\n\t- Phân loại theo luật\n\n| **Cổ phiếu thường(common)** | **Cổ phiếu ưu đãi(preferred)**|\n|---------------- | ---------------|\n|Sở hữu cổ phần doanh nghiệp|Sở hữu cổ phần doanh nghiệp|\n|**Có** quyền biểu quyết tương đương với sổ cổ phần nắm giữ|**Không có** quyền biểu quyết tương đương với sổ cổ phần nắm giữ|\n|Được nhận cổ tức thường|Được nhận cổ tức thường + cổ tức ưu đãi|\n\n- 🌱 **Cổ phiếu tăng trưởng(growth stock) 💢 Cổ phiếu giá trị(value stock)**\n\t- Phân loại theo cổ tức\n\n| **Cổ phiếu tăng trưởng(growth stock)** | **Cổ phiếu giá trị(value stock)**|\n|---------------- | ---------------|\n|Là những cổ phiếu thuộc các tổ chức có khả năng tăng trưởng mạnh trong thời gian ngắn sắp tới|Là những cổ phiếu thuộc các tổ chức đã lớn tuổi, hướng đến sự ổn định bền vững|\n|Rủi ro cao|Ổn định|\n|Lợi nhuận lớn|Lợi nhuận trung bình|\n|Sử dụng lợi nhuận để tái đầu tư|Nhận được cổ tức|\n|Là những công ty phát triển lĩnh vực mới(như sinh học, FinTech, AI,...)|Là những tổ chức thâm niên trên thị trường như Hòa Phát, Vin, ...|\n\n- 🌱 **Cổ phiếu Large Cap/Bluechip 💢 Cổ phiếu Mid Cap 💢 Cổ phiếu Small Cap/Penny 💢 Cổ phiếu Micro Cap**  \n\t- Phân loại theo vốn hóa thị trường\n\n| **Name** | **Volumn** |\n| --------------- | --------------- |\n| **Large Cap/Bluechip** | 10,000 \u003e= Vốn hóa \u003e 1,000 tỷ|\n| **Mid Cap** | 10,000 \u003e= Vốn hóa \u003e 1,000 tỷ|\n| **Small Cap/Penny** | 1,000 \u003e= Vốn hóa \u003e 100 tỷ |\n| **Micro Cap** | 100 tỷ \u003e= Vốn hóa |\n\n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/40123345-posts/44-Finance/The-4-Rule":{"title":"🗺️ The 4% Rule","content":"![[00 Meta/01 Attachments/Pasted image 20221118220330.png]]\n🌱 Quy tắc 4% trong lĩnh vực tài chính cá nhân được sử dụng để xác định tương đối 3 cột mốc quan trọng trong hành trình [[40123345 posts/44 Finance/What is the Financial Freedom?|Tự do tài chính]], đó là:\n- An toàn tài chính (Financial Security)\n- Độc lập tài chính (Financial Independent)\n- Tự do tài chính (Financial Freedom)\n\n## 🌿What?\nQuy tắc 4% được hình thành trong quá trình nghiên cứu và phân tích thị trường trong suốt 75 năm của William P. Bengen. Ông nhận ra rằng trong chu kì 30 năm, 90% các nhà đầu tư có thể bảo toàn được tài sản của mình nếu mỗi năm rút ra 4% trong tổng số đó, cùng với với mức lạm phát trung bình là 3%.\n\n## 🌿 Issue\nTuy nhiên, vẫn có điểm yếu đối với quy tắc này. Theo Bob Dockendorff - chuyên gia tư vấn tài chính cá nhân người Mỹ, Phó chủ tịch Công ty tư vấn tài chính Claro Advisors đã nêu ra khá nhiều điểm bất cập có thể bị ảnh hưởng như:\n- Mức lạm phát hiện nay biến động vô cùng khó đoán\n- Các yếu tố vĩ mô như suy thoái kinh tế, biến động chính trị(Nga X Ucraina), bệnh tật(Covid 19), ...\n\n\u003e Chính vì vậy, chúng ta cần chuẩn bị những phương án quản lý số tiền của mình một cách hợp lý hơn.\n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/40123345-posts/44-Finance/Theo-d%C3%B5i-Ki%E1%BA%BFn-t%E1%BA%A1o":{"title":"✍️ Giai đoạn Theo dõi \u0026 Kiến tạo","content":"\n✍️ Các kiến thức trong bài viết này được tổng hợp từ những chia sẻ của chú Hiếu Nguyễn trong [podcast](https://www.youtube.com/watch?v=lKhIompb0M0\u0026list=PL1bLXQ3Ow2laRk3IFEqbDLM_l6YHNPp8W\u0026index=4\u0026ab_channel=HieuNguyen).\n\n## 🌿 Theo dõi chi tiêu (level 2️⃣ )\n\n🌱 Là bước quan trọng nhất! Nếu trong toàn bộ hành trình, chỉ làm duy nhất một bước theo dõi chi tiêu thì nó chắc chắn vẫn sẽ ảnh hưởng rất lớn đến vấn đề tài chính cá nhân của chúng ta.\n\n###  Bước 1 - Ghi lại chi tiêu\n\n🌱 Sử dụng một app điện thoại(hay bất cứ tool gì tiện nhất) như tôi đang sử dụng Money Lover để ghi chú lại tất cả những chi tiêu hàng ngày của mình. Cấu trúc ghi chú:\n- Ngày.                     Vd: 2022-11-20 \n- Mục đích chi tiêu. Vd: Đổ xăng\n- Số tiền.                  Vd: 70,000\n\n\u003e Quan trọng nhất là ghi chép đầy đủ tất cả chi tiêu. Từ đó mới có đủ dữ liệu để chúng ta đánh giá cho những bước tiếp theo.\n\n### Bước 2 - Phân loại chi tiêu\n\n🌱 Sử dụng Excel thống kê toàn bộ dữ liệu chi tiêu của chúng ta đã log lại theo từng tháng. Cấu trúc thống kê:\n\n![[00 Meta/01 Attachments/Pasted image 20221120145932.png]]\n\n- **Must have**: Các khoản thiết yếu, bắt buộc phải chi tiêu.\n- **Nice to have**: Các khoản có thì tốt mà không có cũng chả làm sao.\n- **Wasted**: Chi tiêu lãng phí, không có mục đích(Ăn nhậu, mua sắm linh tinh, ...).\n\n\u003e Nên làm ít nhất 1 tháng, lí tưởng là vài tháng. Phân loại càng lâu sẽ cover được càng đầy đủ những chi tiêu của chúng ta\n\n🌱 ***Chi tiêu tối thiểu*** =  **Must have**\n\n🌱 ***Chi tiêu tiêu chuẩn*** = **Must have** + **Nice to have**\n\nNếu trong sheet phân loại của chúng ta không có dòng nào là trả nợ, thì chúng ta có thể skip qua bước tiếp theo.\n\n## 🌿 Trả nợ (level 3️⃣)\n\nTháng trước do ăn cơm Thố nhiều quá nên tôi có dùng ví trả sau Momo, mà tôi trả xong rồi nên trộm vía giờ tôi đang không có khoản nợ nào cả 😆.\n\nNhưng kiến thức không thừa, xem trước để nếu sau này có ăn cơm Thố quá liều thì còn biết đường mà trả nợ. Let's gooo 💪!!\n\n![[00 Meta/01 Attachments/Pasted image 20221120152632.png]]\n\n### Bước 1 - Tách nguồn tiền\n \n 🌱 Setup thành 2 nguồn tiền\n - **Everyday account**: là số tiền phục vụ cho chi tiêu tối thiểu của bản thân(= **Must have**)\n - **Emergency Fund**:  quỹ khẩn cấp, theo đúng tên gọi, trong giai đoạn này, khẩn cấp nhất chính là trả nợ.\n\n\u003e Nên tách riêng ra 2 tài khoản ở hai ngân hàng, cho cái quỹ Emergency khuất mắt đi, không nghĩ gì đến nó nữa.\n \n### Bước 2 - Xác định các khoản nợ \u0026 Đánh độ ưu tiên\n- Lãi suất cao trả trước.\n- Cố gắng sống ở mức tối thiểu, chỉ tập trung trả nợ thôi.\n\n## 🌿 Setup dòng tiền (level 4️⃣)\n\n🌱 Setup thành 4 tài khoản:\n\n![[00 Meta/01 Attachments/Pasted image 20221120155605.png]]\n\n### 💰 Everyday Account\n- Mỗi tháng sẽ để ở đây mức sống tối thiểu.\n- Ép bản thân chỉ được chi tiêu với số tiền trong tài khoản này thôi.\n\n### 💰 Emergency Fund\n- Quỹ khẩn cấp dùng khi có những việc bất khả kháng như mất việc, bệnh tật, ...\n- Ưu tiên đổ đầy quỹ khẩn cấp trước tiên(nếu có những nguồn thu nhập khác sẽ đổ vào đây trước, khi đầy rồi mới đổ vào những quỹ tiếp theo).\n- ***Target*** = ***Chi tiêu tối thiểu*** x ***runway***(số tháng quỹ cover)\n\n\u003e Tối thiểu là 6 tháng, lý tưởng là 12 tháng.\n\n### 💰 RainyDay Fund\n- Quỹ dùng cho những việc có kế hoạch trước như mua điện thoại mới, sửa nhà, ...\n- Có 2 kiểu xác định ***target*** cho quỹ này:\n\t- Dựa theo kế hoạch, ví dụ như xác định trước cần mua điện thoại 30tr, sửa nhà 50tr, chúng ta sẽ set **target** cho RainyDay Fund là 80tr\n\t- Dựa theo runway. Nếu chúng ta chưa có kế hoạch gì thì có thể set ***target*** với runway từ 3-6 tháng x ***Chi tiêu tối thiểu***.\n\n### 💰 Investment Account\n- Không có ***target*** cho tài khoản này. Bỏ tiền vào càng nhiều càng tốt.\n\n\u003e Ở giai đoạn này, bất cứ khi nào chúng ta có thêm nguồn thu nhập, ngay lập tức phân phối tiền theo mô hình đã setup ở trên. Hạn chế tối đa việc để tiền rảnh ở ***Everyday Account*** nếu không muốn hối hận khi thấy tiền nó cứ bay đi mất 💸\n\u003e \n\u003e Sau giai đoạn này chúng ta đã có thêm quyền lựa chọn. Vd nếu môi trường làm việc hay công việc hiện tại không còn chất lượng, chúng ta hoàn toàn có thể xin nghỉ 👋, bỏ ra vài tháng để tìm cho mình công việc tốt hơn.\n\u003e \n\u003e ✨ Loại bỏ cảm giác bất an, có đủ khả năng đối ứng với những biến cố trong cuộc sống.","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/40123345-posts/44-Finance/Vai-tr%C3%B2-c%E1%BB%A7a-ti%E1%BB%81n":{"title":"🥦 Vai trò của tiền","content":"\n## 🌿 Câu chuyện\n\n![[00 Meta/01 Attachments/Pasted image 20221217160714.png]]\n\n![[00 Meta/01 Attachments/Pasted image 20221217161149.png]]\n\n![[00 Meta/01 Attachments/Pasted image 20221217164030.png]]\n\n- Loài người đã sử dụng mô hình trên trong hàng ngàn năm. Cách để chúng ta tồn tại và hạnh phúc đó là:\n\t- Hiểu rõ giá trị của mình là gì.\n\t- Biết được nhu cầu thực sự của bản thân.\n\t- Tìm được thị trường phù hợp.\n\t- Đạt được thỏa thuận tốt, win-win giữa hai bên.\n\n\u003e [!info] Note\n\u003e \n\u003e Bản chất, Tiền không tồn tại!\n\n## 🌿 Vấn đề về trao đổi\n\n![[00 Meta/01 Attachments/Pasted image 20221217175513.png]]\n\n- Vấn đề:\n\t- Giá trị của Mea không phù hợp với nhu cầu của Fru.\n\t- Khi Mea có nhiều thịt nhưng chưa có nhu cầu, nếu cứ tích góp lâu dần thịt sẽ bị kém chất lượng.\n\n\u003e [!Info] Tiền\n\u003e \n\u003e Loài người đã phát mình ra tiền để làm vật trao đổi trung gian.\n\n- Nếu muốn hiểu thêm về khái niệm của tiền, mọi người có thể xem ở [đây](https://vi.wikipedia.org/wiki/Ti%E1%BB%81n).\n\n![[00 Meta/01 Attachments/Pasted image 20221217184857.png]]\n\n\u003e [!info] Giá trị\n\u003e \n\u003e Tiền có thể là Giá trị, nhưng Giá trị chưa chắc đã là tiền! \n\n\n## 🌿 Tiền đã làm thay đổi mọi thứ\n\n![[00 Meta/01 Attachments/Pasted image 20221217191232.png]]\n\n![[00 Meta/01 Attachments/Pasted image 20221217192115.png]]\n\n![[00 Meta/01 Attachments/Pasted image 20221217194353.png]]\n\n![[00 Meta/01 Attachments/Pasted image 20221217213754.png]]\n\n![[00 Meta/01 Attachments/Pasted image 20221217220651.png]]\n\n![[00 Meta/01 Attachments/Pasted image 20221217220913.png]]\n\n## 🌿Ngẫm\n\n- Câu chuyện trên không có ý nói Tiền là xấu nhưng Tiền có khả năng chi phối chúng ta nếu chúng ta không có đủ khả năng để kiểm soát nó.\n- Suy cho cùng Tiền cũng chỉ là công cụ giúp cho quá trình vận hành trao đổi được thuận tiện hơn. Để không lệ thuộc vào Tiền hãy quay về mô hình nguyên thủy và phát huy những giá trị cốt lõi.\n\t1. Xác định được đúng giá trị của bản thân.\n\t2. Biết được nhu cầu thật sự của mình là gì.\n\t3. Tìm được đúng thị trường để trân trọng những giá trị và đáp ứng được những nhu cầu của chúng ta.\n\t4. Tạo ra những thỏa thuận chất lượng, thể hiện giá trị bản thân một cách trung thực đáp ứng được nhu cầu của người khác trên thị trường. Từ đó thỏa mãn những nhu cầu thật sự của bản thân.\n\n\u003e [!info] Biết đủ\n\u003e \n\u003e “Biết đủ” chính là cách nắm giữ hạnh phúc trong tay.\n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/40123345-posts/44-Finance/What-is-the-Financial-Freedom":{"title":"🗺️ What is the Financial Freedom?","content":"\n\u003e 🚀 Khi bắt đầu muốn tìm hiểu bất kì lĩnh vực gì, chúng ta nên có thói quen chủ động đặt ra 2 câu hỏi `What?` và `Why?` trước khi thực sự theo đuổi. Trong suốt hành trình đó, liên tục làm rõ câu hỏi `How?`. \n\u003e \n\u003e Câu hỏi `How?` thường sẽ mất rất nhiều thời gian, chúng ta cần có nhiều trải nghiệm, kinh nghiệm để đúc kết. Quá trình này có thể là một vài năm, chục năm hay có khi là cả đời. Chính vì vậy làm rõ  `What?` và `Why?` thật sự quan trọng nếu không chúng ta sẽ lãng phí thời gian và công sức của mình. \n\u003e \n\u003e 🌱 What? : làm rõ cái chúng ta muốn thực hiện, theo đuổi là gì?\n\u003e \n\u003e 🌱 Why? : tại sao chúng ta nên thực hiện, theo đuổi nó, chúng ta sẽ \n\u003e nhận được gì?\n\u003e \n\u003e 🌱 How? : tôi cần làm như thế nào để cải thiện kết quả?\n \n## 🌿 What?\n\u003e 🤔 Tự do tài chính là gì?\n\n![[00 Meta/01 Attachments/Pasted image 20221119145610.png]]\n\n🌱 Theo ý hiểu ở thời điểm hiện tại của tôi, ***tự do tài chính*** là trạng thái đạt được khi chúng ta đã thoát khỏi sự ràng buộc của đồng tiền. \n\n🌱 Tiền sẽ là công cụ để chúng ta thực hiện những mục tiêu khác.\n\n🌱 Là khi chúng ta có thể tự tin nói: \n\u003e Fuckyou Money 😏😏😏\n\n\n## 🌿 Why?\n\u003e 🤔 Tại sao tôi phải bỏ ra rất nhiều thời gian và công sức để đạt được ***Tự do tài chính***?\n\n\u003e Đồng tiền không có xấu. Chỉ có 2 sự lựa chọn: ***Mình quản lý Tiền*** hoặc ***Tiền quản lý Mình***.\n\n🌱 Không phải Tự do tài chính là **~~Sự giàu có~~**. Gốc rễ thật sự của hành trình này chính là ***Tự Do***. Đây là thứ xa xỉ nhất mà đến cả những người có rất nhiều tiền cũng chưa chắc đã có được. \n\n🌱 Lúc này đồng tiền chỉ là công cụ giúp chúng ta thoải mái hơn trong mọi quyết định mà thôi.\n\n🌱 Là hành trình giúp chúng ta thay đổi và trau dồi mindset.\n\n🌱 Mang lại chất lượng cho cuộc sống - một cuộc đời đáng sống.\n\n## 🌿 How?\n\u003e 🤔 Làm thế nào để đạt đuợc ***Tự do tài chính***?\n\n🌱 Loại bỏ những lối suy nghĩ sai lệch về tài chính.\n- Đánh đồng chi tiêu phóng khoáng và chi tiêu không có kiểm soát.\n- Không có quản lý chi tiêu, lương tháng nào tiêu hết tháng đấy.\n- Cẩn thận khi chưa kịp ***Giàu*** đã ***Già***.\n\n🌱 Trang bị kiến thức:\n- **Mindset \"biết đủ\"**.\n- **Escape Velocity** - Vận tốc thắng được trọng lực của Trái Đất để có thể đưa được vệ tinh ra ngoài vũ trụ. Trong lĩnh vực tài chính, **là một con số (dựa trên [[40123345 posts/44 Finance/The 4% Rule|The 4% Rule]] thắng được sức cản của đồng tiền** giúp chúng ta mở rộng danh sách lựa chọn của bản thân(Tự do).\n- [[40123345 posts/44 Finance/Each step to the Financial Freedom|Xác định từng cột mốc nhỏ]] cho hành trình này.","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/40123345-posts/45-Mindset/L%C3%A0-%C4%91%C3%A0n-%C3%B4ng-...":{"title":"🥦 Là đàn ông ...","content":"\n*Vì thấy hay nên mình lưu lại để đối chiếu với những trải nghiệm của cá nhân sau này. Nguồn lầy từ [post này](https://ngochieu.com/neu-ban-la-dan-ong/) của chú Hiếu Nguyễn, chú đã dịch từ một bài viết của Tiến sĩ Lý Khai Phục ([Kai-Fu Lee](http://en.wikipedia.org/wiki/Kai-Fu_Lee)) – ông từng là Phó tổng giám đốc Microsoft toàn cầu trong thập kỷ 90, rồi đảm nhận Phó tổng giám đốc Google châu Á năm 2005. Ông sinh năm 1961 tại Đài Bắc, thường gây sóng gió bởi những phát ngôn sáng suốt nhưng ngôn từ trần trụi khó nghe*\n\n🌿 Nếu bạn là đàn ông, nếu bạn đã hai mươi, nhưng bạn chưa hai lăm tuổi, bạn buộc phải tìm được một thứ gì đó ngoài tình yêu, giúp đôi chân bạn đứng vững vàng trong cuộc đời này. Bạn phải bắt đầu nghĩ cách để kiếm ĐỦ và sống ĐƯỢC.\n\nTôi chưa từng bao giờ nghĩ bằng cấp là thứ quan trọng, thiên tài với danh nhân đâu phải từ lò luyện và trường lớp mà ra. Nhưng nếu bạn không học tới nơi tới chốn, thì dù có đi làm cửu vạn, ngay cả bao cát cũng sợ rằng chẳng biết cách mà vác.\n\nBạn buộc phải làm cho những suy nghĩ văn vẻ và cảm xúc màu mè thị dân của mình dần trở thành lối tư duy sáng sủa, rõ ràng và những ngôn từ giản tiện ngắn gọn. Bởi những thứ màu mè và bồng bột sẽ không thể tồn tại lâu. Bạn phải biết rằng, những sự thích thú khi khi đọc văn hay, nghe lời bay bướm mang lại sẽ chẳng mấy giá trị, trong khi thứ quan trọng nhất lại nằm ở trí tuệ, tinh thần, tâm hồn, nội dung, tư duy của bạn.\n\nLà đàn ông, làm ơn đừng đọc văn của những nhà văn nữ cùng thời với bạn.\n\nLà đàn ông, làm ơn đừng trách người khác, đừng nhỏ nhặt, làm ra vẻ đáng thương.\n\nLàm ơn đừng nghĩ đến cái gì là viết về cái đó.\n\nVà chớ tiếc rẻ đôi chút cảm động bé nhỏ, đôi chút thương xót nhỏ nhoi.\n\nBạn phải tin vào cái đẹp, tin vào hơi ấm, vào lòng tin con người, sự tự trọng của mỗi người, bạn hãy giữ gìn những phẩm chất xưa cũ này. Tôi không muốn bạn bốc đồng, vô vị, mù mờ, chà đạp chính mình và làm thương tổn người khác. Bạn không nên nhào nặn đời bạn thành một đống hỗn độn tổng hợp đủ thứ.\n\nKhi bạn thay đổi con người bạn, hãy cố nâng niu những giá trị bản thân, cho dù bạn biết rõ, không phải ai cũng ưa những gì bạn đang có.\n\nLàm ơn đừng chấp nhận thỏa hiệp với những con người đang ngụy trang là họ thức thời, cấp tiến. Họ chỉ là những kẻ vô công rồi nghề đang tìm cách biện minh cho sự thua kém của bản thân họ. Sự mạnh mẽ, bản lĩnh đàn ông nằm ở tận trong trái tim bạn, bạn có sức mạnh và vẻ đẹp từ trong tim, từ niềm tin mà dù thời gian và tuổi trẻ có trôi qua cũng không khuất phục được.\n\nBạn không có quyền ngồi trong cái tháp ngà của trường học, rồi bảo tôi yêu thế giới này tươi đẹp. Bạn phải nhìn thấy cái đen tối của thế giới, sự bẩn thỉu của cuộc đời, sự xấu xa của con người, sau đó mới nói rằng tôi vẫn yêu thế giới này, tôi vẫn yêu cuộc sống và tôi sống.\n\nTuổi trẻ ngắn ngủi thế, nhưng đừng sợ tuổi già.\n\nĐôi khi, bạn có thể dừng lại nghỉ ngơi, nhưng đừng quỳ xuống.\n\nKhi đi một con đường, bạn chớ ngoái đầu nhìn lại, hoặc tự hỏi, mình đang làm cái gì?\n\nKhi đau và nhục, đàn ông có thể khóc và gào. Khóc đi, rồi rửa mặt, vỗ má mình, rồi áp má mình để trên gương mặt bạn có một nụ cười. Chứ bạn đừng dụi mắt hay lấy tay lau nước mắt. Bởi có thể sớm mai bạn sẽ mang một đôi mắt trũng và sưng vì khóc. Chớ để sớm mai ai cũng nhận ra bạn từng khóc.\n\nĐàn ông hãy xác định cho mình một mục tiêu xa hơn và một lộ trình dài hơn. Hãy nhớ thỉnh thoảng ngửa đầu nhìn trời xanh, và lúc nhìn lên trời xanh hãy nhớ cúi xuống nhìn đất dưới chân mình.\n\nVào bất kỳ lúc nào, bất kỳ người nào hỏi bạn, bạn yêu mấy lần, đáp án của bạn phải luôn là Hai.\n\nMột lần, cô ấy yêu tôi nhưng tôi không cảm xúc, một lần là tôi yêu cô ấy nhưng không được đáp lại. Hãy luôn nhớ rằng, tình yêu đẹp vẫn luôn đang đợi bạn ở lần yêu sau. Nên đừng luyến tiếc, đừng để một người đàn bà nào có cơ hội làm bạn bị tổn thương tới lần thứ hai.\n\nLàm đàn ông, đừng giao du với văn nghệ sĩ hay bọn văn sĩ trẻ, cũng như đừng làm bạn với những kẻ bất đắc chí, thiếu tâm huyết với đời, cũng tuyệt đối không được bạn bè với những người đàn ông không có nghề nghiệp chính thức, kiêm quá nhiều nghề.\n\nCũng đừng yêu người phụ nữ nào hy sinh vì bạn. Khi có một cô nàng tự chà đạp bản thân nàng, tự hy sinh, tự chịu thiệt vì bạn, bạn chớ nên vì thế mà cảm động hoặc yêu kẻ lụy tình ấy. Bởi một người đàn ông nghiện hút trộm cắp đầy mình thân với bạn, có thể kẻ nghiện hút trộm cắp tiếp theo sẽ là chính bản thân bạn. Tình yêu cũng tương tự như vậy, khi một người phụ nữ vì yêu mà cầm dao cứa tay mình đau, có thể kẻ tiếp theo bị nàng cứa chính là bạn.\n\nKhông bao giờ đặt niềm tin vào một gã đàn ông chỉ định giao du với mình bạn chứ không cho bạn biết hắn đang chơi bời với những bạn bè nào khác.\n\nKhi một cô nàng định gọi bạn là “anh yêu, baby, chồng yêu ơi”, bạn hãy bắt buộc cô nàng gọi bạn bằng tên bạn, bởi bạn là một người đàn ông, bạn không phải thú cưng của ai.\n\nKhi một người đàn ông hoặc một người đàn bà tự nhiên không tới tìm bạn nữa, bạn hãy dứt khoát đừng gọi tới làm phiền họ.\n\nĐừng tin những kẻ dùng tiểu xảo trong tình yêu. Và đừng ác miệng sau khi chia tay người tình. Nghe lời khuyên của người khác, nhưng đừng hối hận, bởi hối hận chưa từng mang lại cho đàn ông bất cứ thứ gì hay ho.\n\nĐàn ông thì không xé ảnh, đốt thư, xé nhật ký, làm những việc mà chỉ diễn viên ba xu trên phim truyền hình mới làm. Bởi bạn tin vào tình yêu. Tin rằng trên đời vẫn còn những người đàn ông tốt và những người phụ nữ tốt đẹp, có thể họ cũng chưa kết hôn, họ cũng vẫn đang vượt trùng trùng biển người trong đời để tìm đến bạn. Nên đừng nói những câu đại loại như: “Thời này làm gì có đàn bà tử tế” hoặc “Làm gì có đàn ông tốt!”. Những câu như thế thường làm người ta hiểu rằng, bạn đã no xôi chán chè, hời hợt với vô số người, vơ đũa cả nắm và không hề sống nghiêm túc, chưa trưởng thành.\n\nHãy yêu tiền, yêu vật chất, dùng tiền để sống cho ra sống. Nhưng vẫn hiểu rằng những giá trị tinh thần cũng quan trọng biết bao. Và con người bạn, một người đàn ông đầy sức sống, háo hức sống vẫn luôn có giá trị và đẹp đẽ hơn những đồng hồ hàng hiệu, thời trang, phụ kiện sành điệu bạn đang mang. Nếu đã hơn hai mươi tuổi nhưng mỗi phút bạn sống, bạn vẫn phải ngửa tay xin tiền bố mẹ, thì những tiền bạc bạn có, đồ hiệu bạn mặc chỉ làm cho sự vô liêm sỉ của bạn nổi bật hơn mà thôi. Nên đồ hiệu không làm bạn có giá hơn. Bản thân người đàn ông không có giá trị bản thân, thì dù có bọc vàng, được bố mẹ nâng đỡ sự nghiệp chức này tước kia, cũng vẫn chỉ là một kẻ ăn bám bọc vàng. Một con lừa dù có đóng yên cương vàng khối cũng không thể trở thành tuấn mã.\n\nBạn còn trẻ, có thể chưa đủ tuổi để bắt đầu một sự nghiệp riêng, một tương lai huy hoàng. Nhưng bạn đã đủ tuổi thành niên, nên ít nhất, cũng không thể làm một cái gánh nặng đeo trên lưng bố mẹ, để bố mẹ mất hai mươi năm nuôi dạy, cái gánh nặng đã sống ký sinh trên lưng chỉ nặng thêm và nhiều đòi hỏi hơn.\n\nBạn đừng tưởng bạn trẻ, bạn làm một kiểu tóc có màu khác người, mặc một bộ quần áo dở nam dở nữ Unisex, rồi phun lên người một thứ mùi nước hoa, thì người khác sẽ tôn trọng bạn. Cái ngước nhìn của người khác không mang ý trầm trồ ngưỡng mộ, mà là cái nhìn khi đi ngang qua sở thú. Rất nhiều đàn ông khác chỉ bởi họ được giáo dục tốt nên họ sẽ không bày tỏ thái độ gì với bạn đâu, họ sẽ tôn trọng sự “cá tính” của bạn, nhưng không có nghĩa rằng, họ không nhận ra sự xấu xí của người đàn ông trước mặt.\n\nXin bạn đừng coi rẻ những người lao động nghèo. Đừng xấu hổ vì phải làm việc nặng nhọc. Đất không bẩn, mồ hôi không hôi hám. Xin hãy tôn trọng những người có thể không giàu bằng bạn, nhưng họ đang nuôi cả gia đình bằng đôi tay lương thiện và cần cù của họ. Bạn tôn trọng họ, bạn mới biết giá trị của bạn nằm ở đâu.\n\nLàm đàn ông, hãy tha thứ, nhưng đừng quên. Và hãy khoan dung với cả thế giới cũng như với chính bản thân bạn. Để luôn tự nhủ rằng, ta là đàn ông, ta xứng đáng để có được những thứ tốt đẹp hơn.\n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.01-Style/SOLID":{"title":"💪 What is SOLID?","content":"\n🌱 SOLID là cụm từ  tạo thành từ những chữ cái viết tắt của 5 nguyên tắc được đúc kết từ 'xương máu' của rất nhiều lập trình viên đi trước =)) Nếu đã từng làm dự án thực tế, mọi người sẽ đều biết là gần 80% thời gian sẽ là bảo trì hệ thống(thêm tính năng, sửa lỗi, ...). Áp dụng SOLID, công việc bảo trì  và mở rộng sẽ dễ dàng hơn rất nhiều. Cùng xem những nguyên tắc 'thần thánh' nhưng vô cùng 'thân thuộc' này là gì nha! \n\n## 🌿 Single Responsibility Principle\n\nMỗi class chỉ nên thực hiện **một nhiệm vụ** đơn lẻ!\n\n![[00 Meta/01 Attachments/Single Responsibility Principle.png]]\n\n\n## 🌿 Open/Closed Principle\n\nKhi thêm tính năng cho class, nên viết những class mới kế thừa class cần mở rộng.\n\n![[00 Meta/01 Attachments/Open-Closed Principle.png]]\n\n## 🌿 Liskov Substitution Principle\n\n\n![[00 Meta/01 Attachments/Liskov Subtitution Principle.png]]\n\n## 🌿 Interface Segregation Principle\n\n![[00 Meta/01 Attachments/Interface Segregation Principle.png]]\n\n\n## 🌿 Dependency Inversion Principle\n\n![[00 Meta/01 Attachments/Dependency Inversion Principle.png]]","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.02-Git/Create-bio-on-my-github":{"title":"🥦 Create bio on my github","content":"\n- 🌱 Github cho phép hiển thị README trên profile github cá nhân. Chúng ta chỉ cần tạo một repo có tên trùng với account github, sau đó thỏa sức sáng tạo thôi 🥳 \n\n![[00 Meta/01 Attachments/Pasted image 20221128185803.png]]\n\n\u003e [!info] Info\n\u003e \n\u003e File README.md sử dụng chuẩn markdown của Git, mọi người có thể tham khảo ở [đây](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github)\n\n- 🌱 Chức năng này đã được các lập trình viên hưởng ứng sôi nổi sau khi ra mắt. Có cả một repo tổng hợp lại những profiles ấn tượng, mọi người có thể tham khảo ở [đây](https://github.com/abhisheknaiidu/awesome-github-profile-readme)  \n\n\n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.02-Git/Delete-gits-branchs-safely":{"title":"🥦 Delete git's branchs safely","content":"\n## 🌿 What?\n\n- 🌱 Sau một thời gian làm việc trên 1 repo git, chắc chắn chúng ta sẽ cần xóa đi những merged branchs hoặc những branchs không cần sử dụng tới nữa. Dưới đây là cách mình dùng để xóa đồng thời nhiều branchs có các partterns chung dưới local:\n\n```sh\n\u003e git branch -D `git branch -a | grep merge`\n```\n\n- 🌱 Nhưng khi xóa các nhánh remote, cần bảo đảm an toàn, cẩn thận hơn nên mình sẽ bó cẩn thêm phần `confirmation`.\n\n```sh\n\u003e git branch -a | grep remotes/anhnh-3008/deleted_branch | xargs -I % -p git push origin :%\n\n\u003e git push origin :remotes/sun/fixbug/game_room_controller ?... # y- Yes, n- No\n```\n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.02-Git/Git-config-for-multi-accounts":{"title":"⚙️ Git config for multi accounts","content":"\n## 🌿 Vấn đề\n - Bài viết này ra đời khi mình bị các anh ngồi cạnh 'cười chê' do dùng nhiều accounts git trên cùng một máy nhưng lại switch bằng cơm =))) Sau khi khóc xong thì mình có tìm hiểu cách config để thuận tiện hơn cho việc sử dụng.\n\n## 🌿 Giải pháp\n- 🌱 Ý tưởng là mình sẽ chia ra làm 2 thư mục **work** và **personal**  để sử dụng cho các repo tương ứng.\n- 🌱 Ở file **.gitconfig** global set user mặc định và điều hướng config riêng cho từng folder.\n``` git\n# .gitconfig\n\n[user]\n  name = anhnh-1028\n  email = nguyen.hoang.anh-c@sun-asterisk.com\n\n[includeIf \"gitdir:~/personal/\"]\n  path = ~/personal/.gitconfig-personal\n\n[includeIf \"gitdir:~/work/\"]\n  path = ~/work/.gitconfig-work\n```\n- 🌱 Set user cho từng folder\n```git\n# ~/work/.gitconfig\n\n[user]\n  name = anhnh-1028\n  email = nguyen.hoang.anh-c@sun-asterisk.com\n\n# ~/personal/.gitconfig\n[user]\n  name = anhnh-3008\n  email = mail-personal@gmail.com\n```\n- 🌱 Xong phần config thông tin, giờ đến phần ssh. Skip bước gen ssh-key + add key lên git, giờ mình set [[50 til/51 Code/51.06 Servers/Config SSH]] thôi.\n\n```git\n# ~/.ssh/config\n\nHost git-work\n  HostName github.com\n  User git\n  IdentityFile ~/.ssh/ssh-key-work\n\nHost git-personal\n  HostName github.com\n  User git\n  IdentityFile ~/.ssh/ssh-key-personal\n```\n\n- 🌱 Thế là xong rồi, giờ mình chỉ cần set-url remote theo tên Host đã config thôi là chạy phà phà rồi.\n\n```sh\ngit@github.com:anhnh-3008/app.git -\u003e git@git-personal:anhnh-3008/app.git\n```\n\n- 🌱 Ngoài ra trong file .gitconfig còn có thể setup được cả color branch, alias, editor, ... Mình có chôm được mấy cái [settings](https://github.com/ttuan/dotfiles/blob/master/git/gitconfig) hay hay của một anh ở công ty, mọi người có thể tham khảo nhé =)) nếu thấy hay thì cho anh mình một ⭐ nha \u003c3\n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.02-Git/Git-hooks-with-pre-commit":{"title":"🥦 Git hooks with pre-commit","content":"\n- 🌱 Để tránh tình trạng gặp phải **stupid mistakes** như push code lên mà có cả `byebug`, `binding.pry`, `debugger`, ... Git cho phép chúng ta sử dụng `hooks` để kiểm tra tự động những vấn đề ntn 🥳\n\n- 🌱 Tất cả các hooks của 1 repo được lưu trong folder `.git/hooks`\n\n![](00%20Meta/01%20Attachments/Pasted%20image%2020221121182121.png)\n\n- 🌱 Tạo file `.git/hooks/pre-commit`. Có thể viết bằng bất kỳ `script language(như Ruby, Python, JS, ...)` nào chúng ta muốn.\n\n```sh\n#!/bin/sh\n\nFILES_PATTERN='\\.?$'\n\nFORBIDDEN='binding.pry\\|byebug\\|console.log'\n\ngit diff --cached --name-only | \\\n    grep -E $FILES_PATTERN | \\\n    xargs grep --color --with-filename -n $FORBIDDEN \u0026\u0026 \\\n    echo 'COMMIT REJECTED' \u0026\u0026 \\\n    exit 1\n\nexit 0\n```\n\n- 🌱 Bạn có thể custom những từ khóa không muốn push lên repo thông qua biến `FORBIDDEN`.\n\n![](00%20Meta/01%20Attachments/Pasted%20image%2020221121182849.png)","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.02-Git/Highlight-Note-and-Warning-with-Git-MarkdownBeta-feature":{"title":"🥦 Highlight Note and Warning with Git Markdown(Beta)","content":"\n- 🌱 Git cung cấp syntax markdown highlight `Note` và `Warning`. Giúp chúng ta viết tài liệu hay description cho PR long lanh hơn ✨\n\n```md\n\u003e **Note**\n\u003e This is a note\n\n\u003e **Warning**\n\u003e This is a warning\n```\n\n- ✨ Kết quả:\n\n![[00 Meta/01 Attachments/Pasted image 20221130103107.png]]\n\n- 🌱 Topic thảo luận: https://github.com/orgs/community/discussions/16925","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.03-Operating-System/Exit-code-on-terminal":{"title":"🥦 Exit code on terminal","content":"\n## 🌿 Run multi commands in on line on terminal\n\n```bash\n$\u003e command1; command2; command3\n```  \n\n-   Sẽ luôn excute hết các câu lệnh, kể cả khi các câu lệnh ở trước nó bị lỗi.\n\n-    Nhưng nếu cần sự ràng buộc **phải đúng** ở các câu lệnh trước thì mới được chạy tiếp, vd như `apt-get update`  và `apt-get install package` , dùng dấu `\u0026\u0026`\n\n```bash\n$\u003e apt-get update \u0026\u0026 apt-get install package\n```  \n\n## 🌿 Exit code in shell\n\n-   Như bên trên có nói đến việc check đúng - các câu lệnh chạy thành công được xác định bởi **Exit Code.**\n\t-   **Exit code** trả về 0 -\u003e success\n\t-   **Exit code** trả về khác 0, có giá trị từ 1-255 -\u003e nghĩa là câu lệnh chạy có lỗi\n-   Check Exit Code của câu lệnh gần nhất:\n\n```bash\n$\u003e who\n=\u003e hoanganh8999 :1           2022-12-14 19:24 (:1)\n\n$\u003e echo $?\n=\u003e 0\n\n$\u003e wo\n=\u003e wo: command not found\n\n$\u003e echo $?\n=\u003e 127\n```\n\n## 🌿 Refer \n\n- [https://mazer.dev/en/linux/tips/how-to-determine-error-and-exit-main-shell-script/](https://mazer.dev/en/linux/tips/how-to-determine-error-and-exit-main-shell-script/)","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.03-Operating-System/Permission-in-Linux":{"title":"🥦 Permission in Linux","content":"\n## 🌿 What?\n\n- Bình thường mình hay chạy lệnh `chmod 777` khi thấy báo lỗi không có quyền tương tác, mà 777 là cái gì?\n- Làm sao để biết File hay Folder mình muốn thao tác có những quyền gì? Tài khoản nào được quyền tương tác?\n\n![[00 Meta/01 Attachments/Pasted image 20221218133654.png]]\n\n## 🌿 Refer \n- https://blog.bytebytego.com/","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.03-Operating-System/Pipe-Data-between-Programs":{"title":"🥦 Pipe Data between Programs","content":"\n- 🌱 Trong Shell, The Pipe cho phép kết hợp giữa nhiều commands trên cùng một dòng. Được kí hiệu bằng ký tự ASCII 124 ( | ), dấu gạch dọc.\n\n```sh\nVD1:\n🌱 kết hợp câu lệnh tìm kiếm theo pattern và đếm có bao nhiêu lines trả về từ grep\n\n\u003e grep /bin/bash$ [PATTERN] | wc -l\n```\n\n![](https://lh3.googleusercontent.com/P_MDCWdC8VPh8ZMVK3p-MxX8uWYP2w2XFv9mEeMoIudE4x9hJw4S5OaAMjaIRn6Utr8gjNVSSVg89VtDzlL5TI-PUwcDJEM24e-ylJUzcIMpeNFSvTnbrDbctMs8FHrnp_xQ8Mz-jf4pNJzsGQ-79Tf1hTenyIh1fAGdLqz5DS4X9KAtvQVhaVv358Qi)\n\n### Nguồn\n- LPIC - 1 - trang 105 ","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.03-Operating-System/Some-Tips-for-irb-rails-console":{"title":"🥦 Some Tips for irb/rails console","content":"\n### 🌿 Lấy giá trị output cuối cùng\n- 🌱 `_` được gán giá trị là output mới nhất của irb/rails console.\n\n```sh\n\u003e 1 + 1 \n=\u003e 2\n\u003e _\n=\u003e 2\n```\n\n### 🌿 Sandbox\n- 🌱 Khi dùng option `--sandbox` các thay đổi đối với `atabase` sẽ được `rollback` khi thoát `rails console`.  \n\n```sh\nrails c --sandbox\n\n\u003e Account.first.destroy\n=\u003e true\n\u003e Account.find(1)\n=\u003e ActiveRecord::RecordNotFound: Could not find Account with id=1\n\u003e exit\n\nrails c\n\u003e Account.find(1)\n=\u003e #\u003cAccount id: 1, ...\u003e\n```\n\n### Tham khảo\n- https://pragmaticstudio.com/tutorials/rails-console-shortcuts-tips-tricks","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.03-Operating-System/Why-must-run-apt-update-before-install-any-lib-for-Linux":{"title":"🥦 Why must run apt update before install any lib for Linux?","content":"\n[Câu trả lời](https://askubuntu.com/questions/337198/is-sudo-apt-get-update-mandatory-before-every-package-installation)\n\n- 🌱 Lệnh `apt update` sẽ cập nhật danh sách mới nhất các packages có trong kho Ubuntu.\n\n\u003e [!info] Info\n\u003e \n\u003e Danh sách repo được lưu trong file **/etc/apt/sources.list**\n\n- 🌱 Lệnh `apt install` sẽ đọc trong danh sách packages được cập nhật ở lệnh `apt update` gần nhất.\n\n- 🌱 Nếu chắc chắn package chuẩn bị install đã nằm trong danh sách cập nhật, việc chạy `apt update` có vẻ là hơi thừa 😶 Cơ mà thay vì ngồi xác định như thế thì mình chọn chạy `apt update` cho đỡ mệt mọi 😆\n\n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.03-Operating-System/create-multi-folders-linux":{"title":"🥦 Create multi folders linux","content":"\n- 🌱 Create multi foders in Linux with command below:\n\n```sh\nmkdir /path/{folder1, folder2, folder3}\n\ntree /path/\n \n├── folder1\n├── folder2\n├── folder3\n```\n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.03-Operating-System/visudo":{"title":"🥦 visudo","content":"\n- 🌱 Cấp quyền(cho user root, lệnh sudo, group admin) được cấu hình trong file `/etc/sudoers` .\n\t- Không bao giờ sử dụng trình soạn thảo văn bản thông thường(nano, vim, ...) để sửa `/etc/sudoers` , thay vào đó hãy dùng `visudo` .\n\t-  `visudo` validate cú pháp trước khi save file còn nano, vim, .... thì không, save mà sai syntax là oẳng luôn đó 🥵\n\n- 🌱 Xem thêm: [https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file](https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file)","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.04-Rails/Add-custom-flash-keys":{"title":"🥦 Add custom flash keys","content":"\n- 🌱 `ActionController::Base` mặc định cung cấp key `:notice` cho `#redirect_to`   \n```ruby\n  class flash_demo\n    if true\n      redirect_to root_path, notice: \"Notice\"\n    else\n      flash[:error] = \"Error\"\n      redirect_to root_path\n    end\n  end\n```\n\n- 🌱 Nhưng nếu bạn muốn thêm `:error` như `:notice` thì có thể thử cách này nhé!\n```ruby\n  class flash_demo\n    add_flash_types :error\n    \n    if true\n      redirect_to root_path, notice: \"Notice\"\n    else\n      redirect_to root_path, error: \"Error\"\n    end\n  end\n```\n\n- 🌱 Refer: [add_flash_keys](https://til.hashrocket.com/posts/ouyfd1cpfu-add-custom-flash-keys)","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.04-Rails/Config-warning-when-fetched-a-lot-of-records":{"title":"🥦 Config warning when fetched a lot of records","content":"\n - 🌱 Từ Rails 5 chúng ta đã có thể thêm config `warn_on_records_fetched_greater_than`:  hiển thị cảnh báo trong `rails server` hoặc `rails console` khi có số lượng câu queries lớn hơn số lượng chúng ta đã chỉ định.\n\n```rb\n# config/environments/development.rb\n\n# Show warn if fetch greater than 50 records\nconfig.active_record.warn_on_records_fetched_greater_than = 50\n```\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Config warning when fetched a lot of records/Pasted image 20221020091559.png]]","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.04-Rails/Credentials-file-in-Rails":{"title":"🥦 Credential file in Rails","content":"\n\u003e [!question] Question\n\u003e \n\u003e Khi khởi tạo một project, Rails sẽ tự động tạo ra file **credentials.yml.enc** trong folder **config**. Khi click vào xem nội dung thì chỉ có mỗi một dòng hash dài ngoằng ngoẵng. Thế nó sinh ra để làm gì nhỉ 🤔\n\n- 🌱 Từ sau Rails 5.2, khi init project sẽ tự động tạo file `config/credentials.yml.enc` chứa hash được mã hóa bởi [aes-128-gcm](https://www.cryptosys.net/pki/manpki/pki_aesgcmauthencryption.html)  để lưu những thông tin \"nhạy cảm\" của dự án. \n\n- 🌱 Rails sẽ dùng `config/master.key` hoặc `ENV[\"RAILS_MASTER_KEY\"]` để mã hóa nội dung. Vì đã được mã hóa nên file `config/credentials.yml.enc` vẫn có thể public, miễn là chúng ta không làm lộ `master key` là được.\n\n- 🌱 Mặc định file tạo ra sẽ chỉ lưu `secret_key_base` của Rails app. Tuy nhiên chúng ta có thể edit thêm thông tin bằng command:\n\n```sh\n$ rails credentials:edit\n```\n\n\u003e [!info] Info\n\u003e \n\u003e 📝 Câu lệnh trên sẽ tạo file **config/credentials.yml.enc** và   **config/master.key** nếu chưa tồn tại hoặc chưa được định nghĩa.\n\u003e \n\u003e Tìm hiểu thêm: **rails credentials:help**  \n\n- 🌱 Đọc thông tin mã hóa bằng câu lệnh:\n\n```sh\n\u003e Rails.application.credentials\n```\n\n![[00 Meta/01 Attachments/Pasted image 20221202152110.png|800]]\n\n\u003e [!danger] Danger\n\u003e \n\u003e Tuyệt đối không được làm mất hay public master key! \n\n- 🌱 Source: https://guides.rubyonrails.org/security.html#custom-credentials\n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.04-Rails/Custom-condition-sign-in-for-devise":{"title":"🥦 Custom condition sign-in for devise gem","content":"\nMặc định khi đăng nhập, Devise sẽ tìm User dựa theo scope đã được thiết lập trong `config/initializers/devise.rb` \nVd như đăng nhập theo email:\n\n```rb\nDevise.setup do |config|\n  config.authentication_keys = [:v_code]\nend\n```\n\n### 🌿  Vấn đề\n- 🌱 Thế nhưng cuộc sống thường lắm gian truân và cuộc đời của mình cũng không ngoại lệ. \n- 🌱 Dự án của mình có đồng thời 2 cơ chế đăng nhập 1 là qua Devise, 2 là SSO thông qua bên thứ 3. Khi thực hiện SSO, hệ thống sẽ lưu user đó vào DB chung luôn và phân biệt bằng trường `provider`. Vấn đề là giờ phải xử lý sao cho khi đăng nhập với Devise, những thằng user do bên thứ 3 cung cấp không thể login vào được hệ thống.\n\n### 🌿 find_for_database_authentication(warden_conditions)\n- 🌱 Chúng ta có thể overwrite lại method `find_for_database_authentication` của Devise.\n\t- Method nhận vào scope chứa `authentication_keys`.\n\t- Output trả về một record tồn tại trong DB hoặc `nil`.\n\n```rb\ndef find_for_database_authentication(warden_conditions)\n  conditions = warden_conditions.dup\n  # trim space and downcase\n  email = conditions.delete(:email).strip.downcase\n  find_by(email: email, provider: :traditional)\nend\n```\n\n\n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.04-Rails/Custom-direct-URL-by-Routes-in-Rails":{"title":"🥦 Custom direct URL by Routes in Rails","content":"\n### 🌿 What?\n- 🌱 Rails cung cấp `direct` giúp chúng ta xác định một `route` `redirect` đến một URL bất kỳ. \n\n```rb\n# config/routes.rb\nRails.application.routes.draw do\n\tdirect :get_to_my_blog do\n\t\t\"https://nhanh.netlify.app\"\n\tend\nend\n```\n\n- 🌱 Trong Rails ta sẽ có route `get_to_my_blog_url` gọn gàng đẹp đẽ. \n- 🌱 Ngoài ra có thể thêm điều kiện để  get URL.\n\n```rb\n# config/routes.rb\nRails.application.routes.draw do\n\tdirect :get_to_the_goog, search: nil do |options| \n\t\t\"https://google.com/search?q=#{options[:search]}\"\n\tend\nend\n\nget_to_the_goog_url(search: \"stackoverflow\")\n```\n\n- 🌱 `Direct` sẽ không hiển thị routes khi chúng ta gõ `rails routes`. Chúng ta sẽ vẫn có `_path` helper nhưng ko nên sử dụng vì nó cắt mất cái tên miền đấy 😂. \n- 🌱 Ngoài ra `direct` không dùng được trong `namespace` hoặc `scope`. Nếu đặt nhầm thì rails sẽ `raise exception`.\n\n### 🌿 Refer\n- https://guides.rubyonrails.org/v5.2/routing.html#direct-routes","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.04-Rails/Custom-order-in-SQL-with-RoR":{"title":"🥦 Custom order in SQL with RoR","content":"\n- 🌱 `in_order_of` cho phép order theo thứ tự chỉ định trong SQL.\n\n```rb\nUser.in_order_of(:id, [1, 5, 3])\n# SELECT \"users\".* FROM \"users\"\n#   WHERE \"users\".\"id\" IN (1, 5, 3)\n#   ORDER BY CASE\n#     WHEN \"users\".\"id\" = 1 THEN 1\n#     WHEN \"users\".\"id\" = 5 THEN 2\n#     WHEN \"users\".\"id\" = 3 THEN 3\n#   END ASC\n```\n\n- 🌱 [source code](https://github.com/rails/rails/blob/1f6202a1fe6cd976993c88a7e22afc165ba06c5f/activerecord/lib/active_record/relation/query_methods.rb#L526)\n\n- 📑 FYI: Cách này trong SQL sẽ sort mà không sử dụng index. \n\n![[00 Meta/01 Attachments/Pasted image 20221114184148.png|800]]\n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.04-Rails/Delegate-in-Rails":{"title":"🥦 Delegate in Rails","content":"\n## 🌿 Issues\n\n- Khi code RoR, mình thường xuyên sử dụng delegate trong các dự án. Nhưng nay tự nhiên có anh hỏi mình mấy câu như delegate là cái gì? tại sao phải dùng? nên dùng thế nào cho hợp lý? thì mình lại có sự ngập ngừng nhẹ 😅. Tiện đây mình lược lại một lần sau đi khè cho trôi chảy 😆 Let's gooo!!  \n\n## 🌿 What?\n\n- Theo APIdock:\n\u003e Provides a [delegate](https://apidock.com/rails/Module/delegate) class method to easily expose contained objects’ public methods as your own.\n\n- `Delegate` hỗ trợ một object truy xuất dễ dàng các public methods của một object khác như chính các methods của nó.\n\n\n## 🌿 Why?\n\n\u003e The Law of Demeter Principle – LoD, còn gọi khác là nguyên tắc Demeter hay nguyên tắc “càng biết ít càng tốt” hay nguyên tắc “Một dấu chấm”. Nó **là một nguyên tắc thiết kế để phát triển phần mềm, đặc biệt là các chương trình hướng đối tượng**\n\n- Delegate giúp code của cta tuân thủ theo nguyên tắc trên.\n\n## 🌿 How?\n\n- Có 3 options:\n1. `:to` - chỉ định object cần truy xuất public methods(có thể nhận nhiều giá trị).\n\n```rb\nclass A \u003c ActiveRecord::Base\n\thas_many :Bs\nend\n\nclass B \u003c ActiveRecord::Base\n\tbelongs_to :A\n\n\tdelegate :name, :description, to: :A\nend\n\npry(main)\u003e B.first.name\n=\u003e \"A\"\npry(main)\u003e B.first.description\n=\u003e \"Description of A\"\n```\n\n2. `:prefix` - chỉ định tiền tố.\n\n```rb\nclass A \u003c ActiveRecord::Base\n\thas_many :Bs\nend\n\nclass B \u003c ActiveRecord::Base\n\tbelongs_to :A\n\n\tdelegate :name, :description, to: :A, prefix: 'A'\nend\n\npry(main)\u003e B.first.A_name\n=\u003e \"A\"\npry(main)\u003e B.first.A_description\n=\u003e \"Description of A\"\n```\n\n3. `:allow_nil` - nếu flag=true, không raise [DelegationError](https://apidock.com/rails/Module/DelegationError)\n\n```rb\nclass A \u003c ActiveRecord::Base\n\thas_many :Bs\nend\n\nclass B \u003c ActiveRecord::Base\n\tbelongs_to :A\n\n\tdelegate :name, :description, to: :A, prefix: 'A', allow_nil: true\nend\n\n# allow_nil: false - default\npry(main)\u003e B.first.A_name\n=\u003e Module::DelegationError: B#A_name ...\n\n# allow_nil: true\npry(main)\u003e B.first.A_name\n=\u003e \"A\"\n```\n\n## 🌿 Refer \n- https://apidock.com/rails/Module/delegate","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.04-Rails/Encrypt-attribute-in-Rails-7":{"title":"🥦 Encrypt attribute in Rails 7","content":"\n\u003e [!question] Question\n\u003e \n\u003e Rails 7 vừa ra mắt **Active Record Encryption**, cho phép **encrypt data** ở trên tầng **Application**. Nhưng nó đem lại tác dụng gì khi chúng ta đã **encrypt data** ở tầng **Database** rồi nhỉ 🤔. \n\n## 🌿 Why?\n- 🌱 Khi có hacker chiếm được quyền hệ thống, snapshot database hoặc application logs sẽ chỉ hiển thị dữ liệu đã được mã hóa.\n\n- 🌱 Ngăn ngừa lập trình viên sơ xuất để lộ dữ liệu nhạy cảm thông qua application logs.\n\n- 🌱 Ngăn truy xuất dữ liệu trong Rails console nếu không có bộ keys để giải mã.\n\n## 🌿 How?\n### Setup\n- Tạo keys:\n\n```sh\n$ rails db:encryption:init\n```\n\n- Thêm keys vào [[50 til/51 Code/51.04 Rails/Credentials file in Rails| credentials file]].\n\n### Declare attribute\n- Định nghĩ trong modal trường encrypts.\n\n```rb\nclass User \u003c ApplicationRecord\n  encrypts :email\nend\n```\n\n- Khi tạo user, giá trị của email đã được mã hóa.  \n\n![[00 Meta/01 Attachments/Pasted image 20221202182529.png|800]]\n\n\u003e [!info] Info\n\u003e \n\u003e Không thể find_by theo thuộc tính được mã hóa. \n\u003e \n\u003e Nếu vẫn muốn truy vấn theo thuộc tính, hãy thêm option \n**deterministic: true**\n\n```rb\nclass User \u003c ApplicationRecord\n  encrypts :email, deterministic: true\nend\n```\n\n### 🌿 Refer\n- 🌱 https://guides.rubyonrails.org/active_record_encryption.html","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.04-Rails/How-to-safely-remove-a-column-in-Rails":{"title":"🥦 How to safely remove a column in Rails? ","content":"\n### 🌿 What?\n- 🌱 Rails cung cấp method `ignored_columns` để xóa tạm thời một cột trong DB, sau khi sửa logic xong xuôi chúng ta mới thực hiện migrate, tránh việc migrate đi migrate lại, deploy nhiều lần(nếu cột đã có trên môi trường STG/PROD).\n\n### 🌿 How?\n- 🌱 Step 1️⃣: Set ignore cột cần xóa trong model.\n\n```rb\nclass User \u003c ActiveRecord::Base\n  self.ignored_columns = [:username]\nend\n```\n\n- 🌱 Step 2️⃣: Kiểm tra xem cột `username` đã được xóa tạm thời chưa.\n\n```rb\nUser.first.username\n\n=\u003e raises exception NoMethodError\n```\n\n- 🌱 Step 3️⃣: Thay đổi logic code liên quan đến trường `username`.\n\n- 🌱 Step 4️⃣: Deploy lên các môi trường, test/fix những \"lỗi lầm\" nếu có.\n\n- 🌱 Step 5️⃣: Thêm migrate xóa cột `username` .\n\n### 🌿 Refer\n🌵 [https://newsletter.shortruby.com/p/how-to-safely-remove-a-column-in](https://newsletter.shortruby.com/p/how-to-safely-remove-a-column-in)","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.04-Rails/Kill-rails-server-quickly":{"title":"🥦 Kill rails server quickly","content":"\n### 🌿 Vấn đề\n- 🌱 Khi làm việc với rails, chắc hẳn đã có lần chạy server bạn đã gặp lỗi này.\n\n![[00 Meta/01 Attachments/Pasted image 20221129232330.png]]\n\n- 🌱 Sau khi chạy `rails s`, file `tmp/pids/server.pid` được tự động sinh ra, lưu Process ID(PID) của server đang chạy. Nguyên nhân xảy ra lỗi trên có thể là do chẳng may crash server(mất điên, máy lag) hay bất kì tình huống nào khác mà rails chưa kịp kill server cho chúng ta.\n\n### 🌿 Giải pháp\n\n- 🌱 Để giải quyết, tôi hay xóa xừ cái file `server.pid`.\n\n```sh\nrm -rf tmp/pids/server.pid\n```\n\n- 🌱 Sau đó thêm alias trong `.bashrc` để đỡ phải gõ nhiều 😄\n\n```sh\n# /.bashrc\n\nalias kars=\"rm -rf tmp/pids/server.pid\"\n```","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.04-Rails/Quick-delete-a-record-in-rails":{"title":"🥦 Quick delete a recond in rails","content":"\n## 🌿 What?\n- Trước đây khi muốn xóa một record, mình thường phải find trước xong mới xóa.\n\n```rb\nuser = User.find(1)\n\nuser.destroy # xóa dependent và check callback\nuser.delete # xóa luôn, chả check chiếc gì hớt\n```\n\n- Nhưng từ Rails 6, nếu chúng ta chỉ muốn xóa record, có thể viết gọn hơn như sau:\n\n```rb\nUser.destroy_by(id: 1) # xóa dependent và check callback\nUser.delete_by(id: 1) # xóa luôn, chả check chiếc gì hớt\n```\n\n- Cả hai không có khác nhau gì về hiệu suất. Đây chỉ là một phiên bản rút gọn cách viết thôi. \n\n## 🌿 Refer\n\n- Mọi người có thể xem thêm code trong [Pull](https://github.com/rails/rails/pull/35316/files) này ạ.","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.04-Rails/Quick-open-source-of-gem":{"title":"🥦 Quick open source of gem","content":"\n- 🌱 Nếu bạn muốn debug hoặc sửa gem, có thể truy cập đến thư mục gem một cách nhanh chóng bằng command:\n\n```sh\nbundle open GEM_NAME\n```\n\n- 🌱 Trình soạn thảo văn bản sẽ được mở theo `$EDITOR` hoặc `$BUNDLER_EDITOR`\n","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.04-Rails/Run-Rspec-save-your-time":{"title":"🥦 Run Rspec save your time","content":"\n### 🌿 What?\n- 🌱 If you want to run rspec for a specific example, context or describe without having to care about path file, line number, you can try it:\n\n```ruby\n# spec/rails_helper.rb\n\nRSpec.configure do |config|\n  config.filter_run_when_matching focus: true\nend\n```\n- 🌱 Then you add f to example, context or describe, Rspec will only focus it.\n\n```ruby\n#example\nfit 'should tell height' do\n  expect(@person.height).to eq(160)\nend\n\n# as well\n\nit 'should tell height', focus: true do\n  expect(@person.height).to eq(160)\nend\n```\n\n- 🌱 You can add focus for multi examples\n\n### 🌿 Refer\nhttps://manny.codes/7-ways-to-selectively-run-rspec-tests/","lastmodified":"2023-01-16T11:01:51.577980119Z","tags":null},"/50-til/51-Code/51.04-Rails/Save-serialized-object-to-the-database":{"title":"🥦  Save serialized object to the database","content":"\n## 🌿 What?\n- Như mọi người đã biết, chỉ trong Postgresql chúng ta mới có thể lưu Array vào db còn MySQL thì chịu chết. Trong Rails nếu muốn làm việc trên, tôi thường viết custom attribute trong model để xử lý dữ liệu.\n\n```rb\n# models/user.rb\n\nclass User\n  def codes\n    codes.split(',') #phone_numbers in db = \"123,345,567\" \n  end \nend\n```\n\n## 🌿 Serialization of ActiveRecord\n-   Rails cung cấp một  Instance Public methods là serialize để giúp chúng ta thực hiện việc lưu serialized object(như Array, Hash, YAML, JSON) và tự động convert về đúng kiểu dữ liệu khi truy xuất.\n-   Params của method:\n\t-   **attr_name:** Tên attribute cần lưu serialized object\n\t-   **class_name_or_coder:** Optional, chỉ định kiểu dữ liệu\n\t\t-   Mặc định là YAML, ngoài ra có thể chọn Array, Hash, và JSON\n\t\t- **_custom coder:_** _Có thể tự define kiểu dữ liệu (xem them ở_ _[doc](https://api.rubyonrails.org/classes/ActiveRecord/AttributeMethods/Serialization/ClassMethods.html#method-i-serialize)__)_\n-\n```rb\n# models/user.rb\n\nclass User\n  serialize:codes\nend\n\n3.1.2 :001 \u003e Comment.create! user_id: 1, content: [1,2,3]\n#\u003cComment:0x00007fdf8dd6dac0                                   \n id: 1,                                                        \n content: [1, 2, 3],\n ...\n```\n\n## 🌿 Refer\n-   [Serialize Document](https://api.rubyonrails.org/classes/ActiveRecord/AttributeMethods/Serialization/ClassMethods.html#method-i-serialize)","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.04-Rails/Show-entire-length-of-output-in-Rspec":{"title":"🥦 Show entire length of output in Rspec","content":"\n## 🌿 Issues\n- Khi chạy test case compare 2 objects, trong trường hợp không match + object dài, output lỗi sẽ hiển thị rút gọn như dưới đây(mặc định sẽ hiển thị 200 kí tự cho từng object).\n\n![[00 Meta/01 Attachments/Pasted image 20221223163807.png]]\n\n## 🌿 Solution \n- Set `RSpec::Support::ObjectFormatter.default_instance.max_formatted_output_length = nil`  để show đầy đủ thông tin của 2 objects.\n- Hoặc\n```rb\nRSpec.configure do |rspec|\n  rspec.expect_with :rspec do |config|\n    config.max_formatted_output_length = nil\n  end\nend\n```\n\n![[00 Meta/01 Attachments/Pasted image 20221223163953.png]]\n\n## 🌿 Refer\n\n- [Code Rspec xử lý độ dài output](https://github.com/rspec/rspec-expectations/blob/ae06ba1535fca7c0ce4014d7d05fae823e6be9d4/lib/rspec/expectations/configuration.rb#L70)\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.04-Rails/Show-schema-and-relationships-of-Model":{"title":"🥦 Show schema and relationships of Model","content":"\n## 🌿 What?\n- 🌱 Gem pry-rails cung cấp method `show-models` hiển thị schema và relationships của tất cả Model trong DB.\n\n```rb\n\u003e pry(main)\u003e show-models\n\u003e WhitelistedJwt\n\t  id: integer\n\t  jti: string\n\t  aud: string\n\t  exp: datetime\n\t  refresh_token: string\n\t  account_id: integer\n\t  device_id: integer\n\t  created_at: datetime\n\t  updated_at: datetime\n\t  refresh_token_exp: datetime\n\t  active_flag: boolean\n\t  belongs_to :account\n\t  belongs_to :device\n\u003e Schedule\n\t  id: integer\n\t  jti: string\n\t  aud: string\n\t  exp: datetime\n\t  refresh_token: string\n...\n```\n\n- 🌱 Nếu DB nhiều model, chúng ta có thể chỉ định riêng model cần xem.\n\n```rb\npry(main)\u003e show-model Project\n```\n\n- 🌱 Dùng `--grep` để tìm theo partial. Trả về Model chưa partial truyền vào.\n\n```rb\npry(main)\u003e show-models --grep aud\n```\n\n## 🌿 Refer \nMình quên mất tiêu 😅","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.04-Rails/Sidekiq-Beta-7.0-available":{"title":"🥋 Sidekiq Beta 7.0 available","content":"\nHôm 2022-09-26 Author and Maintainer của Sidekiq **Mike Perham** đã cho ra mắt bản beta version 7.0 của **Sidekiq**. Đây được giới thiệu là một đợt big update với một vài tính năng siêu to và mới =)) một vài tính năng bị loại bỏ, một số API được cấu trúc lại và requirements được update.\n\n### 🌿 Version Support\n- Required Redis 6.2+\n- Required Ruby 2.7+\n- Support for Rails 6.0+\n\n### 🌿 Upgrade\nNếu bạn muốn upgrade lên ver 7.0 để trải nghiệm và có cơ hội trở thành contributer cho **sidekiq** thì đừng ngần ngại mà hãy thêm dòng này vào Gemfile của mình nhé =))\n```ruby\ngem 'sidekiq', '\u003c 8'\n```\n\n### 🌿 What's new?\n\n#### Job Metrics\nVersion 7.0 sẽ add một tab metrics trên Web UI với high-resolution data cho thời gian excute job cũng như là khả năng đánh dấu thời điểm deploy. \nMọi người có thể xem chi tiết tính năng này ở [Metrics](https://github.com/mperham/sidekiq/wiki/Metrics) \n\n#### Embedding\n---\nTrước đây mọi người chỉ có thể khởi động **Sidekiq** bằng câu lệnh \n```sh\nbundle exec sidekiq\n```\nTính năng này theo tác giả có nói là một cách thử nghiệm để chạy **Sidekiq** thông qua việc gọi trực tiếp bằng những dòng code Ruby. Nó được gán nhãn thử nghiệm là vì có khả năng xung đột với plugins bên thứ 3 hay với chính hệ thống của bạn.\nMọi người có thể xem chi tiết tính năng này ở [Embedding](https://github.com/mperham/sidekiq/wiki/Embedding)\n\n#### Capsules\n---\n...\n\n#### redis-client\n---\n- **redis-client** là một Rubygem mới sử dụng giao thức RESP3 có trong Redis 6.0+.\n- Sidekiq 6.5 đã giới thiệu về việc hỗ trợ cho gem **redis-client**  trong khi vẫn sử dụng gem **redis** là mặc định. Đến sidekiq 7.0 đã hoàn thiện việc chuyển đổi này và đã không còn sử dụng **redis** là mặc định nữa.\n- **App của bạn vẫn có thể tiếp tục sử dụng redis**. \n- Hiện tại nếu bạn sử dụng **Sidekiq.redis** để truy cập vào kết nối Redis, API đó sẽ expose một connection dựa trên **redis-client**.\n\n#### redis-namespace\n- 7.0 đã bỏ phần support cho **redis-namespace**. \n\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.04-Rails/Truncate-by-amount-of-word-in-Rails":{"title":"🥦 Truncate by amount of word in Rails","content":"\n- 🌱 Rails cung cấp method truncate một chuỗi dựa theo số lượng từ. Ví dụ như chỉ muốn hiển thị 3 chữ đầu:\n\n```rb\nmy_string = \"một hai ba bốn năm!\"\nmy_string.truncate_words(3)\n\n#=\u003e \"một hai ba...\"\n```\n\n- 🌱 Dấu 3 chấm tự động được thêm vào sau chuỗi đã được truncate. Chúng ta có thể custom bằng arg `omission` .\n\n```rb\nmy_string.truncate_words(3, omission: \" ... more\")\n\n#=\u003e \"một hai ba ... more\"\n```\n\n- 🌱 Đương nhiên là cũng có truncate theo ký tự nữa, mọi người có thể đọc thêm ở [đây](https://apidock.com/rails/String/truncate).","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.04-Rails/Validate-number-of-association":{"title":"🥦 Validate number of association","content":"\n### 🌿 What?\n- 🌱 If you have a People model and a Vehicle model, every people has_many vehicles but you want to set maximum for number of vehicles which a people can has. You can use following command below:\n\n```ruby\n# vehicle.rb\nclass Vehicle\n  belongs_to :people\nend\n\n# people.rb\nclass People\n  has_many :vehicles\n\n  validates :vehicles, length: { maximum: 2 }\nend\n```\n\n### 🌿 Refer\nhttps://til.hashrocket.com/posts/egegrgsdnj-limiting-object-counts-in-rails-associations-\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.04-Rails/Validate-numeric-in-Rails":{"title":"🥦 Validate numeric in rails","content":"## 🌿 Issues\n- Option `only_integer` được dùng để validate chỉ nhận giá trị integer. Nhưng mình muốn nhận được cả giá trị float và integer cơ 😅\n\n## 🌿 Solutuion\n- Theo [doc](https://edgeguides.rubyonrails.org/active_record_validations.html#numericality), option `only_integer` validate format theo regex `/\\A[+-]?\\d+\\z`.\n- Nếu muốn pass các giá trị float, có thể thay thế format regex `/\\A-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)\\z/`\n\n```ruby\nvalidates :number, format: { with: /\\A-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)\\z/ }\n```\n\n- Hoặc Rails 7 đã thêm option `only_numeric` để giải quyết vấn đề trên.\n\n```ruby\nvalidates :number, numericality: { only_numeric: true }\n```\n\n## 🌿 Refer \n- [Pull add opion to numericality validator](https://github.com/rails/rails/pull/43914/files)","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.04-Rails/Why-is-must-run-bundle-exec-before-any-command":{"title":"🥦 why is must run bundle exec before any command?","content":"\n## 🌿 Issue\n\n- 🌱 Trước làm dự án, lúc đầu mình chạy mỗi  `rspec` hay `rubocop` thì vẫn ô's kê mà sau lại phải thêm `bundle exec` ở đầu thì mới chạy được 🥵\n\n## 🌿 Why?\n\n- 🌱 Nếu chạy chay không dùng `bundle exec` hệ thống sẽ tìm trong PATH, nếu trong PATH có nhiều versions của 1 gem, nó có thể xảy ra việc sử dụng sai version.\n- 🌱 `bundle exec`  để đảm bảo rằng version gem được sử dụng đúng với version gem chỉ định trong Gemfile chứ không phải là một version khác đã được cài trong hệ thống của chúng ta.\n\n\u003e Ví dụ như `rspec` trước đây mình chạy được là do máy của mình mới reset, chỉ có duy nhất 1 gem `rspec` được cài đặt cho dự án đang làm =\u003e chạy không bị lỗi. Vấn đề xảy ra khi mình cài thêm các versions `rspec` cho các projects khác =\u003e lệch version.\n\n- 🌱 Theo mục đích trên, các câu lệnh không liên quan đến version gem, mình ko cần phải thêm `bundle exec` nữa. Ví dụ như `rails s` hoặc `rails db:create` ,...\n\n## 🌿 Refer \n- [https://bundler.io/v2.4/man/bundle-exec.1.html](https://bundler.io/v2.4/man/bundle-exec.1.html)\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.04-Rails/_in_-and-_out_-of-Pry":{"title":"🥦 _in_ and _out_ of Pry","content":"\n### 🌿 What?\n- 🌱 Trong Pry, các giá trị `input`, `output` sẽ tự động được lưu trong 2 array có thể truy cập được đó là `_in_` và `_out_`. Số lượng phần tử cache của 2 cu này được định nghĩa ở `Pry.config.memory_size`(mặc định là 100 phần tử). Nếu hết dung lượng, những giá trị mới sẽ được ghi đè.\n\n```sh\npry(main)\u003e 1\n=\u003e 1\npry(main)\u003e 2\n=\u003e 2\npry(main)\u003e 3\n=\u003e 3\npry(main)\u003e _in_\n=\u003e #\u003cPry::Ring:0x0000562f98b2ce88 @buffer=[nil, \"1\\n\", \"2\\n\", \"3\\n\", \"_in_\\n\"], @count=5, @max_size=100, @mutex=#\u003cThread::Mutex:0x0000562f98b2ce60\u003e\u003e\npry(main)\u003e _out_\n=\u003e #\u003cPry::Ring:0x000055d4e3002b80 @buffer=[nil, 1, 2, 3, #\u003cPry::Ring:0x000055d4e3002b80 ...\u003e], @count=5, @max_size=100, @mutex=#\u003cThread::Mutex:0x000055d4e3002b58\u003e\u003e\npry(main)\u003e _out_.to_a[1] + _out_.to_a[2]\n=\u003e 3\n```\n\n### 🌿 Refer\n- 🌱 Mọi người có thể đọc thêm ở  [document](https://github.com/pry/pry/wiki/Special-Locals#the-input-and-output-cache)\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.04-Rails/frozen_string_literal-in-rails":{"title":"🥦 frozen_string_literal in rails","content":"\n### 🌿 What?\n- 🌱 Rubocop có rule check khai báo `frozen_string_literal: true` cho từng file, nhưng nó để làm gì?\n\n- 🌱 `frozen_string_literal` là một **magic comments** có từ Ruby 2.3, nó giúp tối ưu bộ nhớ cũng như cải thiện performance bằng việc **cung cấp vùng nhớ dựa theo nội dung của string**(nội dung giống nhau sẽ chung 1 vùng nhớ), tương tự như `:symbol`. Ngoài ra, sử dụng comment trên cũng sẽ ngăn chặn việc thay đổi string.\n\n```rb\n# test.rb\n# frozen_string_literal: true \np 'name'.object_id\np 'name'.object_id\n\nstr  =  'hello'\nstr  \u003c\u003c  ' world'\n\np str\n```\n\n```sh\n\u003e ruby test.rb\n60\n60\nTraceback (most recent call last):\ntest.rb:6:in `\u003cmain\u003e': can't modify frozen String: \"hello\" (FrozenError)\n```\n\n- 🌱 Nếu trong file `frozen`, chúng ta vẫn muốn một string động, có thể khai báo:\n\n```rb\nstr = String.new('hello')\nstr \u003c\u003c ' world'\n```\n\n### 🌿 Refer\n- 🌱 [Tham khảo](https://www.mikeperham.com/2018/02/28/ruby-optimization-with-one-magic-comment/)\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.05-Ruby/Awesome-Ruby-Repository":{"title":"💎 Awesome-Ruby Repository","content":"\n### 🌿 What?\n- 🌱 Được khởi xướng bởi Marc Anguera - Lead engineer \u0026 CTO tại Crisalix(cung cấp dịch vụ xuất hình ảnh 3D, 4D cho những người muốn nhìn thấy trước những thay đổi như phẫu thuật thẩm mỹ chẳng hạn, em **cảnh báo** là không nên xem web này ở trên cty nha 😂), repo hiện tại đã nhận được 12.4k sao và nhiều phản hồi tích cực từ cộng đồng Ruby Dev.\n- 🌱 [Awesome-ruby](https://github.com/markets/awesome-ruby) là repo phân loại tổng hợp những `thư viện cho Ruby`, những `tools`, `frameworks`, `best practice` và `phần mềm` có chất lượng `awesome` có thể sẽ cần thiết để chúng ta xây dựng những `modern Apps` hay `Web Apps` .\n\n### 🌿 Điều kiện tiêu chuẩn:\n- 🌱 Để được thêm vào repo, cần đạt những chất lượng tiêu chuẩn sau:\n\t- Thường được sử dụng(tối thiểu là 20k lượt tải) và hữu ích với cộng đồng.\n\t-   Chủ động bảo trì, cập nhật thường xuyên(chỉ cần là vẫn giải quyết các issues cho version hiện tại cũng là đạt yêu cầu rồi).\n\t-   Ổn định.\n\t-   Được tài liệu hóa.\n\t-   Có tests.\n\n\u003e [!note]\n\u003e \n\u003e Với những điều kiện trên thì mọi người có thể yên tâm mấy thứ được suggests trên repo toàn là hàng chất lượng thôi nhé :v\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.05-Ruby/Check-prefix-of-string":{"title":"🥦 Check prefix of string","content":"\n### 🌿 What?\n- 🌱 Trong Ruby, class `String` cung cấp method `start_with?` nhận vào những tiền tố mà bạn muốn xác định, trả về `true` nếu chuỗi kiểm tra bắt đầu bằng một trong những tiền tố đó.\n\n```rb\nstring = \"hello world\"\n\nstring.start_with?(\"abc\", \"mentor\") # =\u003e false\nstring.start_with?(\"zys\", \"hell\")   # =\u003e true\n```\n\n- 🌱 Tham số:  \n\t- Phân biệt chữ Hoa và chữ thường\n\t- Nhận regex\n\n```rb\nstring = \"hello world\"\n\nstring.start_with?(\"zys\", \"Hell\") # =\u003e false\nstring.start_with?(/[\\s\\S]*/)     # =\u003e true\n```\n\n### 🌿 Refer\n[https://til.hashrocket.com/posts/rettwv4dgl-check-if-string-starts-with-prefixes](https://til.hashrocket.com/posts/rettwv4dgl-check-if-string-starts-with-prefixes)","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.05-Ruby/Combine-arrays-in-Ruby":{"title":"🥦 Combine arrays in Ruby","content":"\n## 🌿 What?\n\n- 🌱 Trong quá trình làm dự án, mình cần build dữ liệu cho `f.select` từ 2 mảng lấy được từ server, ruby cung cấp method `.zip` để kết hợp mảng.\n\n```rb\nids = [1,2,3,4]\naddress = ['a', 'b', 'c', 'd']\n\nids.zip(address)\n=\u003e [[1,'a'],[2,'b'],[3,'c'], [4,'d']]\n```\n\n- 🌱 Trường hợp cần kết hợp đầy đủ tất cả các cases từ các phần tử của mảng, sử dụng `Enumerator.product`.\n- Ví dụ như web bán quần áo, cta có mảng Size và mảng Brand, vì mới bán nên các Brand vẫn còn đủ các size.\n\n```rb\nsizes = ['small', 'medium', 'large']\nbrands = ['adidas', 'nike', 'puma', 'lv']\n\nEnumerator.product(sizes, brands)\n=\u003e [\n  ['small', 'adidas'],\n  ['small', 'nike'],\n  ['small', 'puma'],\n...\n  ['large', 'puma'],\n  ['large', 'lv']\n]\n```","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.05-Ruby/Comment-multi-lines-in-ruby":{"title":"🥦 Comment multi lines in ruby","content":"\n- 🌱 Comment nhiều dòng(thay vì dùng # ở mỗi dòng) trong Ruby như sau:\n\n```rb\n=begin\n  this is first comment!\n  this is sencond comment!\n=end\n\ndef func; end\n```\n\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.05-Ruby/Floating-point-error":{"title":"🥦 Floating-point error","content":"\n## 🌿 What?\n\n-   Trong các ngôn ngữ lập trình, khi tính toán với float hoặc double thì sẽ gặp sai số. VD:\n\n```rb\n1.9 + 1.2\n=\u003e 3.0999999999999996\n```\n\n- Với những ngành như tài chính, tiền bạc mà tính lệch một số sau dấu phẩy thôi là tới công chiện liền 🥵\n\n## 🌿 Solution\n\n- Trong DB chúng ta hay dùng `decimal` với 2 thông số `precision(số lượng chữ số tính cả sau dấu ,)` và `scale(số lượng chữ số sau dấu ,)` để tính toán.\n- Còn khi chúng ta thao tác ở bên ngoài, ví dụ như trong code hoặc console thì có thể sử dụng BigDecimal.\n\n```rb\nBigDecimal(\"1.2\") + BigDecimal(\"1.9\")\n=\u003e 0.31e1\n\n_.to_f\n=\u003e 3.1\n```\n\n\n## 🌿 Refer \n\n-   [https://spin.atomicobject.com/2014/08/14/currency-rounding-errors/](https://spin.atomicobject.com/2014/08/14/currency-rounding-errors/)\n-   [https://ttuan.xyz/til/computer/floating_point_math/](https://ttuan.xyz/til/computer/floating_point_math/)\n-   https://www.youtube.com/watch?v=PZRI1IfStY0\u0026ab_channel=Computerphile","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.05-Ruby/Get-last-occurrence-of-value-in-an-array":{"title":"🥦 Get last occurrence of value in an array","content":"\n- 🌱 Trong Ruby, hàm `rindex` nhận vào một giá trị và trả về index cho lần cuối cùng giá trị đó xuất hiện trong array.\n\n```rb\narr= ['b', 'a', 'a', 'a']\narr.rindex('a')\n#=\u003e 3\n\narr.rindex('b')\n#=\u003e 0\n```\n\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.05-Ruby/Operator-+-and-with-string":{"title":"🥦 Operator += and \u003c\u003c with string","content":"\n- 🌱 Trong Ruby, hãy nối chuỗi bằng `\u003c\u003c` thay vì `+=`!\n\t- `+=` sẽ tạo ra một object mới sau khi nối chuỗi.\n\n```rb\nname = \"Hoang\"\n\nname.object_id\n=\u003e 71860\n\nname += \" Anh\"\n\nname.object_id\n=\u003e 71880\n```\n\n- 🌱 `\u003c\u003c` sẽ nối chuỗi trực tiếp trên object cũ, không tạo ra object mới. Cải thiện performance khi thao tác với những chuỗi lớn.\n\n```rb\nname = \"Hoang\"\n\nname.object_id\n=\u003e 71900\n\nname \u003c\u003c \" Anh\"\n\nname.object_id\n=\u003e 71900\n```\n\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.05-Ruby/Ruby-Module-Include-Prepend-and-Extend":{"title":"🥦 Ruby Module: Include, Prepend and Extend","content":"\n## 🌿 Ancestors chain\n- Khi khởi tạo một Class, mỗi Class sẽ có một `ancestors chain` - là danh sách các classes và modules mà nó được kế thừa hoặc imported.\nTrong Ruby có 3 cách để import Module cho 1 Class.\n\n### 🌱 Include\n- Method trong module sẽ trở thành `instance method` của Class.\n- Thứ tự trong `ancestors chain`: `Class` \u003e `Module/Class imported` \u003e `Superclass`.  \n\n```rb\nmodule A\n\tdef say\n\t\tp 'hello'\n\tend\t\nend\n\nclass B\n\tinclude A\nend\n```\n\n``` sh\n\u003e B.new.say\n=\u003e \"hello\"\n\u003e\n\u003e B.ancestors\n=\u003e [B, A, ..., Object, ..., BasicObject]\n```\n\n### 🌱 Prepend\n- Giống `include`, khác thứ tự được thêm vào trong `list ancestors`.\n- Thứ tự trong `ancestors chain`: `Module/Class imported` \u003e `Class` \u003e `Superclass`.\n\n```rb\nmodule A\n\tdef say\n\t\tp 'hello'\n\tend\t\nend\n\nclass B\n\tprepend A\nend\n```\n\n``` sh\n\u003e B.new.say\n=\u003e \"hello\"\n\u003e\n\u003e B.ancestors\n=\u003e [A, B, ..., Object, ..., BasicObject]\n```\n\n### 🌱 Extend\n- Method trong module trở thành `class method` của Class.\n- Import methods của module vào `ancestors chain` của `singleton class` của class extend.\n\n```rb\nmodule C\n\tdef say\n\t\tp 'hello'\n\tend\t\nend\n\nclass D\n\textend C\nend\n```\n\n``` sh\n\u003e D.new.say\n=\u003e undefined method 'say' ...\n\u003e\n\u003e D.say\n=\u003e \"hello\"\n\u003e\n\u003e D.ancestors\n=\u003e [D, ..., Object, ..., BasicObject]\n\u003e\n\u003e D.singleton_class.ancestors\n=\u003e [#\u003cClass:D\u003e, C, ...] \n```\n\n\n### 🌿 Tham khảo\n- https://medium.com/@leo_hetsch/ruby-modules-include-vs-prepend-vs-extend-f09837a5b073","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.05-Ruby/Splat-in-ruby":{"title":"🥦 Splat in ruby","content":"\n- 🌱 Splat array in ruby with syntax below:\n\n```rb\narray = [1,2,3]\nsplat_array = [*array, 4, 5] # =\u003e [1,2,3,4,5]\n```\n\n- 🌱 Splat hash in ruby with syntax below:\n\n```rb\nhash = {a: 1, b: 2}\nsplat_hash = { **hash, c: 3} # =\u003e {:a=\u003e1, :b=\u003e2, :c=\u003e3}\n```","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.05-Ruby/Split-array-by-condition-in-Ruby":{"title":"🥦 Split array by condition in Ruby","content":"\n### 🌿 What?\n- 🌱 Từ 2.5.1, Ruby cung cấp method `partition`, chia 1 mảng thành 2 mảng con dựa theo điều kiện truyền vào.\n\n```rb\n(1..6).partition { |v| v.even? }\n#=\u003e [[2, 4, 6], [1, 3, 5]]\n\n['', '1', '12', '123', '1234'].partition { |v| v.length \u003e 2 }\n#=\u003e [['123', '1234'], ['', '1', '12']]\n```\n\n### 🌿 Refer\n- 🌱 Link doc: [Enumerable#partition](https://ruby-doc.org/core-2.5.1/Enumerable.html#:~:text=partition%20%7B%20%7Cobj%7C%20block%20%7D%20%E2%86%92%20%5B%20true_array%2C%20false_array%20%5D)\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.05-Ruby/each_with_object-method-in-ruby":{"title":"🥦 each_with_object in ruby","content":"\n## 🌿 What?\n\n- 🌱 `each_with_object` là method viết gọn cho TH chúng ta cần khởi tạo biến để lưu giá trị sau từng lần lặp. Tương tự như [[50 til/51 Code/51.05 Ruby/reduce() method in Ruby|reduce()]].\n\n```rb\nnumbers = [1, 2, 3, 4, 5]\n\ndef specify_array(array)\n  array.each_with_object([]) { |n, arr| arr \u003c\u003c n if n \u003e 3 }\nend\n\nspecify_array(numbers)\n=\u003e [4, 5]\n```\n\n## 🌿 Compare with reduce()\n\n- 🌱 Khác nhau về thứ tự tham số.\n\n```rb\nnumbers = [1, 2, 3, 4, 5]\n\n# initial object is first arg, second arg is array's element\nsum_by_reduce = numbers.reduce(0) { |sum, num| sum + num }\n\n# opposite to reduce() method\nsum_by_each_with_object = numbers.each_with_object(0) { |num, sum| sum += num }\n```\n\n- 🌱 Thêm nữa là reduce sẽ trả về đối giá trị tích lũy còn each_with_object trả về object khởi tạo. Để ý syntax của 2 ví dụ trên, `each_with_object` phải sử dụng `+=` còn `reduce` thì không.\n## 🌿 Refer \n\n- [https://ruby-doc.org/core-3.0.1/Enumerable.html#method-i-each_with_object](https://ruby-doc.org/core-3.0.1/Enumerable.html#method-i-each_with_object)","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.05-Ruby/instance_eval-in-ruby":{"title":"🥦 instance_eval() in ruby","content":"\n## 🌿 What?\n\n- 🌱 Trong Ruby, class Object có public method là `instance_eval()`, method này cấp quyền truy cập tới các biến instance của object, nhận vào string chứa code Ruby hoặc block và excute theo context của object.\n\n```rb\nclass Klass\n  def initialize\n    @secret = 99\n  end\nend\n\nirb(main):001:0\u003e k = Klass.new\nirb(main):002:0\u003e k.instance_eval { @secret }\n=\u003e 99\n```\n\n```rb\n# add method\nstring = \"String\"\nstring.instance_eval do\n  def new_method\n    self.reverse\n  end\nend\n\nirb(main):033:0\u003e string.new_method\n=\u003e \"gnirtS\"\n```\n\n- 🌱 Tương tự với module và class sẽ có `module_eval()` và `class_eval()`\n\n## 🌿 Refer \n- [https://apidock.com/ruby/Object/instance_eval](https://apidock.com/ruby/Object/instance_eval)\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.05-Ruby/reduce-method-in-Ruby":{"title":"🥦 reduce() method in Ruby","content":"\n## 🌿 What?\n\n- 🌱 `reduce` là method viết gọn cho TH chúng ta cần khởi tạo biến để lưu giá trị sau từng lần lặp.\n\n```rb\nnumbers = [1, 2, 3, 4, 5]\n\ndef specify_array(arr)\n  array = 0\n  arr.each do |num|\n    arr \u003c\u003c num if num \u003e 3\n  end\n  array\nend\n\nspecify_array(numbers)\n=\u003e [4, 5]\n```\n\n- Sử dụng `reduce()`\n\n```rb\nnumbers = [1, 2, 3, 4, 5]\n\ndef specify_array(array)\n  array.reduce([]) { |arr, n| arr \u003c\u003c n if n \u003e 3 }\nend\n\nspecify_array(numbers)\n=\u003e [4, 5]\n```\n\n## 🌿 Refer \n- https://apidock.com/ruby/Enumerable/reduce","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.05-Ruby/w-and-W-in-Ruby":{"title":"🥦 %w and %W in Ruby","content":"\n## 🌿 What?\n\n- 🌱 `%w` return an splited array from a input string by space.\n\n```sh\nirb\u003e %w(I am from Vietnam)\n#=\u003e [\"i\", \"am\", \"from\", \"Vietnam\"]\n```\n\n- 🌱 `%W` is similar `%w` but allows receive interpolation value.\n\n```sh\nirb\u003e country = \"Vietnam\" \nirb\u003e %w(I am from #{country})\n#=\u003e [\"i\", \"am\", \"from\", \"\\#{country}\"]\n\nirb\u003e %W(I am from #{country})\n#=\u003e [\"i\", \"am\", \"from\", \"Vietnam\"]\n```\n\n- 🌱 Similar with %q, %Q, %i, %I, ...\n\n## 🌿 Refer \n- [https://til.hashrocket.com/posts/aqkz0yqdky-the-difference-between-w-and-w-in-ruby](https://til.hashrocket.com/posts/aqkz0yqdky-the-difference-between-w-and-w-in-ruby)","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.06-Servers/Bastion-Host-l%C3%A0-g%C3%AC":{"title":"🥦 Bastion Host là gì?","content":"\n## 🌿 What?\n\n![[00 Meta/01 Attachments/Pasted image 20221124184306.png]]\n\n🌱 **Bastion Host(máy chủ pháo đài)** đúng như tên gọi, là một server sinh ra với sứ mệnh phòng vệ trước những mối hiểm họa có thể tấn công vào mạng lưới nội bộ của chúng ta.\n\n🌱 **Theo định nghĩa của AWS**, **Bastion Host** là một server có mục đích cung cấp quyền truy cập vào mạng nội bộ từ mạng bên ngoài, chẳng hạn như Internet.\n\n🌱 Hoạt động như cầu nối, đứng giữa **private instance** và những truy cập từ bên ngoài. Vì vậy khi tắt **Bastion**, người ngoài cũng sẽ không có cách nào có thể truy cập vào **private instance** của chúng ta.\n\n## 🌿 Why?\n\n🌱 Tăng khả năng bảo mật trong việc quản lý truy cập vào **private instance**.\n\n## 🌿 Architect\n\n![[00 Meta/01 Attachments/Pasted image 20221124183444.png]]\n\n- **Bastion Host** đặt ở Public subnet, để bên ngoài truy cập vào được. \n- **Linux Instance** đặt ở Private subnet, chỉ có thể truy cập thông qua Bastion.\n\n🌱 Về mặt lý thuyết, hành trình thật sự để từ ngoài có thể vào được Linux Instance đó là:\n-   Internet Gateway\n-   Route Table\n-   Network ACL\n-   Security Group\n-   Bastion Host\n\n## 🌿 Refer\n📑 https://aws.amazon.com/blogs/security/how-to-record-ssh-sessions-established-through-a-bastion-host/","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.06-Servers/Config-SSH":{"title":"⚙️ Config SSH","content":"\n## 🌿 Issue\n- 🌱Chắc hẳn là một dev BE, các bạn ít nhiều cũng từng có lần ssh lên server để check log, xem db, hay là config dự án, ... Quy trình đểcó thể ssh được lên  server sẽ gồm có những bước cơ bản như sau:\n\t- Tạo một bộ khóa tại máy local.\n\t- Đưa public key cho bên infra hoặc người có thể lên được server, để họ thêm key của chúng ta vào 1 file - file này sẽ chứa các keys có thể ssh.\n- 🌱 Sau đó mỗi lần ssh chúng ta sẽ cần phải gõ command:\n\n```sh\nssh user_name@ip\n```\n\n- 🌱 Vấn đề ở đây là, chúng ta khó có thể nhớ chính xác 2 thông tin trên cho mỗi lần ssh. Trước đây mình sẽ note những thông tin này vào một chỗ nào đấy bí mật, khi nào cần ssh thì bật lên và copy vào, rất là mất thời gian. Đã thế khi gen ra nhiều key ssh, mình còn phải set -i để chỉ định ssh-key nào sẽ được dùng để ssh nữa.\n\n## 🌿 Solution\n\n- 🌱 Khi search vấn đề này, mình thấy mọi người thường sẽ không dùng cách stupid trên kia của mình mà sẽ sử dụng file  ~/.ssh/config. Và nó giải quyết hoàn toàn được 2 vấn đề mình gặp phải ở trên.\n\t1. Không cần nhớ thông tin ssh: user_name, ip\n\t2. Không cần chỉ định bằng cơm ssh-key khi ssh nữa\n- 🌱 Mọi người chỉ cần thêm vào file ~/.ssh/config như ở dưới:\n\n```sh\nHost project-dev\n  Hostname 1.0.5.374\n  User deployer\n  IdentityFile ~/.ssh/project-dev-ecdsa\n\nHost project-prod\n  HostName 1.12.6.52\n  User deployer\n  IdentityFile ~/.ssh/project-pro-ecdsa\n```\n\n- Host: tên tắt dùng để ssh, có thể đặt tên theo project để dễ nhớ nhé. \n- Hostname: ip server\n- User: user trên server\n- IndentityFile: chỉ định ssh-key sẽ dùng để ssh cho Host\n\n🌱 Việc đơn giản bây giờ là chúng ta ssh theo Host thôi 💪🏻 !!\n\n```sh\nssh project-dev\n```\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.06-Servers/Remote-Desktop-Protocol":{"title":"🥦 Remote Desktop Protocol","content":"\nBình thường các server mình được làm trước đây đều là Ubuntu Server, muốn truy cập lên thì dùng ssh-key là được. Nhưng do spec của dự án hiện tại mình làm có yêu cầu sử dụng Window Server. Khi gửi thông tin Server(IP, users, pass) anh PSM có gợi ý dùng `RDP Client` để truy cập vào. Cơ mà `RDP Client` là cái khỉ gì 😅\n\n## 🌿 What?\n- 🌱`RDP` là một giao thức độc quyền được phát triển bởi Microsoft, cung cấp cho người dùng giao diện để truy cập đến một máy tính khác thông qua kết nối internet. Bạn có thể làm mọi thứ với PC remote như một PC vật lý bình thường. Ví dụ như:  \n\t- Sử dụng các ứng dụng của PC remote.\n\t- Truy cập file và các tài nguyên mạng của PC remote.\n\t- Tắt các ứng dụng khi bạn thoát khỏi `RDP Client` (giống shut down PC vật lý.)\n- 🌱 `Remote Desktop Protocol severs` được dùng để các clients kết nối, severs mặc định của RDP là `TCP port 3389` và `UDP port 3389`.\n- 🌱 **Remote Desktop Connection** được tích hợp cho `RDP Clients` trong hệ điều hành Windows.\n\n## 🌿 Quick connect to a Windows Server from Ubuntu using RDP Client\n\n- 1️⃣ Step 1: Đảm bảo PC hoặc server Windows mà bạn muốn truy cập đã được bật Remote Desktop Connections. \n- 🌱 Nếu chưa bạn có thể xem cách bật ở [đây](https://www.digitalcitizen.life/enable-remote-desktop-windows/).\n- 2️⃣ Step 2: Mặc định Ubuntu cung cấp `Remmina` để hỗ trợ RDP. Turn on!\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Remote Desktop Protocol/Pasted image 20221017142240.png]]\n\n- 3️⃣ Step 3: Tạo một connect mới.\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Remote Desktop Protocol/Pasted image 20221017171736.png]]\n\n- 4️⃣ Step 4: Điền thông tin server.\n\t- Tiếp theo là setting độ phân giải và color depth của màn hình desktop remote. Mặc định sẽ chọn độ phân giải và color depth ở mức cao nhất. Tuy nhiên, setting 2 thông số này thấp hơn sẽ cải thiện khá nhiều perfomance đấy.\n\t- Nếu muốn chia sẻ folder với Windows Server, check folder box và chỉ định folder cần chia sẻ.\n\t- Ngoài ra ở mục Advanced, bạn có thể bật/tắt tiếng, chia sẻ máy in, tắt đồng bộ cho bộ nhớ tạm, ...\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Remote Desktop Protocol/Pasted image 20221017172232.png]]\n\n- 5️⃣ Step 5: Lưu và chạy thôi!\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Remote Desktop Protocol/Pasted image 20221017174839.png]]\n\n\n## 🌿 Góc so sánh\n\n- 🌱 Theo định nghĩa, công dụng của thằng này nghe cũng khá giống TeamView nhỉ 😀 So sánh thôi 😗\n\nRemote Desktop Protocol | TeamView\n------------ | ------------\nLà giao thức được tích hợp sẵn trong hệ điều hành Windows và được phát triển độc quyền bởi công ty Microsoft  | Là một phần mềm chia sẻ quyền điều hành máy tính được phát triển bởi TeamViewer GmbH\nKhông cho phép người dùng theo dõi tác vụ trên máy remote | Cho phép người dùng dõi tác vụ trên máy remote\nYêu cầu cấu hình port chuyển tiếp trên `firewall` hoặc route của máy remote | Chỉ cần cài đặt là dùng bình thường\n\n- 🌱 Nhìn chung TeamView ngon và dễ sử dụng hơn RDP nhưng TeamView lại tiềm ẩn rủi ro bị lộ dữ liệu,  thông tin, như ở công ty mình TeamView được liệt vào danh sách đen không được cài đặt ấy.\n- 🌱 Tùy theo bối cảnh mọi người có thể cân nhắc sử dụng giữa 2 này nhé. \n\n## 🌿 Tham khảo\n- https://learn.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/remote-desktop-clients\n- https://www.techrepublic.com/article/teamviewer-vs-remote-desktop/","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.06-Servers/The-paradigms-that-generually-applied-when-release":{"title":"🥦 The paradigms that generually applied when release","content":"\n\nVới những dự án đã có cộng đồng người dùng lớn, việc deploy những tính năng mới lên môi trường `production` cần phải có những phương pháp để giảm thiểu tối đa những rủi ro cũng như đạt được trải nghiệm tốt nhất dành cho người dùng.  Những mô hình thường được áp dụng thực tế: `A/B Testing`, `Canary Deployments`  và  `Blue-Green Deployments`.\n\n### 🌿 A/B Testing\n- 🌱 Sử dụng để review độ hiệu quả và phản ứng của người dùng đối với những thay đổi mới.\n- 🌱 Những thay đổi mới sẽ chỉ được `rolled out` với một bộ phận người dùng nhất định. So sánh đánh giá của người dùng để đưa ra những chiến lược phát triển phù hợp hơn trong tương lai.\n- 🌱 Mô hình này được áp dụng cả cho phát triển web, bán hàng, quảng cáo, vv... \n\n![[00 Meta/01 Attachments/Pasted image 20221025184727.png]]\n\n\n### 🌿 Blue-Green Deployments\n- 🌱 Là một chiến lược deploy dùng để kiểm thử những tính năng mới của dự án.\n- 🌱 Deploy without downtime.\n- 🌱 Mô hình này gồm 2 servers chạy đồng thời là Blue và Green, đều là môi trường `production` nhưng một server có status `live` - nhận reqs của users còn server kia là `idle` - không hoạt động.\n\n![[00 Meta/01 Attachments/Blue-Green Deployments.excalidraw.png]]\n\n### 🌿 Canary Testing\n- 🌱 Cũng giống 2 ý đầu của  `Blue-Green Deployments`.\n- 🌱 Thay vì switch toàn bộ users truy cập giữa Blue và Green, `Canary Testing` sử dụng cân bằng tải, cho phép một số users có thể sử dụng version code mới, sau khi chạy ngon lành thì dần dần áp dụng cho toàn bộ users của hệ thống.\n\n![[00 Meta/01 Attachments/Pasted image 20221025184522.png]]\n\n### 🌿 Tham khảo\n- https://www.oreilly.com/library/view/spring-50-microservices/9781787127685/6fab55ad-8897-42b7-b509-dd90850c861b.xhtml\n- https://circleci.com/blog/canary-vs-blue-green-downtime/\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.07-Utils/%C4%90%C3%A1nh-s%E1%BB%91-hi%E1%BB%87u-phi%C3%AAn-b%E1%BA%A3n-ph%E1%BA%A7n-m%E1%BB%81m":{"title":"🌿 Đánh số hiệu phiên bản phần mềm","content":"\n### 🌿 What?  \n- 🌱 Là quy tắc để xác định và phân biệt tên của phần mềm ở mỗi giai đoạn phát triển. \n- 🌱 Sematic Versioning  \n\t- Là quy tắc thường được sử dụng nhất. Do [Tom Preston-Werner](https://tom.preston-werner.com/) (ng sáng lập và là cựu CEO của Github) tạo ra.\n\t- Có format là `[major].[minor].[patch]` , vd: 5.6.8\n\t\t-   `major`  - tăng lên khi có những thay đổi **không tương thích với phiên bản cũ** (vd thay đổi cấu trúcc response).\n\t\t-   `minor`  - tăng lên khi thêm tính năng mới **nhưng vẫn tương thích với phiên bản cũ** (vd thêm trường trả về trong response).\n\t\t-   `patch`  - tăng lên khi fix bug **nhưng vẫn tương thích với phiên bản cũ**.\n\n### 🌿 Refer\n[https://viblo.asia/p/semantic-versioning-OeVKBN2EKkW](https://viblo.asia/p/semantic-versioning-OeVKBN2EKkW)","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.07-Utils/Cron-job-notify-drink-water":{"title":"🥂 Tạo background job nhắc nhở uống nước đều đặn","content":"\nKhông biết mọi người có giống mình không, mỗi khi làm việc mình cứ bị quên uống nước ấy, có khi cả buổi mình còn chả uống được 250ml nước =((. Tác hại của việc uống ít nước mọi người có thể gg nha, nhưng ncl uống nước đủ mỗi ngày là thói quen rất có lợi cho sức khỏe cũng như làn da của chúng ta =)).\n\nHôm trước mình có gặp anh mentor ở cty, anh ấy chia sẻ là vì hay ngồi gù lưng nên anh ấy viết một script để sau một khoảng thời gian, thông báo kiểu như 'Thẳng lưng lên!' được hiển thị trên Touch Bar. 🤩, hay thế!!! Sao mình ko áp dụng để improve khả năng uống nước của bản thân nhỉ 🤔 Thế nên tranh thủ cuối tuần, mình có tìm cách để setup cronjob cho Ubuntu.\n\n### 🌿 How?\n- 🌱 Đầu tiên là setup cronjob, mình có xài `cron`, mn có thể dùng apt để install và enable nó lên nhé.\n\n```sh\nsudo apt update\n# Check if cron package is installed\ndpkg -l cron\n\n# install cron\nsudo apt install cron\n\n# enable cron\nsystemctl start cron\n\n# check status cron\nsystemctl status cron\n\n# stop cron\nsystemctl stop cron\n```\n\n- 🌱 Để thêm job, sử dụng command:\n\n```sh\ncrontab -e\n```\n\n- 🌱 Trong file đã có hướng dẫn cụ thể, về cơ bản cũng giống như setup cron-sidekiq, nếu chưa quen settings thời gian chạy job mọi người có thể sử dụng [cron-time](https://crontab.guru/) cho trực quan nhé!\n\nVí dụ mình set 20p là phải nhắc t uống nước đó nha Ubuntu =))\n\n```sh\n20 * * * * cd ~/personal \u0026\u0026 ./script-notify-myself.sh\n```\n\n- 🌱 Tạo script:\n```sh\n#!/bin/bash\n\nexport DBUS_SESSION_BUS_ADDRESS=\"${DBUS_SESSION_BUS_ADDRESS:-unix:path=/run/user/${UID}/bus}\"\nnotify-send \"Uống nước đii!!!\"\n```\n\n- 🌱 Và kết quả là:\n\n\n### 🌿 Update\n- 🌱 Sau một thời gian thêm cronjob, mình khá là khó chịu vì cái bảng thông báo của mình nó cứ hiển thị chất đống `Uống nước đii!!!`, rất là mất mỹ quan đô thị.\n\n![[00 Meta/01 Attachments/Notifi Trash.png]]\n\n- 🌱 Để khắc phục vấn đề này, mình có thêm một script chịu trách nhiệm để clear-all tất cả những thông báo hiện tại. \n\n```sh\n# ./remove-all-notify-tray.sh\n\n#!/bin/bash\ngdbus call --session --dest org.gnome.Shell --object-path /org/gnome/Shell --method org.gnome.Shell.Eval 'Main.panel.statusArea.dateMenu._messageList._notificationSection._list.remove_all_children()'\n```\n\n- 🌱 Mình có viết scripts ở [đây](https://github.com/anhnh-3008/dotfiles/tree/main/cronjob)  để sau dùng lại cho tiện, nếu thấy hứng thú mọi người có thể pull về chạy thử nha ❤️\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.07-Utils/DATE_SUB":{"title":"🥦 DATE_SUB - ngược về quá khứ","content":"\n- 🌱 Trong SQL, hàm `DATE_SUB()` trả về ngày sau khi đã lùi một khoảng thời gian chỉ định.\n\n```sql\nDATE_SUB(date, INTERVAL value unit)\n\n# date: Ngày làm mốc.\n# value: thời gian bị trừ(có thể chỉ định giá trị âm || dương)\n# unit: đơn vị thời gian(ngày, giờ, phút, ...)\n```","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.07-Utils/Find-by-Regex-in-VsCode":{"title":"🥦 Find by Regex in VsCode","content":"\n\n## 🌿 Vấn đề\n\n🌱 Tôi có một file cần xóa nhiều dòng thừa có cấu trúc giống nhau (dòng trống, dòng comment ,...) trong VsCode.\n\n## 🌿 Giải pháp\n\n- 🌱 Trong thanh tìm kiếm của VsCode, có option tìm kiếm theo regex. Nếu muốn xóa dòng trống,  `Ctrl + H` -\u003e thêm regex `^$\\n` -\u003e `Ctrl + Alt + Enter ` là xong.\n\n![[00 Meta/01 Attachments/Pasted image 20221130152936.png]]\n\n- 🌱 Option rất tiện khi chúng ta muốn tìm những giá trị có format giống nhau(số điện thoại, email, etc ...) ","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.08-System-Design/CORS-Cross-origin-Resource-Sharing":{"title":"📑 CORS - Cross-origin Resource Sharing","content":"\n## 🌿 What?\n- 🌱 `CORS`  là một cơ chế cho phép chia sẻ nhiều tài nguyên(images, files, fonts, javascript,...) giữa nhiều trang web khác nhau.\n\n## 🌿 Why?\n- 🌱 CORS ra đời do sự xuất hiện của [[50 til/51 Code/51.08 System Design/Same-origin policy]].\n\n## 🌿 How?\n- 🌱 `CORS` sử dụng các HTTP Header để thông báo với trình duyệt nhận request là 'Em là con ông A nhà bà B ở cuối làng, anh cho em vào lấy ít đồ cho bố em nhé ' =))\n- 🌱 `Access-Control-Allow-Origin`  ở header mà trường này ko có giá trị hoặc giá trị ko hợp lệ thì sẽ bị báo lỗi.\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.08-System-Design/Open-ID-ConnectOIDC":{"title":"🔐 Open ID Connect(OIDC)","content":"\nLà một loại cơ chế xác thực kiểu [[50 til/51 Code/51.08 System Design/Single Sign-On(SSO)]] dựa trên thuật toán **mật mã hóa khóa bất đối xứng**. Có 2 khóa đảm nhiệm riêng từng nhiệm vụ là mã hóa và giải mã.\n**![](https://lh5.googleusercontent.com/1cxM7BkCmyzrm0Q17OIv7x3GcMzfyLhaHnExHl6foJLIL0e0nruB8tWPJu4RwoZNlLn1XFNlieM0gG2JiCHff760sQ87LyzxX1GJobxyoPGE0i72olWaxzLasNXmm3_iC4NEYfsKheuPVME_LxigUMArWVomwIKfbCD1Gt82o_Hs3Vh2d_HKWweu3A)**\n**![](https://lh4.googleusercontent.com/ku-PU5gsE-WnRbitam-zVKFWzcmYPxsst_bfbtVlU3KhmKcIbJ9qB5-TVBnoxQHkOfWRWEVLmV_fwQk7lgiU_t8-UYHti_T4ZBSXxh3k-Ei_2Gm_oufq8LKosdEVYrjenxEnkzPqNYCKAA_3vggJT2XeD8_Rj_ud8g6gNCTWO_0qtfKY_kfMFiD66g)**\n\nẢnh trên mô tả cơ chế hoạt động của [Mật mã hóa khóa công khai](https://vi.wikipedia.org/wiki/M%E1%BA%ADt_m%C3%A3_h%C3%B3a_kh%C3%B3a_c%C3%B4ng_khai), hiểu đơn giản thì 2 cái này sẽ giống nhau nhưng với 1 cái thì cả 2 khóa phải được giữ bí mật còn lại thì một khóa bí mật một khóa công khai.\n\nOIDC là phiên bản mở rộng của Oauth 2.0, thay vì là Access-Token chúng ta sẽ nhận được một Id Token từ Auth Server. Với [access-token](https://oauth.net/id-tokens-vs-access-tokens/#:~:text=Access%20tokens%20are%20what%20the,read%20by%20the%20OAuth%20client.), mỗi lần qua một trang web khác chúng ta sẽ cần request lại access-token mới nhưng với id-token có thể dùng lại thoải mái, [id-token](https://oauth.net/id-tokens-vs-access-tokens/#:~:text=Access%20tokens%20are%20what%20the,read%20by%20the%20OAuth%20client.) có thể xác thực được user cũng như đảm bảo được các thông tin thuộc về User là ko thể bị giả mạo.\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.08-System-Design/Robustness-Diagram":{"title":"🥦 Robustness Diagram","content":"\n## 🌿 What?\n- 🌱 Là một dạng UML diagram nằm trong `ICONIX Process`, xác định tất cả những objects và mối liên hệ của từng `use case`.\n\t- Giảm sự mơ hồ của phần mô tả `use case`, dễ dàng hơn cho việc thiết kế, kiểm tra và estimate. \n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/Robustness Diagram/Robustness reponsibility.excalidraw.png]]\n\n\u003e [!info] ICONIX Process\n\u003e \n\u003e `ICONIX Process` là một phương pháp luận phát triển phần mềm, mục tiêu là để tránh [analysis paralysis](https://en.wikipedia.org/wiki/Analysis_paralysis). Chỉ sử dụng 4 UML cơ bản ứng với 4 bước trong quá trình chuyển đổi từ `Use Case text` thành `Code` .\n\n- 🌱 Mỗi diagram sẽ trả lời cho từng câu hỏi:\n\t- `Use Cases` - Users đang làm gì?\n\t- `Domain Models` - Có những Objects nào?\n\t- `Robustness Diagrams` - Những Object nào tham gia trong từng `use case`?\n\t- `Sequence Diagrams` - Những Object tương tác với nhau như thế nào?\n\n## 🌿 How?\n- 🌱 Sử dụng khuôn mẫu `boundary/control/entity class`.\n\n- 🌱 4 nguyên tắc cơ bản:\n\t- `Actors` chỉ có thể giao tiếp với `Boundary objects`.\n\t- `Boundary objects` chỉ có thể giao tiếp với `Control objects` hoặc `Actors`.\n\t- `Entity objects` chỉ giao tiếp được với `Control objects`.\n\t- `Control objects` có thể giao tiếp với `Boundary objects`, `Entity objects` và một số `Control objects` khác, nhưng cấm chơi với `Actors`.\n\u003e [Ý nghĩ của các khuôn mẫu](https://docs.nomagic.com/display/MD190/Robustness+diagram#:~:text=Boundary%20or%20Interface,and%20entity%20objects.)\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/Robustness Diagram/Object Rubustness.excalidraw.png|500]]\n\n\n- 🌱 Ví dụ:\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/Robustness Diagram/Robustness of use case access to homepage.excalidraw.png]]\n\n## 🌿 Tham khảo\n- https://en.wikipedia.org/wiki/ICONIX\n- https://docs.nomagic.com/display/MD190/Robustness+diagram","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.08-System-Design/Same-origin-policy":{"title":"📑 Same-origin policy","content":"\n\n## 🌿 What?\n-  Là một cơ chế bảo mật hạn chế việc `documents` hoặc `script load` thuộc một `origin` có thể tương tác với những `resources` thuộc một `origin` khác.\n-  Được cài đặt vào toàn bộ  các trình duyệt hiện nay.\n-  Chính sách này giúp trang web của chúng ta không bị truy cập bừa bãi từ những tác nhân lạ.\n\t- Ví dụ nếu bạn vào một trang web bất kỳ được cài sẵn một mã độc truy cập đến trang web VCB, nếu bạn đã đăng nhập vào VCB, vẫn còn hiệu lực đăng nhập và không có chính sách này, hacker sẽ chiếm được quyền sử dụng tài khoản ngân hàng của bạn.\n\t- Còn bình thường mn sẽ nhận được message này ở console browser\n\n```js\nAccess to XMLHttpRequest at 'https://vietcombank.com/profile' from origin 'xxx' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.\n```\n\n- 🌱 Nhưng thực hiện truy vấn giữa nhiều trang web với nhau là việc rất thường xuyên đối với một lập trình viên, đặc biệt là vụ call API. Và thế là Cross-origin Resource Sharing - CORS ra đời =))","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.08-System-Design/Sequence-Diagram-l%C3%A0-g%C3%AC":{"title":"🥦 Sequence Diagram là gì?","content":"\nSắp tới mình được giao tasks là vẽ lại `sequence diagram` cho toàn bộ tính năng của một con dự án ở cty, mà nghe đâu là gần 40 chục cái hay sao ấy 🤢 Thế nên tranh thủ cuối tuần mình ngồi ôn lại chút để tuần sau vào việc cho lẹ 💪 Let's go!!!\n\n## 🌿  What?\n- `Sequence Diagram`  -Biểu đồ tuần tự là một dạng biểu đồ `UML - Unified Modeling Language` dùng để xác định trình tự diễn ra của một nhóm đối tượng nào đó.\n- Biểu đồ miêu tả chi tiết các thông điệp được gửi và nhận của từng đối tượng đồng thời cũng chú trọng cả việc xác định thứ tự của những thông điệp đó.\n\n## 🌿  Các thành phần\n\nGồm 4 thành phần chính:\n- Đối tượng (Object or Class)\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Đối tượng.excalidraw.png]]\n\n- Đường đời đối tượng (Lifelines)\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Đường đời đối tượng.excalidraw.png]]\n\n\n- Thông điệp (messages)\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp.excalidraw.png]]\n\n- Các dạng thông điệp\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp đồng bộ.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp không đồng bộ.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp trả về.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp nội tại.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp tạo mới.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp cập nhật.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp xóa.excalidraw.png]]\n\n- Tiến trình xử lý (process)\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Tiến trình xử lý.excalidraw.png]]\n\n\n\n## 🌿 Ví dụ\n\n![[00 Meta/01 Attachments/Sequence Diagram chức năng đăng nhập.excalidraw.png]]\n\n## 🌿 Tham khảo\n- https://www.smartdraw.com/uml-diagram/\n\n\n\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.08-System-Design/Single-Sign-OnSSO":{"title":"🔐 Single Sign-On(SSO)","content":"\n## 🌿  Issue\nHiện nay hầu hết các dịch vụ web đều yêu cầu người dùng đăng nhập trước khi sử dụng. Nhu cầu sử dụng dịch vụ ngày càng nhiều đồng nghĩa chúng ta càng phải nhớ nhiều thông tin đăng nhập, giả sử nếu chúng ta dùng 10 webs khác nhau, việc nhớ thông tin đăng nhập cũng khá là 'vất vả' đúng ko nào =))\n- Chính vì vậy mà đã lòi ra cu SSO này =))\n\n## 🌿  What?\n![[00 Meta/01 Attachments/Single Sign-On.png]]\n\n- `Single Sign-On` là cơ chế giúp người dùng đăng nhập một ID cho một vài trang webs hoặc hệ thống liên quan nhưng độc lập với nhau. Kiểu như Google dùng tài khoản Gmail đăng nhập cho các services độc lập(Driver, Clouds, ...). Một khóa mở được nhiều chìa 🤞\n\n## 🌿  Why?\n### Ưu điểm\n- Giảm thời gian nhập lại thông tin đăng nhập\n- Giảm [password fatigue](https://en.wikipedia.org/wiki/Password_fatigue) cho hệ thống\n- Giảm effort phát triển chức năng log-in\n- Giảm thiểu rủi ro việc lộ thông tin của người dùng\n- Nâng cao hiệu suất cho người dùng. Người dùng ko phải nhớ nhiều thông tin đăng nhập.\n- Quản lý dễ dàng hơn. Giả sử bạn có 3 trang webs và bạn muốn ban account A, nếu dùng SSO bn chỉ cần setting banned một lần cho cả 3 webs.\n\n### Nhược điểm:\n- Phụ thuộc vào bên thứ 3\n\n\n🌱 Lắm ưu ít nhược nên SSO khá là ngon, hiện tại cũng có khá nhiều service thứ 3 cung cấp dịch vụ SSO miễn phí(Facebook, Google, Github, ...) mọi người có thể cân nhắc sử dụng theo nhu cầu phát triển của dự án nhé =))\n\n## 🌿  How?\nSSO là một phần của [[50 til/51 Code/51.08 System Design/System Identification Link]], có liên quan chặt chẽ với việc xác thực thông tin người dùng. Nó sẽ định danh người dùng, và sau đó chia sẻ thông tin định danh được với các hệ thống con.\n\n### Cơ chế\nTheo luồng bình thường user đăng nhập web A sẽ sinh ra cookie để xác thực cho những request sau, nếu mang cookie đó sang web B để xác thực thì sẽ tạch do các trình duyệt hiện nay chỉ có thể truy cập cookie do chính nó tạo ra.\n![[00 Meta/01 Attachments/Auth SSO.png]]\nHiểu đơn giản giữa các web sẽ có một **browser cookie storage** chung và sử dụng cơ chế Cross-origin resource sharing. Khi Web nào đăng nhập thì sẽ truy cập vào **browser cookie storage** để lấy cookie lên **server auth**(của bên thứ 3) để xác thực.\n\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.08-System-Design/Store-passwords-safely-in-the-database":{"title":"🛡️ Store passwords safely in the database","content":"\n## 🌿 Những điều không nên làm\n- Không được lưu passwords dạng text trong db, vì bất cứ người nào có quyền connect vào db đều sẽ xem được nó.\n- Lưu password hashes trực tiếp cũng không an toàn vì nó có thể vị vô hiệu hóa bởi những cuộc tấn công tính toán trước(`precomputation attacks`), vd như là `rainbow tables`.\n- Để hạn chế `precomputation attacks`, chúng ta hãy `salt the passwords`.\n\n### What is salt?\n- Theo như hướng dẫn của OWASP, `salt` là một chuỗi duy nhất, được sinh ra ngẫu nhiên và được thêm cho từng password như là một phần của quá trình mã hóa.\n\n\n## 🌿 How to store?\n![[00 Meta/01 Attachments/Pasted image 20221004102412.png]]\nTheo hình trên, mọi người có thể hình dung các bước để lưu password vào DB như sau:\n\t1. User cung cấp password.\n\t2. Hệ thống sinh ra `salt` cho password.\n\t3. Trong DB sẽ lưu cả `salt` và `hash` được mã hóa từ `password + salt`. \n\n## 🌿 How to validate?\n**![](https://lh5.googleusercontent.com/VT3b8cvDZ6idbl8D3zYpTNiHhiBp72vR4CLfjAvJx0-Tjp7ZIGy63DtQeMfbtsjwfh5Q8uk3ch16YIMp4wCVwmzyb1A9-aTZ0cSFgyb3kVjvr9X3N_ZmP7-iD_Akoh7TqveaTkM-jBZG1084xwwNqYUs5RaI7GwfxiV7fxYwQngMrmgirVgS9lHk)**\nCác bước hệ thống thực hiện validate:\n\t1. User cung cấp validate.\n\t2. Lấy mã `salt`  của user được lưu trong DB.\n\t3. Thực hiện mã hóa từ `password + salt` =\u003e `hash`\n\t4. So sánh `hash` tạo từ bước 3 và `hash` lưu trong DB. \n\nP/s:  Ngoài ra mọi người có thêm cơ chế nào khác để có thể lưu trữ pasword an toàn trong DB không? Nếu có hãy cmt cho mình biết với nha \u003c3\n\n## 🌿 Tham khảo\n- Free System Design - ByteByteGo - Trang 13\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.08-System-Design/System-Identification-Link":{"title":"📑 Hệ thống nhận diện liên kết","content":"\nHệ thống nhận dạng liên kết( Federated Identity Glossary) là nơi tập trung và liên kết thông tin người dùng. Có 4 yếu tố nền tảng cấu thành nên hệ thống này:\n-   **Xác thực (Authentication):** kiểm tra thông tin đăng nhập và tiến hàng định danh người dùng.\n-   **Phân quyền (Authorization):** dựa trên thông tin định danh để kiểm tra quyền truy cập của user.\n-   **Trao đổi thông tin người dùng (User attributes exchange):** Mỗi hệ thống con sẽ cần và lưu trữ các thông tin khác nhau của người dùng, tuy nhiên sẽ có các thông tin bị lặp lại, ví dụ như tên, họ.... Do đó, cần có một nơi để tổng hợp lại các thông tin này, và trao đổi cho các hệ thống con.\n-   **Quản lí người dùng (User management):** admin có thể quản lí người dùng bằng các thao tác thêm, sửa, xóa... ở các hệ thống con.\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.08-System-Design/Why-is-RAM-access-faster-than-hard-disk-drive":{"title":"♻️ Why is RAM access faster than hard disk drive?","content":"\nKhi sử dụng Redis, mọi người thường hay nói Redis thực hiện thao tác dữ liệu trên Ram nên có tốc độ truy xuất nhanh hơn rất nhiều so với truy cập vào HDD. Vậy tại sao lại như thế? \n \n## 🌿 Why?\n\n![[00 Meta/01 Attachments/Communication between CPU - RAM - Hard Storage.png]]\n\n\n- HDD nằm cách xa CPU, được kết nối với bảng điều khiển thông qua cổng SATA. 6Gb/s là tốc độ tiêu chuẩn của SATA III, HDD chỉ có thể đọc hoặc viết chứ không thể làm cả hai trong cùng một thời điểm.\n- RAM nằm rất gần CPU và có kết nối băng thông rất cao. Thông lượng của DDR4 là khoản 40Gb/s, ngoài ra RAM còn có thể thực hiện đọc và viết cùng lúc. Khi sử dụng dual channel, RAM sẽ đọc/đọc, viết/đọc, viết/viết chính vì vậy mà nó có thể thao tác một lượng dữ liệu vô cùng lớn trong cùng một thời điểm.\n\n\n## 🌿 Câu hỏi\nThế tại sao người ta lại không thiết kế để HDD lại gần CPU?\nVấn đề lớn nhất là chi phí. Tốc độ xử lý cao tương ứng với giá thành sản xuất cũng sẽ đắt. Và tùy theo mục đích nên mỗi phần sẽ có thiết kế phù hợp -\u003e đạt được cả hiệu năng và giá thành tốt nhất.\n-   Đối với những tác vụ lưu trữ file, đọc/ ghi đơn giản, không yêu cầu xử lý nhanh thì người ta dùng HDD cho rẻ. (ổ cứng lưu trữ)\n-   Các tác vụ cần xử lý nhanh hơn 1 chút, như load hệ điều hành, người ta ưu tiên dùng SSD (ổ cài win ý :v )\n-   Thằng nào cần cache, xử lý tốc độ bàn thờ (làm bộ nhớ tạm cho các phần mềm đang chạy) thì người ta dùng tới RAM, CPU.\n\n![[00 Meta/01 Attachments/Why is RAM access faster than hard disk drive acess.png]]\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.08-System-Design/Why-is-Redis-so-Fast":{"title":"♻️ Why is Redis so Fast?","content":"\n🌱 Có 3 lý do chính giải thích điều này:\n\n![[00 Meta/01 Attachments/3 Reasons why Redis is fast.png]]\n\n- Redis là một cơ sở dữ liệu lưu trữ trên RAM. Tốc độ truy cập RAM đểu nhất cx nhanh hơn 1000 lần so với tốc độ truy cập ổ cứng. Mọi người có thể xem thêm \n- Redis sử dụng `IO multiplexing` và `single-threaded`. IO multiplexing là cơ chế đọc/ghi liên tục của RAM. RAM nhận tất cả các yêu cầu đọc/ghi dữ liệu, để vào một chỗ, sau đó dùng single-threaded lặp qua từng event để tiếp tục xử lý.\n- Redis sử dụng một vài cấu trúc dữ liệu `lower-level`(String lưu thành SDS, ...).\n\n\n## 🌿 Câu hỏi\n- 🌱 Tại sao truy cập từ RAM lại nhanh hơn từ HDD?\n[[50 til/51 Code/51.08 System Design/Why is RAM access faster than hard disk drive?]]\n\n\nP/s: Memcached cũng là một giải pháp khá phổ biến để giải quyết vấn đề cached dữ liệu, mọi người có thể tìm hiểu thêm nhé.\n\n## 🌿  Tham khảo\n- Free System Design - ByteByteGo - Trang 76","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.09-Docker/Best-practice-when-build-Dockerfile":{"title":"🥦 Best practice when build Dockerfile","content":"\n## 🌿 I. Chỉ định rõ version của Base Image\n\n- 🌱 Bad\n\n```Dockerfile\nFROM ruby\n...\n```\n\n- 🌱 Good\n\n```Dockerfile\nFROM ruby:3.1.2\n...\n```\n\n- Nên chỉ định rõ version để có thể tái sử dụng. Cũng tiện theo dõi khi chúng ta muốn upgrade \u0026 maintain. \n\n## 🌿 II. Chỉ nên sử dụng trusted or official base images\n\n- 🌱 Bad\n\n```Dockerfile\nFROM random-dude-on-the-internet/ruby:3.1.2\n```\n\n- 🌱 Good\n\n```Dockerfile\nFROM ruby:3.1.2\n\n# hoặc \n\nFROM random-dude-on-the-internet/ruby:3.1.2\n\n# giả sử chúng ta biết chắc rằng random-dude-on-the-internet uy tín/tín.\n```\n\n- Vì chúng ta không thể chắc rằng Base Image có được sửa đổi hay không. Với những nguồn không uy tín, nếu người viết không ghi change log rõ ràng có thể gây ảnh hưởng đến hệ thống.\n\n## 🌿 III. Chỉ định rõ version của dependencies\n\n- 🌱 Bad\n\n```Dockerfile\nFROM ruby:3.1.2\n\nRUN gem install sinatra\n```\n\n- 🌱 Good\n\n```Dockerfile\nFROM ruby:3.1.2\n\nRUN gem install sinatra -v 2.0.5\n```\n\n- Tương tự như base image, chúng ta cũng nên chỉ định rõ version cho dependencies. Hầu hết các trình quản lý package như `Gemfile.lock`, `package-lock.json`, `yarn.lock` đều chỉ định rõ, dễ dàng quản lý, theo dõi cũng như thuận tiện tái sử dụng.\n\n## 🌿 IV. Đưa những commands ít thay đổi lên trước  \n\n- 🌱 Bad\n\n```Dockerfile\nFROM ruby:3.1.2\n\n# Source code\nCOPY my-code/ /srv/\n\n# Application dependencies\nCOPY Gemfile Gemfile.lock ./\nRUN bundle install\n```\n\n- 🌱 Good\n\n```Dockerfile\nFROM ruby:3.1.2\n\n# Application dependencies\nCOPY Gemfile Gemfile.lock ./\nRUN bundle install\n\n# Source code\nCOPY my-code/ /srv/\n```\n\n- Docker sẽ build lại tuần tự từ trên xuống dưới, bắt đầu từ câu lệnh có 'thay đổi'. Ví dụ như trên, source code sẽ được thay đổi thường xuyên hơn Gemfile, nếu đặt source code ở trên, Docker sẽ build lại cả phần `COPY` với `RUN bundle install` nữa. \n\n\u003e [!note] Note \n\u003e \n\u003e Đặt các lệnh ít có khả năng thay đổi nhất ở trên cùng để tận dụng cache, giảm thời gian build Image.\n\n## 🌿 V. Tránh chạy container với quyền root\n\n- 🌱 Bad\n\n```Dockerfile\nFROM ruby:3.1.2\n\nRUN gem install sinatra -v 2.0.5\n\nRUN echo 'require \"sinatra\"; run Sinatra::Application.run!' \u003e config.ru\n\n# By default this is run as root\nCMD rackup\n```\n\n- 🌱 Good\n\n```Dockerfile\nFROM ruby:3.1.2\n\nRUN gem install sinatra -v 2.0.5\n\n# Tạo user riêng để chạy container\nRUN adduser -D my-sinatra-user\n\n# Chỉ định User thực hiện các câu lệnh RUN, CMD hoặc ENTRYPOINT ở dưới\nUSER my-sinatra-user\n\n# Chỉ định thư mục riêng\nWORKDIR /home/my-sinatra-user\n\nRUN echo 'require \"sinatra\"; run Sinatra::Application.run!' \u003e config.ru\n\n# Các câu lệnh sẽ chạy với quyền của user my-sinatra-user\nCMD rackup\n```\n\n- Mặc định container run với quyền root.\n- Container của chúng ta sẽ tạo ra một process chạy với quyền root trong Linux kernel, điều này có thể gây ra lỗ hổng bảo mật, cho phép attackers thoát khỏi container và thực hiện quyền root trên thiết bị của chúng ta.\n\n## 🌿 VI. Sử dụng -chown khi run COPY hoặc ADD\n\n- 🌱 Bad\n\n```Dockerfile\nFROM ruby:3.1.2\n\n# Tạo user riêng để chạy container\nRUN adduser -D my-sinatra-user\n\n# Chỉ định User thực hiện các câu lệnh RUN, CMD hoặc ENTRYPOINT ở dưới\nUSER my-sinatra-user\n\n# Chỉ định thư mục riêng\nWORKDIR /home/my-sinatra-user\n\n# File copy sẽ thuộc sở hữu của root user\nCOPY Gemfile Gemfile.lock ./\n\nRUN bundle install\n\nCMD rackup\n```\n\n- 🌱 Good\n\n```Dockerfile\nFROM ruby:3.1.2\n\n# Tạo user riêng để chạy container\nRUN adduser -D my-sinatra-user\n\n# Chỉ định User thực hiện các câu lệnh RUN, CMD hoặc ENTRYPOINT ở dưới\nUSER my-sinatra-user\n\n# Chỉ định thư mục riêng\nWORKDIR /home/my-sinatra-user\n\n# File copy sẽ thuộc sở hữu của my-sinatra-user user\nCOPY --chown=my-sinatra-user Gemfile Gemfile.lock ./\n\nRUN bundle install\n\nCMD rackup\n```\n\n- `USER` chỉ chỉ định user thực hiện `RUN`, `CMD` hoặc `ENTRYPOINT`. Còn với `COPY` và `ADD` chúng ta cần sử dụng `--chown`.\n\n## 🌿 VII. Tránh làm lộ thông tin nhạy cảm trong Dockerfile\n\n- 🌱 Bad\n\n```Dockerfile\nFROM ruby:3.1.2\n\nENV DB_PASSWORD \"real password\"\n```\n\n- Các thông tin như trên không bao giờ được hiện diện trong Dockerfile của chúng ta dưới dạng text thô. Thay vào đó, chúng ta có thể sử dụng thông qua những cách sau:\n\t- Lệnh `ARG` và truyền giá trị thông qua flag `--build-arg` khi run.\n\t- Biến môi trường.\n\n\u003e [!warning] Lưu ý\n\u003e Hai cách trên vẫn có rủi ro vì các giá trị thô sẽ vẫn được ghi lại trong lịch sử build.\n\n## 🌿 VIII. Xóa luôn những thông tin nhạy cảm sử dụng để build\n\n- 🌱 Bad\n\n```Dockerfile\nFROM ruby:3.1.2\n\nARG PRIVATE_SSH_KEY\n\n# Bước này sẽ lưu lại PRIVATE_SSH_KEY\nRUN echo \"${PRIVATE_SSH_KEY}\" \u003e /root/.ssh/id_rsa\n\n# Đến bước này vẫn sẽ còn giá trị của PRIVATE_SSH_KEY\nRUN bundle install\n\nRUN rm /root/.ssh/id_rsa\n```\n\n- 🌱 Good\n\n``` Dockerfile\nFROM ruby:3.1.2\n\nARG PRIVATE_SSH_KEY\n\nRUN echo \"${PRIVATE_SSH_KEY}\" \u003e /root/.ssh/id_rsa \u0026\u0026 \\\n  bundle install \u0026\u0026 \\\n  rm /root/.ssh/id_rsa\n```\n\n- Nếu có ai truy cập được vào lịch sử build thì có thể lấy được giá trị của PRIVATE_SSH_KEY. Chúng ta nên xóa luôn trong cùng một step để tránh trường hợp trên.\n\n## 🌿 IX. Tối ưu size của base image nếu có thể\n\n- 🌱 Bad\n\n```Dockerfile \nFROM ruby:3.1.2\n\nCMD ruby -e \"puts 1 + 2\"\n```\n\n- 🌱 Good\n\n```Dockerfile \nFROM ruby:3.1.2-alpine\n\nCMD ruby -e \"puts 1 + 2\"\n```\n\n- Base Image có nhiều version(chủ yếu khác nhau về base OS), chúng ta nên lựa chọn phù hợp với nhu cầu sử dụng. Mọi người có thể xem thêm ở [[50 til/51 Code/51.09 Docker/What is mean the tag suffix of an image on docker hub?|đây]]\n- Khi lựa chọn Image base từ OS thu gọn, cần để ý:\n\t- Phải có package manager và các gói có sẵn.\n\t- Xem OS đó sử dụng Shell gì.\n\t- Tránh các môi trường thử nghiệm, dễ gây rủi ro về mặt bảo mật hoặc tính ổn định.\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.09-Docker/Docker":{"title":"🐬 Docker","content":"\n## 🌿 I. Bối cảnh\n\n**![](https://lh6.googleusercontent.com/l1T2krPv068MLPC1J8jYFIDgQ47_VT1VmUcFofBWypN-Kb-EX6IBfULvpeD4TsBh40meAUN-7A6erjR-s48nkuQxA8xWOxAC4GiFLLWPoyLHEViSScy14ABVJP0VPY8sT1MMUFNDBp8yTOQWxEZcgS0erEK4qO9orhKcrRJEv_6KlyPbbjl-Pmca)**\n🌱 Trước đây mô hình máy chủ được tạo thành bởi ba yếu tố:\n* Máy chủ vật lý (Physical Server)\n- Hệ điều hành ([[50 til/51 Code/51.03 Operating System/Linux Basic|Operating System]])\n- Các ứng dụng (Application)\n\nMô hình trên có những nhược điểm:\n-   Một máy chủ chỉ cài được 1 OS\n-   Cho dù ổ cứng khủng, ram khủng thì cũng không thể tận dụng hết được\n\n🌱 Vì những nhược điểm đó, công nghệ ảo hóa **Virtualization** được ra đời, ưu điểm so với mô hình cũ là:\n-   Trên một máy chủ vật lý, có thể cài được nhiều hệ điều hành, tận dụng được tài nguyên tốt hơn do có thể phân chia tài nguyên cho từng máy ảo\n\nNhưng vẫn có những thứ chưa được tối ưu:\n-   Về tài nguyên:\n\t-   Khi thiết lập máy ảo chúng ta sẽ cần cấu hình để cung cấp tài nguyên từ ổ cứng và ram từ máy thật cho máy ảo. Những tài nguyên được phân ra sẽ là cố định. Dẫn đến việc, khi bật máy ảo, kể cả khi không làm gì thì máy thật cũng sẽ mất một lượng tài nguyên mà ban đầu chúng ta đã cung cấp.\n-   Về thời gian:\n\t-   Thời gian bật/tắt máy ảo khá lâu(mấy phút lận)\n\n🌱 Để khắc phục những nhược điểm còn tồn đọng đó, công nghệ **Containerization**, ưu điểm của công nghệ này đó là:\n\n![](https://lh4.googleusercontent.com/mUbQaVuvrz58iy4ySacviA8nGD1-MNeX6TzY3sSxY982frJtmsICy3JZplo52qHH4ffyiy01eKZpH9x0oE2nMgnkLT7l2iAHkSzoucvthQsozcYFAt1soJAmHPjftBXcQ8x5EGPJYzYV5GvZJ9LTZ1XfFTvNzMf8K6wBMei84RzAicKTG0fBsVLk)\n\n-   Thừa hưởng khả năng tạo được nhiều máy ảo trên cùng một máy chủ vật lý như **Virtualization** , nhưng tốt hơn ở chỗ những máy ảo này sẽ dùng chung phần nhân và cùng chia sẻ với nhau tài nguyên của máy mẹ. Máy ảo dùng bao nhiêu tài nguyên sẽ được cấp bấy nhiêu, chứ ko có tình trạng tài nguyên bị rảnh rỗi nữa, như vậy thì việc tận dụng tài nguyên sẽ tối ưu hơn.\n-   Đặc trưng của công nghệ này là sử dụng các **containers**.    \n\n![](https://lh6.googleusercontent.com/r4-OlfYsbR1dZ0M_NkB6e49MefZWZUR2RZK2kppihpj1PTkebxA_C-cT4SIRJuKiNuSBYxpWO46t_-U16KCSHJNiYD9P1Mdr1SEIomyw9fi5gEga5srvhymPoJoOpx_sOtR2KJsytnhTDk6fhS-3O-7yfFuRPy5Oh6Tsi48i-BYiU999MuwBsSZ7)\n\n\n🌱 Với công nghệ **Virtualization**, chúng ta có thể dùng các công cụ tiêu biểu như **Virtualbox** hay **VMware**, còn với **Containerization** đó chính **Docker**.\n\n![](https://lh3.googleusercontent.com/tc5QldwzU46Kx0zuTQZ8inuJax19jfTODrl5z6Wo8KnYXExUbuEA1hKcQ6Os6R_RWv9qU0knCYzlFdOspkgtuE7LRgqrKEYqwdSfXOh7dCw1l3-7RYuKg6BqN_X22_JcGxJNA2Z1NFmMwEqI8mjspbvD6X8XWj7S86edsc-s269_XqNFF--EIkHb)\n\n\n## 🌿 II. What Docker?\n\n- Là mã nguồn mở\n- Mục đích develop, deploy and run applications bằng những containers\n\nXem hướng dẫn cài Docker tại [đây](https://docs.docker.com/engine/installation/)\n\n## 🌿 III. Why Docker?\n\n- Build một lần dùng được nhiều lần và nhiều chỗ\n- Bật/tắt nhanh chóng\n\n## 🌿 IV. Những khái niệm phổ biến\n\n### 1. Container\n- Là một quá trình chạy trên **[[50 til/51 Code/51.03 Operating System/Linux Basic|Linux kernel]]**. \n\tĐược cấp phát tài nguyên riêng: CPU, bộ nhớ và hệ thống tập tin. Chính vì vậy, Docker độc lập với những tiến trình đang chạy của máy tính và không ảnh hưởng đến các containers/processes khác đang chạy.\n\n### 2. Image\nLà tệp chứa mọi thứ cần để thực thi: dependencies, binaries, source code, ... Xây dựng bằng cách thực thi các câu lệnh trong **Dockerfile**. Một **Image** có thể được sử dụng để tạo nhiều **containers** giống nhau. Mỗi **container** là một **instantiation** của **image**.\n\n### 3. Dockerfile\nLà một tệp chứa các câu lệnh cần thiết để xây dựng một **Image**.\n\n## 🌿 V. Một vài câu lệnh hay được sử dụng\n\n- **docker pull image_name**: pull một image từ Docker Hub.\n\n- **docker build**: build một container từ Dockerfile và một context(bao gồm các folders|files được đặt ở PATH/URL).\n\n- **docker run**: chạy container từ một image.\n\n- **docker ps**: list ra những containers đang chạy. **-a/--all** để lấy tất cả containers hoặc -q/--quite nếu chỉ muốn lấy cấc ids của containers.\n\n- **docker logs [container_id/container_name]**: xem logs của 1 container, **-f/--follow** để xem log output.\n\n- **docker volume ls**: list ra các volumes được dùng để lưu trữ data được sinh ra và sử dụng bởi các containers.\n\n- **docker rm [container_id/container_name]**: xóa 1 hoặc nhiều containers.\n\n- **docker rmi [image_id]**: xóa 1 hoặc nhiều images.\n\n- **docker stop**: dừng 1 hoặc nhiều containers.\n\n- **docker kill**: kill 1 hoặc nhiều containers.\n\n- **docker kill $(docker ps -q)**: kill tất cả containers đang chạy\n```cmd\n$(docker ps -q) #lấy ra id của các containers đang chạy.\n\n$(docker ps -a -q) #lấy id của toàn bộ các containers.\n```\n\n- **docker system prune**: Dọn toàn bộ resources(images, containers, volumes, networks) đang bị treo(không liên kết với bất kì container nào).\n\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.09-Docker/Docker-Compose":{"title":"🦑 Docker Compose","content":"\n**![](https://lh6.googleusercontent.com/xSCCWpZ4m29JV6UPl9zCuNj4pDxdGD9shUACJ1auetH158BOcrCYKdtuETCxhgwHVjVrR4BFAeSCXAlz3-QfkhJ9tQoipVV2Taq0O64Bu_TITkvRfVM9io8uUNuc3Mf0amW_Z_mbRVEWhivppaEnymHpucB7YKB08UqkzUzYxoEp8SfG0pysEEpq-g)**\n\n## 🌿 I. What?\n🌱 Chúng ta muốn ứng dụng [[50 til/51 Code/51.09 Docker/Docker]] cho:\n\t- Dự án mới\n\t- Dự án đang phát triển\n\n🌱 Chúng ta có thể dùng [[50 til/51 Code/51.09 Docker/Dockerfile]] cài chung tất cả vào một container duy nhất sau đó chạy project trên container đó.\n**![](https://lh4.googleusercontent.com/mS7LvI78YjVqb9jh1QY0K_KR_n_9jQJm_XLUhq-cVmKhgbj2KKqqA0xczpkSxfDPIf8Z85lI5J9-h1MDb2CLtR2Nod47XYNQFGtwwQ7qr0QqakS5hf9kGHoZ-05xQ46PG6vQI9z0RGCmfrTOe5HrezDmZkzdPnQY5yEMf28vQnubyKVXS0AcyTakDQ)**\n🌱 Tuy nhiên cách này không hợp lý cho việc mở rộng cũng như sử dụng lại cho nhiều projects.\n-\u003e docker-compose ra đời để kết nối những containers riêng lẻ với nhau.\n\u003e - Có thể hiểu docker là con cá voi đang vận chuyển nhiều containers đến cảng Project A.\n\u003e \n\u003e - Còn docker-compose sẽ là con bạch tuộc sử dụng các xúc tua của mình để lấy những containers cần thiết cho Project A.\n\nXem hướng dẫn cài docker-compose tại [đây](https://docs.docker.com/compose/install/)\n\n## 🌿 II. Xây dựng docker-compose\n\n### 1. Cấu trúc thư mục\n🌱 Mình sẽ chỉ làm một project demo nên cấu trúc đơn giản gồm:\n- [x] docker/entrypoint.sh\n- [x] Dockerfile\n- [x] docker-compose.yml\n\n🌱 Khi làm dự án thật, do phải build cho từng môi trường(development, staging, production) nên cấu trúc sẽ có khác hơn một chút, nhưng về cơ bản vẫn là vẫn có đủ thành phần cấu trúc như trên.\n\n### 2. Xác định những containers cần thiết\n🌱 Mình làm demo trên Rails app và những công nghệ mình thấy hay được sử dụng nhất là:\n- [x] Web\n\t- Ruby\n\t- Rails(là Ruby framework nên chỉ cần pull image của ruby thôi)\n- [x] Mysql (hoặc postgret)\n- [x] Redis (lưu cache, backgournd job)\n- [x] Sidekiq (chạy background job)\n\nok triển thôi!!\n\n## 🌿 3. Viết docker-compose\n1. **version**: những version sẽ có vài điểm khác nhau như:\n\t- về cấu trúc và các keys config\n\t- về Docker Engine version thấp nhất mà bạn cần đáp ứng\n\t- networking\nTại thời điểm viết bài này, trên trang chủ cập nhật version mới nhất là 3.8 hỗ trợ cho Docker Engine 19.03.0+\nChi tiết hơn về sự khác nhau của từng version hay các năng cấp từ 2.x lên 3.x thì mọi người có thể đọc thêm ở [đây](https://docs.docker.com/compose/compose-file/compose-versioning) nhé.\n2. **services**: những containers chúng ta định nghĩa sẽ nằm ở đây.\n3. những config trong từng container:\n\t- [x] **image**: chỉ định image được dùng để build container\n\t- [x] **build**: khi muốn build container bằng Dockerfile\n\t- [x] **container_name**: chỉ định tên tùy chỉnh của container nếu ko muốn dùng tên mặc định\n\t- [x] **restart**: mặc định là **no**, nếu set **always** container sẽ khởi động lại khi có lỗi\n\t- [x] **environment**: chỉ định biến mối trường, có thể chỉ định từng biến hoặc file chứa các biến môi trường\n\t- [x] **volumes**: chia sẻ dữ liệu từ máy ảo tới máy thật hoặc giữa nhiều containers với nhau\n\t\t- Ví dụ như container mysql, dữ liệu được tạo ra sẽ được lưu ở thư mục **var/lib/mysql**  trong container, nếu xóa container thì dữ liệu sẽ bị mất sạch.\n\t\t- Chính vì thế nên chúng ta dùng volumes để dữ liệu của container được mount ra ngoài host, nếu có xóa container thì dữ liệu vẫn còn, và khi khởi động lại, dữ liệu được mount ngược vào container và sử dụng bình thường.\n\t- [x] **ports**: Cấu hình cổng kết nối\n\t\t- có thể chỉ định cả 2 cổng **host:container** \n\t\t- vd 123:345 cổng 123 của máy thật sẽ trỏ đến cổng 345 của container\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.09-Docker/Docker-Network":{"title":"🐬 Docker Network","content":"\n## 🌿 What? \n\n🌱 Là mạng sử dụng cho các **containers** có thể kết nối và giao tiếp với nhau. Mỗi **container** có một vùng chứa riêng biệt nên cũng sẽ có mạng, port, IP riêng.\n\n🌱 **[[50 til/51 Code/51.09 Docker/Docker]]** cung cấp sẵn một số mạng mặc định cho các **container**, chúng ta có thể gom một nhóm **[[50 til/51 Code/51.09 Docker/Docker|container]]** vào một mạng chung. Điều này khá là tiện lợi trong trường hợp chúng ta muốn chỉ định một stack phù hợp cho dự án.\n\n## 🌿 What type of network?\n\n- 🌱 Bridge network\n\t- Mạng **Bridge** cho phép kết nối giữa các **container** cùng mạng và sử dụng một dải ip được cấp ngẫu nhiên hoặc tự thiết lập.\n\t- Mạng Bridge đáp ứng hầu hết các usecase nếu triển khai các container trên cùng một host. Nhưng nếu chạy một môi trường đa host, **Bridge** sẽ không làm được điều này, đây sẽ là nhược điểm của mạng **Bridge**.\n\t- Driver của mạng **Bridge** là **bridge**.\n\n- 🌱 Host network\n\t- **Host network** cho phép mạng **container** kết nối với **host**. Và sử dụng IP có cùng dải mạng với **host**.\n\t- Driver của mạng **Host** là **host**.\n\n- 🌱  None network\n\t-   Tắt tất cả kết nối mạng.\n\t-   Driver của mạng **None** là **null**.\n\n- 🌱  Overlay network\n\t-   Nhược điểm của mạng **Bridge** được **Overlay network** và **Macvlan** khắc phục.\n\t-   **Overlay network** thực hiện kết nối nhiều **Docker daemon** với nhau để tạo một mạng ảo trên các máy chủ. Nơi có thể thiết lập kêt nối giữa **swarm service** và **container** độc lặp hoặc hai **container** trên các host khác nhau.\n\t-   Driver của mạng **Overlay** là **overlay**.\n\n- 🌱  Macvlan netwrok\n\t-  **Macvlan network** cho phép bạn gán địa chỉ MAC cho một **container**, biến **container** như một thiết bị vật lý trên mạng.\n\t-   Driver của mạng **Macvlan** là **macvlan**.\n\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.09-Docker/Dockerfile":{"title":"🐬 Dockerfile","content":"\n\n## 🌿 I. Config\n\n- **FROM**: chỉ định image gốc. [[50 til/51 Code/51.09 Docker/Docker]] Hub nơi lưu trữ và chia sẻ các images. Chúng ta có thể lấy các image gốc trên này và về xào nấu lại để phù hợp với nhu cầu sử dụng của mình.\n\n- **MAINTAINER**: optional để đặt tên cho tác giả viết Dockerfile\n\n- **RUN**: thực thi 1 câu lệnh trong quá trình build image.\n\n- **CMD**: thực thi 1 câu lệnh trong quá trình bật [[50 til/51 Code/51.09 Docker/Docker|container]].\n\n\t- Mỗi **Dockerfile** chỉ chạy một câu lệnh CMD, nếu có nhiều hơn sẽ chỉ chạy câu lệnh **CMD** cuối cùng.\n\t\n\t- Nếu muốn khởi động nhiều ứng dụng khi start container, hay sử dụng **ENTRYPOINT**.\n\n- **ENTRYPOINT**: thực thi một số câu lệnh trong quá trình bật container, những câu lệnh này sẽ được viết trong file script có đuôi .sh.\n\n- **EXPOSE**: chỉ định cổng mà container sẽ nghe khi chạy.\n\n- **ADD**: Copy file, thư mục, hoặc remote file thêm chúng vào filesystem của image.\n\n- **COPY**: Copy file, thư mục từ host machine vào image. Có thể sử dụng url cho tập tin cần copy(chưa dùng baoh =))).\n\n- **WORKDIR**: chỉ định directory cho câu lệnh CMD\n\n- **VOLUME**: mount thư mục từ máy host vào container.\n\n\nMình sẽ build những gì học được về docker ở repo này : [app-demo-rails-docker]( https://github.com/anhnh-3008/app-demo-rails-docker), mọi người có thể theo dõi các steps theo pulls cho tiện nhé. \n\nPull mình build Dockerfile: [pull build Dockerfile](https://github.com/anhnh-3008/app-demo-rails-docker/pull/1)\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/51-Code/51.09-Docker/What-is-mean-the-tag-suffix-of-an-image-on-docker-hub":{"title":"🥦 What is mean the tag suffix of an image on docker hub?","content":"\n### 🌿 Vấn đề\n- Khi chạy apt-get update , gặp lỗi KEYEXPIRED như dưới đây.\n\n```sh\nStep 3/15 : RUN apt-get update -qq \u0026\u0026 apt-get install -y build-essential libpq-dev nodejs vim cron\n ---\u003e Running in 8437242de6eb\nW: GPG error: http://deb.debian.org jessie-updates InRelease: The following signatures were invalid: KEYEXPIRED 1668891673\nW: GPG error: http://deb.debian.org jessie Release: The following signatures were invalid: KEYEXPIRED 1668891673\n```\n\n### 🌿 Nguyên nhân\n- Lỗi trên được xác định là do Dockerfile đang base theo Image `ruby:2.4.2` , sử dụng `debian:jessie` , đã hết hạn LTS.\n\n\u003e [!info] LTS (Long Term Time)\n\u003e \n\u003e 🌱 [LTS (Long Term Support)]([https://wiki.debian.org/LTS](https://wiki.debian.org/LTS)) là một dự án hỗ trợ(cập nhật repo, vá lỗi, ...) các versions Debian ổn định đã được release trong vòng ít nhất là 5 năm. LTS không phải do Team Security Debian phát triển mà do một bộ phận những lập trình viên + công ty \"tình nguyện\" triển khai.\n\n### 🌿 Giải pháp\nCó 2 cách\n1. 🌱 Sửa file `/etc/apt/sources.list`, replace repo `jessie-updates` bằng tay. Xem chi tiết hơn ở [đây](https://github.com/docker-library/ruby/issues/394).\n\n 2. 🌱 Đổi Image `ruby:2.4.2 -\u003e ruby:2.4.2-stretch`\n\t- Khi sử dụng Image, mọi người nên để ý phần tag xem nó đang được base theo version OS nào(nhất là các dự án thâm niên). Một số suffix thường gặp:\n\t\t- [-jessie](https://wiki.debian.org/DebianJessie) - Mã phát triển của Debian 8. Có LTS từ ngày 26/04/2015, hết hạn 30/06/2020.\n\t\t-  [-stretch](https://wiki.debian.org/DebianStretch) - Mã phát triển của Debian 9. Team Security Debian ngừng update bảo mật từ 06/07/2020 và đổi qua LTS -\u003e đến khoảng 2025 là hết hạn LTS.\n\t\t-  [-buster](https://wiki.debian.org/DebianBuster) - Mã phát triển của Debian 10, released từ ngày 06/07/2019. Vẫn được Team Security Debian support.\n\t\t-  [-bullseyes](https://wiki.debian.org/DebianBullseye) - Mã phát triển của Debian 11, released từ ngày 14/08/2021. Vẫn được Team Security Debian support.\n\t\t- [-slim](https://github.com/docker-slim/docker-slim) - Tối ưu containers tốt hơn, nhỏ hơn, bảo mật hơn. Cân nhắc khi dùng, vì đây là phiên bản rút gọn, sẽ không đầy đủ bằng bản offical.\n\t\t- [-alpine](https://alpinelinux.org/) - Image được base theo Alpine Linux, đây là một OS thiết kế đặc biệt để chạy trong container. Có size rất bé, vài Mb(\u003c slim). Highly recommended nếu bộ nhớ là tiêu chí ưu tiên. Xem thêm ở [đây](https://stschindler.medium.com/the-problem-with-docker-and-alpines-package-pinning-18346593e891).\n\n### 🌿 Tham khảo\n- Mọi người có thể đọc thêm những thông tin khác(bash, package management, ...) của các versions tag ở đây:\n\t- [https://stackoverflow.com/questions/52083380/in-docker-image-names-what-is-the-difference-between-alpine-jessie-stretch-an](https://stackoverflow.com/questions/52083380/in-docker-image-names-what-is-the-difference-between-alpine-jessie-stretch-an)","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/52-Journey/C%C3%A1c-th%C3%B3i-quen-gi%C3%A0u-c%C3%B3":{"title":"🥦 Các thói quen giàu có","content":"\n## 🌿 What?\n- 🌱 [Thói quen](https://vi.wikipedia.org/wiki/Th%C3%B3i_quen) là một chuỗi phản xạ có điều kiện do rèn luyện mà có. Chuỗi phản xạ này là những hành vi định hình trong cuộc sống và được coi là bản chất thứ hai của con người. \n- 🌱 Xây dựng và kỷ luật bản thân với những thói quen tốt sẽ cải thiện rất nhiều đến chất lượng cuộc sống cũng như xác suất thành công của bản thân.\n\n\u003e [!info] Thói quen tốt\n\u003e \n\u003e Thói quen tốt mang lại cho bản thân sự thịnh vượng cả về sức khỏe, các mối quan hệ, nghề nghiệp, tài chính, và nhiều khía cạch khác trong cuộc sống.\n\n- 🌱 Post này mình sẽ update những thói quen mình đã và đang áp dung với bản thân 💪 để lưu lại bản chất thứ hai của con người mà mình muốn hướng tới ✨ Let's gooooo!!!\n\n### 1. Tập thể dục ít nhất 30p mỗi ngày\n\n![[00 Meta/01 Attachments/Pasted image 20221210173912.png]]\n\n\u003e [!info] Sức khỏe\n\u003e \n\u003e Nằm ở tầng thấp nhất trong [tháp tài sản](https://www.dnse.com.vn/hoc/thap-tai-san-la-gi). Củng cố vững chắc nền móng, về lâu về dài tòa tháp của chúng ta mới có thể xây thật cao và kiên cố.\n\n### 2. Tiết kiệm ít nhất 10% thu nhập hàng tháng\n\n![[00 Meta/01 Attachments/Pasted image 20221210162937.png]]\n\n\u003e [!Info] Tiết kiệm\n\u003e \n\u003e Hãy luôn trả lương cho mình đầu tiên!\n\n- 🌱 Mọi người thường chi tiêu sinh hoạt trước, sau đó còn dư bao nhiêu sẽ tiết kiệm. Vấn đề là ít khi có \"dư\" lắm 😄\n\n### 3. Kiểm soát cảm xúc\n\n![[00 Meta/01 Attachments/Pasted image 20221210170148.png]]\n\n\u003e [!info] Cảm xúc\n\u003e \n\u003e Cảm xúc ảnh hưởng rất nhiều đến những quyết định và hành vi.\n\n### 4. Rèn luyện kỹ năng đọc mỗi ngày\n\n![[00 Meta/01 Attachments/Pasted image 20221211155042.png]]\n\n\u003e [!info] Đọc sách\n\u003e \n\u003e Ai cũng biết đọc sách quan trọng nhưng quan trọng là ko phải ai cũng cố gắng đọc sách (mình đấy 🤣). \n\n\n### 5. Rèn luyện kỹ năng viết mỗi ngày\n\n![[00 Meta/01 Attachments/Pasted image 20221211160225.png]]\n\n\u003e [!info] TIL - Today I Learn\n\u003e \n\u003e Não bộ là nơi suy nghĩ và đưa ra quyết định, không phải là nơi lưu trữ những kiến thức. Việc viết TIL để đảm nhiệm công việc này là vô cùng cần thiết. Khi viết mình có thể hệ thống kiến thức lại một cách rõ ràng, dễ hiểu với bản thân hơn.  \n\n\n### 6. Updating\n\n## 🌿 Refer \n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/52-Journey/C%C3%A1ch-ph%C3%A2n-bi%E1%BB%87t-r%C6%B0%E1%BB%A3u-gi%E1%BA%A3":{"title":"🥦 Cách phân biệt rượu giả(kém chất lượng)","content":"\n## 🌿 What?\n\n- 🌱 Theo TS. Nguyễn Duy Thịnh - Viện Công nghệ sinh học và Công nghệ thực phẩm, Đại học Bách khoa Hà Nội, rượu giả không được kiểm soát trên thị trường Việt Nam đa phần là loại rượu có pha chế `**methanol - một loại cồn công nghiệp**`.  \n- 🌱 Cách phân biệt:  \n\t- Đổ 1 ít rượu ra lòng bàn tay rồi xoa xoa hai bàn tay vào nhau. Nếu hai bàn tay còn dính dính thì là rượu không tốt vì `**andehit dầu Fugien**`  còn đọng lại trong rượu. Rượu tốt sẽ  bay hơi hết khi có tác động của ma sát (cách này hợp lý, dễ áp dụng, để tết em thử).\n\t- Ngửi - nếu mùi cồn thơm cay nồng thì là rượu tốt (cách này hơi khó áp dụng).\n\t- Nếm - rượu chứa `**methanol**` vị sẽ hơi ngọt (cái này cũng khó).\n\t- Thử với lửa - nếu mẫu đốt lên lửa màu vàng thì là rượu chưa `**methanol**` .\n\t- Dùng giấy quỳ đỏ - nhúng giấy vào rượu 2-3 phút nếu giấy đổi màu xanh nước biển -\u003e bỏ ngay không chơi.\n\n## 🌿 Refer\n- Nguồn: VTV24\n\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/52-Journey/Kh%C3%A1m-ph%C3%A1-V%C4%83n-h%C3%B3a-Ngh%E1%BB%87-thu%E1%BA%ADt":{"title":"🥦 Khám phá Văn hóa \u0026 Nghệ thuật","content":"\n## 🌿 What?\n- 🌱 https://artsandculture.google.com/\n- 🌱 Một trang web rất thú vị cho những ai có hứng thú tới Văn hóa \u0026 Nghệ thuật. Google Arts \u0026 Culture là một sáng kiến phi thương mại. GG đã kết nối với rất nhiều tổ chức văn hóa và các nghệ sĩ trên toàn thế giới để có được tài nguyên phong phú cho chủ đề này.\n\n\u003e [!info] Thông điệp\n\u003e \n\u003e Sứ mệnh của chúng ta, đó là bảo tồn và đưa những giá trị văn hóa\u0026nghệ thuật Thế Giới lên Internet để có thể tiếp cận đến bất kỳ ai, ở bất cứ đâu. \n\u003e \n\n- 🌱 Mình lưu cái này zô, khi nào đi du lịch ở đâu thì lên đây tìm hiểu trước, khè mọi người trong đoàn cho zui :v\n- 🌱 Mọi người có thể xem thử [Dấu ấn của một vương triều](https://artsandculture.google.com/story/WQLy5ELTLuXLLQ?hl=vi) nao mà có dịp đi Huế thì đỡ bỡ ngỡ 😆\nObsidian\n\n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/53-Psychology/S%E1%BB%B1-ng%E1%BB%A5y-bi%E1%BB%87n-c%E1%BB%A7a-tay-thi%E1%BB%87n-x%E1%BA%A1-Texas":{"title":"🧠 Sự ngụy biện của tay thiện xạ Texas","content":"\n### 🌿 What?\nMột gã cao bồi bắn bừa lên trên một bức tường, sau đó anh ta vẽ một vòng tròn bao quanh chỗ có nhiều lỗ đạn nhất và tự nhận mình là thiện xạ.\n\n![[00 Meta/01 Attachments/Pasted image 20221026172307.png]]\n\nĐây là cơ chế tâm lý phổ biến ở con người. Chúng ta thường sẽ có xu hướng bỏ qua sự ngẫu nhiên khi kết quả có vẻ có ý nghĩa. \n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/50-til/54-Mindset/L%C3%B9i-l%E1%BA%A1i-m%E1%BB%99t-b%C6%B0%E1%BB%9Bc":{"title":"🥦 Lùi lại một bước ...","content":"\n## 🌿 What?\n\n\u003e [!question] Question\n\u003e \n\u003e Theo bạn, khi nào là thời điểm tốt nhất để bắt đầu một ngày mới?\n\u003e \n\n- Theo mình, thời điểm bắt đầu tốt nhất chính là ngay từ tối hôm trước, khi chúng ta chủ động chuẩn bị cho mình một giấc ngủ đủ và chất lượng thì tự khắc ngày hôm sau sẽ rất là chè tươi ✨\n- Khi đi làm mình cũng có gặp nhiều hoạt động ảnh hưởng bởi tư tưởng này, đơn cử như 5Whys meeting khi một dự án có incident. Mục tiêu của buổi họp là tìm ra lý do gốc rễ gây ra incident. Để làm được điều đó, tất cả các thành viên cần đưa ra các câu hỏi - câu trả lời để dẫn từ ngọn(incident) đến lý do gốc. \n\n```\n                    incident\n                   /        \\\n            lý do 1(issue)  lý do 2(issue)\n                   |          |\n            lý do 3(issue)  lý do 4(root)\n              .....................\n```\n\n- Áp dụng tư duy này vào các vấn đề trong cuộc sống, mình cần suy nghĩ lùi lại một hoặc nhiều bước trước khi đánh giá mọi việc. Tư duy này giúp chúng ta xác định rõ những vấn đề cũng như các bước cần chuẩn bị để đạt được kết quả tốt. \n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/Custom":{"title":"🥦 Fill title","content":"\n## 🌿 What?\n\n\n\n## 🌿 Refer \n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null},"/What-happens-when-add-acts_as-into-model":{"title":"🥦 What happens when add acts_as into model?","content":"\n\u003e [!question] Q?\n\u003e \n\u003e Khi dùng gem paranoia để xóa mềm, chúng ta phải thêm acts_as_paranoid vào model. Vậy acts_as_paranoid tác động gì đến model của chúng ta?  \n\n## 🌿 What?\n\n- 🌱 Trong Rails, `acts_as_xyz` sẽ bổ sung thêm những methods(thường sẽ là method class) cho model chứa nó thông qua các modules và mixins, ví dụ như sắp xếp thứ tự của list, filter theo điều kiện nào đó, ...\n- 🌱 Các acts_as gems sẽ cần chỉ định trước các cột trong bảng, ví dụ như gem `paranoia` mặc định là cột `deleted_at`.\n- \n\n## 🌿 Refer \n","lastmodified":"2023-01-16T11:01:51.581980186Z","tags":null}}