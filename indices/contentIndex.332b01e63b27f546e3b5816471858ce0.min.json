{"/":{"title":"Home","content":"\n\n\u003ch1\u003e Hi there, I'm a Ruby Developer 👋\n\u003ch2\u003e Welcome to my blog!!!\n\n🌱 \u003ca class=\"homepage-list-link\" href=\"40-posts/\"\u003eMy Posts\u003c/a\u003e\n\n🌱 \u003ca class=\"homepage-list-link\" href=\"50-til/\"\u003eTIL\u003c/a\u003e","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/40-posts/42-Code/42.01-Ruby/RubyCritic":{"title":"🌳 RubyCritic","content":"![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020164959.png]]\n\n🌱 `RubyCritic` cung cấp báo cáo trực quan về những vấn đề như code thối, cấu trúc code, tính dễ kiểm tra, và độ phủ của test case cho app Ruby. \n\n🌱 Đang liên tục phát triển và release tính năng mới. Có trong danh sách [Ruby Awesome](https://github.com/markets/awesome-ruby#:~:text=Rubycritic%20%2D%20A%20Ruby%20code%20quality%20reporter.).\n\n🌱 Bài viết này sẽ giới thiệu về một số những lợi ích mà `RubyCritic` đem lại, các `dependencies` của nó và cách để đọc `code reports`.\n\n## 🌿Why?\n\n🌱 Bạn có thể xem xét sử dụng `RubyCritic` nếu muốn có một nơi có thể theo dõi sự phát triển của code trong dự án. Áp dụng `RubyCritic` vào process dự án chắc chắn sẽ giảm được thời gian của team dev cho việc khắc phục `Technical debts`. Hầu hết các `technical debts` đều sẽ được phát hiện sớm và 'trả nợ' trong giai đoạn phát triển luôn.\n\n\u003e technical debts là gì?\n\u003e ...\n\u003e ...\n\u003e ...\n\n🌱 Một số những lợi ích của `RubyCritic` khi chúng ta áp dụng cho dự án hay process phát triển:\n- Thống nhất thông tin về một nơi duy nhất.\n- Báo cáo trực quan\n- Cài đặt dễ dàng\n- Không config\n- Cho phép tùy chỉnh theo nhu cầu sử dụng\n- Có thể mở rộng - Là open-source chúng ta có thể tích hợp thêm tính năng của mình.\n- Một trình tạo huy hiệu.\n\nĐể hiểu hơn về cách `RubyCritic` hoạt động, hãy xem những `internal dependencies` được sử dụng để tạo một report mặt mũi như thế nào nhé!  \n\n## 🌿 Internal dependencies trong Rubycritic\n\n- Khi bạn thêm `RubyCritic`, một số dependencies cũng được thêm kèm. \n- Điểm qua những dependencies chủ chốt: `The Reek`, `Flay`, và `Flog`. Đây đều là những gem cho phép `RubyCritic` hiển thị những thông tin hữu ích liên quan đến những code của bạn. Hiểu được cách hoạt động của bọn này sẽ thuận tiện hơn trong việc sử dụng `RubyCritic`.\n\n### 🌱 Reek: Tìm code Ruby bốc mùi 💩\n\n- [Reek](https://github.com/troessner/reek) là một gem dùng để tìm những dòng code 💩 trong Ruby. Code thối không phải là code sai, nó là những dòng code có thể được viết dễ đọc hơn, dễ bảo trì hoặc phát triển hơn nhưng vẫn đúng logic với ban đầu.\n- Reek sẽ phân tích xem có chỗ nào bốc mùi nhưng sẽ không gợi ý là sửa như thế nào vì hầu như code 'có mùi' đều liên quan đến business logic hoặc dựa theo kinh nghiệm của lập trình viên đối với một ngôn ngữ lập trình.\n\n\u003e Reek chỉ đánh giá được theo hướng chủ quan, nên chúng ta cũng nên cân nhắc thêm dựa theo logic của dự án cũng như kinh nghiệm của bản thân trước khi quyết định sửa code.\n\n- Reek cung cấp  [extensive list of smells](https://github.com/troessner/reek/blob/master/docs/Code-Smells.md). Kiểm tra và chỉ ra những chỗ bốc mùi trong:\n\t- Classes\n\t- Attributes\n\t- Methods\n\t- Parameters\n\t- Moduldes\n\t- Iterators\n\t- The implementation of polymorphism\n\n- Nhờ đó chúng ta sẽ chủ động trong việc làm cho code dễ đọc và dễ bảo trì hơn.\n\n- Cho phép config để:\n\t- Tắt kiểm tra những rule ko phù hợp với dự án.\n\t- Chỉ định các thư mục không cần kiểm tra.\n\t- Sử dụng filter để tắt tiếng cảnh báo.\n\n### 🌱 Flay: Kiểm tra code lặp\n- [Flay](https://ruby.sadi.st/Flay.html) xác định những điểm tương đồng trong cấu trúc code, bao gồm:\n\t- Tìm ra code bị lặp lại trong dự án.\n\t- Cho điểm để đánh giá mức độ tốt của code(điểm càng thấp, code càng ngon).\n\t- Checking the difference at any code level.\n\n- Nếu Flay báo cáo có sự trùng lặp trong code, khả năng cao chúng ta nên sửa nó. Đừng  bỏ qua vì nó rất có khả năng dẫn đến bugs. Khi bạn fix thêm gì đó ở một chỗ nhưng quên sửa những chỗ còn lại thì có khả năng bug sẽ xuất hiện đó.\n\n```rb\n# lib/flay.rb:80\nopts.on(\"-m\", \"--mass MASS\", Integer, \"Sets mass threshold (default = #{options[:mass]})\") do |m|\n  options[:mass] = m.to_i\nend\n \n# lib/flay.rb:105\nopts.on(\"-t\", \"--timeout TIME\", Integer, \"Set the timeout. (default = #{options[:timeout]})\") do |t|\n  options[:timeout] = t.to_i\nend\n```\n\nKiểm tra:\n```bash\n$ flay lib/flay.rb\nTotal score (lower is better) = 36\n \n1) Similar code found in :iter (mass = 36)\n  lib/flay.rb:80\n  lib/flay.rb:105\n```\n\nMặc dù nội dung bên trong không giống nhau hoàn toàn nhưng cấu trúc code có thể được cấu trúc lại để tránh trùng lặp. Đó là magic của Flay.\n\n\u003e Flay đánh giá trùng lặp dựa trên cấu trúc code, nếu điểm trùng lặp càng thấp có nghĩa code chúng ta càng ngon(dry). Tuy nhiên, chúng ta vẫn cần đánh giá thêm cả về logic của dự án trước khi sửa nhé.\n\n### 🌱 Flog: Kiểm tra độ phức tạp trong code\n[Flog](https://ruby.sadi.st/Flog.html) kiểm tra xem độ phức tạp của code(code khó đọc). Flog gán điểm phức tạp cho từng dòng sau đó tính tổng cho mỗi method hoặc class.\n\n``` rb\ndef validate_expiration\n  return if exp_month.blank? || exp_year.blank?\n \n  ...\nend\n```\n\nKiểm tra:\n```sh\n$ flog app/models/credit_card.rb\n \n5.2: CreditCard#validate_expiration   app/models/credit_card.rb:12-15\n```\n\n\n- Độ phức tạp đang là 5.2, giờ mình sẽ sửa để nó dễ đọc hơn một chút\n\n```rb\ndef validate_expiration\n  return if exp_month.blank?\n  return if exp_year.blank?\n \n  ...\nend\n```\n\nKiểm tra:\n```sh\n$ flog app/models/credit_card.rb\n \n4.8: CreditCard#validate_expiration app/models/credit_card.rb:12-15\n```\n\n\u003e Viết code là trò chơi đơn giản, nhưng để viết code đơn giản, dễ hiểu thì lại khó nhất trên đời 😆 Đừng cố viết cao siêu làm gì, hãy viết code thật dễ hiểu, hiệu quả để những người đồng nghiệp đọc code của bạn không phải chửi thầm nhé ❤️  \n\n### 🌱 Other Dependencies \n- Ngoài ra `RubyCritic` còn có nhiều dependencies khác, có cả những gem phổ biến mà chúng ta vẫn thường dùng như `buybug`, `simpleCov`, `rubocop`. Mọi người có thể xem đầy đủ các dependencies ở [đây](https://github.com/whitesmith/rubycritic/blob/main/rubycritic.gemspec).\n\n\n## 🌿Áp dụng cho dự án Ruby on Rails\n\n- `RubyCritic` cung cấp tài liệu chi tiết để bắt đầu mà không cần config nhiều. Trong khuôn khổ bài viết này, chúng ta sẽ tập trung cho việc phân tích những thông số có trong những báo cáo của `RubyCritic`.\n- Có 3 vấn đề được báo cáo là `Code`, `Smells` và `Coverage`. Cùng lược qua từng tính năng này nhé!\n\n### 🌱 Overview\nSau khi chạy `rubycritic` xong, tự động redirect tới một trang html chứa các reports của dự án.\n\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020153521.png]]\n\n- Màn `Overview` hiển thị tổng điểm của dự án trên một cái biểu đồ donut, xếp hạng theo A là tốt nhất và F là tệ nhất.\n- Phần `Summary` hiển thị chi tiết của từng rating (A -\u003e F) bao gồm số lượng files, số lượng commit(churns) và số lượng smell code được tìm thấy.\n- `Churn vs Complexity` hiển thị vị trí các Class/Module là một điểm, ứng với 2 chỉ số độ phức tạp và số lượng commit =\u003e phản ánh chính xác những điểm chưa tốt của dự án.\n\n### 🌱 Code Report\n\n- Hiển thị điểm của từng Class/Module bao gồm `churn`, `complexity`, `duplication` and `smells`.\n- Bạn có thể sort theo từng chỉ số để tiện đánh giá.\n- Có thể search tên của Class/Module.\n\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020154211.png]]\n\n- Click vào một Class/Module bất kỳ sẽ hiển thị chi tiết source code và các số liệu đi kèm như:\n\t- Code line\n\t- Chất lượng code\n\t- Churn\n\t- Độ phức tạp của method\n\t- Điểm phức tạp(tổng của class)\n\t- Số lượng code bị duplicates.\n\t- Số lượng smells tìm thấy.\n\n- Những dòng code có vấn đề sẽ được highlight(Dựa theo thông tin cả Reek gem cung cấp)\n\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020155314.png]]\n\n\n### 🌱 Smells Report\n- Hiển thị smell type, vị trí chính xác nơi bốc mùi và tình trạng khắc phục.\n- Như đã nói ở trên, Smells được cung cấp bởi gem Reek, và màn này chúng ta cũng có thể search và sort được như `Code Report`.\n- Bạn có thể nhìn thấy các class/module được nhóm theo smell type.\n\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020162956.png]]\n\n### 🌱 Coverage Report\n![[00 Meta/01 Attachments/01.01 Post/Code/Ruby/RubyCritic Gem/Pasted image 20221020164032.png]]\n\n- Chỉ hiển thị thông số độ bao phủ của kiếm thử đối với những class/module. \n- Không thể sắp xếp hoặc tìm kiếm như 2 trang bên trên.\n- Nếu tích hợp `SimpleCov` thì sẽ chi tiết và trực quan hơn, nhưng với hầu hết trường hợp chỉ cần một báo cáo đơn giản để đánh giá độ phủ của dự án, `Coverage Report` đã hoàn toàn đáp ứng được rồi.\n\n## ☘️Tham khảo\n- https://github.com/whitesmith/rubycritic\n- https://blog.appsignal.com/2022/10/19/improve-code-in-your-ruby-application-with-rubycritic.html\n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/40-posts/42-Code/42.02-Docker/Docker":{"title":"🐬 Docker","content":"\n---\n\n## I. Bối cảnh\n---\n\n**![](https://lh6.googleusercontent.com/l1T2krPv068MLPC1J8jYFIDgQ47_VT1VmUcFofBWypN-Kb-EX6IBfULvpeD4TsBh40meAUN-7A6erjR-s48nkuQxA8xWOxAC4GiFLLWPoyLHEViSScy14ABVJP0VPY8sT1MMUFNDBp8yTOQWxEZcgS0erEK4qO9orhKcrRJEv_6KlyPbbjl-Pmca)**\n🌱 Trước đây mô hình máy chủ được tạo thành bởi ba yếu tố:\n* Máy chủ vật lý (Physical Server)\n- Hệ điều hành ([[50 til/51 Code/51.03 Operating System/Linux Basic|Operating System]])\n- Các ứng dụng (Application)\n\nMô hình trên có những nhược điểm:\n-   Một máy chủ chỉ cài được 1 OS\n-   Cho dù ổ cứng khủng, ram khủng thì cũng không thể tận dụng hết được\n\n🌱 Vì những nhược điểm đó, công nghệ ảo hóa **Virtualization** được ra đời, ưu điểm so với mô hình cũ là:\n-   Trên một máy chủ vật lý, có thể cài được nhiều hệ điều hành, tận dụng được tài nguyên tốt hơn do có thể phân chia tài nguyên cho từng máy ảo\n\nNhưng vẫn có những thứ chưa được tối ưu:\n-   Về tài nguyên:\n\t-   Khi thiết lập máy ảo chúng ta sẽ cần cấu hình để cung cấp tài nguyên từ ổ cứng và ram từ máy thật cho máy ảo. Những tài nguyên được phân ra sẽ là cố định. Dẫn đến việc, khi bật máy ảo, kể cả khi không làm gì thì máy thật cũng sẽ mất một lượng tài nguyên mà ban đầu chúng ta đã cung cấp.\n-   Về thời gian:\n\t-   Thời gian bật/tắt máy ảo khá lâu(mấy phút lận)\n\n🌱 Để khắc phục những nhược điểm còn tồn đọng đó, công nghệ **Containerization**, ưu điểm của công nghệ này đó là:\n\n![](https://lh4.googleusercontent.com/mUbQaVuvrz58iy4ySacviA8nGD1-MNeX6TzY3sSxY982frJtmsICy3JZplo52qHH4ffyiy01eKZpH9x0oE2nMgnkLT7l2iAHkSzoucvthQsozcYFAt1soJAmHPjftBXcQ8x5EGPJYzYV5GvZJ9LTZ1XfFTvNzMf8K6wBMei84RzAicKTG0fBsVLk)\n\n-   Thừa hưởng khả năng tạo được nhiều máy ảo trên cùng một máy chủ vật lý như **Virtualization** , nhưng tốt hơn ở chỗ những máy ảo này sẽ dùng chung phần nhân và cùng chia sẻ với nhau tài nguyên của máy mẹ. Máy ảo dùng bao nhiêu tài nguyên sẽ được cấp bấy nhiêu, chứ ko có tình trạng tài nguyên bị rảnh rỗi nữa, như vậy thì việc tận dụng tài nguyên sẽ tối ưu hơn.\n-   Đặc trưng của công nghệ này là sử dụng các **containers**.    \n\n![](https://lh6.googleusercontent.com/r4-OlfYsbR1dZ0M_NkB6e49MefZWZUR2RZK2kppihpj1PTkebxA_C-cT4SIRJuKiNuSBYxpWO46t_-U16KCSHJNiYD9P1Mdr1SEIomyw9fi5gEga5srvhymPoJoOpx_sOtR2KJsytnhTDk6fhS-3O-7yfFuRPy5Oh6Tsi48i-BYiU999MuwBsSZ7)\n\n\n🌱 Với công nghệ **Virtualization**, chúng ta có thể dùng các công cụ tiêu biểu như **Virtualbox** hay **VMware**, còn với **Containerization** đó chính **Docker**.\n\n![](https://lh3.googleusercontent.com/tc5QldwzU46Kx0zuTQZ8inuJax19jfTODrl5z6Wo8KnYXExUbuEA1hKcQ6Os6R_RWv9qU0knCYzlFdOspkgtuE7LRgqrKEYqwdSfXOh7dCw1l3-7RYuKg6BqN_X22_JcGxJNA2Z1NFmMwEqI8mjspbvD6X8XWj7S86edsc-s269_XqNFF--EIkHb)\n\n\n## II. What Docker?\n---\n\n- Là mã nguồn mở\n- Mục đích develop, deploy and run applications bằng những containers\n\nXem hướng dẫn cài Docker tại [đây](https://docs.docker.com/engine/installation/)\n\n## III. Why Docker?\n---\n\n- Build một lần dùng được nhiều lần và nhiều chỗ\n- Bật/tắt nhanh chóng\n\n## IV. Những khái niệm phổ biến\n---\n\n### 1. Container\n---\n- Là một quá trình chạy trên **[[50 til/51 Code/51.03 Operating System/Linux Basic|Linux kernel]]**. \n\tĐược cấp phát tài nguyên riêng: CPU, bộ nhớ và hệ thống tập tin. Chính vì vậy, Docker độc lập với những tiến trình đang chạy của máy tính và không ảnh hưởng đến các containers/processes khác đang chạy.\n\n### 2. Image\n---\nLà tệp chứa mọi thứ cần để thực thi: dependencies, binaries, source code, ... Xây dựng bằng cách thực thi các câu lệnh trong **Dockerfile**. Một **Image** có thể được sử dụng để tạo nhiều **containers** giống nhau. Mỗi **container** là một **instantiation** của **image**.\n\n### 3. Dockerfile\n---\nLà một tệp chứa các câu lệnh cần thiết để xây dựng một **Image**.\n\n## V. Một vài câu lệnh hay được sử dụng\n---\n\n- **docker pull image_name**: pull một image từ Docker Hub.\n\n- **docker build**: build một container từ Dockerfile và một context(bao gồm các folders|files được đặt ở PATH/URL).\n\n- **docker run**: chạy container từ một image.\n\n- **docker ps**: list ra những containers đang chạy. **-a/--all** để lấy tất cả containers hoặc -q/--quite nếu chỉ muốn lấy cấc ids của containers.\n\n- **docker logs [container_id/container_name]**: xem logs của 1 container, **-f/--follow** để xem log output.\n\n- **docker volume ls**: list ra các volumes được dùng để lưu trữ data được sinh ra và sử dụng bởi các containers.\n\n- **docker rm [container_id/container_name]**: xóa 1 hoặc nhiều containers.\n\n- **docker rmi [image_id]**: xóa 1 hoặc nhiều images.\n\n- **docker stop**: dừng 1 hoặc nhiều containers.\n\n- **docker kill**: kill 1 hoặc nhiều containers.\n\n- **docker kill $(docker ps -q)**: kill tất cả containers đang chạy\n```cmd\n$(docker ps -q) #lấy ra id của các containers đang chạy.\n\n$(docker ps -a -q) #lấy id của toàn bộ các containers.\n```\n\n- **docker system prune**: Dọn toàn bộ resources(images, containers, volumes, networks) đang bị treo(không liên kết với bất kì container nào).\n\n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/40-posts/42-Code/42.02-Docker/Docker-Compose":{"title":"🦑 Docker Compose","content":"\n**![](https://lh6.googleusercontent.com/xSCCWpZ4m29JV6UPl9zCuNj4pDxdGD9shUACJ1auetH158BOcrCYKdtuETCxhgwHVjVrR4BFAeSCXAlz3-QfkhJ9tQoipVV2Taq0O64Bu_TITkvRfVM9io8uUNuc3Mf0amW_Z_mbRVEWhivppaEnymHpucB7YKB08UqkzUzYxoEp8SfG0pysEEpq-g)**\n\n## I. What?\n---\n\n🌱 Chúng ta muốn ứng dụng [[40 posts/42 Code/42.02 Docker/Docker]] cho:\n\t- Dự án mới\n\t- Dự án đang phát triển\n\n🌱 Chúng ta có thể dùng [[40 posts/42 Code/42.02 Docker/Dockerfile]] cài chung tất cả vào một container duy nhất sau đó chạy project trên container đó.\n**![](https://lh4.googleusercontent.com/mS7LvI78YjVqb9jh1QY0K_KR_n_9jQJm_XLUhq-cVmKhgbj2KKqqA0xczpkSxfDPIf8Z85lI5J9-h1MDb2CLtR2Nod47XYNQFGtwwQ7qr0QqakS5hf9kGHoZ-05xQ46PG6vQI9z0RGCmfrTOe5HrezDmZkzdPnQY5yEMf28vQnubyKVXS0AcyTakDQ)**\n🌱 Tuy nhiên cách này không hợp lý cho việc mở rộng cũng như sử dụng lại cho nhiều projects.\n-\u003e docker-compose ra đời để kết nối những containers riêng lẻ với nhau.\n**![](https://lh5.googleusercontent.com/Jw9aHt8OVq5fMYhpOD_QYb0k3SGMT9hJvafVH7yiJdODYDeiQR_A6_b2wuXKhO5E5xr75B5wrl9KNL_jdRDgHHpiIvPCKxmZEToJ8_W1-C3vhRUGlAbfTHJHkfiBB6HKPSfWJEgqgawsqpFUa5h1WtDEVABZdKYvUCsO4f8VkXXMaXi12Hwff_xmNQ)**\n\n---\n- Có thể hiểu docker là con cá voi đang vận chuyển nhiều containers đến cảng Project A.\n- Còn docker-compose sẽ là con bạch tuộc sử dụng các xúc tua của mình để lấy những containers cần thiết cho Project A.\n---\n\nXem hướng dẫn cài docker-compose tại [đây](https://docs.docker.com/compose/install/)\n\n## II. Xây dựng docker-compose\n---\n\n### 1. Cấu trúc thư mục\n🌱 Mình sẽ chỉ làm một project demo nên cấu trúc đơn giản gồm:\n- [x] docker/entrypoint.sh\n- [x] Dockerfile\n- [x] docker-compose.yml\n\n🌱 Khi làm dự án thật, do phải build cho từng môi trường(development, staging, production) nên cấu trúc sẽ có khác hơn một chút, nhưng về cơ bản vẫn là vẫn có đủ thành phần cấu trúc như trên.\n\n### 2. Xác định những containers cần thiết\n🌱 Mình làm demo trên Rails app và những công nghệ mình thấy hay được sử dụng nhất là:\n- [x] Web\n\t- Ruby\n\t- Rails(là Ruby framework nên chỉ cần pull image của ruby thôi)\n- [x] Mysql (hoặc postgret)\n- [x] Redis (lưu cache, backgournd job)\n- [x] Sidekiq (chạy background job)\n\nok triển thôi!!\n\n### 3. Viết docker-compose\n1. **version**: những version sẽ có vài điểm khác nhau như:\n\t- về cấu trúc và các keys config\n\t- về Docker Engine version thấp nhất mà bạn cần đáp ứng\n\t- networking\nTại thời điểm viết bài này, trên trang chủ cập nhật version mới nhất là 3.8 hỗ trợ cho Docker Engine 19.03.0+\nChi tiết hơn về sự khác nhau của từng version hay các năng cấp từ 2.x lên 3.x thì mọi người có thể đọc thêm ở [đây](https://docs.docker.com/compose/compose-file/compose-versioning) nhé.\n2. **services**: những containers chúng ta định nghĩa sẽ nằm ở đây.\n3. những config trong từng container:\n\t- [x] **image**: chỉ định image được dùng để build container\n\t- [x] **build**: khi muốn build container bằng Dockerfile\n\t- [x] **container_name**: chỉ định tên tùy chỉnh của container nếu ko muốn dùng tên mặc định\n\t- [x] **restart**: mặc định là **no**, nếu set **always** container sẽ khởi động lại khi có lỗi\n\t- [x] **environment**: chỉ định biến mối trường, có thể chỉ định từng biến hoặc file chứa các biến môi trường\n\t- [x] **volumes**: chia sẻ dữ liệu từ máy ảo tới máy thật hoặc giữa nhiều containers với nhau\n\t\t- Ví dụ như container mysql, dữ liệu được tạo ra sẽ được lưu ở thư mục **var/lib/mysql**  trong container, nếu xóa container thì dữ liệu sẽ bị mất sạch.\n\t\t- Chính vì thế nên chúng ta dùng volumes để dữ liệu của container được mount ra ngoài host, nếu có xóa container thì dữ liệu vẫn còn, và khi khởi động lại, dữ liệu được mount ngược vào container và sử dụng bình thường.\n\t- [x] **ports**: Cấu hình cổng kết nối\n\t\t- có thể chỉ định cả 2 cổng **host:container** \n\t\t- vd 123:345 cổng 123 của máy thật sẽ trỏ đến cổng 345 của container\n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/40-posts/42-Code/42.02-Docker/Docker-Network":{"title":"🐬 Docker Network","content":"\n## What? \n---\n\n🌱 Là mạng sử dụng cho các **containers** có thể kết nối và giao tiếp với nhau. Mỗi **container** có một vùng chứa riêng biệt nên cũng sẽ có mạng, port, IP riêng.\n\n🌱 **[[40 posts/42 Code/42.02 Docker/Docker]]** cung cấp sẵn một số mạng mặc định cho các **container**, chúng ta có thể gom một nhóm **[[40 posts/42 Code/42.02 Docker/Docker|container]]** vào một mạng chung. Điều này khá là tiện lợi trong trường hợp chúng ta muốn chỉ định một stack phù hợp cho dự án.\n\n## What type of network?\n---\n\n### 🌱 Bridge network\n---\n- Mạng **Bridge** cho phép kết nối giữa các **container** cùng mạng và sử dụng một dải ip được cấp ngẫu nhiên hoặc tự thiết lập.\n- Mạng Bridge đáp ứng hầu hết các usecase nếu triển khai các container trên cùng một host. Nhưng nếu chạy một môi trường đa host, **Bridge** sẽ không làm được điều này, đây sẽ là nhược điểm của mạng **Bridge**.\n- Driver của mạng **Bridge** là **bridge**.\n\n### 🌱 Host network\n---\n- **Host network** cho phép mạng **container** kết nối với **host**. Và sử dụng IP có cùng dải mạng với **host**.\n- Driver của mạng **Host** là **host**.\n\n### 🌱 None network\n---\n-   Tắt tất cả kết nối mạng.\n-   Driver của mạng **None** là **null**.\n\n### 🌱 Overlay network\n---\n-   Nhược điểm của mạng **Bridge** được **Overlay network** và **Macvlan** khắc phục.\n-   **Overlay network** thực hiện kết nối nhiều **Docker daemon** với nhau để tạo một mạng ảo trên các máy chủ. Nơi có thể thiết lập kêt nối giữa **swarm service** và **container** độc lặp hoặc hai **container** trên các host khác nhau.\n-   Driver của mạng **Overlay** là **overlay**.\n\n### 🌱 Macvlan netwrok\n---\n-  **Macvlan network** cho phép bạn gán địa chỉ MAC cho một **container**, biến **container** như một thiết bị vật lý trên mạng.\n-   Driver của mạng **Macvlan** là **macvlan**.\n\n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/40-posts/42-Code/42.02-Docker/Dockerfile":{"title":"🐬 Dockerfile","content":"\n---\n\n# I. Config\n---\n\n- **FROM**: chỉ định image gốc. [[40 posts/42 Code/42.02 Docker/Docker]] Hub nơi lưu trữ và chia sẻ các images. Chúng ta có thể lấy các image gốc trên này và về xào nấu lại để phù hợp với nhu cầu sử dụng của mình.\n\n- **MAINTAINER**: optional để đặt tên cho tác giả viết Dockerfile\n\n- **RUN**: thực thi 1 câu lệnh trong quá trình build image.\n\n- **CMD**: thực thi 1 câu lệnh trong quá trình bật [[40 posts/42 Code/42.02 Docker/Docker|container]].\n\n\t- Mỗi **Dockerfile** chỉ chạy một câu lệnh CMD, nếu có nhiều hơn sẽ chỉ chạy câu lệnh **CMD** cuối cùng.\n\t\n\t- Nếu muốn khởi động nhiều ứng dụng khi start container, hay sử dụng **ENTRYPOINT**.\n\n- **ENTRYPOINT**: thực thi một số câu lệnh trong quá trình bật container, những câu lệnh này sẽ được viết trong file script có đuôi .sh.\n\n- **EXPOSE**: chỉ định cổng mà container sẽ nghe khi chạy.\n\n- **ADD**: Copy file, thư mục, hoặc remote file thêm chúng vào filesystem của image.\n\n- **COPY**: Copy file, thư mục từ host machine vào image. Có thể sử dụng url cho tập tin cần copy(chưa dùng baoh =))).\n\n- **WORKDIR**: chỉ định directory cho câu lệnh CMD\n\n- **VOLUME**: mount thư mục từ máy host vào container.\n\n\nMình sẽ build những gì học được về docker ở repo này : [app-demo-rails-docker]( https://github.com/anhnh-3008/app-demo-rails-docker), mọi người có thể theo dõi các steps theo pulls cho tiện nhé. \n\nPull mình build Dockerfile: [pull build Dockerfile](https://github.com/anhnh-3008/app-demo-rails-docker/pull/1)\n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/40-posts/43-Psychology/T%C6%B0-duy-nhanh-v%C3%A0-ch%E1%BA%ADm":{"title":"📘 Tư duy nhanh và chậm","content":"\n---\n\nChào mọi người, thời tiết hôm nay nó cứ bị mưa mưa, mát mẻ làm mình lười viết về mấy bài công nghệ khô khan quá =)) Chắc để đổi gió nay mình sẽ viết về quyển sách mà dạo này mình đang đọc nha. Quyển sách này giúp chúng ta nhìn cách vận hành suy nghĩ một cách rất dễ hiểu thông qua những diễn đạt của tác giả - một người đã dành cả cuộc đời để nghiên cứu về Tâm lý học hành vi.\n\n![[00 Meta/01 Attachments/tu-duy-nhanh-va-cham.png]]\n\n## Tác giả\n---\n`Daniel Kahneman` sinh năm 1934, nhà Tâm lý học người Mỹ gốc Israel, giành giải Nobel kinh tế năm 2002. Ông dành cả đời để nghiên cứu về Tâm lý học hành vi. Cùng với người động sự đã qua đời là Amos Tversky, hai ông đã có những nghiên cứu sâu sắc về con đường tư duy và nhận thức của con người.\n\nCuốn sách đã dành được nhiều giải thưởng danh giá như: Sách khoa học hay nhất của Học viện Khoa học Quóc gia năm 2012, Sách hay nhất nhất năm 2011 do Thời Báo New York bình chọn, cuốn sách được quan tâm nhất năm 2021 của tạp chí Los Angeles. \n## Nội dung\n---\nXuyên suốt quyển sách hai khái niệm được nhắc đến nhiều nhất đó là `Hệ Thống 1` và `Hệ Thống 2`. Hai nhân vật chính này là xuất phát điểm cho tất cả những suy nghĩ, quan sát, hành vi, trải nghiệm, hay quyết định, ... của mỗi chúng ta.\n`Hệ Thống 1` hoạt động với cơ chế suy nghĩ nhanh, tự động, cảm tính, bản năng, rập khuôn và kiểu giác quan thứ 6 mà chị em phụ nữ hay được trải nghiệm =))\n`Hệ Thống 2` thì ngược lại, suy nghĩ chậm, sở hữu sự điềm tĩnh, logic, tính toán, ý thức và đòi hỏi một sự nỗ lực khi hoạt động.\n\nKhông phải tự nhiên mà ca sĩ Tóc Tiên đã hát:\n\t`Chọn con \u003c3 hay là nghe lý trí, chọn yêu anh hay chọn phút giây biệt ly.`\n\nPhần lớn chúng ta thường lười kích hoạt `Hệ Thống 2`, để mặc cho `Hệ Thống 1` 'tự do tác oai tác quái' :D. Bạn nhớ lại xem bạn đã từng đột nhiên nổi hứng lên mua một món đồ đắt tiền nhưng khi nhận về bạn lại bỏ xó. Nếu tại thời điểm nổi hứng đó `Hệ Thống 2` xuất hiện có phải đã tốt hơn rồi không =))) Nhưng nếu chúng ta kích hoạt liên tục `Hệ Thống 2` thì sao? Cẩn thận bộ não của bạn sẽ bị quá tải đấy =)) 'Hội trầm cảm sau sinh' sẽ ko quên mời bạn gia nhập đâu :D   \n\nChúng ta luôn luôn suy nghĩ, lựa chọn, quyết định với mọi vấn đề trong cuộc sống và những điều đó đôi khi sẽ thay đổi cả cuộc đời của chính chúng ta hay nhiều người khác nữa. Hiểu được các cơ chế hoạt động, tránh được `những lỗi sai hệ thống` là điều vô cùng cần thiết. Cuốn sách này sẽ giúp chúng ta hiểu được những 'dòng chảy' của não bộ, hai Hệ Thống giao tiếp với thế giới xung quanh ntn, ... từ đó giúp chúng ta sẽ phần nào hiểu được năng lực tư duy của chính mình và phát huy nó một cách hiệu quả \u003c3\n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.01-Style/SOLID":{"title":"💪 What is SOLID?","content":"\n---\nSOLID là cụm từ  tạo thành từ những chữ cái viết tắt của 5 nguyên tắc được đúc kết từ 'xương máu' của rất nhiều lập trình viên đi trước =)) Nếu đã từng làm dự án thực tế, mọi người sẽ đều biết là gần 80% thời gian sẽ là bảo trì hệ thống(thêm tính năng, sửa lỗi, ...). Áp dụng SOLID, công việc bảo trì  và mở rộng sẽ dễ dàng hơn rất nhiều. Cùng xem những nguyên tắc 'thần thánh' nhưng vô cùng 'thân thuộc' này là gì nha! \n\n## Single Responsibility Principle\n---\nMỗi class chỉ nên thực hiện **một nhiệm vụ** đơn lẻ!\n\n![[00 Meta/01 Attachments/Single Responsibility Principle.png]]\n\n\n## Open/Closed Principle\n---\nKhi thêm tính năng cho lass, nên viết những class mới kế thừa class cần mở rộng.\n![[00 Meta/01 Attachments/Open-Closed Principle.png]]\n\n## Liskov Substitution Principle\n---\n\n![[00 Meta/01 Attachments/Liskov Subtitution Principle.png]]\n\n## Interface Segregation Principle\n---\nThiết kế \n![[00 Meta/01 Attachments/Interface Segregation Principle.png]]\n\n\n## Dependency Inversion Principle\n---\n\n![[00 Meta/01 Attachments/Dependency Inversion Principle.png]]","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.02-Git/Git-config-for-multi-accounts":{"title":"⚙️ Git config for multi accounts","content":"\n---\n\n#til #gitconfig\n## Vấn đề\n---\n Bài viết này ra đời khi mình bị các anh ngồi cạnh 'cười chê' do dùng nhiều accounts git trên cùng một máy nhưng lại switch bằng cơm =))) Sau khi khóc xong thì mình có tìm hiểu cách config để thuận tiện hơn cho việc sử dụng.\n\n## Giải pháp\n---\n Ý tưởng là mình sẽ chia ra làm 2 thư mục **work** và **personal**  để sử dụng cho các repo tương ứng.\nỞ file **.gitconfig** global set user mặc định và điều hướng config riêng cho từng folder.\n``` git\n# .gitconfig\n\n[user]\n  name = anhnh-1028\n  email = nguyen.hoang.anh-c@sun-asterisk.com\n\n[includeIf \"gitdir:~/personal/\"]\n  path = ~/personal/.gitconfig-personal\n\n[includeIf \"gitdir:~/work/\"]\n  path = ~/work/.gitconfig-work\n```\n- Set user cho từng folder\n---\n```git\n# ~/work/.gitconfig\n\n[user]\n  name = anhnh-1028\n  email = nguyen.hoang.anh-c@sun-asterisk.com\n\n# ~/personal/.gitconfig\n[user]\n  name = anhnh-3008\n  email = mail-personal@gmail.com\n```\n- Xong phần config thông tin, giờ đến phần ssh. Skip bước gen ssh-key + add key lên git, giờ mình set [[50 til/51 Code/51.06 Servers/Config SSH]] thôi.\n---\n```git\n# ~/.ssh/config\n\nHost git-work\n  HostName github.com\n  User git\n  IdentityFile ~/.ssh/ssh-key-work\n\nHost git-personal\n  HostName github.com\n  User git\n  IdentityFile ~/.ssh/ssh-key-personal\n```\n\nThế là xong rồi, giờ mình chỉ cần set-url remote theo tên Host đã config thôi là chạy phà phà rồi.\n```sh\ngit@github.com:anhnh-3008/app.git -\u003e git@git-personal:anhnh-3008/app.git\n```\n\nNgoài ra trong file .gitconfig còn có thể setup được cả color branch, alias, editor, ... Mình có chôm được mấy cái [settings](https://github.com/ttuan/dotfiles/blob/master/git/gitconfig) hay hay của một anh ở công ty, mọi người có thể tham khảo nhé =)) nếu thấy hay thì cho anh mình một ⭐ nha \u003c3\n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.03-Operating-System/Pipe-Data-between-Programs":{"title":"🥦 Pipe Data between Programs","content":"\n🌿 Trong Shell, The Pipe cho phép kết hợp giữa nhiều commands trên cùng một dòng. Được kí hiệu bằng ký tự ASCII 124 ( | ), dấu gạch dọc.\n\n```sh\nVD1:\n🌱 kết hợp câu lệnh tìm kiếm theo pattern và đếm có bao nhiêu lines trả về từ grep\n\n\u003e grep /bin/bash$ [PATTERN] | wc -l\n```\n\n![](https://lh3.googleusercontent.com/P_MDCWdC8VPh8ZMVK3p-MxX8uWYP2w2XFv9mEeMoIudE4x9hJw4S5OaAMjaIRn6Utr8gjNVSSVg89VtDzlL5TI-PUwcDJEM24e-ylJUzcIMpeNFSvTnbrDbctMs8FHrnp_xQ8Mz-jf4pNJzsGQ-79Tf1hTenyIh1fAGdLqz5DS4X9KAtvQVhaVv358Qi)\n\n### Nguồn\n- LPIC - 1 - trang 105 ","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.04-Rails/Add-custom-flash-keys":{"title":"🥦 Add custom flash keys","content":"\n---\n\n`ActionController::Base` mặc định cung cấp key `:notice` cho `#redirect_to`   \n```ruby\n  class flash_demo\n    if true\n      redirect_to root_path, notice: \"Notice\"\n    else\n      flash[:error] = \"Error\"\n      redirect_to root_path\n    end\n  end\n```\n\nNhưng nếu bạn muốn thêm `:error` như `:notice` thì có thể thử cách này nhé!\n```ruby\n  class flash_demo\n    add_flash_types :error\n    \n    if true\n      redirect_to root_path, notice: \"Notice\"\n    else\n      redirect_to root_path, error: \"Error\"\n    end\n  end\n```\n\nRefer: [add_flash_keys](https://til.hashrocket.com/posts/ouyfd1cpfu-add-custom-flash-keys)","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.04-Rails/Config-warning-when-fetched-a-lot-of-records":{"title":"🥦 Config warning when fetched a lot of records","content":"\n 🌱 Từ Rails 5 chúng ta đã có thể thêm config `warn_on_records_fetched_greater_than`:  hiển thị cảnh báo trong `rails server` hoặc `rails console` khi có số lượng câu queries lớn hơn số lượng chúng ta đã chỉ định.\n\n```rb\n# config/environments/development.rb\n\n# Show warn if fetch greater than 50 records\nconfig.active_record.warn_on_records_fetched_greater_than = 50\n```\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Config warning when fetched a lot of records/Pasted image 20221020091559.png]]","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.04-Rails/Custom-condition-sign-in-for-devise":{"title":"🥦 Custom condition sign-in for devise gem","content":"\n---\n\nMặc định khi đăng nhập, Devise sẽ tìm User dựa theo scope đã được thiết lập trong `config/initializers/devise.rb` \nVd như đăng nhập theo email:\n\n```rb\nDevise.setup do |config|\n  config.authentication_keys = [:v_code]\nend\n```\n\n## Vấn đề\n---\nThế nhưng cuộc sống thường lắm gian truân và cuộc đời của mình cũng không ngoại lệ. \nDự án của mình có đồng thời 2 cơ chế đăng nhập 1 là qua Devise, 2 là SSO thông qua bên thứ 3. Khi thực hiện SSO, hệ thống sẽ lưu user đó vào DB chung luôn và phân biệt bằng trường `provider`. Vấn đề là giờ phải xử lý sao cho khi đăng nhập với Devise, những thằng user do bên thứ 3 cung cấp không thể login vào được hệ thống.\n\n## find_for_database_authentication(warden_conditions)\n---\nChúng ta có thể overwrite lại method `find_for_database_authentication` của Devise.\n\t- Method nhận vào scope chứa `authentication_keys`.\n\t- Output trả về một record tồn tại trong DB hoặc `nil`.\n\n```rb\ndef find_for_database_authentication(warden_conditions)\n  conditions = warden_conditions.dup\n  # trim space and downcase\n  email = conditions.delete(:email).strip.downcase\n  find_by(email: email, provider: :traditional)\nend\n```\n\n\n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.04-Rails/How-to-safely-remove-a-column-in-Rails":{"title":"🥦 How to safely remove a column in Rails? ","content":"\n---\n\nRails cung cấp method `ignored_columns` để xóa tạm thời một cột trong DB, sau khi sửa logic xong xuôi chúng ta mới thực hiện migrate, tránh việc migrate đi migrate lại, deploy nhiều lần(nếu cột đã có trên môi trường STG/PROD).\n\n🌱 Step 1️⃣: Set ignore cột cần xóa trong model.\n\n```rb\nclass User \u003c ActiveRecord::Base\n  self.ignored_columns = [:username]\nend\n```\n\n🌱 Step 2️⃣: Kiểm tra xem cột `username` đã được xóa tạm thời chưa.\n\n```rb\nUser.first.username\n\n=\u003e raises exception NoMethodError\n```\n\n🌱 Step 3️⃣: Thay đổi logic code liên quan đến trường `username`.\n\n🌱 Step 4️⃣: Deploy lên các môi trường, test/fix những \"lỗi lầm\" nếu có.\n\n🌱 Step 5️⃣: Thêm migrate xóa cột `username` .\n\n🌵Refer: [https://newsletter.shortruby.com/p/how-to-safely-remove-a-column-in](https://newsletter.shortruby.com/p/how-to-safely-remove-a-column-in)","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.04-Rails/Run-Rspec-save-your-time":{"title":"🥦 Run Rspec save your time","content":"\n---\n\n#til #rspec\n\tIf you want to run rspec for a specific example, context or describe without having to care about path file, line number, you can try it:\n\n```ruby\n# spec/rails_helper.rb\n\nRSpec.configure do |config|\n  config.filter_run_when_matching focus: true\nend\n```\nThen you add f to example, context or describe, Rspec will only focus it.\n\n```ruby\n#example\nfit 'should tell height' do\n  expect(@person.height).to eq(160)\nend\n\n# as well\n\nit 'should tell height', focus: true do\n  expect(@person.height).to eq(160)\nend\n```\np/s: you can add focus for multi examples\nRef: https://manny.codes/7-ways-to-selectively-run-rspec-tests/","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.04-Rails/Sidekiq-Beta-7.0-available":{"title":"🥋 Sidekiq Beta 7.0 available","content":"\n---\n\nHôm 2022-09-26 Author and Maintainer của Sidekiq **Mike Perham** đã cho ra mắt bản beta version 7.0 của **Sidekiq**. Đây được giới thiệu là một đợt big update với một vài tính năng siêu to và mới =)) một vài tính năng bị loại bỏ, một số API được cấu trúc lại và requirements được update.\n\n## Version Support\n---\n- Required Redis 6.2+\n- Required Ruby 2.7+\n- Support for Rails 6.0+\n\n## Upgrade\n---\nNếu bạn muốn upgrade lên ver 7.0 để trải nghiệm và có cơ hội trở thành contributer cho **sidekiq** thì đừng ngần ngại mà hãy thêm dòng này vào Gemfile của mình nhé =))\n```ruby\ngem 'sidekiq', '\u003c 8'\n```\n\n## What's new?\n---\n\n### Job Metrics\n---\nVersion 7.0 sẽ add một tab metrics trên Web UI với high-resolution data cho thời gian excute job cũng như là khả năng đánh dấu thời điểm deploy. \nMọi người có thể xem chi tiết tính năng này ở [Metrics](https://github.com/mperham/sidekiq/wiki/Metrics) \n\n### Embedding\n---\nTrước đây mọi người chỉ có thể khởi động **Sidekiq** bằng câu lệnh \n```sh\nbundle exec sidekiq\n```\nTính năng này theo tác giả có nói là một cách thử nghiệm để chạy **Sidekiq** thông qua việc gọi trực tiếp bằng những dòng code Ruby. Nó được gán nhãn thử nghiệm là vì có khả năng xung đột với plugins bên thứ 3 hay với chính hệ thống của bạn.\nMọi người có thể xem chi tiết tính năng này ở [Embedding](https://github.com/mperham/sidekiq/wiki/Embedding)\n\n### Capsules\n---\n...\n\n### redis-client\n---\n- **redis-client** là một Rubygem mới sử dụng giao thức RESP3 có trong Redis 6.0+.\n- Sidekiq 6.5 đã giới thiệu về việc hỗ trợ cho gem **redis-client**  trong khi vẫn sử dụng gem **redis** là mặc định. Đến sidekiq 7.0 đã hoàn thiện việc chuyển đổi này và đã không còn sử dụng **redis** là mặc định nữa.\n- **App của bạn vẫn có thể tiếp tục sử dụng redis**. \n- Hiện tại nếu bạn sử dụng **Sidekiq.redis** để truy cập vào kết nối Redis, API đó sẽ expose một connection dựa trên **redis-client**.\n\n### redis-namespace\n- 7.0 đã bỏ phần support cho **redis-namespace**. \n\n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.04-Rails/Validate-number-of-association":{"title":"🥦 Validate number of association","content":"\n---\n\n#til #validate #rails \n\tIf you have a People model and a Vehicle model, every people has_many vehicles but you want to set maximum for number of vehicles which a people can has. You can use following command below:\n\n```ruby\n# vehicle.rb\nclass Vehicle\n  belongs_to :people\nend\n\n# people.rb\nclass People\n  has_many :vehicles\n\n  validates :vehicles, length: { maximum: 2 }\nend\n```\nRef: https://til.hashrocket.com/posts/egegrgsdnj-limiting-object-counts-in-rails-associations-\n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.05-Ruby/Awesome-Ruby-Repository":{"title":"💎 Awesome-Ruby Repository","content":"\n---\n\n-   Được khởi xướng bởi Marc Anguera - Lead engineer \u0026 CTO tại Crisalix(cung cấp dịch vụ xuất hình ảnh 3D, 4D cho những người muốn nhìn thấy trước những thay đổi như phẫu thuật thẩm mỹ chẳng hạn, em **cảnh báo** là không nên xem web này ở trên cty nha :D ), repo hiện tại đã nhận được 12.4k sao và nhiều phản hồi tích cực từ cộng đồng Ruby Dev.\n-   [Awesome-ruby](https://github.com/markets/awesome-ruby) là repo phân loại tổng hợp những `thư viện cho Ruby`, những `tools`, `frameworks`, `best practice` và `phần mềm` có chất lượng `awesome` có thể sẽ cần thiết để chúng ta xây dựng những `modern Apps` hay `Web Apps` .\n-   Điều kiện tiêu chuẩn:\nĐể được thêm vào repo, cần đạt những chất lượng tiêu chuẩn sau:\n\t- Thường được sử dụng(tối thiểu là 20k lượt tải) và hữu ích với cộng đồng.\n\t-   Chủ động bảo trì, cập nhật thường xuyên(chỉ cần là vẫn giải quyết các issues cho version hiện tại cũng là đạt yêu cầu rồi).\n\t-   Ổn định.\n\t-   Được tài liệu hóa.\n\t-   Có tests.\n\nVới những điều kiện trên thì mọi người có thể yên tâm mấy thứ được suggests trên repo toàn là hàng chất lượng thôi nhé =))","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.05-Ruby/Check-prefix-of-string":{"title":"🥦 Check prefix of string","content":"\n---\n\n🌱 Trong Ruby, class `String` cung cấp method `start_with?` nhận vào những tiền tố mà bạn muốn xác định, trả về `true` nếu chuỗi kiểm tra bắt đầu bằng một trong những tiền tố đó.\n\n```rb\nstring = \"hello world\"\n\nstring.start_with?(\"abc\", \"mentor\") # =\u003e false\nstring.start_with?(\"zys\", \"hell\")   # =\u003e true\n```\n\n🌱 Tham số:  \n\t- Phân biệt chữ Hoa và chữ thường\n\t-   Nhận regex\n\n```rb\nstring = \"hello world\"\n\nstring.start_with?(\"zys\", \"Hell\") # =\u003e false\nstring.start_with?(/[\\s\\S]*/)     # =\u003e true\n```\n\n🌱 Ref: [https://til.hashrocket.com/posts/rettwv4dgl-check-if-string-starts-with-prefixes](https://til.hashrocket.com/posts/rettwv4dgl-check-if-string-starts-with-prefixes)","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.05-Ruby/Ruby-Module-Include-Prepend-and-Extend":{"title":"🥦 Ruby Module: Include, Prepend and Extend","content":"\n## 🌿 Ancestors chain\n- Khi khởi tạo một Class, mỗi Class sẽ có một `ancestors chain` - là danh sách các classes và modules mà nó được kế thừa hoặc imported.\nTrong Ruby có 3 cách để import Module cho 1 Class.\n\n### 🌱 Include\n- Method trong module sẽ trở thành `instance method` của Class.\n- Thứ tự trong `ancestors chain`: `Class` \u003e `Module/Class imported` \u003e `Superclass`.  \n\n```rb\nmodule A\n\tdef say\n\t\tp 'hello'\n\tend\t\nend\n\nclass B\n\tinclude A\nend\n```\n\n``` sh\n\u003e B.new.say\n=\u003e \"hello\"\n\u003e\n\u003e B.ancestors\n=\u003e [B, A, ..., Object, ..., BasicObject]\n```\n\n### 🌱 Prepend\n- Giống `include`, khác thứ tự được thêm vào trong `list ancestors`.\n- Thứ tự trong `ancestors chain`: `Module/Class imported` \u003e `Class` \u003e `Superclass`.\n\n```rb\nmodule A\n\tdef say\n\t\tp 'hello'\n\tend\t\nend\n\nclass B\n\tprepend A\nend\n```\n\n``` sh\n\u003e B.new.say\n=\u003e \"hello\"\n\u003e\n\u003e B.ancestors\n=\u003e [A, B, ..., Object, ..., BasicObject]\n```\n\n### 🌱 Extend\n- Method trong module trở thành `class method` của Class.\n- Import methods của module vào `ancestors chain` của `singleton class` của class extend.\n\n```rb\nmodule C\n\tdef say\n\t\tp 'hello'\n\tend\t\nend\n\nclass D\n\textend C\nend\n```\n\n``` sh\n\u003e D.new.say\n=\u003e undefined method 'say' ...\n\u003e\n\u003e D.say\n=\u003e \"hello\"\n\u003e\n\u003e D.ancestors\n=\u003e [D, ..., Object, ..., BasicObject]\n\u003e\n\u003e D.singleton_class.ancestors\n=\u003e [#\u003cClass:D\u003e, C, ...] \n```\n\n\n### Tham khảo\n- https://medium.com/@leo_hetsch/ruby-modules-include-vs-prepend-vs-extend-f09837a5b073","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.06-Servers/Config-SSH":{"title":"⚙️ Config SSH","content":"\n---\n\n## Issue\n---\nChắc hẳn là một dev BE, các bạn ít nhiều cũng từng có lần ssh lên server để check log, xem db, hay là config dự án, ... Quy trình đểcó thể ssh được lên  server sẽ gồm có những bước cơ bản như sau:\n- Tạo một bộ khóa tại máy local.\n- Đưa public key cho bên infra hoặc người có thể lên được server, để họ thêm key của chúng ta vào 1 file - file này sẽ chứa các keys có thể ssh.\nSau đó mỗi lần ssh chúng ta sẽ cần phải gõ command:\n\n```sh\nssh user_name@ip\n```\n\nVấn đề ở đây là, chúng ta khó có thể nhớ chính xác 2 thông tin trên cho mỗi lần ssh. Trước đây mình sẽ note những thông tin này vào một chỗ nào đấy bí mật, khi nào cần ssh thì bật lên và copy vào, rất là mất thời gian. Đã thế khi gen ra nhiều key ssh, mình còn phải set -i để chỉ định ssh-key nào sẽ được dùng để ssh nữa.\n\n## Solution\n---\nKhi search vấn đề này, mình thấy mọi người thường sẽ không dùng cách stupid trên kia của mình mà sẽ sử dụng file  ~/.ssh/config. Và nó giải quyết hoàn toàn được 2 vấn đề mình gặp phải ở trên.\n1. Không cần nhớ thông tin ssh: user_name, ip\n2. Không cần chỉ định bằng cơm ssh-key khi ssh nữa\n\nMọi người chỉ cần thêm vào file ~/.ssh/config như ở dưới:\n\n```sh\nHost project-dev\n  Hostname 1.0.5.374\n  User deployer\n  IdentityFile ~/.ssh/project-dev-ecdsa\n\nHost project-prod\n  HostName 1.12.6.52\n  User deployer\n  IdentityFile ~/.ssh/project-pro-ecdsa\n```\n- Host: tên tắt dùng để ssh, có thể đặt tên theo project để dễ nhớ nhé. \n- Hostname: ip server\n- User: user trên server\n- IndentityFile: chỉ định ssh-key sẽ dùng để ssh cho Host\n\nViệc đơn giản bây giờ là chúng ta ssh theo Host thôi :D !!\n\n```sh\nssh project-dev\n```\n\n---","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.06-Servers/Remote-Desktop-Protocol":{"title":"🥦 Remote Desktop Protocol","content":"\nBình thường các server mình được làm trước đây đều là Ubuntu Server, muốn truy cập lên thì dùng ssh-key là được. Nhưng do spec của dự án hiện tại mình làm có yêu cầu sử dụng Window Server. Khi gửi thông tin Server(IP, users, pass) anh PSM có gợi ý dùng `RDP Client` để truy cập vào. Cơ mà `RDP Client` là cái khỉ gì 😅\n\n# 🌱 What?\n---\n- `RDP` là một giao thức độc quyền được phát triển bởi Microsoft, cung cấp cho người dùng giao diện để truy cập đến một máy tính khác thông qua kết nối internet. Bạn có thể làm mọi thứ với PC remote như một PC vật lý bình thường. Ví dụ như:  \n\t- Sử dụng các ứng dụng của PC remote.\n\t- Truy cập file và các tài nguyên mạng của PC remote.\n\t- Tắt các ứng dụng khi bạn thoát khỏi `RDP Client` (giống shut down PC vật lý.)\n\n🌿 `Remote Desktop Protocol severs` được dùng để các clients kết nối, severs mặc định của RDP là `TCP port 3389` và `UDP port 3389`.\n\n🌿 **Remote Desktop Connection** được tích hợp cho `RDP Clients` trong hệ điều hành Windows.\n\n# 🌱 Quick connect to a Windows Server from Ubuntu using RDP Client\n---\n\n🌿 Step 1: Đảm bảo PC hoặc server Windows mà bạn muốn truy cập đã được bật Remote Desktop Connections. \n- Nếu chưa bạn có thể xem cách bật ở [đây](https://www.digitalcitizen.life/enable-remote-desktop-windows/).\n\n🌿 Step 2: Mặc định Ubuntu cung cấp `Remmina` để hỗ trợ RDP. Turn on!\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Remote Desktop Protocol/Pasted image 20221017142240.png]]\n\n🌿 Step 3: Tạo một connect mới.\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Remote Desktop Protocol/Pasted image 20221017171736.png]]\n\n🌿 Step 4: Điền thông tin server.\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Remote Desktop Protocol/Pasted image 20221017172232.png]]\n\n- Tiếp theo là setting độ phân giải và color depth của màn hình desktop remote. Mặc định sẽ chọn độ phân giải và color depth ở mức cao nhất. Tuy nhiên, setting 2 thông số này thấp hơn sẽ cải thiện khá nhiều perfomance đấy.\n- Nếu muốn chia sẻ folder với Windows Server, check folder box và chỉ định folder cần chia sẻ.\n- Ngoài ra ở mục Advanced, bạn có thể bật/tắt tiếng, chia sẻ máy in, tắt đồng bộ cho bộ nhớ tạm, ...\n\n🌿 Step 5: Lưu và chạy thôi!\n\n![[00 Meta/01 Attachments/01.02 TIL/Server/Remote Desktop Protocol/Pasted image 20221017174839.png]]\n\n\n# 🌱 Góc so sánh\n---\n\n🌿 Theo định nghĩa, công dụng của thằng này nghe cũng khá giống TeamView nhỉ 😀 So sánh thôi 😗\n\n\nRemote Desktop Protocol | TeamView\n------------ | ------------\nLà giao thức được tích hợp sẵn trong hệ điều hành Windows và được phát triển độc quyền bởi công ty Microsoft  | Là một phần mềm chia sẻ quyền điều hành máy tính được phát triển bởi TeamViewer GmbH\nKhông cho phép người dùng theo dõi tác vụ trên máy remote | Cho phép người dùng dõi tác vụ trên máy remote\nYêu cầu cấu hình port chuyển tiếp trên `firewall` hoặc route của máy remote | Chỉ cần cài đặt là dùng bình thường\n\n🌿 Nhìn chung TeamView ngon và dễ sử dụng hơn RDP nhưng TeamView lại tiềm ẩn rủi ro bị lộ dữ liệu,  thông tin, như ở công ty mình TeamView được liệt vào danh sách đen không được cài đặt ấy.\n\n🌿 Tùy theo bối cảnh mọi người có thể cân nhắc sử dụng giữa 2 này nhé. \n\n### Tham khảo\n- https://learn.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/remote-desktop-clients\n- https://www.techrepublic.com/article/teamviewer-vs-remote-desktop/","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.06-Servers/The-paradigms-that-generually-applied-when-release":{"title":"🥦 The paradigms that generually applied when release","content":"\n\nVới những dự án đã có cộng đồng người dùng lớn, việc deploy những tính năng mới lên môi trường `production` cần phải có những phương pháp để giảm thiểu tối đa những rủi ro cũng như đạt được trải nghiệm tốt nhất dành cho người dùng.  Những mô hình thường được áp dụng thực tế: `A/B Testing`, `Canary Deployments`  và  `Blue-Green Deployments`.\n\n### 🌱 A/B Testing\n-  Sử dụng để review độ hiệu quả và phản ứng của người dùng đối với những thay đổi mới.\n- Những thay đổi mới sẽ chỉ được `rolled out` với một bộ phận người dùng nhất định. So sánh đánh giá của người dùng để đưa ra những chiến lược phát triển phù hợp hơn trong tương lai.\n- Mô hình này được áp dụng cả cho phát triển web, bán hàng, quảng cáo, vv... \n\n![[00 Meta/01 Attachments/Pasted image 20221025184727.png]]\n\n\n### 🌱 Blue-Green Deployments\n- Là một chiến lược deploy dùng để kiểm thử những tính năng mới của dự án.\n- Deploy without downtime.\n-  Mô hình này gồm 2 servers chạy đồng thời là Blue và Green, đều là môi trường `production` nhưng một server có status `live` - nhận reqs của users còn server kia là `idle` - không hoạt động.\n\n![[00 Meta/01 Attachments/Blue-Green Deployments.excalidraw.png]]\n\n### 🌱 Canary Testing\n- Cũng giống 2 ý đầu của  `Blue-Green Deployments`.\n- Thay vì switch toàn bộ users truy cập giữa Blue và Green, `Canary Testing` sử dụng cân bằng tải, cho phép một số users có thể sử dụng version code mới, sau khi chạy ngon lành thì dần dần áp dụng cho toàn bộ users của hệ thống.\n\n![[00 Meta/01 Attachments/Pasted image 20221025184522.png]]\n\n### Tham khảo\n- https://www.oreilly.com/library/view/spring-50-microservices/9781787127685/6fab55ad-8897-42b7-b509-dd90850c861b.xhtml\n- https://circleci.com/blog/canary-vs-blue-green-downtime/\n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.07-Utils/Cron-job-notify-drink-water":{"title":"🥂 Tạo background job nhắc nhở uống nước đều đặn","content":"\n---\nKhông biết mọi người có giống mình không, mỗi khi làm việc mình cứ bị quên uống nước ấy, có khi cả buổi mình còn chả uống được 250ml nước =((. Tác hại của việc uống ít nước mọi người có thể gg nha, nhưng ncl uống nước đủ mỗi ngày là thói quen rất có lợi cho sức khỏe cũng như làn da của chúng ta =)).\n\nHôm trước mình có gặp anh mentor ở cty, anh ấy chia sẻ là vì hay ngồi gù lưng nên anh ấy viết một script để sau một khoảng thời gian, thông báo kiểu như 'Thẳng lưng lên!' được hiển thị trên Touch Bar. 🤩, hay thế!!! Sao mình ko áp dụng để improve khả năng uống nước của bản thân nhỉ 🤔 Thế nên tranh thủ cuối tuần, mình có tìm cách để setup cronjob cho Ubuntu.\n\n🌱 Đầu tiên là setup cronjob, mình có xài `cron`, mn có thể dùng apt để install và enable nó lên nhé.\n```sh\nsudo apt update\n# Check if cron package is installed\ndpkg -l cron\n\n# install cron\nsudo apt install cron\n\n# enable cron\nsystemctl start cron\n\n# check status cron\nsystemctl status cron\n\n# stop cron\nsystemctl stop cron\n```\n\n🌱 Để thêm job, sử dụng command:\n```sh\ncrontab -e\n```\n\nTrong file đã có hướng dẫn cụ thể, về cơ bản cũng giống như setup cron-sidekiq, nếu chưa quen settings thời gian chạy job mọi người có thể sử dụng [cron-time](https://crontab.guru/) cho trực quan nhé!\n\nVí dụ mình set 20p là phải nhắc t uống nước đó nha Ubuntu =))\n```sh\n20 * * * * cd ~/personal \u0026\u0026 ./script-notify-myself.sh\n```\n\n🌱 Tạo script:\n```sh\n#!/bin/bash\n\nexport DBUS_SESSION_BUS_ADDRESS=\"${DBUS_SESSION_BUS_ADDRESS:-unix:path=/run/user/${UID}/bus}\"\nnotify-send \"Uống nước đii!!!\"\n```\n\n🌱 Và kết quả là:\n**![](https://lh5.googleusercontent.com/0NKuSVNogMqGwdDajpn-B901GQITiJWGHqrWUFlI6FYn20D7eaE3DbcREvNv-bBYiwZQvJxaC0GuQry-tXdIIWbm-VG9WpXql-A8pr8ZzybJRR0q62qFrfVKmioH9AHzGqZ6oES1olMjkKRUNN18liShoJREFpkd9EflllQjAGoJW2D1EJkM3WBI0A)**\n\n\n### 🌱 Update\n---\nSau một thời gian thêm cronjob, mình khá là khó chịu vì cái bảng thông báo của mình nó cứ hiển thị chất đống `Uống nước đii!!!`, rất là mất mỹ quan đô thị.\n\n![[00 Meta/01 Attachments/Notifi Trash.png]]\n\nĐể khắc phục vấn đề này, mình có thêm một script chịu trách nhiệm để clear-all tất cả những thông báo hiện tại. \n\n```sh\n# ./remove-all-notify-tray.sh\n\n#!/bin/bash\ngdbus call --session --dest org.gnome.Shell --object-path /org/gnome/Shell --method org.gnome.Shell.Eval 'Main.panel.statusArea.dateMenu._messageList._notificationSection._list.remove_all_children()'\n```\n\n🌱 Mình có viết scripts ở [đây](https://github.com/anhnh-3008/dotfiles/tree/main/cronjob)  để sau dụng lại cho tiện, nếu thấy hứng thú mọi người có thể pull về chạy thử nha ❤️\n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.08-System-Design/CORS-Cross-origin-Resource-Sharing":{"title":"📑 CORS - Cross-origin Resource Sharing","content":"\n## What?\n---\n`CORS`  là một cơ chế cho phép chia sẻ nhiều tài nguyên(images, files, fonts, javascript,...) giữa nhiều trang web khác nhau.\n\n## Why?\n---\nCORS ra đời do sự xuất hiện của [[50 til/51 Code/51.08 System Design/Same-origin policy]].\n\n## How?\n---\n`CORS` sử dụng các HTTP Header để thông báo với trình duyệt nhận request là 'Em là con ông A nhà bà B ở cuối làng, anh cho em vào lấy ít đồ cho bố em nhé ' =))\n`Access-Control-Allow-Origin`  ở header mà trường này ko có giá trị hoặc giá trị ko hợp lệ thì sẽ bị báo lỗi.\n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.08-System-Design/Open-ID-ConnectOIDC":{"title":"🔐 Open ID Connect(OIDC)","content":"\n---\n\nLà một loại cơ chế xác thực kiểu [[50 til/51 Code/51.08 System Design/Single Sign-On(SSO)]] dựa trên thuật toán **mật mã hóa khóa bất đối xứng**. Có 2 khóa đảm nhiệm riêng từng nhiệm vụ là mã hóa và giải mã.\n**![](https://lh5.googleusercontent.com/1cxM7BkCmyzrm0Q17OIv7x3GcMzfyLhaHnExHl6foJLIL0e0nruB8tWPJu4RwoZNlLn1XFNlieM0gG2JiCHff760sQ87LyzxX1GJobxyoPGE0i72olWaxzLasNXmm3_iC4NEYfsKheuPVME_LxigUMArWVomwIKfbCD1Gt82o_Hs3Vh2d_HKWweu3A)**\n**![](https://lh4.googleusercontent.com/ku-PU5gsE-WnRbitam-zVKFWzcmYPxsst_bfbtVlU3KhmKcIbJ9qB5-TVBnoxQHkOfWRWEVLmV_fwQk7lgiU_t8-UYHti_T4ZBSXxh3k-Ei_2Gm_oufq8LKosdEVYrjenxEnkzPqNYCKAA_3vggJT2XeD8_Rj_ud8g6gNCTWO_0qtfKY_kfMFiD66g)**\n\nẢnh trên mô tả cơ chế hoạt động của [Mật mã hóa khóa công khai](https://vi.wikipedia.org/wiki/M%E1%BA%ADt_m%C3%A3_h%C3%B3a_kh%C3%B3a_c%C3%B4ng_khai), hiểu đơn giản thì 2 cái này sẽ giống nhau nhưng với 1 cái thì cả 2 khóa phải được giữ bí mật còn lại thì một khóa bí mật một khóa công khai.\n\nOIDC là phiên bản mở rộng của Oauth 2.0, thay vì là Access-Token chúng ta sẽ nhận được một Id Token từ Auth Server. Với [access-token](https://oauth.net/id-tokens-vs-access-tokens/#:~:text=Access%20tokens%20are%20what%20the,read%20by%20the%20OAuth%20client.), mỗi lần qua một trang web khác chúng ta sẽ cần request lại access-token mới nhưng với id-token có thể dùng lại thoải mái, [id-token](https://oauth.net/id-tokens-vs-access-tokens/#:~:text=Access%20tokens%20are%20what%20the,read%20by%20the%20OAuth%20client.) có thể xác thực được user cũng như đảm bảo được các thông tin thuộc về User là ko thể bị giả mạo.\n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.08-System-Design/Robustness-Diagram":{"title":"🥦 Robustness Diagram","content":"\n## 🌿 What?\n🌱 Là một dạng UML diagram nằm trong `ICONIX Process`, xác định tất cả những objects và mối liên hệ của từng `use case`.\n- Giảm sự mơ hồ của phần mô tả `use case`, dễ dàng hơn cho việc thiết kế, kiểm tra và estimate. \n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/Robustness Diagram/Robustness reponsibility.excalidraw.png]]\n\n\u003e `ICONIX Process` là một phương pháp luận phát triển phần mềm, mục tiêu là để tránh [analysis paralysis](https://en.wikipedia.org/wiki/Analysis_paralysis). Chỉ sử dụng 4 UML cơ bản ứng với 4 bước trong quá trình chuyển đổi từ `Use Case text` thành `Code` .\n\nMỗi diagram sẽ trả lời cho từng câu hỏi:\n- `Use Cases` - Users đang làm gì?\n- `Domain Models` - Có những Objects nào?\n\u003e 🌱 `Robustness Diagrams` - Những Object nào tham gia trong từng `use case`?\n- `Sequence Diagrams` - Những Object tương tác với nhau như thế nào?\n\n## 🌿 How?\n🌱 Sử dụng khuôn mẫu `boundary/control/entity class`.\n\n🌱 4 nguyên tắc cơ bản:\n- `Actors` chỉ có thể giao tiếp với `Boundary objects`.\n- `Boundary objects` chỉ có thể giao tiếp với `Control objects` hoặc `Actors`.\n- `Entity objects` chỉ giao tiếp được với `Control objects`.\n- `Control objects` có thể giao tiếp với `Boundary objects`, `Entity objects` và một số `Control objects` khác, nhưng cấm chơi với `Actors`.\n\u003e [Ý nghĩ của các khuôn mẫu](https://docs.nomagic.com/display/MD190/Robustness+diagram#:~:text=Boundary%20or%20Interface,and%20entity%20objects.)\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/Robustness Diagram/Object Rubustness.excalidraw.png|500]]\n\n\n🌱 Ví dụ:\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/Robustness Diagram/Robustness of use case access to homepage.excalidraw.png]]\n\n## Tham khảo\n- https://en.wikipedia.org/wiki/ICONIX\n- https://docs.nomagic.com/display/MD190/Robustness+diagram","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.08-System-Design/Same-origin-policy":{"title":"📑 Same-origin policy","content":"\n---\n\n## What?\n---\n-  Là một cơ chế bảo mật hạn chế việc `documents` hoặc `script load` thuộc một `origin` có thể tương tác với những `resources` thuộc một `origin` khác.\n-  Được cài đặt vào toàn bộ  các trình duyệt hiện nay.\n-  Chính sách này giúp trang web của chúng ta không bị truy cập bừa bãi từ những tác nhân lạ.\n\t- Ví dụ nếu bạn vào một trang web bất kỳ được cài sẵn một mã độc truy cập đến trang web VCB, nếu bạn đã đăng nhập vào VCB, vẫn còn hiệu lực đăng nhập và không có chính sách này, hacker sẽ chiếm được quyền sử dụng tài khoản ngân hàng của bạn.\n\t- Còn bình thường mn sẽ nhận được message này ở console browser\n\n```js\nAccess to XMLHttpRequest at 'https://vietcombank.com/profile' from origin 'xxx' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.\n```\n\nNhưng thực hiện truy vấn giữa nhiều trang web với nhau là việc rất thường xuyên đối với một lập trình viên, đặc biệt là vụ call API. Và thế là Cross-origin Resource Sharing - CORS ra đời =))","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.08-System-Design/Sequence-Diagram-l%C3%A0-g%C3%AC":{"title":"🥦 Sequence Diagram là gì?","content":"\n---\n\nSắp tới mình được giao tasks là vẽ lại `sequence diagram` cho toàn bộ tính năng của một con dự án ở cty, mà nghe đâu là gần 40 chục cái hay sao ấy 🤢 Thế nên tranh thủ cuối tuần mình ngồi ôn lại chút để tuần sau vào việc cho lẹ 💪 Let's go!!!\n\n# 🌱 What?\n---\n- `Sequence Diagram`  -Biểu đồ tuần tự là một dạng biểu đồ `UML - Unified Modeling Language` dùng để xác định trình tự diễn ra của một nhóm đối tượng nào đó.\n- Biểu đồ miêu tả chi tiết các thông điệp được gửi và nhận của từng đối tượng đồng thời cũng chú trọng cả việc xác định thứ tự của những thông điệp đó.\n\n# 🌱 Các thành phần\n---\n\nGồm 4 thành phần chính:\n- Đối tượng (Object or Class)\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Đối tượng.excalidraw.png]]\n\n- Đường đời đối tượng (Lifelines)\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Đường đời đối tượng.excalidraw.png]]\n\n\n- Thông điệp (messages)\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp.excalidraw.png]]\n\n- Các dạng thông điệp\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp đồng bộ.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp không đồng bộ.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp trả về.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp nội tại.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp tạo mới.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp cập nhật.excalidraw.png]]\n\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Thông điệp xóa.excalidraw.png]]\n\n- Tiến trình xử lý (process)\n![[00 Meta/01 Attachments/01.02 TIL/18 System Design/19 Sequence Diagram là gì/Tiến trình xử lý.excalidraw.png]]\n\n\n\n# 🌱 Ví dụ\n---\n\n![[00 Meta/01 Attachments/Sequence Diagram chức năng đăng nhập.excalidraw.png]]\n\n## 🌱 Tham khảo\n- https://www.smartdraw.com/uml-diagram/\n\n\n\n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.08-System-Design/Single-Sign-OnSSO":{"title":"🔐 Single Sign-On(SSO)","content":"\n## 🌱 Issue\n---\nHiện nay hầu hết các dịch vụ web đều yêu cầu người dùng đăng nhập trước khi sử dụng. Nhu cầu sử dụng dịch vụ ngày càng nhiều đồng nghĩa chúng ta càng phải nhớ nhiều thông tin đăng nhập, giả sử nếu chúng ta dùng 10 webs khác nhau, việc nhớ nhớ thông tin đăng nhập cũng khá là 'vất vả' đúng ko nào =))\n- Chính vì vậy mà đã lòi ra cu SSO này =))\n\n## 🌱 What?\n---\n![[00 Meta/01 Attachments/Single Sign-On.png]]\n\n- `Single Sign-On` là cơ chế giúp người dùng đăng nhập một ID cho một vài trang webs hoặc hệ thống liên quan nhưng độc lập với nhau. Kiểu như Google dùng tài khoản Gmail đăng nhập cho các services độc lập(Driver, Clouds, ...). Một khóa mở được nhiều chìa 🤞\n\n## 🌱 Why?\n---\n\n### Ưu điểm\n- Giảm thời gian nhập lại thông tin đăng nhập\n- Giảm [password fatigue](https://en.wikipedia.org/wiki/Password_fatigue) cho hệ thống\n- Giảm effort phát triển chức năng log-in\n- Giảm thiểu rủi ro việc lộ thông tin của người dùng\n- Nâng cao hiệu suất cho người dùng. Người dùng ko phải nhớ nhiều thông tin đăng nhập.\n- Quản lý dễ dàng hơn. Giả sử bạn có 3 trang webs và bạn muốn ban account A, nếu dùng SSO bn chỉ cần setting banned một lần cho cả 3 webs.\n\n### Nhược điểm:\n- Phụ thuộc vào bên thứ 3\n\n\n🌱 Lắm ưu ít nhược nên SSO khá là ngon, hiện tại cũng có khá nhiều service thứ 3 cung cấp dịch vụ SSO miễn phí(Facebook, Google, Github, ...) mọi người có thể cân nhắc sử dụng theo nhu cầu phát triển của dự án nhé =))\n\n---\n\n## 🌱 How?\n---\n\nSSO là một phần của [[50 til/51 Code/51.08 System Design/System Identification Link]], có liên quan chặt chẽ với việc xác thực thông tin người dùng. Nó sẽ định danh người dùng, và sau đó chia sẻ thông tin định danh được với các hệ thống con.\n\n### Cơ chế\n---\nTheo luồng bình thường user đăng nhập web A sẽ sinh ra cookie để xác thực cho những request sau, nếu mang cookie đó sang web B để xác thực thì sẽ tạch do các trình duyệt hiện nay chỉ có thể truy cập cookie do chính nó tạo ra.\n![[00 Meta/01 Attachments/Auth SSO.png]]\nHiểu đơn giản giữa các web sẽ có một **browser cookie storage** chung và sử dụng cơ chế Cross-origin resource sharing. Khi Web nào đăng nhập thì sẽ truy cập vào **browser cookie storage** để lấy cookie lên **server auth**(của bên thứ 3) để xác thực.\n\n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.08-System-Design/Store-passwords-safely-in-the-database":{"title":"🛡️ Store passwords safely in the database","content":"\n## Những điều không nên làm\n---\n- Không được lưu passwords dạng text trong db, vì bất cứ người nào có quyền connect vào db đều sẽ xem được nó.\n- Lưu password hashes trực tiếp cũng không an toàn vì nó có thể vị vô hiệu hóa bởi những cuộc tấn công tính toán trước(`precomputation attacks`), vd như là `rainbow tables`.\n- Để hạn chế `precomputation attacks`, chúng ta hãy `salt the passwords`.\n\n### What is salt?\n---\n- Theo như hướng dẫn của OWASP, `salt` là một chuỗi duy nhất, được sinh ra ngẫu nhiên và được thêm cho từng password như là một phần của quá trình mã hóa.\n\n\n## How to store?\n---\n![[00 Meta/01 Attachments/Pasted image 20221004102412.png]]\nTheo hình trên, mọi người có thể hình dung các bước để lưu password vào DB như sau:\n\t1. User cung cấp password.\n\t2. Hệ thống sinh ra `salt` cho password.\n\t3. Trong DB sẽ lưu cả `salt` và `hash` được mã hóa từ `password + salt`. \n\n## How to validate?\n---\n**![](https://lh5.googleusercontent.com/VT3b8cvDZ6idbl8D3zYpTNiHhiBp72vR4CLfjAvJx0-Tjp7ZIGy63DtQeMfbtsjwfh5Q8uk3ch16YIMp4wCVwmzyb1A9-aTZ0cSFgyb3kVjvr9X3N_ZmP7-iD_Akoh7TqveaTkM-jBZG1084xwwNqYUs5RaI7GwfxiV7fxYwQngMrmgirVgS9lHk)**\nCác bước hệ thống thực hiện validate:\n\t1. User cung cấp validate.\n\t2. Lấy mã `salt`  của user được lưu trong DB.\n\t3. Thực hiện mã hóa từ `password + salt` =\u003e `hash`\n\t4. So sánh `hash` tạo từ bước 3 và `hash` lưu trong DB. \n\nP/s:  Ngoài ra mọi người có thêm cơ chế nào khác để có thể lưu trữ pasword an toàn trong DB không? Nếu có hãy cmt cho mình biết với nha \u003c3\n\n### Tham khảo\n- Free System Design - ByteByteGo - Trang 13\n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.08-System-Design/System-Identification-Link":{"title":"📑 Hệ thống nhận diện liên kết","content":"\n---\n\nHệ thống nhận dạng liên kết( Federated Identity Glossary) là nơi tập trung và liên kết thông tin người dùng. Có 4 yếu tố nền tảng cấu thành nên hệ thống này:\n-   **Xác thực (Authentication):** kiểm tra thông tin đăng nhập và tiến hàng định danh người dùng.\n-   **Phân quyền (Authorization):** dựa trên thông tin định danh để kiểm tra quyền truy cập của user.\n-   **Trao đổi thông tin người dùng (User attributes exchange):** Mỗi hệ thống con sẽ cần và lưu trữ các thông tin khác nhau của người dùng, tuy nhiên sẽ có các thông tin bị lặp lại, ví dụ như tên, họ.... Do đó, cần có một nơi để tổng hợp lại các thông tin này, và trao đổi cho các hệ thống con.\n-   **Quản lí người dùng (User management):** admin có thể quản lí người dùng bằng các thao tác thêm, sửa, xóa... ở các hệ thống con.\n\n---\n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.08-System-Design/Why-is-RAM-access-faster-than-hard-disk-drive":{"title":"♻️ Why is RAM access faster than hard disk drive?","content":"\n# Why is RAM access faster than hard disk drive acess?\n---\n Khi sử dụng Redis, mọi người thường hay nói Redis thực hiện thao tác dữ liệu trên Ram nên có tốc độ truy xuất nhanh hơn rất nhiều so với truy cập vào HDD. Vậy tại sao lại như thế? \n \n## Why?\n---\n\n![[00 Meta/01 Attachments/Communication between CPU - RAM - Hard Storage.png]]\n\n\n- HDD nằm cách xa CPU, được kết nối với bảng điều khiển thông qua cổng SATA. 6Gb/s là tốc độ tiêu chuẩn của SATA III, HDD chỉ có thể đọc hoặc viết chứ không thể làm cả hai trong cùng một thời điểm.\n- RAM nằm rất gần CPU và có kết nối băng thông rất cao. Thông lượng của DDR4 là khoản 40Gb/s, ngoài ra RAM còn có thể thực hiện đọc và viết cùng lúc. Khi sử dụng dual channel, RAM sẽ đọc/đọc, viết/đọc, viết/viết chính vì vậy mà nó có thể thao tác một lượng dữ liệu vô cùng lớn trong cùng một thời điểm.\n\n\n## Câu hỏi\n---\nThế tại sao người ta lại không thiết kế để HDD lại gần CPU?\nVấn đề lớn nhất là chi phí. Tốc độ xử lý cao tương ứng với giá thành sản xuất cũng sẽ đắt. Và tùy theo mục đích nên mỗi phần sẽ có thiết kế phù hợp -\u003e đạt được cả hiệu năng và giá thành tốt nhất.\n-   Đối với những tác vụ lưu trữ file, đọc/ ghi đơn giản, không yêu cầu xử lý nhanh thì người ta dùng HDD cho rẻ. (ổ cứng lưu trữ)\n-   Các tác vụ cần xử lý nhanh hơn 1 chút, như load hệ điều hành, người ta ưu tiên dùng SSD (ổ cài win ý :v )\n-   Thằng nào cần cache, xử lý tốc độ bàn thờ (làm bộ nhớ tạm cho các phần mềm đang chạy) thì người ta dùng tới RAM, CPU.\n\n![[00 Meta/01 Attachments/Why is RAM access faster than hard disk drive acess.png]]\n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/51-Code/51.08-System-Design/Why-is-Redis-so-Fast":{"title":"♻️ Why is Redis so Fast?","content":"\n---\n🌱 Có 3 lý do chính giải thích điều này:\n\n![[00 Meta/01 Attachments/3 Reasons why Redis is fast.png]]\n\n- Redis là một cơ sở dữ liệu lưu trữ trên RAM. Tốc độ truy cập RAM đểu nhất cx nhanh hơn 1000 lần so với tốc độ truy cập ổ cứng. Mọi người có thể xem thêm \n- Redis sử dụng `IO multiplexing` và `single-threaded`. IO multiplexing là cơ chế đọc/ghi liên tục của RAM. RAM nhận tất cả các yêu cầu đọc/ghi dữ liệu, để vào một chỗ, sau đó dùng single-threaded lặp qua từng event để tiếp tục xử lý.\n- Redis sử dụng một vài cấu trúc dữ liệu `lower-level`(String lưu thành SDS, ...).\n\n\n## Câu hỏi\n---\n### 🌱 Tại sao truy cập từ RAM lại nhanh hơn từ HDD?\n[[50 til/51 Code/51.08 System Design/Why is RAM access faster than hard disk drive?]]\n\n\nP/s: Memcached cũng là một giải pháp khá phổ biến để giải quyết vấn đề cached dữ liệu, mọi người có thể tìm hiểu thêm nhé.\n\n### 🌱 Tham khảo\n- Free System Design - ByteByteGo - Trang 76","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null},"/50-til/53-Psychology/S%E1%BB%B1-ng%E1%BB%A5y-bi%E1%BB%87n-c%E1%BB%A7a-tay-thi%E1%BB%87n-x%E1%BA%A1-Texas":{"title":"🧠 Sự ngụy biện của tay thiện xạ Texas","content":"\nMột gã cao bồi bắn bừa lên trên một bức tường, sau đó anh ta vẽ một vòng tròn bao quanh chỗ có nhiều lỗ đạn nhất và tự nhận mình là thiện xạ.\n\n![[00 Meta/01 Attachments/Pasted image 20221026172307.png]]\n\nĐây là cơ chế tâm lý phổ biến ở con người. Chúng ta thường sẽ có xu hướng bỏ qua sự ngẫu nhiên khi kết quả có vẻ có ý nghĩa. \n","lastmodified":"2022-11-01T03:45:08.034536147Z","tags":null}}